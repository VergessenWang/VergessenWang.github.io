{"meta":{"title":"Anonymous World","subtitle":"迷失仙境","description":"虚己以游世，乘物以游心","author":"Liana_Wang","url":"http://vergessenwang.github.io"},"pages":[{"title":"categories","date":"2019-08-11T13:37:11.000Z","updated":"2019-08-11T13:46:50.957Z","comments":true,"path":"categories/index.html","permalink":"http://vergessenwang.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-11T13:39:37.000Z","updated":"2019-08-11T13:46:56.688Z","comments":true,"path":"tags/index.html","permalink":"http://vergessenwang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"VUE+ElementUI+SpringBoot实现前后端分离","slug":"VUE-ElementUI-SpringBoot实现前后端分离","date":"2020-03-06T12:40:14.000Z","updated":"2020-03-06T12:44:46.973Z","comments":true,"path":"posts/Java/2020-03-06-VUE-ElementUI-SpringBoot实现前后端分离.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-03-06-VUE-ElementUI-SpringBoot实现前后端分离.html","excerpt":"环境配置安装node与npmsudo apt-get install -y nodejs 配置运行路径 sudo ln -s /usr/bin/nodejs /usr/bin/node 但是npm用同样的方法处理，报错： bash: /usr/bin/npm: 符号连接的层数过多升级node到指定版本，后面接版本号 先寻找路径：whereis npm 然后查看该目录下路径，删掉有误的 然而再安装npm时却没有对应的包(我还以为跟windows一样npm会跟node一起安装呢..) sudo apt remove nodejs 先删除了看看有没有别的包可用 看了下BBS，好像是官方apt源有点问题一直安装不了npm 尝试安装nodejs-bin, 查询npm时仍然 bash: /usr/bin/npm: 权限不够 寻找npm sudo find / -name npm 看到可以用nvm来解决这个问题","text":"环境配置安装node与npmsudo apt-get install -y nodejs 配置运行路径 sudo ln -s /usr/bin/nodejs /usr/bin/node 但是npm用同样的方法处理，报错： bash: /usr/bin/npm: 符号连接的层数过多升级node到指定版本，后面接版本号 先寻找路径：whereis npm 然后查看该目录下路径，删掉有误的 然而再安装npm时却没有对应的包(我还以为跟windows一样npm会跟node一起安装呢..) sudo apt remove nodejs 先删除了看看有没有别的包可用 看了下BBS，好像是官方apt源有点问题一直安装不了npm 尝试安装nodejs-bin, 查询npm时仍然 bash: /usr/bin/npm: 权限不够 寻找npm sudo find / -name npm 看到可以用nvm来解决这个问题 nvm官方文档 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash nvm install node 果真方便 nvm的详细使用（Linux） 稳妥起见还是安装了一个LTS版本 安装vue-cli开始下载不动，配置一下国内源 npm config set registry https://registry.npm.taobao.org npm install vue npm install -g @vue/cli 速度果然很快了 vue -V 4.2.3版本 使用 VUE UI创建项目vue ui 启动8000端口，界面如下： 该GUI界面只支持3.0以上版本 深色控改成了夜间模式… 手动完成相关配置，项目创建完成后自动打开一个仪表盘 运行服务器, 打开8080端口，出现前端页面，VUE牛皮！ 在IDEA中开发前端VUE在IDEA中导入刚才创建的项目，并安装vue.js插件 在IDE的终端 npm run serve 也可以直接启动8080端口 用假数据测试新建Book.vue文件，写好页面内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;书名&lt;/td&gt; &lt;td&gt;作者&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=&quot;item in books&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.author&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Book&quot;, data()&#123; return&#123; books:[ &#123; id:1, name: &apos;java_learn&apos;, author: &apos;wallen&apos; &#125;, &#123; id:2, name: &apos;java_learn30day&apos;, author: &apos;wallen&apos; &#125;, &#123; id:3, name:&apos;java&apos;, author: &apos;wallen&apos; &#125;, ] &#125; &#125; &#125;&lt;/script&gt; 在router的index.js中引入该组件 前端页面/book热更新 后端Spring Boot创建一个后端项目，选择所需依赖 配置application.perporties连接到Mysql 123456789101112spring.datasource.url = jdbc:mysql://localhost:3306/bookstorespring.datasource.username = ...spring.datasource.password = ...spring.datasource.driverClassName = com.mysql.jdbc.Driver# Specify the DBMSspring.jpa.database = MYSQL# Show or not log for each sql queryspring.jpa.show-sql = truespring.jpa.properties.hibernate.format_sql = trueserver.port=8181 JPA绑定数据创建实体类BookList 12345678@Entity@Datapublic class BookList &#123; @Id private Integer id; private String name; private String author;&#125; 创建BookListRepository 接口 12public interface BookListRepository extends JpaRepository&lt;BookList,Integer&gt; &#123;&#125; 对该接口进行单元测试 接口右键go to test 添加测试代码 1234567891011@SpringBootTestclass BookListRepositoryTest &#123; @Autowired private BookListRepository bookListRepository; @Test void findAll()&#123; System.out.println(bookListRepository.findAll()); &#125;&#125; 运行findAll()方法，报错 Failed to resolve org.junit.platform:junit-platform-launcher:1.5.2 在maven的setting.xml文件中添加阿里云镜像后依赖导入成功，运行报错 Caused by: java.sql.SQLSyntaxErrorException: Table ‘bookstore.book_list’ doesn’t exist 难道不能用驼峰？把之前的类和接口中的List都改成小写，再次运行，成功。可能的原因是JPA与数据库表名对应时只有首字母的大小写可以忽略 因为配置了show-sql 和 hibernate.format_sql 才显示上面的部分 根据提示：Loading class com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class iscom.mysql.cj.jdbc.Driver`. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 更改application中的配置类为com.mysql.cj.jdbc.Driver 对外接口创建BooklistHandler作为controller 1234567891011@RestController@RequestMapping(\"/book\")public class BooklistHandler &#123; @Autowired private BooklistRepository booklistRepository; @GetMapping(\"/findAll\") public List&lt;Booklist&gt; findAll()&#123; return booklistRepository.findAll(); &#125;&#125; 运行项目application的main方法, 访问 http://localhost:8181/book/findAll ，成功读出数据 前后端Axios对接在前端页面发送请求后端8181端口 vue add axios 在IDEA终端中安装插件axios，安装完毕在src中自动添加了一个plugins文件夹 Vue2.0之后，尤雨溪推荐大家用axios替换JQuery ajax，axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 支持 Promise API 客户端支持防止CSRF 提供了一些并发请求的接口（重要，方便了很多的操作） 从 node.js 创建 http 请求 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。简单来说： ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。 Axios中文说明 在Book.vue中添加初始化方法create() 12345created() &#123; axios.get(&apos;http://localhost:8181/book/findAll&apos;).then(function(resp)&#123; console.log(resp) &#125;) &#125; 请求类型为get , then 是回调函数，传入reponse结果 CROS跨域问题可以在前端或者后端进行解决，这里选择后端。 创建CrosConfig配置类 123456789101112131415161718@Configurationpublic class CrosConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; //设置允许跨域的路径 registry.addMapping(\"/**\") //设置允许跨域请求的域名 .allowedOrigins(\"*\") //是否允许证书 不再默认开启 .allowCredentials(true) //设置允许的方法 .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\",\"HEAD\",\"OPTIONS\") //跨域允许时间 .maxAge(3600) .allowedHeaders(\"*\"); &#125;&#125; 然后刷新8080,就可以在控制台获取到后台的data了 后台数据展示到页面123456created() &#123; const _this = this axios.get('http://localhost:8181/book/findAll').then(function(resp)&#123; _this.books = resp.data &#125;) &#125; 这里需要注意的是function原本的this 不能访问到外面的变量，所以要用_this把当前页面传进去 数据成功加载出来了 集成ElementUInpm install --save element-ui 项目命令行安装或者vue ui 查找element插件安装 重启项目，打开8080端口，主页会多出一个Button Element官方文档 CV布局容器中代码到App.vue , 注意html部分的el-container要放到div中 主页已经与官方示例一致，接下来分析el-xxx 了解其构成 el-menu :default-openeds 默认展开的子菜单，通过子菜单的index 值来关联 :default-active 默认选中的子菜单 el-submenu 可展开的菜单 index 必须是加引号的文本类型 template 菜单名 i 通过class 设置菜单图标 el-icon-message el-icon-menu el-icon-setting 更多样式参考icon组件 el-menu-item 菜单不可展开的子节点 index 必须是加引号的文本类型 el-main 一般用来存放页面跳转时的刷新内容 router-view 放在这里实现路由 导航动态加载App.vue中设置左侧菜单 12345678&lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt; &lt;el-menu&gt; &lt;el-submenu v-for=&quot;(item,index) in $router.options.routes&quot; :index=&quot;index+&apos;&apos;&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;&#123;&#123;item.name&#125;&#125;&lt;/template&gt; &lt;el-menu-item v-for=&quot;(item2,index2) in item.children&quot; :index=&quot;index+&apos;-&apos;+index2&quot;&gt;&#123;&#123;item2.name&#125;&#125;&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt;&lt;/el-aside&gt; v-for循环可以遍历index.js中配置的routes，加载相应个数的el-menu 这样的好处是方便以后新增菜单页面 读取出页面名称，:index = “index+’-‘“ 将遍历的下标转为文本类型的菜单index, 方便控制index.js路由内容123456789101112131415161718192021222324252627282930313233343536const routes = [ &#123; path: '/', name: 'nav1', component: App, children:[ &#123; path: '/pageone', name:\"pageone\", component: PageOne &#125;, &#123; path: '/pagetwo', name:\"pagetwo\", component: PageTwo &#125;, ] &#125;, &#123; path:\"/navigation\", name:\"nav2\", component:App, children:[ &#123; path: '/pagethree', name:\"pagthree\", component: PageThree &#125;, &#123; path: '/pagefour', name:\"pagefour\", component: PageFour &#125;, ] &#125;] 导航效果 左边的导航可以点击展开，下面的页面也可以点击切换了 确定驻留区和更新区可以看到上面的页面存在着页面嵌套的问题，接下来要对切换区域进行划分 App.vue只加载路由 12345&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 菜单栏放在Index.vue中 1234567891011121314151617&lt;template&gt; &lt;el-container style=&quot;height: 500px; border: 1px solid #eee&quot;&gt; &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt; &lt;el-menu&gt; &lt;el-submenu v-for=&quot;(item,index) in $router.options.routes&quot; :index=&quot;index+&apos;&apos;&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;&#123;&#123;item.name&#125;&#125;&lt;/template&gt; &lt;el-menu-item v-for=&quot;(item2,index2) in item.children&quot; :index=&quot;index+&apos;-&apos;+index2&quot;&gt;&#123;&#123;item2.name&#125;&#125;&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/el-container&gt;&lt;/template&gt; 然后把index.js中的app组件改为index，即可去掉嵌套 菜单切换与页面绑定 el-menu 标签添加router属性 Index.vue中el-menu 标签添加 router 在页面添加router-view 标签，这个容器可以动态渲染router el-menu-item 标签index 值就是要跳转的router el-menu-item 标签index 值改为`:index=”item2.path” 默认初始页面 redirect:跳转路径 路由数组中添加 redirect:&quot;/pageone&quot; 当前显示的页面被选中(特殊颜色) :class=&quot;$route.path==item2.path?&#39;is-active&#39;:&#39;&#39;&quot; 即地址栏路径与菜单栏item的index路径一致时，将该item标记特殊颜色 默认展开菜单 el-menu 添加 :default-openeds=&quot;[&#39;0&#39;,&#39;1&#39;]&quot; 表示默认展开菜单1和菜单2 1234567891011121314151617&lt;template&gt; &lt;el-container style=&quot;height: 500px; border: 1px solid #eee&quot;&gt; &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt; &lt;el-menu router :default-openeds=&quot;[&apos;0&apos;,&apos;1&apos;]&quot;&gt; &lt;el-submenu v-for=&quot;(item,index) in $router.options.routes&quot; :index=&quot;index+&apos;&apos;&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;&#123;&#123;item.name&#125;&#125;&lt;/template&gt; &lt;el-menu-item v-for=&quot;(item2,index2) in item.children&quot; :index=&quot;item2.path&quot; :class=&quot;$route.path==item2.path?&apos;is-active&apos;:&apos;&apos;&quot;&gt;&#123;&#123;item2.name&#125;&#125;&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/el-container&gt;&lt;/template&gt; 基于具体页面的数据对接选择一个所需的表样式和分页样式，注意要放在一个容器中，故可以新建一个div 绑定本页面script 中的数据el-table-column 标签的label 表示表头的名称，prop 用于跟script 中的tabelData中对应键名称进行绑定，实现数据导入 el-pagination分页标签 设置每页展示的记录条数:page-size=&quot;5&quot; 点击切换页面记录 @current-change=&quot;page&quot; 绑定page切换方法，方法要在script中实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;template&gt; &lt;div&gt; &lt;el-table :data=&quot;tableData&quot; border style=&quot;width: 100%&quot;&gt; &lt;el-table-column prop=&quot;id&quot; label=&quot;编号&quot; width=&quot;150&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;书名&quot; width=&quot;150&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;author&quot; label=&quot;标签&quot; width=&quot;150&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;150&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button @click=&quot;handleClick(scope.row)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;查看&lt;/el-button&gt; &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;编辑&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-pagination background layout=&quot;prev, pager, next&quot; :page-size=&quot;5&quot; :total=&quot;50&quot; @current-change=&quot;page&quot;&gt; &lt;/el-pagination&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; handleClick(row) &#123; console.log(row); &#125;, page(currentPage)&#123; switch(currentPage)&#123; case 1: this.tableData = [&#123; id: 1, name: &apos;前端&apos;, author: &apos;f&apos;, &#125;, ] break; case 2: this.tableData = [&#123; id: 2, name: &apos;后端&apos;, author: &apos;b&apos;, &#125;,] break; &#125; &#125; &#125;, data() &#123; return &#123; tableData: [&#123; id: 1, name: &apos;前端&apos;, author: &apos;f&apos;, &#125;, &#123; id: 2, name: &apos;后端&apos;, author: &apos;b&apos;, &#125;,] &#125; &#125; &#125;&lt;/script&gt; 页面效果 绑定后端数据首先在后端也要实现数据分页，JPA已经实现了这个功能, 进行测试，注意由于有多个重载，要选对参数类型。 1234567891011121314@SpringBootTestclass VueBackendtestApplicationTests &#123; @Autowired private BooklistRepository repository; @Test void contextLoads() &#123; PageRequest pageRequest = PageRequest.of(0,2); Page&lt;Booklist&gt; page = repository.findAll(pageRequest); int i = 0; &#125;&#125; 取第0页的两条记录，bug测试结果 BooklistHandler 中进行分页展示 123456789101112@RestController@RequestMapping(\"/book\")public class BooklistHandler &#123; @Autowired private BooklistRepository booklistRepository; @GetMapping(\"/findAll/&#123;page&#125;/&#123;size&#125;\") public Page&lt;Booklist&gt; findAll(@PathVariable(\"page\") Integer page, @PathVariable(\"size\") Integer size)&#123; PageRequest request = PageRequest.of(page,size); return booklistRepository.findAll(request); &#125;&#125; 打开http://localhost:8181/book/findAll/0/2 查看分页内容 对接要做的就是用实际的数据去替换tableData, 注意resp获取的数据格式, 数据在resp.data.content中 script 初始化 1234567created() &#123; const _this = this axios.get('http://localhost:8181/book/findAll/0/2').then(function(resp)&#123; //console.log(resp) _this.tableData = resp.data.content &#125;) &#125; 前端内容已更新为数据库内容 还要动态获取page和size, 在data中定义pageSize和total 变量，从created()中获取值 然后绑定给el-pagination的对应属性 :page-size=&quot;pageSize&quot; :total=&quot;total&quot; 同时更改跳转函数 page(), 只需在created()基础上传入当前页面参数即可 完整script代码(每页显示两条记录) 123456789101112131415161718192021222324252627282930313233&lt;script&gt; export default &#123; methods: &#123; handleClick(row) &#123; console.log(row); &#125;, page(currentPage)&#123; const _this = this axios.get(&apos;http://localhost:8181/book/findAll/&apos;+(currentPage-1)+&apos;/2&apos;).then(function(resp)&#123; _this.tableData = resp.data.content _this.pageSize = resp.data.size _this.total = resp.data.totalElements &#125;) &#125; &#125;, data() &#123; return &#123; pageSize:&apos;&apos;, total:&apos;&apos;, tableData: [] &#125; &#125;, created() &#123; const _this = this axios.get(&apos;http://localhost:8181/book/findAll/0/2&apos;).then(function(resp)&#123; _this.tableData = resp.data.content _this.pageSize = resp.data.size _this.total = resp.data.totalElements &#125;) &#125; &#125;&lt;/script&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://vergessenwang.github.io/tags/vue/"}]},{"title":"黑盒测试用例设计","slug":"黑盒测试用例设计","date":"2020-03-04T16:58:05.000Z","updated":"2020-03-04T16:59:23.971Z","comments":true,"path":"posts/Test/2020-03-05-黑盒测试用例设计.html","link":"","permalink":"http://vergessenwang.github.io/posts/Test/2020-03-05-黑盒测试用例设计.html","excerpt":"测试用例的构成要素 用例编号：唯一标识 如QQmail_login_001 用例标题：简要描述测试目的 何种情况下做何事有何结果 测试项目：所属项目 用例级别：重要程度，优先级 P1&gt;P2&gt;P3 预设条件：执行前提，如环境/数据 — 非必须 测试输入 执行步骤 预期结果：与执行的实际结果对比 在实际中根据项目要求对用例设计要素进行调整 黑盒测试用例设计方法从理论上讲，黑盒测试只能通过穷举输入测试。但是实际工作中这种方法是不可行的。所以衍生出多种黑盒测试用例设计方法，包括等价类划分法、边界值分析法、错误推测法、因果图发、判定表驱动法、正交试验设计法、功能图法、场景法等。 等价类分类代替穷举，根据功能需求分类 等价类：在所有测试的数据中，具有某种共同特征的子集 等价划分：是把程序的输入域划分成若干部分（子集），然后从每个部分中选取少数代表性数据作为测试用例。每一类的代表性数据在测试中的作用等价于这一类中的其他值。 有效等价类：是指对于程序的规格说明来说是合理的，有意义的输入数据构成的集合.利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。 无效等价类：与有效等价类的定义恰巧相反。无效等价类中是无效输入，系统预期返回一个错误值。测试无效输入能确保软件具有更高的可靠性。 设计测试用例时，要同时考虑这两种等价类.因为，软件不仅要能接收合理的数据，也要能经受意外的考验.这样的测试才能确保软件具有更高的可靠性。","text":"测试用例的构成要素 用例编号：唯一标识 如QQmail_login_001 用例标题：简要描述测试目的 何种情况下做何事有何结果 测试项目：所属项目 用例级别：重要程度，优先级 P1&gt;P2&gt;P3 预设条件：执行前提，如环境/数据 — 非必须 测试输入 执行步骤 预期结果：与执行的实际结果对比 在实际中根据项目要求对用例设计要素进行调整 黑盒测试用例设计方法从理论上讲，黑盒测试只能通过穷举输入测试。但是实际工作中这种方法是不可行的。所以衍生出多种黑盒测试用例设计方法，包括等价类划分法、边界值分析法、错误推测法、因果图发、判定表驱动法、正交试验设计法、功能图法、场景法等。 等价类分类代替穷举，根据功能需求分类 等价类：在所有测试的数据中，具有某种共同特征的子集 等价划分：是把程序的输入域划分成若干部分（子集），然后从每个部分中选取少数代表性数据作为测试用例。每一类的代表性数据在测试中的作用等价于这一类中的其他值。 有效等价类：是指对于程序的规格说明来说是合理的，有意义的输入数据构成的集合.利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。 无效等价类：与有效等价类的定义恰巧相反。无效等价类中是无效输入，系统预期返回一个错误值。测试无效输入能确保软件具有更高的可靠性。 设计测试用例时，要同时考虑这两种等价类.因为，软件不仅要能接收合理的数据，也要能经受意外的考验.这样的测试才能确保软件具有更高的可靠性。 划分准则等价类划分准则 在输入条件规定了取值范围或值的个数的情况下，则可以确立有一个有效等价类和两个无效等价类。—-如手机号由11位构成，无效则大/多于或者小/少于 在输入条件规定了输入值的集合或者规定了“必须如何”的条件情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则） —- 如要求电话都是数字，无效的情况可能是字母/汉字/特殊字符等多种情况 在输入条件是一个布尔量的情况下，可以确定一个有效等价类和一个无效等价类。 在规定了输入数据的一组值（假定n个），并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。 测试用例规则 为每一个等价类规定一个唯一的编号。 设计一个新的测试用例，使其尽可能多的覆盖尚未被覆盖的有效类。重复这一步，直到所有的有效等价类都被覆盖为止。 设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类被覆盖为止。 边界值大量的错误是发生在输入或输出范围的边界上，而不是在输入范围的内部。经验证明，考虑了边界调节的测试用例与其他没有考虑边界条件的测试用例相比，具有更高的测试回报率。 相比与等价类法，多了一个步骤：确定上点，离点，内点 上点 离点 内点 如果是闭区间，例如[1，10]。那么上点就是1,10。内点就是区间内任意一个数字，例如5。离点则是0,11 如果是开区间，例如（1,10）。那么上点就是1,10。内点就是区间内任意一个数字，例如5。离点则是（2,9） 这两个最大的区别就是在于离点的不同，概括起来一句话就是闭两边，开中间。也就是说闭区间的离点是区间外边相邻的两个数字（0,11），开区间的离点就是区间里边相邻的两个数字（2,9）。如两位整数加法器数的范围为-99—99，则应测试-99，-100和99，100 继续以电话号码的地区嘛为例，现在需要关注的是边界，如无效等价类6要测小于四位数的情况，现在的边界值就是3位 判定表使用等价类方法时对于输入域及输出域存在关联时无法覆盖，可以理解为判定表通过组合覆盖更多的情况 优点：能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。因此，利用判定表能够设计出完整的测试用例集合。在一些数据处理问题当中，某些操作的实施依赖于多个逻辑条件的组合，即：针对不同逻辑条件的组合值，分别执行不同的操作。判定表适合于处理这类问题。 判定表要素1)条件桩（Condition Stub）：列出了问题得所有条件。通常认为列出的条件的次序无关紧要。—- 输入 2)动作桩（Action Stub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。—- 输入的结果 3)条件项（Condition Entry）：列出针对它左列条件的取值。在所有可能情况下的真假值。—条件集合 4)动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作。 —- 动作集合 规则及规则合并1)规则：任何一个条件组合的特定取值及其相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。显然,判定表中列出多少组条件取值,也就有多少条规则,既条件项和动作项有多少列。 2)化简：就是规则合并有两条或多条规则具有相同的动作，并且其条件项之间存在着极为相似的关系。 如果动作结果一样，对于某些因素取“1”或“0”没有影响，即以“—”表示，并合并。 步骤：定义条件桩与动作桩 –&gt; 设计优化判定表 –&gt; 填写动作项 –&gt; 简化判定表 –&gt; 抽取用例(每个规则一条用例) 假定：优先警告缺纸，然后警告没有墨粉，最后警告驱动程序不对。 判定表的优/缺点优点：把复杂的问题按各种可能的情况一一列举，简明而易于理解，也避免遗漏。 缺点：不能表达重复执行的动作，如循环结构。判定表不能很好的伸缩。如有n个条件的判定表有2^n个规则。 因果图判定表的指数增长不适合复杂的条件，是先组合再分析关系；而因果图是先考虑所有输入/输出条件的相关制约关系及组合，输入与输出的关系，再根据分析的关系转化为判定表的规则 输入和输出的关系 输入条件之间的关系 输出条件之间的关系 设计步骤： 分析程序规格说明的描述中，哪些是原因，哪些是结果。 分析程序规格的描述中语义的内容，并将其表示成连接各个原因与各个结果的“因果图”。由于语法或环境的限制，有些原因与原因之间、原因与结果之间的组合情况不可能出现。为表明这些特殊情况，在因果图上用一些记号表明约束或限制条件。 把因果图转换为决策表。用0和1标识，中间状态也放在开始里面 根据决策表中的每一列设计测试用例。即：找出原因、结果 – 找出关系，画因果图 – 找出约束和限制，加上标记 – 转化为决策表 – 为每一个规则设计测试用例 场景法软件几乎都是用事件触发来控制流程的，时间触发时的情景形成场景，同一事件不同的触发顺序和处理结果形成事件流 事件流和备选流基本流：仅有一个基本流；经过用例的最简单的路径，指每个步骤都“正常”运作时所发生的事 —-正常 备选流 ：可以有多个；可选的或备选的情况 ，异常事件流程。—- 异常 场景是事件流的一个实例，由基本流或（基本流+备选流）的步骤组成，表明了用户执行系统操作系列。从开始到结束才算一个场景，其实画出来有点像UML中的流程图 备选流越多，场景越多，执行路径越多，将导致场景爆炸。 选取典型场景进行测试，其基本如下：1、最少场景数等于基本流与备选流的总数。2、有且唯一有一个场景仅包含基本流。3、对应某个备选流，至少应该有一个场景覆盖备选流，且在该场景中应尽量避免覆盖其他备选流。 上图的用例场景如下： 正交法根据正交性从全面试验中挑选出部分有代表性的点进行试验，这些有代表性的点具备了“均匀分散，齐整可比”的特点，正交试验设计是一种基于正交表的、高效率、快速、经济的试验。 正交实验设计方法：从大量的测试案例中挑选适量的、有代表性的例子，从而合理地安排测试的一种科学实验设计方法。通常用于配置测试 因素与水平因素数：条件因子的个数 水平数：条件因子取值的个数，取所有条件因子中取得值数目最大的那个。 正交表根据因素数、水平数、最小实验次数n，选择合适的正交表。 n = ∑(每列因素的水平数-1) + 1，也就是说正交表的行数要取大于n的最小值。 把变量的值映射到表中，每一行即一个测试用例。 使用正交表设计用例，（1）确定因素的取值范围或集合，（2）采用等价类划分、边界值分析等方法确定测试数据，（3）将确定的测试数据作为对应因素的水平值，（4）根据合适的正交表设计用例。 并不是我们想要什么正交表就有什么正交表，我们选取正交表时只能从现有的正交表中进行选择，而且选择的正交表要满足上述中的因素数、水平数、和最小实验次数n，在这个前提下选择实验次数最少的一个。 步骤：分析需求获取因子及水平 –&gt; 根据因子及水平数选择正交表 –&gt; 替换因子水平，获取实验次数 –&gt; 细化输出测试用例 错误推测法经验和直觉，没有具体的步骤，基于以往的项目经历对常出问题的点针对性设计测试用例 一般不单独使用，要在其他测试方法之上进行针对性测试 总结 可以关注该作者的文章","categories":[{"name":"Test","slug":"Test","permalink":"http://vergessenwang.github.io/categories/Test/"}],"tags":[{"name":"黑盒测试","slug":"黑盒测试","permalink":"http://vergessenwang.github.io/tags/黑盒测试/"}]},{"title":"IDEA内置Database插件连接Deepin上的MySql","slug":"IDEA内置Database插件连接Deepin上的MySql","date":"2020-03-04T06:49:09.000Z","updated":"2020-03-06T12:41:46.056Z","comments":true,"path":"posts/database/2020-03-04-IDEA内置Database插件连接Deepin上的MySql.html","link":"","permalink":"http://vergessenwang.github.io/posts/database/2020-03-04-IDEA内置Database插件连接Deepin上的MySql.html","excerpt":"配置serversudo apt-get install -y mysql-server mysql-client 安装 sudo mysql -uroot -p 初始密码直接空格 进入Mysql命令行 use mysql; update user set authentication_string=&#39;新密码&#39; where user=&#39;root&#39;; 注意修改密码要加单引号","text":"配置serversudo apt-get install -y mysql-server mysql-client 安装 sudo mysql -uroot -p 初始密码直接空格 进入Mysql命令行 use mysql; update user set authentication_string=&#39;新密码&#39; where user=&#39;root&#39;; 注意修改密码要加单引号 进行一些基本的sql操作 么的问题 IDEA驱动设置在IDEA中使用时 mysql-connector-java-8.0.15.jar 下载超时 国内下载链接.. 在项目中导入该jar依赖包 在database插件中配置驱动器 找到IDEA默认的存放驱动器的路径，将jar放在该目录下 /home/wliana/.IntelliJIdea2019.3/config/jdbc-drivers 还得下一个5.1.47版本，放在Mysql for 5.1 重新测试连接 Access denied for user ‘root‘@’localhost’ 连接问题排查可能访问权限没有开放，回到mysql 进行授权 grant all privileges on *.* to &#39;root&#39; @&#39;%&#39; identified by &#39;root&#39;; flush privileges; 然而并不是这个原因，经过好长时间多角度试探，我发觉了一个盲点…应该是密码编码转换的问题 select user, plugin from mysql.user; root的plugin被修改成了unix_socket，用密码登陆的plugin应该是mysql_native_password update mysql.user set plugin=&quot;mysql_native_password&quot; where user=&quot;root&quot;; 但是这样一来我用原来的密码登不上了….应该同步更新一下密码的 /etc/init.d/mysql stop 停止服务 企图跳过授权表…：mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp; ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’ (2 “No such file or directory”) 尝试重启：会重新生产mysqld.sock文件 成功登进去并重置了密码，但还是有同样的问题….算了，该睡觉了 感觉问题出在Linux上，因为之前的plugin是unix_socket 在Debian中软件包mysql已经替换成了mariadb了。在安装后/etc/mysql/mariadb.cnf预设了root用户使用socket的连接方式，所以不输入密码也可在命令行直接使用mysql命令登录。 难道说IDEA用@其实是一种远程连接的形式？ 修改/etc/mysql/mariadb.conf.d/50-server.cnf中的bind-address为允许的网络地址，若为整个网络则填入0.0.0.0或注释掉 啊，我好像发现问题了 authentication_string = password(&#39;密码&#39;) 应该是这样才对，我之前是直接跟的一个字符串… 回到IDEA测试 连接成功！ 可以直接在IDEA中进行mysql操作啦","categories":[{"name":"database","slug":"database","permalink":"http://vergessenwang.github.io/categories/database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://vergessenwang.github.io/tags/MySQL/"}]},{"title":"Git关联Github和码云并利用IDEA内置工具","slug":"Git关联Github和码云并利用IDEA内置工具","date":"2020-03-02T09:07:38.000Z","updated":"2020-03-02T09:40:15.199Z","comments":true,"path":"posts/Project/2020-03-02-Git关联Github和码云并利用IDEA内置工具.html","link":"","permalink":"http://vergessenwang.github.io/posts/Project/2020-03-02-Git关联Github和码云并利用IDEA内置工具.html","excerpt":"Git教程 Git与Svn对比Svn是集中式版本控制系统，必须联网才能工作。在一定成程度上可以看到其他开发人员在干什么，管理员也可以很轻松的掌握每个人的开发权限。 缺点：服务器单点故障；容错性差 Git是分布式版本控制系统，每人的电脑上有一个完整的本地仓库，多人协作时只需要把各自的修改推送给对方 初次使用配置安装git sudo apt-get install git 配置用户名和邮箱 git config --global user.name &quot;用户名&quot; git config --global user.email &quot;邮箱&quot; 生成ssh公匙、私匙 ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;三次回车 将id_rsa.pub的内容追加到authorized_keys 中 cat /home/wliana/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 其中id_rsa 为私钥，id_rsa.pub 为公钥 在github，进入Account Settings，左边选择SSH Keys，Add SSH Key, 粘贴cat /home/deepin/.ssh/id_rsa.pub获取的key 测试下是否配置成功 ssh -T git@github.com 按提示输入 yes 连接成功","text":"Git教程 Git与Svn对比Svn是集中式版本控制系统，必须联网才能工作。在一定成程度上可以看到其他开发人员在干什么，管理员也可以很轻松的掌握每个人的开发权限。 缺点：服务器单点故障；容错性差 Git是分布式版本控制系统，每人的电脑上有一个完整的本地仓库，多人协作时只需要把各自的修改推送给对方 初次使用配置安装git sudo apt-get install git 配置用户名和邮箱 git config --global user.name &quot;用户名&quot; git config --global user.email &quot;邮箱&quot; 生成ssh公匙、私匙 ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;三次回车 将id_rsa.pub的内容追加到authorized_keys 中 cat /home/wliana/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 其中id_rsa 为私钥，id_rsa.pub 为公钥 在github，进入Account Settings，左边选择SSH Keys，Add SSH Key, 粘贴cat /home/deepin/.ssh/id_rsa.pub获取的key 测试下是否配置成功 ssh -T git@github.com 按提示输入 yes 连接成功 Github和本地Git关联远程仓库在Github上新建一个远程仓库，最好不要勾选README.md 由于已经配置了RSA，可以直接使用SSH协议 本地仓库可参照上图命令 进入文件夹，使用git init变成可Git管理的库（或者在文件夹中新建一个.git文件夹） 将项目粘贴到仓库中（粘贴后可以通过git status来查看你当前的状态） git add . 把该目录下的所有文件添加到仓库（注意点是用空格隔开的） git commit -m提交注释把项目提交到仓库 关联及推送$ git remote add origin git@&lt;用户名&gt;/&lt;目标仓库&gt;.git 关联好之后我们就可以把本地库的所有内容推送到远程仓库 首次推送使用：$ git push -u origin master 新建的远程仓库是空的，所以要加上-u 远程仓库里面有了内容之后使用：$ git push origin master 准备回到github上看看，结果又连不上了，看来远程仓库还是的选国内的啊…哦豁，连博客都挂了… 同时关联到码云基于上面github不太稳定的原因，打算同时关联到码云。 注册并添加公钥，创建仓库 多么熟悉的味道.. 下面参照官方文档 如何保持码云Gitee和Github 同步更新 查看目前关联的远程仓库，发现有一个orgin , 这是之前关联到github上的，为了便于管理，删掉并重命名 先删除已关联的名为origin的远程库 git remote rm origin 通过 git remote add &lt;name&gt; &lt;url-of-remote&gt;指令来添加远程仓库 用git remote -v查看远程库信息,可以看到两个远程库 返回码云仓库，已更新, 大功告成 流程及命令 工作区域Git分为三个工作区域：工作区 Working Directory、暂存区 Staging Area、GIT仓库 repository 工作区（Working Directory）就是源码所在目录 隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 文件状态 Untracked 未追踪，即新建一个文件，还没有被git追踪，不会到版本库内。 Unmodified 未修改，该文件在git版本库内，但是还没有被修改。 modified 已修改，该文件在git版本库，已经修改，但还没有暂存。 Staged 已暂存，有修改的文件已经通过git add添加到暂存区。 仓库内文件的状态可以通过git status查看。 分支管理查看分支：git branch 创建分支：git branch 分支名 切换分支：git checkout 分支名 或者git switch 分支名 创建+切换分支：git checkout -b 分支名或者git switch -c 分支名 合并某分支到当前分支：git merge 分支名 删除分支：git branch -d 分支名 假设分支为dev, 合并Fast-forward是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 常用命令命令思维导图，来自文章 git常用操作命令总结(思维导图) 忽略特殊文件在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 在IDEA中使用Git在工具栏找到VCS ，新建Git目录 或者直接打开一个已经初始化了的工作区目录 这时IDEA右上角多了一些git操作 分别是pull 拉取更新；commit 提交；历史版本；回滚 在commit时就可以勾选需要同步的文件 history会在下面出现一个管理界面 同时VSC内容也发生了变化 这样就可以直接使用IDEA内置的工具来进行操作了 讲道理，为什么图这么糊？！强迫症选手根本无法忍受…明明我本地的图片很高清，上去后台看了一下，是原图..所以PicGo和OSS都没有压缩，那问题难道出在Typora的分辨率上？ 打开以前Blog看了一下，好像还真是..","categories":[{"name":"Project","slug":"Project","permalink":"http://vergessenwang.github.io/categories/Project/"}],"tags":[{"name":"版本管理","slug":"版本管理","permalink":"http://vergessenwang.github.io/tags/版本管理/"}]},{"title":"Java正则表达式","slug":"Java正则表达式","date":"2020-02-26T09:56:45.000Z","updated":"2020-02-26T10:02:52.729Z","comments":true,"path":"posts/Java/2020-02-26-Java正则表达式.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-02-26-Java正则表达式.html","excerpt":"正则表达式是一套标准，可用于任何语言 JDK内置正则表达式引擎：Java.uilt.regex 方法String类里也提供了如下几个特殊的方法。 boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。 String replaceAll(String regex, String replacement)：将该字符串中所有匹配regex的子串替换成replacement String replaceFirst(String regex, String replacement)：将该字符串中第一个匹配regex的子串替换成replacement String[] split(String regex)：以regex作为分隔符，把该字符串分割成多个子串。 上面这些特殊的方法都依赖于Java提供的正则表达式支持，除此之外，Java还提供了Pattern和Matcher两个类专门用于提供正则表达式支持。 精确匹配 需匹配 正则表达式 Java中正则 a&amp;c a\\&amp;c a\\&amp;c a和c a\\u548cc a\\u548cc 正则中特殊符号最好转义一下，而Java中\\也需转义 非ASCII字符用了\\u####表示，也要转义，不过这里Markdown没有显示岀来","text":"正则表达式是一套标准，可用于任何语言 JDK内置正则表达式引擎：Java.uilt.regex 方法String类里也提供了如下几个特殊的方法。 boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。 String replaceAll(String regex, String replacement)：将该字符串中所有匹配regex的子串替换成replacement String replaceFirst(String regex, String replacement)：将该字符串中第一个匹配regex的子串替换成replacement String[] split(String regex)：以regex作为分隔符，把该字符串分割成多个子串。 上面这些特殊的方法都依赖于Java提供的正则表达式支持，除此之外，Java还提供了Pattern和Matcher两个类专门用于提供正则表达式支持。 精确匹配 需匹配 正则表达式 Java中正则 a&amp;c a\\&amp;c a\\&amp;c a和c a\\u548cc a\\u548cc 正则中特殊符号最好转义一下，而Java中\\也需转义 非ASCII字符用了\\u####表示，也要转义，不过这里Markdown没有显示岀来 符号合法字符 特殊字符特殊字符在正则表达式中有其特殊的用途，如果需要匹配这些特殊字符，就必须首先将这些字符转义，也就是在前面添加一个反斜线（\\） 将上面多个字符拼起来，就可以创建一个正则表达式。 预定义字符“通配符”是可以匹配多个字符的特殊字符。正则表达式中的“通配符”远远超出了普通通配符的功能，它被称为预定义字符 12String input = “1990”;boolean is19xx = input.matches(“19\\\\d\\\\d”); 范围匹配方括号表达式 注意只能匹配[]其中一个字符 \\^写在[]取非；写在开始从行的开头开始匹配 正则表示还支持圆括号表达式，用于将多个表达式组成一个子表达式，圆括号中可以使用或运算符（|）。例如，正则表达式”(public|protected|private)”用于匹配Java的三个访问控制符其中之一。\\\\w{3,20}@\\\\w+\\\\.(com|org|cn|net|gov) 圆括号还可用于提取所需字符串，去掉多余内容 边界匹配符 数量标识符正则表达式支持的数量标识符有如下几种模式 Greedy（贪婪模式）：数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为——你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。 Reluctant（勉强模式）：用问号后缀（?）表示，它只会匹配最少的字符。也称为最小匹配模式。 Possessive（占有模式）：用加号后缀（+）表示，目前只有Java支持占有模式，通常比较少 使用Pattern和Matcher类Pattern对象是正则表达式编译后在内存中的表示形式，因此，正则表达式字符串必须先被编译为Pattern对象，然后再利用该Pattern对象创建对应的Matcher对象。执行匹配所涉及的状态保留在Matcher对象中，多个Matcher对象可共享同一个Pattern对象。Pattern是不可变类，可供多个并发线程安全使用。只编译一次然后多次使用可以提高匹配效率 123//将一个字符串编译成Pattern对象Pattern p=Pattern.compile(\"a*b\");//使用Pattern对象创建Matcher对象Matcher m=p.matcher(\"aaaaab\");boolean b=m.matches(); //返回true 如果某个正则表达式仅需一次使用，则可直接使用Pattern类的静态matches方法，此方法自动把指定字符串编译成匿名的Pattern对象 boolean b=Pattern.matches(&quot;a*b&quot;, &quot;aaaaab&quot;); //返回true 但采用这种语句每次都需要重新编译新的Pattern对象，不能重复利用已编译的Pattern对象，所以效率不高。 Matcher类提供了如下几个常用方法。 find()：返回目标字符串中是否包含与Pattern匹配的子串。 find()方法还可以传入一个int类型的参数，带int参数的find()方法从该int索引处向下搜索。group()：返回上一次与Pattern匹配的子串。 start()：返回上一次与Pattern匹配的子串在目标字符串中的开始位置。 end()：返回上一次与Pattern匹配的子串在目标字符串中的结束位置加1。 lookingAt()：返回目标字符串前面部分与Pattern是否匹配。 matches()：返回整个目标字符串与Pattern是否匹配。 reset()，将现有的Matcher对象应用于一个新的字符序列。replaceAll()把字符串中所有与正则表达式匹配的子串替换replaceFirst()，该方法只替换第一个匹配的子串 在Pattern、Matcher类的介绍中经常会看到一个CharSequence接口，该接口代表一个字符序列，其中CharBuffer、String、StringBuffer、StringBuilder都是它的实现类。","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://vergessenwang.github.io/tags/正则表达式/"}]},{"title":"JVM数据分区","slug":"JVM数据分区","date":"2020-02-19T15:57:27.000Z","updated":"2020-02-19T15:58:26.485Z","comments":true,"path":"posts/Java/2020-02-19-JVM数据分区.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-02-19-JVM数据分区.html","excerpt":"HotSpot虚拟机HotSpot虚拟机是Oracle/OpenJDK中JVM的一种默认实现，其他实现还有BEA System公司的JRockit与IBM公司的IBM J9。 HotSpot虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准即时编译和栈上替换编译（On-Stack Replacement，OSR）行为 HotSpot虚拟机中含有两个即时编译器，分别是编译耗时短但输出代码优化程度较低的客户端编译器（简称为C1）以及编译耗时长但输出代码优化质量也更高的服务端编译器（简称为C2）通常它们会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统 自JDK 10起，HotSpot中又加入了一个全新的即时编译器：Graal编译器。Graal编译器是以C2编译器替代者的身份登场的。Graal能够做比C2更加复杂的优化，如“部分逃逸分析”（Partial Escape Analysis），也拥有比C2更容易使用激进预测性优化（Aggressive Speculative Optimization）的策略，支持自定义的预测性假设等。 然而需要预热才能达到最高性能等特点有悖于目前微服务架构的趋势。一种解决方案是提前编译，Substrate VM是在Graal VM 0.20版本里新出现的一个极小型的运行时环境，包括了独立的异常处理、同步调度、线程管理、内存管理（垃圾收集）和JNI访问等组件，目标是代替HotSpot用来支持提前编译后的程序执行。但要求目标程序是完全封闭的，即不能动态加载其他编译器不可知的代码和类库。","text":"HotSpot虚拟机HotSpot虚拟机是Oracle/OpenJDK中JVM的一种默认实现，其他实现还有BEA System公司的JRockit与IBM公司的IBM J9。 HotSpot虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准即时编译和栈上替换编译（On-Stack Replacement，OSR）行为 HotSpot虚拟机中含有两个即时编译器，分别是编译耗时短但输出代码优化程度较低的客户端编译器（简称为C1）以及编译耗时长但输出代码优化质量也更高的服务端编译器（简称为C2）通常它们会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统 自JDK 10起，HotSpot中又加入了一个全新的即时编译器：Graal编译器。Graal编译器是以C2编译器替代者的身份登场的。Graal能够做比C2更加复杂的优化，如“部分逃逸分析”（Partial Escape Analysis），也拥有比C2更容易使用激进预测性优化（Aggressive Speculative Optimization）的策略，支持自定义的预测性假设等。 然而需要预热才能达到最高性能等特点有悖于目前微服务架构的趋势。一种解决方案是提前编译，Substrate VM是在Graal VM 0.20版本里新出现的一个极小型的运行时环境，包括了独立的异常处理、同步调度、线程管理、内存管理（垃圾收集）和JNI访问等组件，目标是代替HotSpot用来支持提前编译后的程序执行。但要求目标程序是完全封闭的，即不能动态加载其他编译器不可知的代码和类库。 在JDK 9时期，HotSpot虚拟机开放了Java语言级别的编译器接口（Java Virtual Machine Compiler Interface，JVMCI），使得在Java虚拟机外部增加、替换即时编译器成为可能，Graal编译器就是通过这个接口植入到HotSpot之中。 到了JDK 10，HotSpot又重构了Java虚拟机的垃圾收集器接口（Java Virtual Machine Compiler Interface），统一了其内部各款垃圾收集器的公共行为。 Java技术体系OpenJdk Java程序设计语言、Java虚拟机、Java类库这三部分统称为JDK（Java Development Kit） Java类库API中的Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment） JVM从软件层面屏蔽不同操作系统在底层硬件与指令上的区别 JVM数据分区 线程共享：方法区(元空间) 堆 线程私有：虚拟机栈(线程栈) 本地方法栈 程序计数器 虚拟机栈每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型 方法不能太长，一般不超过120行，过长会占用很多栈空间。拆分成模块，调用后马上弹出。不过也要考虑切换开销，这是时间换空间 这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。 在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。 程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。 每条线程都需要有一个独立的程序计数器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。 此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。 本地方法栈本地方法以Native关键字修饰，没有具体实现，通过执行引擎让操作系统调用相应的dll文件，早期用于Java和C语言的交互，调用C语言实现的底层代码。 与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。 方法区(元空间)存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，这种特性被开发人员利用得比较多的便是String类的intern()方法。 在JDK 8以前，HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。这种设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小） 《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。 堆Java堆在虚拟机启动时创建。在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配”，Java堆是垃圾收集器管理的内存区域 现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。 Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的 从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词，不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。 如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。 直接内存 在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 理解代码底层运行状态反汇编 javap -c xx.class &gt; xx.txt根据JVM命令手册查询每行汇编代码的含义","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://vergessenwang.github.io/tags/JVM/"}]},{"title":"Docker中运行Neo4j","slug":"Docker中运行Neo4j","date":"2020-02-17T12:29:15.000Z","updated":"2020-02-17T12:32:38.061Z","comments":true,"path":"posts/database/2020-02-17-Docker中运行Neo4j.html","link":"","permalink":"http://vergessenwang.github.io/posts/database/2020-02-17-Docker中运行Neo4j.html","excerpt":"查看最新的Neo4j镜像版本 此时最新为4.0 docker pull neo4j:4.0 拉取镜像4.0 报错Error response from daemon: Get https://registry-1.docker.io/v2/: dial tcp: lookup registry-1.docker.io on 10.0.2.3:53: read udp 10.0.2.15:51774-&gt;10.0.2.3:53: i/o timeout 可能DNS解析有点问题，看了一下全都是美国弗吉尼亚的Amazon数据中心，应该是访问不到 去找阿里云镜像，然后被满页的广告蒙蔽了双眼，一个多小时之后，我买了一台云服务器 ：D 我是谁？我在哪？我刚才不是在学Docker吗？后来，我就开始搭服务器了。。。","text":"查看最新的Neo4j镜像版本 此时最新为4.0 docker pull neo4j:4.0 拉取镜像4.0 报错Error response from daemon: Get https://registry-1.docker.io/v2/: dial tcp: lookup registry-1.docker.io on 10.0.2.3:53: read udp 10.0.2.15:51774-&gt;10.0.2.3:53: i/o timeout 可能DNS解析有点问题，看了一下全都是美国弗吉尼亚的Amazon数据中心，应该是访问不到 去找阿里云镜像，然后被满页的广告蒙蔽了双眼，一个多小时之后，我买了一台云服务器 ：D 我是谁？我在哪？我刚才不是在学Docker吗？后来，我就开始搭服务器了。。。 一天之后，我回来了。继续学这个 云服务器在云服务器中 docker pull neo4j 默认拉取 lasted 版本，这时速度依然很慢 添加阿里云地址 速度起飞…. docker run -it -d -p 7474:7474 -p 7687:7687 neo4j:4.0 7474端口用于管理界面，7687端口用于登录连接neo4j服务端 。采用后台运行方式启动，返回一个containerid 然而在云服务器还要进行安全组端口配置 这里试了几次都有点问题，不太明白是哪里出了问题，难度是没装java？或者是防火墙没关？ 先装sdkman来管理java，先装个java8 不得不说挺方便的，不用自己去改环境变量了 java -version 查看的版本为1.8 折腾了一会放弃了，还是在电脑上运行把。 Windows同样添加一下toolbox镜像加速 1234docker-machine ssh defaultsudo sed -i &quot;s|EXTRA_ARGS=&apos;|EXTRA_ARGS=&apos;--registry-mirror=阿里云镜像加速地址 |g&quot; /var/lib/boot2docker/profileexitdocker-machine restart default 这里使用的是我自己阿里云控制台里的镜像加速地址 重启之后提示 docker info 无法查看信息，提示 You may need to re-run the docker-machine env command. docker-machine env default 根据查询结果 输入 eval $(&quot;C:\\Program Files\\Docker Toolbox\\docker-machine.exe&quot; env default) 再次 docker info 查看信息成功，重新拉取neo4j, 很快的样子 二十分钟过后….好吧，并不快…. 运行docker run -d -p 7474:7474 -p 7687:7687 neo4j 在浏览器依然没有显示？？ 怎么回事，之前用neo4j的bin文件运行是没有问题的，难道是docker的原因？ 这时我想到了，docker实际上是一个虚拟机，那么在浏览器用localhost的访问当然是不行的，所以找到docker的IP 为 192.168.99.100 再访问 http://192.168.99.100:7474/browser/ 就有界面了 云服务器这时我又回到云服务器，试图找出存在的问题 用docker ps -a 命令 我发现在本机运行时 12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2d9721591b68 neo4j \"/sbin/tini -g -- /d…\" 53 minutes ago Up 48 minutes 0.0.0.0:7474-&gt;7474/tcp, 7473/tcp, 0.0.0.0:7687-&gt;7687/tcp jolly_goldberg 状态为UP ， 端口也映射成功 但是云服务器上的却是 Exited (1) 12345CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES28ba3f7d0527 neo4j \"/sbin/tini -g -- /d…\" 10 seconds ago Exited (1) 9 seconds ago fervent_ptolemy0ba0cba50e7d neo4j \"/sbin/tini -g -- /d…\" 11 minutes ago Exited (1) 11 minutes ago sad_pascal03f239d99289 neo4j:4.0 \"/sbin/tini -g -- /d…\" 3 hours ago Exited (1) 3 hours ago tender_shannon78df828be80b hello-world \"/hello\" 23 hours ago Exited (0) 23 hours ago suspicious_mestorf 也就是说，neo4j并没有正常的运行起来 去掉后台运行参数-d 后重新运行，报错 /var/lib/neo4j/bin/neo4j: line 238: /var/lib/neo4j/conf/neo4j.conf: Permission denied 出现了访问限制。 然而我并没有找到这个/var/lib/neo4j 这个目录，应该是要修改镜像文件吧。然而docker一般都是部署的已经写好的代码，所以用在云服务器上用docker运行neo4j的话，其实还要对源码进行相应的修改，构建自己的镜像，这个以后真正要部署的时候再说吧，也就是上传源码的事 话说回来，我一定非要在docker中运行neo4j吗… linux又开始折腾了，这次是在linux系统上装了Docker 和Neo4J sudo docker run --publish=7474:7474 --publish=7687:7687 neo4j 成功运行起来了, 使用默认账户密码neo4j/neo4j 登陆","categories":[{"name":"database","slug":"database","permalink":"http://vergessenwang.github.io/categories/database/"}],"tags":[{"name":"Neo4j","slug":"Neo4j","permalink":"http://vergessenwang.github.io/tags/Neo4j/"},{"name":"Docker","slug":"Docker","permalink":"http://vergessenwang.github.io/tags/Docker/"}]},{"title":"LC-链表专题(一)","slug":"LC-链表专题-一","date":"2020-02-16T13:19:09.000Z","updated":"2020-02-16T13:23:34.101Z","comments":true,"path":"posts/Intern/2020-02-16-LC-链表专题-一.html","link":"","permalink":"http://vergessenwang.github.io/posts/Intern/2020-02-16-LC-链表专题-一.html","excerpt":"2 两数相加【中】 思路：先获取两个链表的长度，以较长的的作为遍历次数。新建一个链表存储结果，每次循环将对应的位的数相加，同时设置一个标志位记录本次加法是否进位。若有进位则下一次的加法要+1","text":"2 两数相加【中】 思路：先获取两个链表的长度，以较长的的作为遍历次数。新建一个链表存储结果，每次循环将对应的位的数相加，同时设置一个标志位记录本次加法是否进位。若有进位则下一次的加法要+1 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 改进： 无需遍历获得长度，当两结点均为null时终止循环即可 注意不要遗漏最后的一次进位 使用dummyHead结点保存结果链表的起始位置，用于返回最终结果 dummyHead.next Java中新建值为x的链表结点new ListNode(x) 下一结点Cur.next —不用指针真方便啊 时间和空间复杂度：$O(max(m,n))$ 19 删除链表的倒数第N个节点【中】 思路:双指针差距为n，同时向后移动，当后面那个指针指向null时，前一个指针所指的即为要删除的结点。要返回链表的头结点，还要设一个指针存储头结点位置。—快慢指针 1234567891011121314151617class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode pre = new ListNode(0); pre.next = head; ListNode start = pre, end = pre; while(n != 0) &#123; start = start.next; n--; &#125; while(start.next != null) &#123; start = start.next; end = end.next; &#125; end.next = end.next.next; return pre.next; &#125;&#125; 改进： 为了方便处理head被删除的特殊情况，添加一个pre/dummyHead结点，使pre.next = head 因为删除时要知道前一结点，故判断条件为start.next=null时终止，此时end正好位于倒数n+1的位置 Java的删除end.next = end.next.next; 因为有垃圾回收机制，无需手动free 时间复杂度：$O(n)$ 21 合并两个有序链表【易】 思路：取下两个链表中较小的头结点挂到新链表的末尾，当其中一个链表为空时将另一个链表的剩余部分整体挂上。注意新链表是直接利用原链表中的结点，没有新建。 12345678910111213141516171819class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode prehead = new ListNode(-1); ListNode prev = prehead; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; prev.next = l1 == null ? l2 : l1; return prehead.next;## &#125;&#125; 改进： prev.next = l1 == null ? l2 : l1;此句简单精妙 最好时间复杂度：$O(min(m,n))$最坏时间复杂度：$O(m+n)$ 递归法:两个链表头部较小的一个与剩下元素的 merge 操作结果合并。如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。如果两个链表都是空的，那么过程终止—递归就是简洁 12345678910111213141516171819class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; 时间和空间复杂度：$O(m+n)$ 23 合并K个有序链表【难】思路: k路归并的具体实现，不太清楚，难道是堆排序?建一个K个结点的小根堆 12345678910111213141516171819202122public ListNode mergeKLists(ListNode[] lists) &#123; int len = 0; if((len=lists.length)==0 || lists == null) return null; ListNode preHead = new ListNode(-1); ListNode preNode = preHead; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(len, new Comparator&lt;ListNode&gt;() &#123; @Override public int compare(ListNode o1, ListNode o2) &#123; return o1.val - o2.val; &#125; &#125;); for (ListNode node : lists) &#123; if(node!=null) queue.add(node); &#125; while(!queue.isEmpty())&#123; ListNode small = queue.poll(); preNode.next = small; if(small.next!=null) queue.add(small.next); //将最小值节点后面的节点添加到队里中 preNode = preNode.next; &#125; return preHead.next; &#125; 改进： 用优先队列来代替小根堆，要重写比较器 每次要加入的新结点取自 small.next ListNode node : lists 遍历每个链表的头结点? 时间复杂度：$O(n*(log(k))$空间复杂度：$O(k)$ 分治法：两两归并，关键在于用二分法确定分组。归并法用上一题的递归 1234567891011121314151617181920212223242526class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) return null; return merge(lists, 0, lists.length - 1); &#125; private ListNode merge(ListNode[] lists, int left, int right) &#123; if (left == right) return lists[left]; int mid = left + (right - left) / 2; ListNode l1 = merge(lists, left, mid); ListNode l2 = merge(lists, mid + 1, right); return mergeTwoLists(l1, l2); &#125; private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1,l2.next); return l2; &#125; &#125;&#125; 时间复杂度：$O(n*(log(k))$空间复杂度：$O(n)$ 24 两两交换链表中的节点【中】 思路：第一反应是换值，结果被重点强调了..应该是以某种方式去改变指针指向，注意防止断链。可以想到的做法是： 新建一个额外的结点便于操作头结点。 12345678910111213141516class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode pre = new ListNode(0); pre.next = head; ListNode temp = pre; while(temp.next != null &amp;&amp; temp.next.next != null) &#123; ListNode start = temp.next; ListNode end = temp.next.next; temp.next = end; start.next = end.next; end.next = start; temp = start; &#125; return pre.next; &#125;&#125; 改进: 三个指针，更好理解 递归法返回值：交换完成的子链表调用单元：设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head，完成交换终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换 1234567891011class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; &#125;&#125; 25 K个一组翻转链表【难】 思路：其实跟上题还是同样的原理，只是指针指向要根据k值作相应的调整。最后一组若第一次指针操作发现将指向null，则将此组保持原样。 123456789101112131415161718192021222324252627282930313233public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; ListNode end = dummy; while (end.next != null) &#123; for (int i = 0; i &lt; k &amp;&amp; end != null; i++) end = end.next; if (end == null) break; ListNode start = pre.next; ListNode next = end.next; end.next = null; pre.next = reverse(start); start.next = next; pre = start; end = pre; &#125; return dummy.next;&#125;private ListNode reverse(ListNode head) &#123; ListNode pre = null; ListNode curr = head; while (curr != null) &#123; ListNode next = curr.next; curr.next = pre; pre = curr; curr = next; &#125; return pre;&#125; 改进: 分段进行，模块化重复；将中间逆序后再将首尾相接 end.next = null;先把尾部置空。 pre.next = reverse(start);然后对首部调用逆序函数 逆序函数的实现，需要三个指针 61 旋转链表【中】 思路：先遍历找到尾结点，然后将前k%list.length个结点依次插入到尾部—然后发现我理解错了题意…能不能连成一个环，然后从中间剪断.. 12345678910111213141516171819202122232425class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; // base cases if (head == null) return null; if (head.next == null) return head; // close the linked list into the ring ListNode old_tail = head; for(int n = 1; old_tail.next != null; n++) old_tail = old_tail.next; old_tail.next = head; // find new tail : (n - k % n - 1)th node // and new head : (n - k % n)th node ListNode new_tail = head; for (int i = 0; i &lt; n - k % n - 1; i++) new_tail = new_tail.next; ListNode new_head = new_tail.next; // break the ring new_tail.next = null; return new_head; &#125;&#125; 改进： 新的表头在 n-k%n 处，表尾在表头的前一位置 时间复杂度：$O(n)$空间复杂度：$O(1)$ 83 删除排序链表中的重复元素【易】思路: 由于是排序的所以排序遍历，设定一个比较位，后面的值与该数相等时，删除，不过由于可能有多个连续的相同数，故没有必要一个个删，可以找到一个更大的数后一起删除，同时更新比较位 12345678910111213class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode cur = head; while(cur != null &amp;&amp; cur.next != null) &#123; if(cur.val == cur.next.val) &#123; cur.next = cur.next.next; &#125; else &#123; cur = cur.next; &#125; &#125; return head; &#125;&#125; 此算法依然是挨个删除的，数据较少时区别不大。 时间复杂度：$O(n)$空间复杂度：$O(1)$ 82 删除排序链表中的重复元素 ll【中】思路：相比于上一题的区别在于把重复的数本身也删除了。看来要在前面加多一个指针? 12345678910111213141516171819class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode cur = dummy; while (cur.next != null &amp;&amp; cur.next.next != null) &#123; if (cur.next.val == cur.next.next.val) &#123; ListNode temp = cur.next; while (temp != null &amp;&amp; temp.next != null &amp;&amp; temp.val == temp.next.val ) &#123; temp = temp.next; &#125; cur.next = temp.next; &#125; else cur = cur.next; &#125; return dummy.next; &#125;&#125; 改进: 因为head结点可能要被删除，故应新增一个结点，而不仅仅是增加一个指针。 在迭代过程中，如果cur.next.val == cur.next.next.val说明此时有重复元素，此时创建一个临时指针temp，指向cur的下一个节点，即temp指向的第一个重复元素所在的位置。通过while循环去重，去重后，temp指向的是重复元素中的最后一个位置。最后cur.next = temp.next就实现了消除重复元素。 相比于上一题，把cur = cur.next;放在else中后判断，即可实现有多个相同值时一起删除，妙啊！ 注意退出条件 cur.next != null &amp;&amp; cur.next.next != null 时间复杂度：$O(n)$空间复杂度：$O(1)$ 递归法 12345678910111213141516public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) &#123; return head; &#125; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head != null &amp;&amp; head.next != null &amp;&amp; head.val == head.next.val) &#123; head = head.next; &#125; //去掉所有重复的数字，然后进行递归 return deleteDuplicates(head.next); &#125; else &#123; head.next = deleteDuplicates(head.next); &#125; return head; &#125; 无需dummy结点 对于前面的部分，直接把重复的部分掐掉，剩下的部分递归","categories":[{"name":"Intern","slug":"Intern","permalink":"http://vergessenwang.github.io/categories/Intern/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://vergessenwang.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"http://vergessenwang.github.io/tags/链表/"}]},{"title":"Spring MVC","slug":"Spring-MVC","date":"2020-02-14T16:01:39.000Z","updated":"2020-02-14T16:16:42.160Z","comments":true,"path":"posts/Java/2020-02-15-Spring-MVC.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-02-15-Spring-MVC.html","excerpt":"Spring MVC是Spring提供的一个轻量级Web框架，它实现了Web MVC设计模式。提供了一个前端控制器DispatcherServlet，使开发人员无须额外开发控制器对象。 在老版本的Spring中，配置文件内必须要配置处理器映射器、处理器适配器和视图解析器。但在Spring 4.0以后，如果不配置处理器映射器BeanNameUrlHandlerMapping、处理器适配器SimpleControllerHandlerAdapter和视图解析器InternalResourceViewResolver，就会使用Spring内部默认的配置来完成相应的工作 在web.xml中配置Spring MVC的前端控制器等信息在src目录下创建Spring MVC的核心配置文件springmvc-config.xml，在该文件中配置组件扫描器和视图解析器 执行流程（1）用户通过浏览器向服务器发送请求，请求会被Spring MVC的前端控制器DispatcherServlet所拦截。（2）DispatcherServlet拦截到请求后，会调用HandlerMapping处理器映射器。（3）处理器映射器根据请求URL找到具体的处理器，生成处理器对象及处理器拦截器（如果有就生成）一并返回给DispatcherServlet。（4）DispatcherServlet会通过返回信息选择合适的HandlerAdapter（处理器适配器）。（5）HandlerAdapter会调用并执行Handler（处理器），这里的处理器就是程序中编写的Controller类，也被称为后端控制器。（6）Controller执行完成后，会返回一个ModelAndView对象，该对象中包含视图名或包含模型与视图名。（7）HandlerAdapter将ModelAndView对象返回给DispatcherServlet。（8）DispatcherServlet会根据ModelAndView对象选择一个合适的ViewResolver（视图解析器）。（9）ViewResolver解析后，会向DispatcherServlet中返回具体的View（视图）。（10）DispatcherServlet对View进行渲染（即将模型数据填充至视图中）。（11）视图渲染结果会返回给客户端浏览器显示。","text":"Spring MVC是Spring提供的一个轻量级Web框架，它实现了Web MVC设计模式。提供了一个前端控制器DispatcherServlet，使开发人员无须额外开发控制器对象。 在老版本的Spring中，配置文件内必须要配置处理器映射器、处理器适配器和视图解析器。但在Spring 4.0以后，如果不配置处理器映射器BeanNameUrlHandlerMapping、处理器适配器SimpleControllerHandlerAdapter和视图解析器InternalResourceViewResolver，就会使用Spring内部默认的配置来完成相应的工作 在web.xml中配置Spring MVC的前端控制器等信息在src目录下创建Spring MVC的核心配置文件springmvc-config.xml，在该文件中配置组件扫描器和视图解析器 执行流程（1）用户通过浏览器向服务器发送请求，请求会被Spring MVC的前端控制器DispatcherServlet所拦截。（2）DispatcherServlet拦截到请求后，会调用HandlerMapping处理器映射器。（3）处理器映射器根据请求URL找到具体的处理器，生成处理器对象及处理器拦截器（如果有就生成）一并返回给DispatcherServlet。（4）DispatcherServlet会通过返回信息选择合适的HandlerAdapter（处理器适配器）。（5）HandlerAdapter会调用并执行Handler（处理器），这里的处理器就是程序中编写的Controller类，也被称为后端控制器。（6）Controller执行完成后，会返回一个ModelAndView对象，该对象中包含视图名或包含模型与视图名。（7）HandlerAdapter将ModelAndView对象返回给DispatcherServlet。（8）DispatcherServlet会根据ModelAndView对象选择一个合适的ViewResolver（视图解析器）。（9）ViewResolver解析后，会向DispatcherServlet中返回具体的View（视图）。（10）DispatcherServlet对View进行渲染（即将模型数据填充至视图中）。（11）视图渲染结果会返回给客户端浏览器显示。 注解用法Spring通过@Controller注解找到相应的控制器类后，还需要知道控制器内部对每一个请求是如何处理的，这就需要使用org.springframework.web.bind.annotation.RequestMapping注解类型。RequestMapping用于映射一个请求或一个方法，其注解形式为@RequestMapping，可以使用该注解标注在一个方法或一个类上。 Spring 4.3版本中引入了组合注解来帮助简化常用的HTTP方法的映射，并更好地表达被注解方法的语义。其组合注解如下所示。• @GetMapping：匹配GET方式的请求。• @PostMapping：匹配POST方式的请求。• @PutMapping：匹配PUT方式的请求。• @DeleteMapping：匹配DELETE方式的请求。• @PatchMapping：匹配PATCH方式的请求。以@GetMapping为例，该组合注解是@RequestMapping(method= RequestMethod.GET)的缩写 请求方法参数较多，不一一列举。绝大部分为Servlet API类型。但是，org.springframework.ui.Model类型不是一个Servlet API类型，而是一个包含Map对象的Spring MVC类型。如果方法中添加了Model参数，那么每次调用该请求处理方法时，Spring MVC都会创建Model对象，并将其作为参数传递给方法。 请求方法的返回值，常见的返回类型有ModelAndView、String和void。其中，ModelAndView类型中可以添加Model数据，并指定视图；String类型的返回值可以跳转视图，但不能携带数据；而void类型主要在异步请求时使用，它只返回数据，而不会跳转视图。 数据绑定Spring MVC框架会通过数据绑定组件（DataBinder）将请求参数串的内容进行类型转换，然后将转换后的值赋给控制器类中方法的形参，这样后台方法就可以正确绑定并获取客户端请求携带的参数。 步骤01 Spring MVC将ServletRequest对象传递给DataBinder。步骤02 将处理方法的入参对象传递给DataBinder。步骤03 DataBinder调用ConversionService组件进行数据类型转换、数据格式化等工作，并将ServletRequest对象中的消息填充到参数对象中。步骤04 调用Validator组件对已经绑定了请求消息数据的参数对象进行数据合法性校验。步骤05 校验完成后会生成数据绑定结果BindingResult对象，Spring MVC会将BindingResult对象中的内容赋给处理方法的相应参数。 比较常用的是POJO数据绑定。所有关联的请求参数封装在一个POJO中，然后为每一个参数设定set get 方法使用POJO类型数据绑定时，前端请求的参数名必须与要绑定的POJO类中的属性名一样，这样才会自动将请求数据绑定到POJO对象中，否则后台接收的参数值为null。对象比较复杂时，还可以在其中一个POJO中封装另一个POJO。 为了防止前端传入的中文数据出现乱码问题，可以使用Spring提供的编码过滤器来统一编码。要使用编码过滤器，只需要在web.xml中添加编码过滤器，这样所有的请求信息都会以UTF-8的编码格式进行解析。 有些特殊类型的参数无法在后台进行直接转换，例如日期数据需要开发者自定义转换器（Converter）或格式化（Formatter）进行数据绑定。对于复杂类型的数据，比如数组或者集合可以定义包含数组或者对象类的集合，进行绑定。 JSON数据交互JSON（JavaScript Object Notation，JS对象标记）是一种轻量级的数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据。 对象结构： 123&#123; keyl: valuel, key2: value2, ……&#125; 关键字（key）必须为String类型，值（value）可以是String、Number、Object、Array等数据类型。 为了实现浏览器与控制器类（Controller）之间的数据交互，Spring提供了一个HttpMessageConverter接口来完成此项工作。该接口主要用于将请求信息中的数据转换为一个类型为T的对象，并将类型为T的对象绑定到请求方法的参数中，或者将对象转换为响应信息传递给浏览器显示。MappingJacksona2HttpMessageConverter是Spring MVC默认处理JSON格式请求响应的实现类。 mvc:annotation-driven/配置会自动注册 RequestMappingHandlerMapping和RequestMappingHandlerAdapter两个Bean，并提供对读写XML和读写JSON等功能的支持。 RESTfulRESTful也称为REST（Representational State Transfer），可以将它理解为一种软件架构风格或设计风格。就是把请求参数变成请求路径 http://.../queryitems?id=1http://.../queryitems?id=1变为http://.../items/1 RESTful风格在HTTP请求中使用put、delete、post和get方式分别对应添加、删除、修改和查询的操作。","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://vergessenwang.github.io/tags/Spring/"}]},{"title":"阿里云OSS+PicGo搭建博客图床","slug":"阿里云OSS-PicGo搭建博客图床","date":"2020-02-13T11:54:21.000Z","updated":"2020-02-13T12:02:57.006Z","comments":true,"path":"posts/Blog/2020-02-13-阿里云OSS-PicGo搭建博客图床.html","link":"","permalink":"http://vergessenwang.github.io/posts/Blog/2020-02-13-阿里云OSS-PicGo搭建博客图床.html","excerpt":"博客自创建以来的就没有插入过图片，为了以后浏览的时候能更快明白之前写的东西，还是决定搭个图床。 之前看过在github以及七牛云上搭的，空间限制或需要域名备案而放弃，准备搭在阿里云OSS上。 在OSS中创建Bucket买了一个40G一年的OSS存储包，因为说不定以后还要存别的东西，就没有选择按量付费了。流量就直接按量了，反正应该就我自己会看… 创建Bucket注意权限改为公共读，我选择的标准按量收费。 在PicGO中连接OSSpicgo 项目地址 在图床设置中填写OSS中相应信息 KeyId和KeySecret可以从阿里的控制台获取， 储存空间名就是Bucket的名称，存储区域在访问域名可以找到 我的是 oss-cn-hangzhou。 存储路径比如2020/02/12/的话，上传的图片会默认放在OSS的2020/02/12文件夹下。注意存储路径一定要以/结尾 将图片拖拽或复制后上传剪贴板，会自动重命名并返回一个链接地址，默认为markdown格式","text":"博客自创建以来的就没有插入过图片，为了以后浏览的时候能更快明白之前写的东西，还是决定搭个图床。 之前看过在github以及七牛云上搭的，空间限制或需要域名备案而放弃，准备搭在阿里云OSS上。 在OSS中创建Bucket买了一个40G一年的OSS存储包，因为说不定以后还要存别的东西，就没有选择按量付费了。流量就直接按量了，反正应该就我自己会看… 创建Bucket注意权限改为公共读，我选择的标准按量收费。 在PicGO中连接OSSpicgo 项目地址 在图床设置中填写OSS中相应信息 KeyId和KeySecret可以从阿里的控制台获取， 储存空间名就是Bucket的名称，存储区域在访问域名可以找到 我的是 oss-cn-hangzhou。 存储路径比如2020/02/12/的话，上传的图片会默认放在OSS的2020/02/12文件夹下。注意存储路径一定要以/结尾 将图片拖拽或复制后上传剪贴板，会自动重命名并返回一个链接地址，默认为markdown格式 也可以设置快捷键，截图或复制后直接 shift + ctrl +P 真是 太好用了.. 展示效果如下： URL默认格式 https://blog-picture-wallen.oss-cn-hangzhou.aliyuncs.com/2020/02/12/...jpg 另外找到了一个支持图传的IOS的MWEB , 这下在ipad上也可以写markdown了 Linux下要用AppImage格式安装 出现奇怪报错： 12./PicGo-2.2.2.AppImage:行1: 未预期的符号 `newline' 附近有语法错误./PicGo-2.2.2.AppImage:行1: `&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;' 莫非是最新的2.2.2版本源码有错？定睛一看文件大小376B….重新下载 chmod a+x PicGo-2.2.2.AppImage 添加执行权限后执行 出现一个缩小的图标右键变为详细模式填写相应设置, 注意路径后一定要加/ 运行时会提示未安装xclip sudo apt install xclip 但每次这样运行比较麻烦，另外创建一个desktop文件 sudo vim /usr/share/applications/picgo.desktop 12345678910[Desktop Entry] Encoding=UTF-8 Name=PicGoComment=picture uploader Exec=/media/wliana/_dde_data2/software/PicGo-2.2.2.AppImageIcon=/media/wliana/_dde_data2/software/Icon/22xiaodongwu_18.pngTerminal=false StartupNotify=true Type=Application Categories=Application; 截图时按ctrl + alt + a 即可调用深度截图, ctrl + c 复制，shift + ctrl + p 上传， ctrl + v 直接贴到typora 真的很方便呀！ 自己弄了个小狮子的icon, 很可爱的亚子～ 这一套Icon也不错","categories":[{"name":"Blog","slug":"Blog","permalink":"http://vergessenwang.github.io/categories/Blog/"}],"tags":[{"name":"OSS","slug":"OSS","permalink":"http://vergessenwang.github.io/tags/OSS/"}]},{"title":"Spring基础之IoC与AOP","slug":"Spring基础之IoC与AOP","date":"2020-02-12T09:33:39.000Z","updated":"2020-02-12T09:34:59.510Z","comments":true,"path":"posts/Java/2020-02-12-Spring基础之IoC与AOP.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-02-12-Spring基础之IoC与AOP.html","excerpt":"Spring是一个以IoC（Inversion of Control，控制反转）和AOP（Aspect Oriented Programming）为内核的框架。 IoC和DIIoC是Spring的基础。IoC实现的是一种控制，简单地说，就是以前调用new构造方法来创建对象，现在变成了使用Spring来创建对象。DI（Dependency Inject，依赖注入）与IoC的含义相同，从两个角度描述同一个概念。简单地说，DI就是对象的属性，已经被注入好相关值，直接使用即可。 IoC是Inversion of Control的缩写，译为“控制反转”，还有的译为“控制反向”或者“控制倒置”。 在面向对象传统编程方式中，获取对象的方式通常是用new关键字主动创建一个对象。Spring中的IoC方式对象的生命周期由Spring框架提供的IoC容器来管理，直接从IoC容器中获取一个对象，控制权从应用程序交给了IoC容器。 IoC理论上是借助于“第三方”实现具有依赖关系对象之间的解耦，即把各个对象类封装之后，通过IoC容器来关联这些对象类。这样对象与对象之间就通过IoC容器进行联系，而对象与对象之间没有什么直接联系。 当对象A实例化和运行时，如果需要对象B，IoC容器就会主动创建一个对象B注入（依赖注入）到对象A所需要的地方。由此，对象A获得依赖对象B的过程，由主动行为变成被动行为，即把创建对象交给了IoC容器处理，控制权颠倒过来了，这就是所谓的控制反转","text":"Spring是一个以IoC（Inversion of Control，控制反转）和AOP（Aspect Oriented Programming）为内核的框架。 IoC和DIIoC是Spring的基础。IoC实现的是一种控制，简单地说，就是以前调用new构造方法来创建对象，现在变成了使用Spring来创建对象。DI（Dependency Inject，依赖注入）与IoC的含义相同，从两个角度描述同一个概念。简单地说，DI就是对象的属性，已经被注入好相关值，直接使用即可。 IoC是Inversion of Control的缩写，译为“控制反转”，还有的译为“控制反向”或者“控制倒置”。 在面向对象传统编程方式中，获取对象的方式通常是用new关键字主动创建一个对象。Spring中的IoC方式对象的生命周期由Spring框架提供的IoC容器来管理，直接从IoC容器中获取一个对象，控制权从应用程序交给了IoC容器。 IoC理论上是借助于“第三方”实现具有依赖关系对象之间的解耦，即把各个对象类封装之后，通过IoC容器来关联这些对象类。这样对象与对象之间就通过IoC容器进行联系，而对象与对象之间没有什么直接联系。 当对象A实例化和运行时，如果需要对象B，IoC容器就会主动创建一个对象B注入（依赖注入）到对象A所需要的地方。由此，对象A获得依赖对象B的过程，由主动行为变成被动行为，即把创建对象交给了IoC容器处理，控制权颠倒过来了，这就是所谓的控制反转 DI是Dependency Inject的缩写，译为“依赖注入”。所谓依赖注入，就是由IoC容器在运行期间动态地将某种依赖关系注入对象之中。例如，将对象B注入（赋值）给对象A的成员变量。 事实上，依赖注入（DI）和控制反转（IoC）是对同一件事情的不同描述，依赖注入是从应用程序的角度描述，即应用程序依赖容器创建并注入它所需要的外部资源；而控制反转是从容器的角度描述，即容器控制应用程序，由容器反向地向应用程序注入应用程序所需要的外部资源。这里所说的外部资源可以是外部实例对象，也可以是外部文件对象等 注入方法IoC/DI通常有setter（设置）注入和构造方法注入两种实现方式 • 属性setter()方法注入：IoC容器使用setter()方法注入被依赖的实例。通过调用无参构造器或无参静态工厂方法实例化Bean后，调用该Bean的setter()方法，即可实现基于setter()方法的依赖注入。该方式简单、直观，而且容易理解，所以Spring的设置注入被大量使用。• 构造方法注入：IoC容器使用构造方法注入被依赖的实例。基于构造方法的依赖注入通过调用带参数的构造方法来实现，每个参数代表着一个依赖。 核心容器Spring框架提供的两种核心容器分别是BeanFactory和ApplicationContext。 Spring框架的两个最基本和最重要的包是org.springframework.beans.factory（该包中的主要接口是BeanFactory）和org.springframework.context（该包中的主要接口是ApplicationFactory）。 Spring IoC框架的主要组件有Beans、配置文件applicationContext.xml、BeanFactory接口及其相关类、ApplicationContext接口及其相关类。 （1）Beans是指项目中提供业务功能的Bean，即容器要管理的Bean。Beans就是一个常见的JavaBean、Java类。 （2）在Spring中对Bean的管理是在配置文件中进行的。在Spring容器内编辑配置文件管理Bean又称为Bean的装配，实际上装配就是告诉容器需要哪些Bean，以及容器是如何使用IoC将它们配合起来的。Bean的配置文件是一个XML文件，可以命名为applicationContext.xml或其他，一般习惯使用applicationContext.xml。 配置文件包含Bean的id、类、属性及其值，包含一个元素和数个子元素。Spring IoC框架可根据Bean的id从Bean配置文件中取得该Bean的类，并生成该类的一个实例对象，继而从配置文件中获得该对象的属性和值。例如是元素的子元素，其name属性表示Bean实例中的相应属性名，ref属性用于指定其属性值是元素的子元素，用于调用Bean实例中的setUserDao()方法完成属性赋值，从而实现依赖注入。其name属性表示Bean实例中的相应属性名，ref属性用于指定其属性值 （3）BeanFactory采用了工厂设计模式，即Bean容器模式，负责读取Bean的配置文件，管理对象的生成、加载，维护Bean对象与Bean对象之间的依赖关系，负责Bean的生命周期。对于简单的应用程序来说，使用BeanFactory就已经足够管理Bean了，在对象的管理上可以获得许多便利性。 org.springframework.beans.factory.BeanFactory是一个顶级接口，包含管理Bean的各种方法 org.springframework.beans.factory.xml.XmlBeanFactory是BeanFactory常用的实现类，根据配置文件中的定义装载Bean。要创建XmlBeanFactory，需要传递一个FileInputStream对象，该对象把XML文件提供给工厂。代码可以写成： 1BeanFactory factory=new XmlBeanFactory( new FileInputStream(&quot;applicationContext.xml &quot;)); BeanFactory的常用方法如下：• getBean(String name)：可根据Bean的id生成该Bean的对象。• getBean(String name,Class requiredType)：可根据Bean的id和相应类生成该Bean的对象。 （4）ApplicationContext接口提供高级功能的容器，基本功能与BeanFactory很相似，但它还有以下功能：• 提供访问资源文件更方便的方法。• 支持国际化消息。• 提供文字消息解析的方法。• 可以发布事件，对事件感兴趣的Bean可以接收到这些事件。 ApplicationContext接口的常用实现类有以下3个。• FileSystemXmlApplicationContext：从文件系统中的XML文件加载上下文中定义的信息。• ClassPathXmlApplicationContext：从类路径中的XML文件加载上下文中定义的信息，把上下文定义的文件当成类路径资源。• XmlWebApplicationContext：从Web系统中的XML文件加载上下文中定义的信息。 其中，FileSystemXmlApplicationContext和ClassPathXmlApplicationContext的代码编写如下： 12ApplicationContext context=new FileSystemXmlApplicationContext(&quot;d:/applicationContext.xml￼&quot;);￼ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml &quot;); Beans作用域在Spring配置文件中，Bean的作用域是通过元素的scope属性来指定的，该属性值可以设置为singleton、prototype、request、session、globalSession、application、websocket七个值 singleton是Spring容器默认的作用域，当Bean的作用域为singleton时，Spring容器就只会存在一个共享的Bean实例，并且所有对Bean的请求，只要id与该Bean的id属性相匹配，就会返回同一个Bean的实例。singleton作用域对于无会话状态的Bean（如Dao组件、Service组件）来说是最理想的选择 对需要保持会话状态的Bean应用使用prototype作用域。在使用prototype作用域时，Spring容器会为每个对该Bean的请求都创建一个新的实例 装配方式Spring容器支持多种形式的Bean装配方式，如基于XML的装配、基于Annotation（注解）的装配和自动装配等 基于xml的装配Spring提供了两种基于XML的装配方式：设值注入（Setter Injection）和构造注入（Constructor Injection） 在Spring实例化Bean的过程中，Spring首先会调用Bean的默认构造方法来实例化Bean对象，然后通过反射的方式调用setter()方法来注入属性值。因此，设值注入要求一个Bean必须满足以下两点要求：• Bean类必须提供一个默认的无参构造方法。• Bean类必须为需要注入的属性提供对应的setter()方法。 使用设值注入时，在Spring配置文件中需要使用元素的子元素来为每个属性注入值；而使用构造注入时，在配置文件中需要使用元素的子元素来定义构造方法的参数，可以使用其value属性（或子元素）来设置该参数的值。 基于注解的装配注解将类标识为Spring中的Bean，Spring注解提供了一种高效的注解配置方式（对包路径下的所有Bean文件进行扫描)@Repository、@Service和@Controller的功能与@Component注解的功能相同，但为了使标注类本身用途更加清晰，建议在实际开发中使用@Repository、@Service和@Controller分别对实现类进行标注 自动装配Spring的元素中包含一个autowire属性，我们可以通过设置autowire的属性值来自动装配Bean。所谓自动装配，就是将一个Bean自动注入其他Bean的Property中 AOPAOP的全称是Aspect-Oriented Programming，即面向切面编程（也称面向方面编程），是面向对象编程（OOP）的一种补充，目前已成为一种比较成熟的编程方式。 在AOP思想中，通过Aspect（切面）可以分别在不同类的方法中加入事务、日志、权限和异常等功能。 Aspect（切面）在实际应用中，切面通常是指封装的用于横向插入系统功能（如事务、日志等）的类，该类要被Spring容器识别为切面，需要在配置文件中通过元素指定。 在Spring的配置文件中，配置切面使用的是aop:aspect元素，该元素会将一个已定义好的Spring Bean转换成切面Bean，所以要在配置文件中先定义一个普通的Spring Bean（如上述代码中定义的myAspect）。定义完成后，通过aop:aspect元素的ref属性即可引用该Bean。 Joinpoint（连接点）在程序执行过程中的某个阶段点，它实际上是对象的一个操作，例如方法的调用或异常的抛出。在Spring AOP中，连接点就是指方法的调用。 Pointcut（切入点）指切面与程序流程的交叉点，即那些需要处理的连接点。通常在程序中，切入点指的是类或者方法名，如某个通知要应用到所有以add开头的方法中，那么所有满足这一规则的方法都是切入点。 当aop:pointcut元素作为aop:config元素的子元素定义时，表示该切入点是全局切入点，可以被多个切面所共享；当aop:pointcut元素作为aop:aspect元素的子元素时，表示该切入点只对当前切面有效。在定义aop:pointcut元素时，通常会指定id和expression两个属性 express格式 ： execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-￼pattern) throws-pattern? 带有问号（?）的部分表示可选配置项，其他部分属于必须配置项。 其他• Advice（通知增强处理）：AOP框架在特定的切入点执行增强处理，即在定义好的切入点处所要执行的程序代码。可以将其理解为切面类中的方法，它是切面的具体实现。• Target Object（目标对象）：是指所有被通知的对象，也称为被增强对象。如果AOP框架采用的是动态的AOP实现，那么该对象就是一个被代理对象。• Proxy（代理）：将通知应用到目标对象之后，被动态创建的对象。• Weaving（织入）：将切面代码插入目标对象上，从而生成代理对象的过程。 基于XML的声明式AspectJ通过XML文件来定义切面、切入点及通知，Spring配置文件中的元素下可以包含多个aop:config元素，一个aop:config元素中又可以包含属性和子元素，其子元素包括aop:pointcut、aop:advisor和aop:aspect。在配置时，这3个子元素必须按照此顺序来定义。 基于注解的声明式AspectJ使用@Aspect注解定义了切面类，由于该类在Spring中是作为组件使用的，因此还需要添加@Component注解才能生效。然后使用@Pointcut注解来配置切入表达式，并通过定义方法来表示切入点名称。接下来在每个通知相应的方法上添加了相应的注解，并将切入点名称作为参数传递给需要执行增强的通知方法。如果需要其他参数（如异常通知的异常参数），可以根据代码提示传递相应的属性值。","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://vergessenwang.github.io/tags/Spring/"}]},{"title":"Deepin真好玩之我怎么又黑屏了？？","slug":"Deepin真好玩之我怎么又黑屏了？？","date":"2020-02-10T13:38:39.000Z","updated":"2020-02-10T13:44:10.819Z","comments":true,"path":"posts/OS/2020-02-10-Deepin真好玩之我怎么又黑屏了？？.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2020-02-10-Deepin真好玩之我怎么又黑屏了？？.html","excerpt":"开始使用华为的linux发行版了，2K屏真香！极简风格相当喜欢，UI也设计的不错，就是触摸板不太好滑。 尝试正确的姿势上网(暂时放弃)先去客户中心按指南下载Qt5，并扫描好配置的二维码。然而还要进行系统配置之后才能使用 开始用全局配置，但是考虑到访问国内速度可能较慢，于是打算用动态配置。 法一 配置PAC ：deepin系统安装shadowsocks-qt5并使用PAC全局代理) 配置之后反而国内的网站都访问不了，取消了也不能访问 据说还有个deepin系统的专门插件 https://github.com/lolimay/shadowsocks-deepin 但我懒得编译了 法二尝试使用Chrome插件 https://github.com/FelisCatus/SwitchyOmega/releases/ 注意下载后要将后缀改成.tar 后解压，把里面的”_metadata”文件夹改名为”metadata” 然后拖入Chrome的扩展程序界面即可手动安装 等我装好插件，配置完成之后，连百度都打不开了… 没办法，遇事不决重启试试。然后更刺激的来了，我输入密码进入桌面，两秒之后，黑屏了！！！ 先后经历之前的安装丢失，合屏待机之后无法唤醒等令人摸不着头脑的问题。 接下来，在各种recovery之间反复横跳…","text":"开始使用华为的linux发行版了，2K屏真香！极简风格相当喜欢，UI也设计的不错，就是触摸板不太好滑。 尝试正确的姿势上网(暂时放弃)先去客户中心按指南下载Qt5，并扫描好配置的二维码。然而还要进行系统配置之后才能使用 开始用全局配置，但是考虑到访问国内速度可能较慢，于是打算用动态配置。 法一 配置PAC ：deepin系统安装shadowsocks-qt5并使用PAC全局代理) 配置之后反而国内的网站都访问不了，取消了也不能访问 据说还有个deepin系统的专门插件 https://github.com/lolimay/shadowsocks-deepin 但我懒得编译了 法二尝试使用Chrome插件 https://github.com/FelisCatus/SwitchyOmega/releases/ 注意下载后要将后缀改成.tar 后解压，把里面的”_metadata”文件夹改名为”metadata” 然后拖入Chrome的扩展程序界面即可手动安装 等我装好插件，配置完成之后，连百度都打不开了… 没办法，遇事不决重启试试。然后更刺激的来了，我输入密码进入桌面，两秒之后，黑屏了！！！ 先后经历之前的安装丢失，合屏待机之后无法唤醒等令人摸不着头脑的问题。 接下来，在各种recovery之间反复横跳… 最后也不知道是哪步使她修复好了…看来应该好好学习如何备份，然后就可以瞎折腾了… 尝试更新源(已放弃)先将原先文件备份 sudo cp /etc/apt/source.list /etc/apt/source.list.original vim /etc/apt/source.list 添加镜像源： https://www.deepin.org/mirrors/packages/ 在该网站查找镜像源地址 选择所需的进行替换 lion 是稳定版， panda 是测试版 p 粘贴 例如华为源： deb [trusted=yes] https://mirrors.huaweicloud.com/deepin stable main contrib non-free deb-src deb https://mirrors.huaweicloud.com/deepin stable main 教程 https://blog.csdn.net/baidu_41751590/article/details/89064220 但是！！操作到一半发现自带的Deepin是camel版本的，是官方授权的，如果更换了的话，会导致变为非授权版本，无法正常更新。 作为一个强迫症，最终还是放弃了更新源。不得不说，华为的Linux的发行版还是存在很多问题，诸如居然没有自带应用商店。 我感觉已经要被这个系统整残了。。。 话说回来，Deepin配上华为的2K屏体验真的是不错，一个普通的记事本都能写出Typora的感觉 安装Typora官方指南 或者 sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add - add Typora&#39;s repository sudo add-apt-repository &#39;deb https://typora.io/linux ./&#39; 这一步报错：无法使用add-apt-repository命令 解决： apt-get install software-properties-common sudo apt-get update sudo apt-get install typora 报错：W: GPG 错误：http://dl.google.com/linux/chrome/deb stable Release: 下列签名无效： KEYEXPIRED 1555048520 KEYEXPIRED 1555048520 KEYEXPIRED 1555048520 KEYEXPIRED 1555048520W: 仓库 “http://dl.google.com/linux/chrome/deb stable Release” 没有数字签名。N: 无法认证来自该源的数据，所以使用它会带来潜在风险。N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。 解决： 把 /etc/apt/sources.list.d/ google-chrome.list 删除 这应该是在安装chrome的时候产生的，于是干脆把chrome卸载了，反正火狐也不错 最后发现camel源里面好像没有typora…装个软件这么难吗？？？ 没办法我只能手动下载压缩文件了。解压 创建一个到桌面的软链接方便启动 —后来发现并不方便 还是创建开始启动图标吧，在 /usr/share/applications 目录下创建 typora.desktop 文件 sudo vim /usr/share/applications/typora.desktop 直接参考Deepin 创建快捷方式 12345678910[Desktop Entry] Encoding=UTF-8 Name=TyporaComment=Markdown Editor Exec=/media/wliana/_dde_data2/software/Typora-linux-x64/TyporaIcon=/media/wliana/_dde_data2/software/Typora-linux-x64/resources/app/asserts/icon/icon_32x32@2x.pngTerminal=false StartupNotify=true Type=Application Categories=Application; 到官网下载好看的主题，没错就是要花里胡哨..放到主题文件夹里，重启typora即可。 最后发现还是自带的github主题好看。 接下来还有很多环境要配置，慢慢来吧","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"Deepin","slug":"Deepin","permalink":"http://vergessenwang.github.io/tags/Deepin/"}]},{"title":"云服务器ECS中配置Nginx和Docker","slug":"云服务器ECS中配置Nginx和Docker","date":"2020-02-06T17:40:30.000Z","updated":"2020-02-06T17:43:18.742Z","comments":true,"path":"posts/Project/2020-02-07-云服务器ECS中配置Nginx和Docker.html","link":"","permalink":"http://vergessenwang.github.io/posts/Project/2020-02-07-云服务器ECS中配置Nginx和Docker.html","excerpt":"今天心血来潮买了一个阿里云ECS云服务器，然后想起来以前还买过一个域名一直没用上，就拿来玩玩。 绑定域名在域名的控制台进行DNS解析，绑定好云服务器的公网IP 记录类型：默认A 主机记录：www ，就是给域名加一个前缀 解析路线：默认 记录值：云服务器的公网ip地址 TTL：默认 配置好后，ping 域名 检测一下，可以访问 接下来就可以部署一些自己的应用了 远程连接到服务器 ssh root@IP 输入密码，即可连接 首先对服务器进行升级 sudo apt-get update","text":"今天心血来潮买了一个阿里云ECS云服务器，然后想起来以前还买过一个域名一直没用上，就拿来玩玩。 绑定域名在域名的控制台进行DNS解析，绑定好云服务器的公网IP 记录类型：默认A 主机记录：www ，就是给域名加一个前缀 解析路线：默认 记录值：云服务器的公网ip地址 TTL：默认 配置好后，ping 域名 检测一下，可以访问 接下来就可以部署一些自己的应用了 远程连接到服务器 ssh root@IP 输入密码，即可连接 首先对服务器进行升级 sudo apt-get update Node 参考 wget https://nodejs.org/dist/v10.15.1/node-v10.15.1-linux-x64.tar.xz 下载源码 xz -d node-v10.15.1-linux-x64.tar.xz tar -xvf node-v10.15.1-linux-x64.tar 解压 rm node-v10.15.1-linux-x64.tar 删除多余文件夹 12ln -s /root/node-v10.15.1-linux-x64/bin/node /usr/local/bin/nodeln -s /root/node-v10.15.1-linux-x64/bin/npm /usr/local/bin/npm 创建软链接便于全局访问 为了更清晰的管理文件夹 123456mkdir -p /tool/node/mv /root/node-v10.15.1-linux-x64/* /tool/node/rm -f /usr/local/bin/noderm -f /usr/local/bin/npmln -s /tool/node/bin/node /usr/local/bin/nodeln -s /tool/node/bin/npm /usr/local/bin/npm 查看版本发现已经安装成功 Pm2npm install pm2 -g pm2可以用它来管理node进程 pm2命令 同样要配置软链接，类似于windows中的环境变量 ln -s /tool/node/bin/pm2 /usr/local/bin/ NginxNginx是一个高性能的 HTTP 和反向代理服务器，也是一个IMAP/POP3/SMTP 代理服, 是一个asynchronousservers异步服务器, 一般用来处理高并发 新建一个目录专门存放安装包（不然以后看起来很混乱）mkdir ~/software 下载并解压安装包至指定目录 wget -P ~/software/ http://nginx.org/download/nginx-1.12.2.tar.gz tar -zxvf nginx-1.12.2.tar.gz -C ~/tool 进入所在目前执行默认配置 ./configure 此步骤会报错因为还有很多依赖包没有安装 123apt-get install libpcre3 libpcre3-devapt-get install zlib1g-devapt-get install openssl libssl-dev 安装完毕后编译make 成功后多出一个Makefile文件 然后make install 会安装在 /usr/local/nginx 不知道为什么我在root目录想看不到usr文件夹？ 直接 cd /usr/local/nginx 进到nginx目录直接运行./sbin/nginx 结果说我没有安装?? 算了不编译了，apt一把梭 apt-get install nginx 运行时提示端口被占用 nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use) netstat -ntlp 查看端口情况 杀死进程 kill id 重新运行 ps aux|grep nginx 可以查看Nginx进程情况 但此时还不能通过浏览器直接访问，要在阿里云控制台进行安全组配置 分别设置入方向和出方向规则 刷新网站即可看到80端口可以访问了 非常有帮助的参考 Docker查看位数getconf LONG_BIT 64位 查看系统lsb_release -a 查看内核版本uname -r 4.4.0-170-generic 查看可安装的docker版本apt-cache madison docker-ce 居然没有。。看了要换镜像 apt-get -y install apt-transport-https ca-certificates curl software-properties-common 允许用于通过HTTPS来获取仓库 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 添加 Docker 的官方 GPG 密钥 sudo apt-key fingerprint 0EBFCD88 确认密钥 sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; 添加阿里云镜像仓库 更新 sudo apt-get update 再次apt-cache madison docker-ce 就可以看到极多版本的docker了 安装sudo apt-get install docker-ce docker-ce-cli containerd.io 查看docker是否启动 systemctl status docker 未启动则启动 systemctl start docker 尝试允许hello-world 的image，没有问题，安装成功 参考 其他安装了git方便以后管理代码 本来还想弄个gitbook部署上去，但是域名访问还要备案，内容也还没开始写，同步起来也比较麻烦，还是以后再弄吧 大致步骤是先在本地写好md文件及目录结构，build生成对应的静态文件，其中gitbook的源码还要结合nginx或express，用server.js设置好端口 然后将除modules以外的文件同步到github。服务器clone仓库，进入目录执行npm install安装依赖。 pm2执行server.js即可访问","categories":[{"name":"Project","slug":"Project","permalink":"http://vergessenwang.github.io/categories/Project/"}],"tags":[{"name":"云服务器","slug":"云服务器","permalink":"http://vergessenwang.github.io/tags/云服务器/"}]},{"title":"冲鸭，向着S公司","slug":"冲鸭，向着S公司","date":"2020-02-05T15:52:11.000Z","updated":"2020-02-05T16:19:25.408Z","comments":true,"path":"posts/Intern/2020-02-05-冲鸭，向着S公司.html","link":"","permalink":"http://vergessenwang.github.io/posts/Intern/2020-02-05-冲鸭，向着S公司.html","excerpt":"大概知识点Java基础良好 —- 容器，GC， 多线程 熟悉Spring等主流Web框架 —- java web, cloud 掌握WEB后端开发技术: 协议、架构、存储、缓存、安全等 对ERP有一定的概念，javascript &amp; abap 大数据—HANA相关，内存数据库 细节知识点 设计模式—单例的各种实现，模式的JDK动态，及为什么要动态 类加载器 新生代和老年代 —-GC 标记算法 数据库 —– 触发器和存储过程 基于oracle的一种数据库 —- 该公司会用的 索引、优化、如何处理非常多的数据 优化sql，让模糊查询走索引：%匹配符不能在字符前面 redis","text":"大概知识点Java基础良好 —- 容器，GC， 多线程 熟悉Spring等主流Web框架 —- java web, cloud 掌握WEB后端开发技术: 协议、架构、存储、缓存、安全等 对ERP有一定的概念，javascript &amp; abap 大数据—HANA相关，内存数据库 细节知识点 设计模式—单例的各种实现，模式的JDK动态，及为什么要动态 类加载器 新生代和老年代 —-GC 标记算法 数据库 —– 触发器和存储过程 基于oracle的一种数据库 —- 该公司会用的 索引、优化、如何处理非常多的数据 优化sql，让模糊查询走索引：%匹配符不能在字符前面 redis 线程安全，锁 —- 并发控制 启动线程的方式：Thread.start，线程池自动启动,callable 消息队列 快排：说了各种复杂度、稳定性和思想 红黑树：不会 加密算法底层 —-安全 TCP建立连接为什么需要三次 应用层协议有哪些 邮件的正则 xml转json JUC包 项目主要是做什么，数据库是怎样的 例题 m*n 个格子，从左边的最底层走到最右边的最上层，每一步只能往上或者往前走一步，问有多少种走法？ 内连接，左连接，全连接输出。 设计一个基类，和两个子类，子类分别实现递归与非递归斐波列切数列。 图的深度与广度遍历输出交通灯 observer 模式 JVM 中能实现一种实例的三种方法 WCF 中的 ABC 分别代表什么 三盏灯与三个开关，怎么样能够一个人进入连接开关和灯。 运用Design Pattern改进CopyFactory类，实现必须具有产品标准。 先有鸡还是先有蛋，阐述理由？ 线程在什么情况下会进入等待队列？列出3种情况。 数据库中某表只有1列，具有相同record，在没有index，key的情况下取出第5和第7行的结果。写出一种解决方案。 Implement the simplest singleton pattern(initialize if if necessary). Name three sort algorithms you are familiar with. Write out the correct or der by the average time complexity. Write code to sort a duplex direction linklist. The node T has overridden the comparision operators 形式一个小时，四道算法题，四道Sql题 —- 大概10分钟一道算法题？？？ 实习全年招聘，有上海、西安、成都、南京四个地点。暑期有VT项目 BTW: thoughtworks 也可以关注下，毕竟 全球最佳女性科技人员雇主…","categories":[{"name":"Intern","slug":"Intern","permalink":"http://vergessenwang.github.io/categories/Intern/"}],"tags":[]},{"title":"神奇Docker","slug":"神奇Docker","date":"2020-02-03T15:30:19.000Z","updated":"2020-02-05T16:07:43.096Z","comments":true,"path":"posts/Java/2020-02-03-神奇Docker.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-02-03-神奇Docker.html","excerpt":"Docker是Go语言开发的应用容器引擎，核心概念是：镜像、容器、仓库 关键字是：分布式应用，微服务，容器，虚拟化 传统的虚拟机技术是在硬件层面实现的，需要额外的虚拟机管理软件跟虚拟机操作系统。而Docker是在操作系统层面实现的，直接使用本地操作系统 Docker的主要目标是通过对应用组件的封装。分发、部署、运行等生命周期的管理，做到“一次封装，到处运行” Docker体系原理一个完整的Docker有以下几部分： DockerClient 客户端 Docker Deamon 守护进程 Docker Image 镜像 Docker Container 容器 Docker使用了C/S体系架构，Docker客户端与Docker守护进程通信，Docker守护进程负责构建，运行和分发Docker容器。","text":"Docker是Go语言开发的应用容器引擎，核心概念是：镜像、容器、仓库 关键字是：分布式应用，微服务，容器，虚拟化 传统的虚拟机技术是在硬件层面实现的，需要额外的虚拟机管理软件跟虚拟机操作系统。而Docker是在操作系统层面实现的，直接使用本地操作系统 Docker的主要目标是通过对应用组件的封装。分发、部署、运行等生命周期的管理，做到“一次封装，到处运行” Docker体系原理一个完整的Docker有以下几部分： DockerClient 客户端 Docker Deamon 守护进程 Docker Image 镜像 Docker Container 容器 Docker使用了C/S体系架构，Docker客户端与Docker守护进程通信，Docker守护进程负责构建，运行和分发Docker容器。 Docker Damon DockerD用来监听Docker API的请求和管理Docker对象，比如镜像、容器、网络和Volume Docker Client docker client是我们和Docker进行交互的最主要的方式方法，比如可以通过docker run来运行一个容器，然后我们的这个client会把命令发送给上面的Docker Docker Registry 用来存储Docker镜像的仓库，Docker Hub是Docker官方提供的一个公共仓库，而且Docker默认也是从Docker Hub上查找镜像的，当然你也可以很方便的运行一个私有仓库，当我们使用docker pull或者docker run命令时，就会从我们配置的Docker镜像仓库中去拉取镜像，使用docker push命令时，会将我们构建的镜像推送到对应的镜像仓库中 Images 镜像，镜像是一个制度模板，带有Docker容器的说明，一般来说的，镜像会基于另外的一些基础镜像上面安装一个Nginx服务器，这样就可以构建一个属于我们自己的镜像了 Containers 容器，容器是一个镜像的可运行的实例，可以使用Docker REST API或者CLI来操作容器，容器的实质是进程，但与直接在宿主执行的实例进程不同，容器进程属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间、甚至自己的用户ID。容器内的经常是运行在一个隔离的环境里，使用起来，就好像在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全 Docker详解 安装官网 然而该安装包并不支持WIN10 家庭版….只能用toolbox了 安装指南 然而在找镜像的过程中，感受到了对Windows系统深深的敌意….我生气了，我真的要换Linux本了… 确保虚拟化已启动 启动Docker 终端遇到问题： &quot;This computer doesn&#39;t have VT-X/AMD-v enabled. Enabling it in the BIOS is mandatory&quot; 首先检查一下电脑是否支持VT-X/AMD-v ，检测软件 我的结果是VT-X/AMD-v enabled ，那为什么还有这个问题呢？ 在SO上看到一个回答，关闭虚拟化检查。 cmd运行： 1docker-machine create -d virtualbox --virtualbox-memory=1024 创建了一个内存1G的虚拟机，然后 1docker-machine create -d virtualbox --virtualbox-no-vtx-check default 还是不行？？？ 另一种解决方法 直接修改sh文件设置 Open C:\\Program Files\\Docker Toolbox\\start.sh with an Editor Replace line 69 from &quot;${DOCKER_MACHINE}&quot; create -d virtualbox $PROXY_ENV &quot;${VM} to &quot;${DOCKER_MACHINE}&quot; create -d virtualbox --virtualbox-no-vtx-check $PROXY_ENV &quot;${VM}&quot; 可能是因为之前命令行的权限不够？ 再次启动终端, 上述问题消失，但又有别的问题 Downloading C:\\Users\\18771\\.docker\\machine\\cache\\boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v19.03.5/boot2docker.iso... 这一步下不下来，可能是众所周知的原因。 手动下载该文件 https://github.com/boot2docker/boot2docker/releases/download/v19.03.5/boot2docker.iso 放在 /Users/{user}/.docker/machine/cache/ 目录下 运行成功，会自动创建虚拟机，调用virtualBox的接口，创建虚拟网卡等一系列配置，最后出现了一只小鲸鱼！~~~ 12345678910 ## . ## ## ## == ## ## ## ## ## === /\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\\___/ === ~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~~ ~ / === \\______ o __/ \\ \\ __/ \\____\\_______/docker is configured to use the default machine with IP 192.168.99.100 此时进入了git命令行，即Linux环境 Docker命令命令在Toolbox 运行的 git 终端中运行，而非cmd 基本命令docker version 可以看到客户端OS是 Windows 而 服务端OS是 Linux docker info 查看相关信息 docker pull ... 从官方仓库pull docker run ... 如果本地没有该镜像，会从官方仓库pull下来，然后运行一个container docker image ls 查看本地镜像 docker container ls 查看本地容器—-容器就是动态的镜像(类似进程与程序的关系) 同一个镜像可以运行在不同的端口，每个端口运行着的都是一个容器，也就是镜像的实例 docker container stop contain_id 终止某容器 docker-machine ls 查看虚拟机 docker-machine rm ... 移除某虚拟机 image相关docker tag repoitory_name : old_tag repoitory_name : new_tag 添加tag, 但是ID不变，常常给某一个image加上latest标签, 在开发的过程里可以灵活地让其指向不同的image，管理更加灵活 例如从官方仓库pull时，就会默认下载latest版本 docker image history repoitory_name/id 查看更新历史 docker image inspect repoitory_name/id 查看详细信息，如开发环境，配置信息等 docker image remove repoitory_name/id 移除 container相关docker run -p port:port -d repoitory_name/id:tag -p 指定端口 -d 表示后台运行,返回一个container_id 加上--restart==always 每次重启docker自动创建，默认为no 适用于数据库等重启后就要马上启动的服务 加上-m -512m 分配内存—与实际的占用会有差异 加上--cpu-quato 5000 分配CPU的5% docker container pause container_id 暂停 docker container unpause container_id 继续 docker container stop container_id 停止 docker container kill container_id 立即停止 docker logs -f container_id 查看日志 docker container inspect container_id 查看详细信息，如状态，网络等 docker container prune 移除所有停止的container docker events container事件动态 docker top container_id container中运行的进程信息—–可以理解为container是对进程的封装？ docker stats container占用CPU和内存的情况 docker system df 查看对比信息 其他github下载速度过慢这是经常遇到，但一直没有解决的问题，在github上经常遇到的，下文件很慢很慢，绝大部分是因为来自于亚马逊的国外服务器 尝试1： 更改C:\\Windows\\System32\\drivers\\etc\\hosts文件，在文件中追加219.76.4.4 github-cloud.s3.amazonaws.com, 将域名指向该IP，即香港的服务器 在cmd命令行输入：ipconfig/flushdns（刷新DNS）—– 哇，果然快到飞起 方法2： 码云 —- 改天试试","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://vergessenwang.github.io/tags/Docker/"}]},{"title":"肆意蒸发的2019","slug":"肆意蒸发的2019","date":"2020-02-01T10:38:31.000Z","updated":"2020-02-01T10:39:57.508Z","comments":true,"path":"posts/life/2020-02-01-肆意蒸发的2019.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2020-02-01-肆意蒸发的2019.html","excerpt":"2020真是一个炸裂开局。 上一个频道还是晚会里的张灯结彩，下一个频道就成了医院里的白布裹尸。 谣言与真相，封锁与逃离，疯抢与暴利，牺牲与渎职。 多么荒诞的现实啊。一切仿佛《鼠疫》的情节重演。一切那么遥远，一切那么真实。 大概率是坎坷的一年了。还未到来的事情就不多想了，该总结一下2019了。 一年将尽，又是残冬的急景了，我南北奔跑，一年之内毫无半点成绩，只赢得许多悲愤，啊，想起来，做人真是没趣。 ——《郁达夫日记》 也许人生就是在海水中游泳，没有上岸的一天。","text":"2020真是一个炸裂开局。 上一个频道还是晚会里的张灯结彩，下一个频道就成了医院里的白布裹尸。 谣言与真相，封锁与逃离，疯抢与暴利，牺牲与渎职。 多么荒诞的现实啊。一切仿佛《鼠疫》的情节重演。一切那么遥远，一切那么真实。 大概率是坎坷的一年了。还未到来的事情就不多想了，该总结一下2019了。 一年将尽，又是残冬的急景了，我南北奔跑，一年之内毫无半点成绩，只赢得许多悲愤，啊，想起来，做人真是没趣。 ——《郁达夫日记》 也许人生就是在海水中游泳，没有上岸的一天。 难做的事和应该做的事…往往是同一件事。凡是有意义的事情都不会容易。我以前常常觉得很多事情没有意义，大概只是因为我选择的都是一些容易做的事情吧。同样的，当不知该选哪条路的时候，选比较难的那条路，选可能走不下去的那条路。 也许，学习的很盲目，觉得每日都忙，却不知最后学到了什么，还是因为没有意识到：掌握技术的唯一目的是拿它实现你想实现的想法或产品。 在学校的最后两个月里，其实一直处于一种很沉郁状态，可能总觉得要高网要挂(最后结果还可行，可是我明明卷子做得稀碎….这也让我意识到上课其实并不怎样重要) 可能太多情绪盘亘心头，可能在避世和热情里消耗太多。不过终究是过去了，现在目标逐渐清晰起来，状态也好了很多。 还有，以前我一直试图能让很多事情有个两全的结局，现在并不这样想了。 这一年 身体素质还是老样子 给人拍照依然毫无美感。。 开始喜欢 风景水彩 云彩，雪山，天空和夕阳 —- 从水彩里我感悟到色彩的神奇，而大自然的色彩又是如此浑然天成，令人除了惊叹，无从言语。老年的梦想是在某个欧洲风景优美的小镇画画放牛… 陶陶居的糯米鸡 — 啊，饿了 香蕉牛奶 —啊，好喝 南京东方宫的拉面 — 啊，真香 天海佑希 J2EE — 以后多学学SSM 依然喜欢 那几只居 坚持一件事直至有所收获的感觉 — 要拨一点时间，做有长期价值的事情 中秋的月亮 —- 可惜了，城市的灯太亮，没有月色 古风插画 沙雕表情包。。。 明白了我不喜欢 PM岗，我讨厌做PPT 算法岗，我讨厌数学公式 修福报 — 某日写代码到三点，有点升天的感觉。。相比于健康和快乐，努力获得的东西根本不值一提 太压抑的关系 明白了我做不到 过于精致的绘画技法 从过度的游戏里获得快乐 — 然而这并不影响我想买一个xbox… 想看而未看的 《搏击俱乐部》 《悲剧的诞生》 《卡拉马佐夫兄弟》 《我们赖以生存的隐喻》 …","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[{"name":"又是一年","slug":"又是一年","permalink":"http://vergessenwang.github.io/tags/又是一年/"}]},{"title":"刷LeetCode的正确姿势","slug":"刷LeetCode的正确姿势","date":"2020-01-31T15:23:46.000Z","updated":"2020-01-31T15:26:57.672Z","comments":true,"path":"posts/Intern/2020-01-31-刷LeetCode的正确姿势.html","link":"","permalink":"http://vergessenwang.github.io/posts/Intern/2020-01-31-刷LeetCode的正确姿势.html","excerpt":"今天，小伙伴问我，LeetCode刷了几道了？？？ 晴天霹雳。 确实要开始准备笔试了。但是也不想太盲目，所以先了解一下科学的刷题方法。 第一遍：从易到难—主要是easy和medium，广度，看别人的解法 第二遍：按类别—-深度，要有一个方面比较特殊 需要刷的数量 200~300 ，各个难度刷一半；每个类别的核心思想的理解，达到何种程度的优化。 反刷题：一开始就给出最优解？ 然而能不能做出题目其实是次要，重要的是解决问题的思路 其实刷题并不是要去实现一个量化的目标，诸如我刷了多少？刷了几遍？ 而是要去总结和理解题目背后的涵义。 找实习的话，其实学校的项目经验帮助不大，除非是参加过Github上大型的开源项目。","text":"今天，小伙伴问我，LeetCode刷了几道了？？？ 晴天霹雳。 确实要开始准备笔试了。但是也不想太盲目，所以先了解一下科学的刷题方法。 第一遍：从易到难—主要是easy和medium，广度，看别人的解法 第二遍：按类别—-深度，要有一个方面比较特殊 需要刷的数量 200~300 ，各个难度刷一半；每个类别的核心思想的理解，达到何种程度的优化。 反刷题：一开始就给出最优解？ 然而能不能做出题目其实是次要，重要的是解决问题的思路 其实刷题并不是要去实现一个量化的目标，诸如我刷了多少？刷了几遍？ 而是要去总结和理解题目背后的涵义。 找实习的话，其实学校的项目经验帮助不大，除非是参加过Github上大型的开源项目。 以下总结来自花花酱 刷多少题 每个类型10~20 DP越多越好 总共200~300 如何刷 按类型总结 第一遍：5分钟想不出来就看答案 第二遍：尝试不看答案完整实现( 不超过60min) 第三遍：快速实现( 不超过20min) 看不同版本的代码—-速度中间偏前的 看3~5种不同的实现，分析优缺点，速度快慢的原因 学习新的语言/ API 培养能力 至少能看出该使用什么样的算法 根据数据规模推算时间复杂度 代码风格： 命名、缩进、括号 不多说了，今天就开始吧","categories":[{"name":"Intern","slug":"Intern","permalink":"http://vergessenwang.github.io/categories/Intern/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://vergessenwang.github.io/tags/LeetCode/"}]},{"title":"Spring Boot实现简单REST-API","slug":"Spring-Boot实现简单REST-API","date":"2020-01-27T10:17:29.000Z","updated":"2020-01-27T10:20:24.678Z","comments":true,"path":"posts/Java/2020-01-27-Spring-Boot实现简单REST-API.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-01-27-Spring-Boot实现简单REST-API.html","excerpt":"设计模式之 依赖注入 「依赖注入」就是为了完成这样的 目标：将 依赖组件 的配置和使用分离开，以降低使用者与依赖之间的耦合度。 通过@component将类作为spring bean注入到spring container中，然后用 context.getBean 代替 new 来创建所需的对象 。值得注意的是，即使不显式创建，这些类也会被用单例模式自动创建好一个对象，等待被使用。如果要显式创建，必须用@Scope(value = “prototype”) 原型模式注解 对于有依赖的关系的对象，通过@Autowired 在spring container中自动寻找相应的类来建立依赖 预安装： JDK: Java10.0.2 IDE: IDEA 管理工具: Maven 3.6.1 Git SDKMAN然而在看很多教程的时候发现，java8用的比较多，我又不想卸载我的java10，于是找到了一个SDK管理工具用于管理java版本 安装指引 使用指引 另外该软件还可以管理Ant、Gradle、Maven、Springboot-cli、Groovy、Kotlin、Scala。可以说是java开发必备了","text":"设计模式之 依赖注入 「依赖注入」就是为了完成这样的 目标：将 依赖组件 的配置和使用分离开，以降低使用者与依赖之间的耦合度。 通过@component将类作为spring bean注入到spring container中，然后用 context.getBean 代替 new 来创建所需的对象 。值得注意的是，即使不显式创建，这些类也会被用单例模式自动创建好一个对象，等待被使用。如果要显式创建，必须用@Scope(value = “prototype”) 原型模式注解 对于有依赖的关系的对象，通过@Autowired 在spring container中自动寻找相应的类来建立依赖 预安装： JDK: Java10.0.2 IDE: IDEA 管理工具: Maven 3.6.1 Git SDKMAN然而在看很多教程的时候发现，java8用的比较多，我又不想卸载我的java10，于是找到了一个SDK管理工具用于管理java版本 安装指引 使用指引 另外该软件还可以管理Ant、Gradle、Maven、Springboot-cli、Groovy、Kotlin、Scala。可以说是java开发必备了 POSTMAN在项目还没有开发出前端页面时，用于模拟发送HTTP请求 安装及使用 界面挺不错的 例： POST –&gt; localhost:8080/api/v1/person Body – &gt; raw ,JSON –&gt; {内容} UUID Generator可在线生成UUID IDEA相关配置Maven配置本地仓库在maven安装目录中的conf -&gt; setting 中找到默认的本地仓库地址 为path/to/local/repo 新建一个本地仓库文件夹，并将地址替换 C:/Tools/maven/LocalWarehouse —–注意是另外写一行localrepository ,不是修改注释里面的 其实IDEA自带了maven，但是在这里设置为已经安装的相应配置。在IDEA的setting -&gt; Build tools 中设置maven的所在目录为C:\\Tools\\maven\\apache-maven-3.6.1 ，setting文件 C:\\Tools\\maven\\apache-maven-3.6.1\\conf\\settings.xml和本地仓库C:\\Tools\\maven\\LocalWarehouse Git在setting - &gt; version control 中 Git已经自动检测到，Github输入账号密码即可 实践学习视频 使用spring initializr 新建项目，在dependency的web中选择spring web 一个项目从数据层，服务层和用户接口层逐步去实现。 数据层数据模型 12345678910111213141516171819public class Person &#123; private final UUID id; @NotBlank private final String name; public Person(@JsonProperty(\"id\") UUID id, @JsonProperty(\"name\") String name) &#123; this.id = id; this.name = name; &#125; public UUID getId() &#123; return id; &#125; public String getName() &#123; return name; &#125;&#125; 输入的名字限制为非空 格式为JSON 数据操作接口 12345678910111213141516public interface PersonDao &#123; int insertPerson(UUID id, Person person); default int insertPerson(Person person)&#123; UUID id = UUID.randomUUID(); return insertPerson(id,person); &#125; List&lt;Person&gt; selectAllPeople(); Optional&lt;Person&gt; selectPersonById(UUID id); int deletePersonById(UUID id); int updatePersonById(UUID id,Person person);&#125; 如果只输入了姓名，则生成一个随机ID 接口实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Repository(\"fakeDao\")public class FakePersonDataAccessService implements PersonDao &#123; private static List&lt;Person&gt; DB = new ArrayList&lt;&gt;(); @Override public int insertPerson(UUID id, Person person) &#123; DB.add(new Person(id,person.getName())); return 1; &#125; @Override public List&lt;Person&gt; selectAllPeople() &#123; return DB; &#125; @Override public Optional&lt;Person&gt; selectPersonById(UUID id) &#123; return DB.stream() .filter(person -&gt; person.getId().equals(id)) .findFirst(); &#125; @Override public int deletePersonById(UUID id) &#123; Optional&lt;Person&gt; personMaybe = selectPersonById(id); if(!personMaybe.isPresent())&#123; return 0; &#125; DB.remove(personMaybe.get()); return 1; &#125; @Override public int updatePersonById(UUID id, Person update) &#123; return selectPersonById(id) .map(person -&gt;&#123; int indexOfPersonToUpdate = DB.indexOf(person); if(indexOfPersonToUpdate &gt;= 0)&#123; DB.set(indexOfPersonToUpdate, new Person(id, update.getName())); return 1; &#125; return 0; &#125;) .orElse(0); &#125;&#125; 给数据仓库命名，可以方便后续service处转为其他类型的repository 注意List的add/stream/set/remove等用法 服务层123456789101112131415161718192021222324252627282930@Servicepublic class PersonService &#123; public final PersonDao personDao; @Autowired public PersonService(@Qualifier(\"fakeDao\") PersonDao personDao) &#123; this.personDao = personDao; &#125; public int addPerson(Person person)&#123; return personDao.insertPerson(person); &#125; public List&lt;Person&gt; getAllPeople()&#123; return personDao.selectAllPeople(); &#125; public Optional&lt;Person&gt; getPersonById(UUID id)&#123; return personDao.selectPersonById(id); &#125; public int deletePerson(UUID id)&#123; return personDao.deletePersonById(id); &#125; public int updatePerson(UUID id, Person newPerson)&#123; return personDao.updatePersonById(id, newPerson); &#125;&#125; 注解为@service，明确作用 @Autowired 依赖注入 在spring container中自动寻找相应的类来建立依赖 @Qualifier(“fakeDao”) 按名查找 服务层其实是在调用数据层的操作 用户接口层123456789101112131415161718192021222324252627282930313233343536@RequestMapping(\"api/v1/person\")@RestControllerpublic class PersonController &#123; private final PersonService personService; @Autowired public PersonController(PersonService personService) &#123; this.personService = personService; &#125; @PostMapping public void addPerson( @Valid @NonNull @RequestBody Person person)&#123; personService.addPerson(person); &#125; @GetMapping public List&lt;Person&gt; getAllPeople()&#123; return personService.getAllPeople(); &#125; @GetMapping(path = \"&#123;id&#125;\") public Person getPersonById(@PathVariable(\"id\") UUID id)&#123; return personService.getPersonById(id) .orElse(null); &#125; @DeleteMapping(path = \"&#123;id&#125;\") public void deletePersonById(@PathVariable(\"id\") UUID id)&#123; personService.deletePerson(id); &#125; @PutMapping(path = \"&#123;id&#125;\") public void updatePerson(@PathVariable(\"id\") UUID id, @Valid @NonNull @RequestBody Person personToUpdate)&#123; personService.updatePerson(id, personToUpdate); &#125;&#125; @RequestMapping 指定HTTP路径 @RestController 明确控制器功能 @PostMapping @GetMapping @DeleteMapping @PutMapping 将HTTP类型与方法绑定 @PathVariable(“id”) 指定变量 @RequestBody 指定寻找部位 TIPS IDEA换上了新出的Mono字体真是赏心悦目啊 实现接口时，可以用快捷键 Ctrl + i 最后通过mave打包出来的jar是可以直接运行的","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://vergessenwang.github.io/tags/Spring-Boot/"}]},{"title":"React初体验--谁说前端很简单的？？","slug":"React初体验-谁说前端很简单的？？","date":"2020-01-21T17:14:03.000Z","updated":"2020-01-21T17:16:00.646Z","comments":true,"path":"posts/frontend/2020-01-22-React初体验-谁说前端很简单的？？.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-01-22-React初体验-谁说前端很简单的？？.html","excerpt":"预备知识 Node.js: 基于Chrome V8引擎的JavaScript 运行环境，使用了事件驱动、非阻塞I/O的模式 npm: node包管理工具 webpack：前端资源加载、打包工具，根据模块的依赖生成静态资源 ES6: js语言标准 React核心思想：声明式编程(注重结果而非实现)，组件化(自定义label)，虚拟DOM(减少渲染次数，diff算法) 环境搭建利用脚手架create-react-app来安装react 12345npm install -g create-react-app //安装脚手架C:\\Users\\18771\\AppData\\Roaming\\npm\\create-react-app -&gt; C:\\Users\\18771\\AppData\\Roaming\\npm\\node_modules\\create-react-app\\index.js+ create-react-app@3.3.0added 91 packages in 96.802s 1create-react-app my-app //会自动创建好Server Webpack 和 Babel 此时报错：bash: create-react-app: command not found","text":"预备知识 Node.js: 基于Chrome V8引擎的JavaScript 运行环境，使用了事件驱动、非阻塞I/O的模式 npm: node包管理工具 webpack：前端资源加载、打包工具，根据模块的依赖生成静态资源 ES6: js语言标准 React核心思想：声明式编程(注重结果而非实现)，组件化(自定义label)，虚拟DOM(减少渲染次数，diff算法) 环境搭建利用脚手架create-react-app来安装react 12345npm install -g create-react-app //安装脚手架C:\\Users\\18771\\AppData\\Roaming\\npm\\create-react-app -&gt; C:\\Users\\18771\\AppData\\Roaming\\npm\\node_modules\\create-react-app\\index.js+ create-react-app@3.3.0added 91 packages in 96.802s 1create-react-app my-app //会自动创建好Server Webpack 和 Babel 此时报错：bash: create-react-app: command not found 应该是路径问题 改用命令npx create-react-app my-app , 还是不行 用npm root命令寻找npm 的根目录发现是 C:\\Users\\18771\\node_modules 解决方法参考 12npm config set prefix /usr/localnpm i -g react-create-app 又报错 Unexpected end of JSON input while parsing near &#39;...5mVz30VuXnFvjkEbnA5Oc&#39; 进入 C:\\Users\\18771\\AppData\\Roaming\\npm-cache 目录 执行 npm cache clean --force 解决方法参考 重新安装 切换到要创建项目的目录，执行 npx create-react-app my-app 报错 ： 12npm ERR! code EINTEGRITYnpm ERR! sha512-k1g3gRQ4fwfJoIfgUpz78AovicSWKFANmvTfkAHP24MgJHjWfZI6ya7tsQZt1sLczvP4G9BE5G5MgADHdmJB/w== integrity checksum failed when using sha512: wanted sha512-k1g3gRQ4fwfJoIfgUpz78AovicSWKFANmvTfkAHP24MgJHjWfZI6ya7tsQZt1sLczvP4G9BE5G5MgADHdmJB/w== but got sha512-WkbI2UIeavrFcTouh/pYNWeOYEQFVDIs8JjFZLRlZPSyyYVpmqLA0jN+BTmrDVMN23qY0wBFktjQhVBJ1PO8Yw==. (698 bytes) 似乎是package-json 文件的问题 执行 npm cache verify 再次尝试成功创建 1234567891011121314151617181920212223242526272829303132333435363738npx create-react-app my-appnpm WARN react-scripts@3.3.0 requires a peer of typescript@^3.2.1 but none is installed. You must install peer dependencies yourself.npm WARN sass-loader@8.0.0 requires a peer of node-sass@^4.0.0 but none is installed. You must install peer dependencies yourself.npm WARN sass-loader@8.0.0 requires a peer of sass@^1.3.0 but none is installed. You must install peer dependencies yourself.npm WARN sass-loader@8.0.0 requires a peer of fibers@&gt;= 3.1.0 but none is installed. You must install peer dependencies yourself.npm WARN tsutils@3.17.1 requires a peer of typescript@&gt;=2.8.0 || &gt;= 3.2.0-dev || &gt;= 3.3.0-dev || &gt;= 3.4.0-dev || &gt;= 3.5.0-dev || &gt;= 3.6.0-dev || &gt;= 3.6.0-beta || &gt;= 3.7.0-dev || &gt;= 3.7.0-beta but none is installed. You must install peer dependencies yourself.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 (node_modules\\jest-haste-map\\node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.11: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 (node_modules\\chokidar\\node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.11: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.2 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.2: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)removed 1 package in 29.248sInitialized a git repository.Success! Created my-app at C:\\Users\\18771\\Desktop\\my_app\\my-appInside that directory, you can run several commands: npm start Starts the development server. npm run build Bundles the app into static files for production. npm test Starts the test runner. npm run eject Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can’t go back!We suggest that you begin by typing: cd my-app npm start 执行start 会自动在本地3000端口打开一个页面 在VS Code中安装 Simple React Snippets 和 Prettier插件 同时在setting.json中添加一行&quot;editor.formatOnSave&quot;: true, 自动格式化后保存 在Chrome中添加插件 React Developer Tools 实践Babel 可以将 JSX 翻译为 react boostraps为了设计CSS ，安装bootstrap ，直接在VS Code 的集成终端输入 npm i bootstrap@4.1.1 在index.js 中导入 import &quot;bootstrap/dist/css/bootstrap.css&quot;; components基本用法新建counter.jsx文件写入组件代码 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from \"react\"; //imrcclass Counter extends Component &#123; //cc state = &#123; count: 1, //imageUrl: \"https://picsum.photos/200\", tags: [\"tag1\", \"tag2\", \"tag3\"] &#125;; styles = &#123; fontWeight: \"bold\", fontSize: 20 &#125;; render() &#123; return ( &lt;React.Fragment&gt; &lt;span style=&#123;this.styles&#125; className=&#123;this.getBadgeClasses()&#125;&gt; &#123;this.formatCount()&#125; &lt;/span&gt; &lt;button className=\"btn btn-secondary btn-sm\"&gt;Increment&lt;/button&gt; &lt;ul&gt; &#123;this.state.tags.map(tag =&gt; ( &lt;li key=&#123;tag&#125;&gt;&#123;tag&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;img src=&#123;this.state.imageUrl&#125; alt=\"\" /&gt; &lt;/React.Fragment&gt; ); &#125; getBadgeClasses() &#123; let classes = \"badge m-2 badge-\"; classes += this.state.count === 0 ? \"warning\" : \"primary\"; return classes; &#125; formatCount() &#123; const &#123; count &#125; = this.state; return count === 0 ? \"Zero\" : count; &#125;&#125;export default Counter; 由于装了插件，可以直接用简写；因为render()只能默认产生一个元素，所以多个标签要用&lt;React.Fragment&gt;包起来； {}可以引用类中的成员或方法； className=”btn btn-secondary btn-sm”是bootstrap中的样式； style={this.styles} 自定义样式； classes += this.state.count === 0 ? “warning” : “primary”; 可按数值变化样式 {this.state.tags.map(tag =&gt; {tag})} map是一种遍历方法，为每个值设置一个key是为了react能区分出元素 除了用class，还可以用stateless funciton 来写组件(sfc) 这也是一种比较常用的写法，只是不能用this关键字 然后在index.js中引用 123import Counter from \"./components/counter\";ReactDOM.render(&lt;Counter /&gt;, document.getElementById(\"root\")); 按不同条件进行渲染1234567891011121314151617181920212223242526272829import React, &#123; Component &#125; from \"react\"; class Counter extends Component &#123; state = &#123; count: 1, tags: [\"tag1\", \"tag2\", \"tag3\"] &#125;; renderTags() &#123; if (this.state.tags.length === 0) return &lt;p&gt;There are no tags!&lt;/p&gt;; return ( &lt;ul&gt; &#123;this.state.tags.map(tag =&gt; ( &lt;li key=&#123;tag&#125;&gt;&#123;tag&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; ); &#125; render() &#123; return ( &lt;React.Fragment&gt; &#123;this.state.tags.length === 0 &amp;&amp; \"Please create a new tags!\"&#125; &#123;this.renderTags()&#125; &lt;/React.Fragment&gt; ); &#125;&#125;export default Counter; this.state.tags.length === 0 &amp;&amp; “Please create a new tags!” 在js中 &amp;&amp;结果为真时，返回最后一个表达式 新增一个方法用于条件判断 交互12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from \"react\"; //imrcclass Counter extends Component &#123; //cc state = &#123; count: 1 &#125;; constructor() &#123; super(); this.handleIncrement = this.handleIncrement.bind(this); &#125; handleIncrement() &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125; render() &#123; return ( &lt;React.Fragment&gt; &lt;span className=&#123;this.getBadgeClasses()&#125;&gt;&#123;this.formatCount()&#125;&lt;/span&gt; &lt;button onClick=&#123;this.handleIncrement&#125; className=\"btn btn-secondary btn-sm\" &gt; Increment &lt;/button&gt; &lt;/React.Fragment&gt; ); &#125; getBadgeClasses() &#123; let classes = \"badge m-2 badge-\"; classes += this.state.count === 0 ? \"warning\" : \"primary\"; return classes; &#125; formatCount() &#123; const &#123; count &#125; = this.state; return count === 0 ? \"Zero\" : count; &#125;&#125;export default Counter; button 中添加 *onClick= {this.handleIncrement} —注意没有跟() 并写好handleIncrement() 方法 this.handleIncrement = this.handleIncrement.bind(this); 主要是为了将this与当前的Counter 对象绑定—-还可以用箭头函数 this.setState({ count: this.state.count + 1 }); 需要用setstate显式更改状态才能显示在页面上 复合组件props可以作为一个参数传入，将任意类型的数据传给组件，但是不能修改，定义时也要声明为static state是在组件内部使用并可以修改的 父组件和子组件通信可以通过props进行信息传递，当子组件要更新父组件时，可以让父组件传一个回调函数给子组件，子组件通过调用实现父组件更新——很常用的一种做法 同级之间如果要相互通信，可以将一个的函数上升为共同的父组件的回调函数；或者采用react的上下文方式，子组件可以直接访问祖先组件的属性和方法 为避免写太多this.props ,可以定义 const {func1, func2...} = this.props 选出要用的方法，之后就可以不加this.props前缀了 分清是模块控制还是全局控制 lifecycle&amp;hooks 挂载期：constructor()—先调用super() ; render() —所有父子组件渲染完后才会挂载; componentDidMount() —常用于Ajax与Server交互 更新期：componentDidUpdate() 卸载期: componentWillUnmount() —从DOM树中删除组件之前调用，用于做一些数据清零工作避免内存泄露 每个阶段都有对应的钩子函数，按序执行 只能用于class组件不能用于stateless funciton组件 tips 同时修改前后标签，选中标签，Ctrl+d 为了更好的封装，选中要转为方法的语句，右键，vscode提供了一个refactor功能，可以自动抽取出一个方法 true &amp;&amp; ‘hi’ —&gt; ‘hi’ 在js中 &amp;&amp;结果为真时，返回最后一个表达式 bootstrap一些设计案例，甚至可以直接搜索如“Navbar”, 会给出很多例子 react同时在内存保存有新和旧两份virtualDOM，通过比对，决定只需要对哪些部分进行更新","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"React","slug":"React","permalink":"http://vergessenwang.github.io/tags/React/"}]},{"title":"JavaFX + SQLite实现简单系统","slug":"JavaFX-SQLite实现简单系统","date":"2020-01-20T08:45:36.000Z","updated":"2020-01-20T08:48:52.988Z","comments":true,"path":"posts/Java/2020-01-20-JavaFX-SQLite实现简单系统.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-01-20-JavaFX-SQLite实现简单系统.html","excerpt":"学习来源 为了完成数据库大作业，终于开始了像蔡徐坤一样的学写代码的历程 首先在IDEA中新建一个javaFX项目，在sample文件夹会自动生成三个默认文件，删掉即可，新建自己的package和类 登录模块在class上新建一个fxml文件，发现了什么不得了的东西。。好像是一个可拖拽的界面，看起来大有用处。 加载fxml文件： 12345678public void start(Stage stage)throws Exception&#123; Parent root = (Parent) FXMLLoader.load(getClass().getResource(\"login.fxml\")); Scene scene = new Scene(root); stage.setScene(scene); stage.setTitle(\"School Management System\"); stage.show();&#125; 在fxml中拖入一个AnchorPane, 运行类就会出来一个窗口。 在fxml的源代码中添加控制器 fx:controller=&quot;loginapp.LoginController&quot;","text":"学习来源 为了完成数据库大作业，终于开始了像蔡徐坤一样的学写代码的历程 首先在IDEA中新建一个javaFX项目，在sample文件夹会自动生成三个默认文件，删掉即可，新建自己的package和类 登录模块在class上新建一个fxml文件，发现了什么不得了的东西。。好像是一个可拖拽的界面，看起来大有用处。 加载fxml文件： 12345678public void start(Stage stage)throws Exception&#123; Parent root = (Parent) FXMLLoader.load(getClass().getResource(\"login.fxml\")); Scene scene = new Scene(root); stage.setScene(scene); stage.setTitle(\"School Management System\"); stage.show();&#125; 在fxml中拖入一个AnchorPane, 运行类就会出来一个窗口。 在fxml的源代码中添加控制器 fx:controller=&quot;loginapp.LoginController&quot; SQLiteStudio下载地址 基本操作就不说了，图形化界面点点点就完事了。 新建一个dbUilt库，用于操作数据库。 连接数据库： 1234567891011121314151617public class dbConnection &#123; private static final String USERNAE = \"dbuser\"; private static final String PASSWORD = \"dapassword\"; private static final String CONN = \"jdbc:mysql://localhost/login\"; private static final String SQCONN = \"jdbc:sqlite:schoolsystem.sqlite\"; public static Connection getConnection() throws SQLException&#123; try&#123; Class.forName(\"org.sqlite.JDBC\"); return DriverManager.getConnection(SQCONN); &#125; catch (ClassNotFoundException ex) &#123; ex.printStackTrace(); &#125; return null; &#125;&#125; 在fxml中，如果在使用中出现表格无法激活的情况，需要下载SceneBuilder, 并在IDEA的setting中指定JavaFX的路径到下载好的exe文件。然后就可以右键fxml文件 open in Scene Builder 这个功能更完善一点，可以搜索并配置controller，所以我还是下了一个。虽然下载速度很感人，看着YTB上的UP主秒打开链接我真的好羡慕啊。。 下载地址 还得注册一个oracle…账户 46…qq 密码 B…98 结果登不上..最后在网上找另一个可用的 注意在Scene Builder中修改完要保存一下。 拖入label，第一个命名，第二个设置为code对应的变量名。需要输入的拖入textfield。 password可以用专用PasswordField 拖入一个combobox，这是下拉框，在properties中添加 Admin/ Students, 作为选项,同样也可以在username的properties中甚至promot占位提示符。 还有一个button ，作为login键 为combobox添加枚举类型。 新建enum类option: 12345678910111213public enum option &#123; Admin,Student; private option()&#123;&#125; public String value()&#123; return name(); &#125; public static option fromvalue(String v)&#123; return valueOf(v); &#125;&#125; 登录模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class LoginModel &#123; Connection connection; public LoginModel()&#123; try &#123; this.connection = dbConnection.getConnection(); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; if(this.connection == null)&#123; System.exit(1); &#125; &#125; public boolean isDatabaseConnected()&#123; return this.connection != null; &#125; public boolean isLogin(String user, String password, String opt)throws Exception&#123; PreparedStatement pr = null; ResultSet rs = null; String sql = \"SELECT * FROM login where username = ? and password = ? and division = ?\"; try&#123; pr = this.connection.prepareStatement(sql); pr.setString(1,user); pr.setString(2,password); pr.setString(3,opt); rs = pr.executeQuery(); boolean boll1; if(rs.next())&#123; return true; &#125; return false; &#125; catch (SQLException ex) &#123; return false; &#125; finally &#123; &#123; pr.close(); rs.close(); &#125; &#125; &#125;&#125; 控制模块： 注意在Label时要选择sence里的(因为很多库都有这个，不要弄错了) 12345678910111213141516171819202122232425public class LoginController implements Initializable &#123; LoginModel loginModel = new LoginModel(); @FXML private Label dbstatus; @FXML private TextField username; @FXML private PasswordField password; @FXML private ComboBox&lt;option&gt; combobox; @FXML private Button loginButton; public void initialize(URL url, ResourceBundle rb)&#123; if(this.loginModel.isDatabaseConnected())&#123; this.dbstatus.setText(\"Connected to database\"); &#125;else&#123; this.dbstatus.setText(\"Not connected to database\"); &#125; this.combobox.setItems(FXCollections.observableArrayList(option.values())); &#125;&#125; 运行时报错，java.lang.ClassNotFoundException: org.sqlite.JDBC没有安装sqlite的driver 下载地址 实在下不动，换了另一个网站 添加库：文件 -&gt; 目录结构 -&gt; 库 -&gt; + java -&gt; 下载的包 运行成功。 分用户登录给Login键添加事件onaction。注意ActionEvent要选 javafx.event. 给admin和student分别写方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@FXML public void Login(ActionEvent event) &#123; try &#123; if (this.loginModel.isLogin(this.username.getText(), this.password.getText(), ((option) this.combobox.getValue()).toString())) &#123; Stage stage = (Stage) this.loginButton.getScene().getWindow(); stage.close(); switch (((option) this.combobox.getValue()).toString()) &#123; case \"Admin\": adminLogin(); break; case \"Student\": studentLogin(); break; &#125; &#125; else &#123; this.loginStatus.setText(\"Wrong Credential\"); &#125; &#125;catch(Exception localException)&#123; &#125; &#125; public void studentLogin()&#123; try &#123; Stage userStage = new Stage(); FXMLLoader loader = new FXMLLoader(); Pane root = (Pane) loader.load(getClass().getResource(\"/students/studentFXML.fxml\").openStream()); StudentsController studentsController = (StudentsController) loader.getController(); Scene scene = new Scene(root); userStage.setScene(scene); userStage.setTitle(\"Student Dashboard\"); userStage.setResizable(false); userStage.show(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; public void adminLogin()&#123; try &#123; Stage adminStage = new Stage(); FXMLLoader adminLoader = new FXMLLoader(); Pane adminroot = (Pane) adminLoader.load(getClass().getResource(\"/Admin/Admin.fxml\").openStream()); AdminController adminController = (AdminController) adminLoader.getController(); Scene scene = new Scene(adminroot); adminStage.setScene(scene); adminStage.setTitle(\"Admin Dashboard\"); adminStage.setResizable(false); adminStage.show(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; 这里数据连接有点问题。。不管了先学用法吧 设置Admin.fxml 。tabpane可以创建多标签的表格；右边添加Hbox；添加tableview，按需要添加列;左边添加Vbox,在里面添加所需的label可以设置padding，添加textfield可以设置margin；添加datapicker 在scene builder中可以预览效果 添加数据更新方法。在变量上右键可以快速生成get和set方法， 数据加载： 12345678910111213141516171819202122private void loadStudentData(ActionEvent event)throws SQLException&#123; try&#123; Connection conn = dbConnection.getConnection(); this.data = FXCollections.observableArrayList(); ResultSet rs = conn.createStatement().executeQuery(sql); while(rs.next())&#123; this.data.add(new StudentData(rs.getString(1),rs.getString(2),rs.getString(3),rs.getString(4),rs.getString(5))); &#125; &#125;catch (SQLException e)&#123; System.err.println(\"ERROR\"+ e ); &#125; this.idcolumn.setCellValueFactory(new PropertyValueFactory&lt;StudentData,String&gt;(\"id\")); this.fnamecolumn.setCellValueFactory(new PropertyValueFactory&lt;StudentData,String&gt;(\"fname\")); this.lnamecolumn.setCellValueFactory(new PropertyValueFactory&lt;StudentData,String&gt;(\"lname\")); this.emailcolumn.setCellValueFactory(new PropertyValueFactory&lt;StudentData,String&gt;(\"email\")); this.dobcolumn.setCellValueFactory(new PropertyValueFactory&lt;StudentData,String&gt;(\"dob\")); this.studenttable.setItems(null); this.studenttable.setItems(this.data); &#125; 添加元组： 1234567891011121314151617181920private void addStudent(ActionEvent event)&#123; String sqlInsert = \"INSERT INTO students(id,fname,lname,email,dob) VALUES (?,?,?,?,?)\"; try&#123; Connection conn = dbConnection.getConnection(); PreparedStatement stmt = conn.prepareStatement(sqlInsert); stmt.setString(1,this.id.getText()); stmt.setString(2,this.fname.getText()); stmt.setString(3,this.lname.getText()); stmt.setString(4,this.email.getText()); stmt.setString(5,this.dob.getEditor().getText()); stmt.execute(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; 清空数据： 12345678@FXML private void clearFields(ActionEvent event)&#123; this.id.setText(\"\"); this.fname.setText(\"\"); this.lname.setText(\"\"); this.email.setText(\"\"); this.dob.setValue(null); &#125; 生成jar: 文件 -&gt; 项目结构 -&gt; Artifacts -&gt;jar -&gt;from mode…depen..-&gt; 选择LoginAPP作为入口类 -&gt; build artifacts。 数据和jar要放在同一目录下才可以直接运行。 为避免JRE版本不一致，可以把jar转成exe 学完这个视频内容之后，最后用时三天总算写完了数据库大作业，不过冗余代码好多，我的OOP水平是真的烂啊..","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[]},{"title":"系统建模","slug":"系统建模","date":"2020-01-11T12:37:29.000Z","updated":"2020-01-11T12:41:43.036Z","comments":true,"path":"posts/CS/2020-01-11-系统建模.html","link":"","permalink":"http://vergessenwang.github.io/posts/CS/2020-01-11-系统建模.html","excerpt":"概念CPS系统与实时系统的区别？实时系统（Real-Time Systems） 定义：系统的正确性不仅取决于计算的逻辑结果，还取决于产生结果的时间，在计算和操作上具有性能最后期限。 实时系统通常是嵌入式的，意味着计算系统存在于一个更大的系统内部，目的是帮助系统实现其整体职责。 时间定义： 时间约束（Timing constraint）：对执行时间行为的约束（包括硬实时和软实时） 发布时间（Release Time）：作业变成为可执行的时间。如果所有的工作在系统开始执行时被释放，那么就认为没有释放时间 截止时间（Deadline）：工作被要求执行完成的时间。如果截止时间是无限的，那么工作就没有最后期限。绝对截止时间等于发布时间加上相对截止时间 响应时间（Response time）：作业从发布到执行完成的时间长度","text":"概念CPS系统与实时系统的区别？实时系统（Real-Time Systems） 定义：系统的正确性不仅取决于计算的逻辑结果，还取决于产生结果的时间，在计算和操作上具有性能最后期限。 实时系统通常是嵌入式的，意味着计算系统存在于一个更大的系统内部，目的是帮助系统实现其整体职责。 时间定义： 时间约束（Timing constraint）：对执行时间行为的约束（包括硬实时和软实时） 发布时间（Release Time）：作业变成为可执行的时间。如果所有的工作在系统开始执行时被释放，那么就认为没有释放时间 截止时间（Deadline）：工作被要求执行完成的时间。如果截止时间是无限的，那么工作就没有最后期限。绝对截止时间等于发布时间加上相对截止时间 响应时间（Response time）：作业从发布到执行完成的时间长度 特征 及时性：行为的及时性与时间约束有关，如截止时间。最后期限可能很硬或很软。时效性的重要建模问题是建模执行时间，截止时间，到达模式，同步模式和时间源。 并发性： ​ 多个操作顺序链的同时执行。围绕并发系统执行的问题与此有关： ​ a.并发线程的调度特性——线程调度 ​ b.即将到来的事件的到来模式 ​ c.线程必须同步时使用的集合点模式 ​ d.控制对共享资源访问的方法 可预测性 正确性： 正确性表明一个系统总是运行正确。 鲁棒性：鲁棒性表明系统即使在遇到新的情况（不在计划中）下也是可靠的。因此必须警惕死锁，竞争以及其他异常情况 实时操作系统实时性能定量指标包括 任务上下文切换时间 ：中断延迟，响应，恢复时间，任务响应时间 最大中断禁止时间：反映内核对外界停止中断响应的最长时间 提高内核实时性的方法：任务互斥、同步 资源有限等待：任务没能获得需要的资源会被阻塞。如果资源不是任务继续运行必备的，任务可选择有限等待该资源 优先级反转问题解决：抢占式任务调度中的资源竞争，输入输出时间不一致导致抖动，优先级本身的不确定性导致可预测性下降。多任务内核应允许动态改变任务的优先级以避免发生优先级反转现象。为防止发生优先级反转,内核能自动变换任务的优先级,这叫做优先级继承(Priority inheritance)。 CPS系统(建模对象)​ Cyber（信息技术）: 计算，通信，控制（3C技术,computation,communication, control )，并且离散，逻辑，交换的系统； ​ Physical（物理系统）： 自然的和人造的系统受物理定律的支配，并持续运行；如嵌入式、传感系统 ​ Cyber-Physical Systems（信息物理融合系统）: 网络和物理系统紧密结合在一起的系统。 CPS系统的特点 信息-物理的耦合由新的需求和应用驱动 网络工作在多个和极端的规模下，每个物理组件中的网络性能，大规模的有线和无线网络 系统的系统 新的时空约束 多个时间和空间尺度上的复杂性，动态重组/重新配置，非传统的计算和物理基板 通信/计算/控制 之间的新型交互 自动化程度高，控制回路必须在所有尺度上关闭，控制回路中有大量非技术型的精明用户 无处不在的安全和隐私需求，操作必须可靠 Notice：不是桌面计算；不是传统的，事后嵌入式/实时系统；不是今天的传感器网络. 其研究目标是物理和网络（计算，通信，控制）设计深度集成；未来工程和监控物理系统的新学科 CPS是基于实时操作系统开发的，但是由于各种结构可能是异构的，所以要进行融合。 ※MDA(模型选择/建模方法) MDA定义的三种模型—— 逐步求精 计算独立模型（CIM，Computation-Independent Model）——功能需求：描述系统的需求和将在其中使用系统的业务上下文。此模型通常描述系统将用于做什么，而不描述如何实现系统。CIM 通常用业务语言或领域特定语言来表示。 平台独立模型（PIM，Platform-Independent Model）—— 操作系统：描述如何构造系统，而不涉及到用于实现模型的技术。此模型不描述用于为特定平台构建解决方案的机制。PIM 在由特定平台实现时可能是适当的，或者可能适合于多种平台上的实现。 平台特定模型 （PSM，Platform-Specific Model）—— 硬件：从特定平台的角度描述解决方案。其中包括如何实现 CIM 和如何在特定平台上完成该实现的细节。 MARTE与UML的区别？MARTE(modeling and analysis of real time and embedded systems)是UML在嵌入式实时系统领域的建模规范，取代原有的UML-SPT（UML profile for Schedulability , Performance and Time），支持对嵌入式实时系统的非功能属性建模。弥补了UML在嵌入式实时领域非功能属性表达能力的不足。 实践实时调度算法可调度性：表示实时系统（一组实时任务）是否能够按期完成的属性 对于周期任务（p，e），任务周期性的重复。（注意任务的描述符号表示，调度算法部分会用到）周期 p = inter - release time；p&gt;0执行时间 e = maximum execution time (0 &lt; e &lt; p)利用率 U = e/p 响应时间：任务从释放时间到结束时间 RM算法和EDF算法都属于抢占式算法 RM算法(单调速率，Rate Monotonic)前提假设 所有的任务是相互独立的（它们不相互作用，不相互依赖） 所有任务都是周期的，且运行时间不变 没有任何任务因等待外部事件而阻塞。 所有任务共享一个共同的释放时间（临界时刻，critical instant） 所有的任务的截止时间等于它们的周期，即任务必须在下一个作业释放之前完成。 算法描述 最佳的静态优先级调度 根据周期分配优先权 周期较短的任务具有较高的优先级 以最短的时间执行一项工作 使用限制：$∑U_i &lt;= n*(2^{(1/n)}-1)$ 满足以上式子时才能用RM算法进行调度 EDF算法（最早截止时间优先，Earliest Deadline First）算法描述 最佳的动态优先级调度 具有较早截止时间的任务具有较高的优先级 以最早的截止时间执行任务 注意：当一个任务在执行时，这时有一个新的任务到了，即使优先级更高，当前任务还是会继续执行(类似于磁盘电梯算法) 使用限制：$∑U_i &lt;= 1$ UML(建模工具)UML (Unified Modeling Language)为面向对象软件设计提供统一的、标准的、可视化的建模语言。适用于描述以用例为驱动，以体系结构为中心的软件设计的全过程。 过程: 分析 -&gt; 设计 -&gt; 实现 -&gt; 测试 -&gt; 分析… 用例图：描述用户所看到的系统的功能行为，用例图从用户的角度来表示系统的功能，用例是系统中的一个功能单元（静态视图） 录音机用例图 类图：描述系统的静态结构（对象，属性，联系），类图表示系统的结构 序列图：描述系统对象之间的动态行为，序列图将系统的行为表示为不同对象之间的消息交互。当执行一个用例行为时，顺序图中的每条消息对应了一个类操作或引起状态转换的触发事件 。综合考虑用例图中参与者和类图中对象的关系 状态图：描述单个对象的动态行为，一个类对象所可能经历的所有历程的模型图。状态图由对象的各个状态和连接这些状态的转换组成 活动图：状态图的一个变体，用来描述执行算法的工作流程中涉及的活动，活动图描述了一组顺序的或并发的活动 UML的主要特征是支持有限状态机。状态图的两个基本概念是状态和转换。 状态图​ UML中定义了四种事件： SignalEvent：与信号相关的事件。 ​ Signal是一个异步通信的规范，所以SignalEvent是一个与异步接收信号相关的事件。 CallEvent：与调用相关联的事件。 ​ Call是一个同步通信的规范，所以CallEvent允许一个对象直接调用其中一个方法来影响另一个对象的状态。 TimeEvent：与时间流逝相关的事件，通常用tm（\\）或after（\\）表示。 几乎所有的TimeEvents都是相对的时间。也就是说，它们指定事件将在对象处于指定状态至少\\时间单位后发生。 如果对象在超时之前离开该状态，则与该持续时间关联的逻辑计时器将消失，而不会创建超时事件 ChangeEvent：与属性的值更改关联的事件。 它很少用在软件应用程序中。然而，当一个状态属性被内存映射到一个硬件上时，它可以用来指示内存地址改变的值 状态的特点： ​ 可以在状态图上捕获行为的对象被认为是被动的。 ​ 这样一个对象的行为空间被分解为存在的不相交和不相交的条件，称为状态。 ​ 转换是对导致状态改变的事件的响应。该对象可以在接收到事件（尽管不进行转换）或者进行转换时执行动作，进入或退出状态。 转换（transition） ​ 转换是从起始状态开始并在目标状态结束的弧。 ​ 转换通常具有命名的事件触发器，可选地随后是执行转换时执行的动作（即可执行语句或操作）。 ​ 过渡事件签名的格式为： ​ event-name ‘(‘ parameter-list ‘)’ ‘[‘ guard-expression ‘]’ ‘/‘ action-list ​ 注：事件可以指定形式参数列表，这意味着事件可以携带实际的参数。 ​ digit(key: keyType)/ show(key) ​ 约束（Guard）和行为执行顺序（Execution Order）： ​ guard表达式是一个布尔表达式，包含在方括号中，必须计算为true或false。 ​ 行动的执行顺序很重要，基本规则是退出-&gt;转换-&gt;进入（exit-transition-entry）。 ​ 也就是说，先行状态的退出动作首先执行，然后是转换动作，随后是后续状态的进入动作。 序列图含 Alternatives, Branches, Options, and Loops 时间自动机（Timed automata 建模与验证）​ 时间自动机是实时系统建模与验证的理论。 具有相同目的的其他形式的例子还有时间Petri网（timed Petri Nets）， ​ 时间过程代数（timed process algebras）和实时逻辑（real time logics） ​ 公平地说，以时间自动机作为输入语言的核心开发的几种模型检查器是理论应用和发展的动力。 时间自动机本质上是一个用实值变量（时间系统）进行扩展的有限自动机（包含一组有限节点和一组有限带有标记的边的图） 变量（variables）对系统中的逻辑时钟进行建模，在系统启动时用零初始化，然后以相同的速率同步增加 时钟约束（clock constraints），即边上用于限制自动机行为的约束（Guard） 当时钟值满足在边上标记约束（Guard）时，边表示的转换（transition）就可以发生。 当进行转换时，时钟可能被重置为零。 实验时间自动机工具UPPAAL 同步通信（synchronous）通过使用输入输出行为的握手同步（hand-shake synchronization）来实现 异步通信（asynchronous）使用共享变量（shared variables）来实现 ​ 为了对握手同步进行建模，字母 ∑ 定义为包括：输入动作 a？，输出动作a！，内部行为 ‘T’ 三次实验内容回顾","categories":[{"name":"CS","slug":"CS","permalink":"http://vergessenwang.github.io/categories/CS/"}],"tags":[]},{"title":"在ModelArts上用Caffe-SSD进行目标检测模型训练","slug":"在ModelArts上用Caffe-SSD进行目标检测模型训练","date":"2019-12-27T14:22:10.000Z","updated":"2019-12-27T14:23:50.534Z","comments":true,"path":"posts/DL/2019-12-27-在ModelArts上用Caffe-SSD进行目标检测模型训练.html","link":"","permalink":"http://vergessenwang.github.io/posts/DL/2019-12-27-在ModelArts上用Caffe-SSD进行目标检测模型训练.html","excerpt":"本着不再当队长的原则，这学期的深度学习实践课进了别的同学的队伍，果然，当普通队员的感觉就是……真香！ 今天服从组织安排，用华为云的ModelArts尝试跑一下Caffe框架下的SSD模型来进行目标检测。队友说，让我尽量试试，还给我发了一大堆文档，可以说是相当耐心了。认真学习。 首先是在ModelArts中创建一个GPU实例并编译好Caffe-SSD, 这里队友实在看不下去我编译时的弱智操作，帮我完成了这一步。。 准备数据集虽然模拟电梯环境采集了一些数据，但是明显有很多重复的。 所以只能在寻找另外的方法，而网上很少有所需的数据，于是打算自己爬图片做标注后用于训练。 获取图片爬取谷歌图片 打算用googleimagesdownload工具 由于图片数量较多，还需要安装chromedriver, 我的谷歌版本时版本 78.0.3904.97，下载对应版本, 放在图片存放路径的文件夹中，切换到目录运行命令： googleimagesdownload -k &quot;电动车&quot; -l 300 --chromedriver=&quot;./chromedriver 然后就开始自动下载啦~~~","text":"本着不再当队长的原则，这学期的深度学习实践课进了别的同学的队伍，果然，当普通队员的感觉就是……真香！ 今天服从组织安排，用华为云的ModelArts尝试跑一下Caffe框架下的SSD模型来进行目标检测。队友说，让我尽量试试，还给我发了一大堆文档，可以说是相当耐心了。认真学习。 首先是在ModelArts中创建一个GPU实例并编译好Caffe-SSD, 这里队友实在看不下去我编译时的弱智操作，帮我完成了这一步。。 准备数据集虽然模拟电梯环境采集了一些数据，但是明显有很多重复的。 所以只能在寻找另外的方法，而网上很少有所需的数据，于是打算自己爬图片做标注后用于训练。 获取图片爬取谷歌图片 打算用googleimagesdownload工具 由于图片数量较多，还需要安装chromedriver, 我的谷歌版本时版本 78.0.3904.97，下载对应版本, 放在图片存放路径的文件夹中，切换到目录运行命令： googleimagesdownload -k &quot;电动车&quot; -l 300 --chromedriver=&quot;./chromedriver 然后就开始自动下载啦~~~ 图片预处理筛选出符合要求的图片后，接下来进行数据增强。一方面是为了增加样本量，另一方面能够提高模型的泛化能力。 由于大小不一，先统一转为500*500 1234567891011121314from PIL import Imageimport os.pathimport globdef convertjpg(jpgfile,outdir,width=500,height=500): img=Image.open(jpgfile) try: new_img=img.resize((width,height),Image.BILINEAR) new_img.save(os.path.join(outdir,os.path.basename(jpgfile))) except Exception as e: print(e)for jpgfile in glob.glob(\"C:/Users/18771/Desktop/emotor_1/*.jpg\"): convertjpg(jpgfile,\"C:/Users/18771/Desktop/emotor_2\") 处理完其实已经没多少数据了，应该多爬一点的.. 接下来可以用labelImg标注数据了，我已经是个熟练工了。。感觉触摸板都要摸烂了。。 生成LMDB数据集将数据集划分下训练集、测试集和验证集 按VOC标准建好目录结构，把数据传到ModelArts上面 ImageSets里Main文件夹，用到4个文件： train.txt 是用来训练的图片文件的文件名列表 val.txt是用来验证的图片文件的文件名列表 trianval.txt是用来训练和验证的图片文件的文件名列表 test.txt 是用来测试的图片文件的文件名列表 用脚本生成训练集和测试集， 12345678910111213141516171819202122232425262728293031323334353637import osimport randomtrainval_percent = 0.8 # 修改训练集与测试集比例，此时train:test=8:2train_percent = 0.7 # train 占 trainval 中的 0.7 ， 后面只用 trainval，所以这里这个数值不重要fdir = '/home/ma-user/work/caffe/data/VOC1227/VOCdevkit/VOC1227/ImagesSets/Main/' # 修改对应路径xmlfilepath = '/home/ma-user/work/caffe/data/VOC1227/VOCdevkit/VOC1227/Annotations/label' # 修改对应路径txtsavepath = fdirtotal_xml = os.listdir(xmlfilepath)num=len(total_xml)list=range(num)tv=int(num*trainval_percent)tr=int(tv*train_percent)trainval= random.sample(list,tv)train=random.sample(trainval,tr)ftrainval = open(fdir + 'trainval.txt', 'w')ftest = open(fdir + 'test.txt', 'w')ftrain = open(fdir + 'train.txt', 'w')fval = open(fdir + 'val.txt', 'w')for i in list: name=total_xml[i][:-4]+'\\n' if i in trainval: ftrainval.write(name) if i in train: ftrain.write(name) else: fval.write(name) else: ftest.write(name)ftrainval.close()ftrain.close()fval.close()ftest .close() 接下来引用分好的dataset建立list文件，改下create_list.sh中的路径, 这个文件是从VOC0712中拷贝过来的，记得注释掉[[ \\$dataset == “test” &amp;&amp; \\$name == “VOC1227” ]] 不然无法生成test 文件内容详解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/bin/bashroot_dir=/home/ma-user/work/caffe/data/VOC1227/VOCdevkitsub_dir=ImagesSets/Mainbash_dir=\"$(cd \"$(dirname \"$&#123;BASH_SOURCE[0]&#125;\")\" &amp;&amp; pwd)\"for dataset in trainval test do dst_file=$bash_dir/$dataset.txt if [ -f $dst_file ] then rm -f $dst_file fi for name in VOC1227 do //if [[ $dataset == \"test\" &amp;&amp; $name == \"VOC1227\" ]] //then //continue //fi echo \"Create list for $name $dataset...\" dataset_file=$root_dir/$name/$sub_dir/$dataset.txt img_file=$bash_dir/$dataset\"_img.txt\" cp $dataset_file $img_file sed -i \"s/^/$name\\/JPEGImages\\/image\\//g\" $img_file sed -i \"s/$/.jpg/g\" $img_file label_file=$bash_dir/$dataset\"_label.txt\" cp $dataset_file $label_file sed -i \"s/^/$name\\/Annotations\\/label\\//g\" $label_file sed -i \"s/$/.xml/g\" $label_file paste -d' ' $img_file $label_file &gt;&gt; $dst_file rm -f $label_file rm -f $img_file done # Generate image name and size infomation. if [ $dataset == \"test\" ] then $bash_dir/../../build/tools/get_image_size $root_dir $dst_file $bash_dir/$dataset\"_name_size.txt\" fi # Shuffle trainval file. if [ $dataset == \"trainval\" ] then rand_file=$dst_file.random cat $dst_file | perl -MList::Util=shuffle -e 'print shuffle(&lt;STDIN&gt;);' &gt; $rand_file mv $rand_file $dst_file fidone 接下来根据建好的list文件，生成lmdb文件用于之后的训练 需要export一下openblas的路径 1234export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/ma-user/anaconda2/libsource ~/.bashrcecho &apos;export LD_LIBRARY_PATH=/home/ma-user/work/OpenBLAS:$LD_LIBRARY_PATH&apos; &gt;&gt; ~/.bashrcsource ~/.bashrc 然后调用convert_annoset生成lmdb文件 12345/home/ma-user/work/caffe/build/tools/convert_annoset --anno_type=detection --encode_type=jpg --encoded=true --shuffle=true \\--label_map_file=/home/ma-user/work/caffe/data/VOC1227/labelmap_voc.prototxt \\/home/ma-user/work/caffe/data/VOC1227/VOCdevkit/ \\/home/ma-user/work/caffe/data/VOC1227/trainval.txt \\/home/ma-user/work/caffe/data/emotor_lmdb1227 12345/home/ma-user/work/caffe/build/tools/convert_annoset --anno_type=detection --encode_type=jpg --encoded=true --shuffle=true \\--label_map_file=/home/ma-user/work/caffe/data/VOC1227/labelmap_voc.prototxt \\/home/ma-user/work/caffe/data/VOC1227/VOCdevkit/ \\/home/ma-user/work/caffe/data/VOC1227/test.txt \\/home/ma-user/work/caffe/data/emotor_lmdb1227test 训练模型修改模型中的相应参数，开跑。。 123/home/ma-user/work/caffe/build/tools/caffe train \\-solver=/home/ma-user/work/caffe/MobileNet-SSD/solver_train.prototxt \\--weights=/home/ma-user/work/caffe/MobileNet-SSD/mobilenet_iter_73000.caffemodel 美滋滋地开跑了，结果loss全是0？？？？ 还得重新看数据集有什么问题。。弄了一天，人都傻了。。 后来反应过来是文件名写错了。 当房间烧成了废墟 我看见了更皎洁的月光我看见了所有赐予我的幸福所有转瞬即逝的欢乐我看见了我违背的誓言不曾释怀的痛楚未能痊愈的伤痛压抑住的泪水我看见了我不曾哀悼的死亡没有回应的祈祷未曾开启的门 和始终开放的门我看见了被我遗弃的爱人未能实践的梦想我看见了所有给予我却不能接受的一切我看见了我期盼的却未能收到的来信我看见了所有应该发生但从未发生的一切——《尘与雪》","categories":[{"name":"DL","slug":"DL","permalink":"http://vergessenwang.github.io/categories/DL/"}],"tags":[{"name":"Caffe","slug":"Caffe","permalink":"http://vergessenwang.github.io/tags/Caffe/"},{"name":"SSD","slug":"SSD","permalink":"http://vergessenwang.github.io/tags/SSD/"},{"name":"ModelArts","slug":"ModelArts","permalink":"http://vergessenwang.github.io/tags/ModelArts/"}]},{"title":"基于Caffe的Mnist数据集手写识别","slug":"基于Caffe的Mnist数据集手写识别","date":"2019-12-23T14:33:01.000Z","updated":"2019-12-23T14:34:09.250Z","comments":true,"path":"posts/DL/2019-12-23-基于Caffe的Mnist数据集手写识别.html","link":"","permalink":"http://vergessenwang.github.io/posts/DL/2019-12-23-基于Caffe的Mnist数据集手写识别.html","excerpt":"操作指南——此文已非常之详细 注意执行convert-mnist-data是在 Build\\x64\\Release\\ 目录下，而不是存放数据的目录下, 所以用绝对路径定位到该exe文件 训练集脚本： 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\convert_mnist_data.exe train-images.idx3-ubyte train-labels.idx1-ubyte mnist_train_lmdb pause 测试集脚本： 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\convert_mnist_data.exe t10k-images.idx3-ubyte t10k-labels.idx1-ubyte mnist_test_lmdb pause 把\\examples\\mnist下的文件 lenet_solver.prototxt中的训练平台改为CPU lenet_train_test.prototxt 是要采用的训练模型的具体实现。","text":"操作指南——此文已非常之详细 注意执行convert-mnist-data是在 Build\\x64\\Release\\ 目录下，而不是存放数据的目录下, 所以用绝对路径定位到该exe文件 训练集脚本： 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\convert_mnist_data.exe train-images.idx3-ubyte train-labels.idx1-ubyte mnist_train_lmdb pause 测试集脚本： 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\convert_mnist_data.exe t10k-images.idx3-ubyte t10k-labels.idx1-ubyte mnist_test_lmdb pause 把\\examples\\mnist下的文件 lenet_solver.prototxt中的训练平台改为CPU lenet_train_test.prototxt 是要采用的训练模型的具体实现。 然而，开始训练的时候，魔鬼又出现了。。ImportError: No module named _caffe 明明之前import成功了，后来找到一个解决方案 ：把Build\\x64\\Release\\pycaffe\\caffe目录下的所有文件复制到caffe-windows\\python\\caffe目录中，也就是把原文件夹中的一部分文件用编译完成的新文件替换。 用.\\draw_net.py可以查看训练网络的可视化。 在caffe根目录下创建训练运行脚本 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\caffe.exe train --solver=examples/mnist/lenet_solver.prototxt pause 接下来参考这篇博客 最终模型存储在lenet_iter_10000 测试脚本 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\caffe.exe test --model examples/mnist/lenet_train_test.prototxt -weights=examples/mnist/lenet_iter_10000.caffemodelpause 测试结果 12I1219 00:44:56.921839 6236 caffe.cpp:331] accuracy = 0.9854I1219 00:44:56.921839 6236 caffe.cpp:331] loss = 0.0447507 (* 1 = 0.0447507 loss) 用图片进行测试,参考 脚本生成均值文件mean.binaryproto 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\compute_image_mean mnist_train_lmdb mean.binaryproto pause 准备好测试图片，png格式 标签文件lable.txt 图片测试脚本 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\classification lenet.prototxt ./lenet/_iter_10000.caffemodel mean.binaryproto label.txt 8.pngpause 但是结果有问题，应该是图片格式的原因。 一下步要学习将图片转为Lmdb格式","categories":[{"name":"DL","slug":"DL","permalink":"http://vergessenwang.github.io/categories/DL/"}],"tags":[{"name":"Caffe","slug":"Caffe","permalink":"http://vergessenwang.github.io/tags/Caffe/"}]},{"title":"困兽的悲剧","slug":"困兽的悲剧","date":"2019-12-11T13:45:37.000Z","updated":"2019-12-11T14:09:23.840Z","comments":true,"path":"posts/poetry/2019-12-11-困兽的悲剧.html","link":"","permalink":"http://vergessenwang.github.io/posts/poetry/2019-12-11-困兽的悲剧.html","excerpt":"","text":"泥潭中心的狮子挣扎只能加速下沉索性不动了冬雪盖过来浑然一体的纯洁和寂静如此安心再少一点阴冷的重压带来的窒息吧它呓语着闭眼睡去第一缕春光照上它长满青苔的额头时一只火红的雀鸟飞下歪着头细看了一会啁啾细叹真是一尊栩栩如生的石狮啊风穿心而过在耳后永恒呼嚎（突然想起前几天看过的电影里那个侦探作家的一部书名，有感而发）","categories":[{"name":"poetry","slug":"poetry","permalink":"http://vergessenwang.github.io/categories/poetry/"}],"tags":[]},{"title":"AVL树、红黑树和伸展树","slug":"AVL树、红黑树和伸展树","date":"2019-12-10T04:23:05.000Z","updated":"2019-12-10T04:25:08.906Z","comments":true,"path":"posts/data-structure/2019-12-10-AVL树、红黑树和伸展树.html","link":"","permalink":"http://vergessenwang.github.io/posts/data-structure/2019-12-10-AVL树、红黑树和伸展树.html","excerpt":"二叉查找树二叉查找树的特征(递归) ——或者是一棵空树或者是具有如下特性的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于根结点的值； 它的左、右子树也分别是二叉排序树。 中序遍历二叉排序树可得到一个关键字的有序序列。 在一般情况下，查找和插入的时间复杂度为logN, 但是在极端情况下会退化为链表，此时查找变为顺序遍历，失去了排序树的意义。——构造的二叉查找树的形状依赖于数据项，且依赖于它们加载的顺序 二叉查找树平衡性很差（即失衡）时，可用AVL树、红黑树和伸展树进行改进。其中AVL树和红黑树是高度平衡的，伸展树是加权平衡的(将常用的数据项放在树中接近根部的位置)","text":"二叉查找树二叉查找树的特征(递归) ——或者是一棵空树或者是具有如下特性的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于根结点的值； 它的左、右子树也分别是二叉排序树。 中序遍历二叉排序树可得到一个关键字的有序序列。 在一般情况下，查找和插入的时间复杂度为logN, 但是在极端情况下会退化为链表，此时查找变为顺序遍历，失去了排序树的意义。——构造的二叉查找树的形状依赖于数据项，且依赖于它们加载的顺序 二叉查找树平衡性很差（即失衡）时，可用AVL树、红黑树和伸展树进行改进。其中AVL树和红黑树是高度平衡的，伸展树是加权平衡的(将常用的数据项放在树中接近根部的位置) AVL树定义(递归)：或者是一棵空树，或者是具有如下特性的二叉查找树 左子树和右子树的高度最多相差1； 它的左、右子树也分别是平衡二叉树。 如何调整节点以维持高度的平衡？ Step1：找到不平衡（即左右子树高度差距大于1）的最小子树的根节点（记为A） Step2：依据新插入节点与节点A的相对位置，进行相应处理。 LL型失衡: 在A结点的左孩子的左子树上插入结点,导致A结点失去平衡.——单向右旋平衡处理 RR型失衡: 单向左旋平衡处理 LR型失衡: 双向旋转先左后右平衡处理型。先把下段左旋转换为LL型失衡，再将上段右旋解决LL型失衡 RL型失衡: 双向旋转先右后左平衡处理型。先把下段右旋转换为RR型失衡，再将上段左旋解决RR型失衡 为修复失衡所进行的旋转操作可能需要对插入和删除期间所采用的访问路径执行向后遍历(当需要多次旋转时）——实现起来比较麻烦？ 红黑树红黑树是满足下列条件的二叉查找树： 每个节点都带有红色或黑色。节点的颜色由以下规则确定： 根节点是黑色的。 所有叶节点都是黑色的。 在沿着从根出发的任何路径上都不允许出现两个连续的红色节点，即：“红色”结点的两个子结点都是“黑色”的。 从任一节点到其每个子孙叶子节点的所有简单路径都包含相同数目的黑色节点（简称黑色高度） 节点X的黑色高度：从节点X到其子孙叶子节点的简单路径中的黑色链的数量。 不包括 X 结点本身，包括叶结点 外部结点的阶是零； 红黑树的黑色高度：根节点的黑色高度（称为：根节点的阶） 阶为 k 的红黑树路径长度：最短是 k，最长是 2k ——实现平衡的原因 2-3-4树的二叉树的实现本质上就是红黑树——可利用颜色翻转和旋转来等价实现 两类基本操作： 颜色翻转 实质上为4-节点分裂 当某个结点的两个孩子结点都为红色时 将两个红色孩子结点和其黑色双亲结点的颜色翻转 旋转 出现右的红色链时；有连续两个红色链时 依据两个连续的红色链的形状，进行相应的旋转处理（类似AVL树的失衡旋转规则）；对于右的红色链，进行左旋处理 伸展树实现一种恒定重排的方式：每次访问树时，都使用旋转操作重排树，使得访问过的节点位于树的根部。 优点：最近使用的数据比未使用过的数据可更快的被访问——局部性原理,可以用于缓存 自底向上的伸展(更好理解)利用旋转，将访问的节点c搬根部。有三种基本操作： Case1：若访问的节点c没有祖父节点，则：直接在c与其父节点p之间进行旋转。 Case2：若访问的节点c，其父节点p，其祖父节点g三者之间的相关位置呈LL或RR型，则：先在p和g间旋转，再在p和c间旋转。（由上至下） Case3：若访问的节点，其父节点，其祖父节点三者之间的相关位置呈LR或RL型，则：先在c和p间旋转，再在c和g间旋转。（由下至上） 自顶向下的伸展首先确定从根到访问节点的路径，然后依据路径的形状，进行“分裂”操作。最后，以目标节点作为根进行片断的重组。 每次分裂操作会将当前树分为左，中，右三个片断。左片断为中间片断的前驱，右片断为中间片断的后继；其中，前驱、后继是指中序遍历顺序。左，右片断分别插入到左右存储树中。 左连接点：指左存储树中插入新片断的位置，指向左存储树中最右下角的节点。 右连接点：右存储树中插入新片断的位置，指向右存储树中最左下角的节点。","categories":[{"name":"data_structure","slug":"data-structure","permalink":"http://vergessenwang.github.io/categories/data-structure/"}],"tags":[{"name":"红黑树","slug":"红黑树","permalink":"http://vergessenwang.github.io/tags/红黑树/"},{"name":"AVL树","slug":"AVL树","permalink":"http://vergessenwang.github.io/tags/AVL树/"}]},{"title":"VS2017+Miniconda2编译Caffe","slug":"VS2017-Miniconda2编译Caffe","date":"2019-12-09T04:51:21.000Z","updated":"2019-12-09T04:54:06.103Z","comments":true,"path":"posts/DL/2019-12-09-VS2017-Miniconda2编译Caffe.html","link":"","permalink":"http://vergessenwang.github.io/posts/DL/2019-12-09-VS2017-Miniconda2编译Caffe.html","excerpt":"捣腾了一晚上的caffe。。环境配置什么的，真的是很容易上头。 官方安装文档 以下为踩坑过程。 【如果你的VS是2017版本，请直接看下一部分】 首先下载windows适用的caffe版本 在下载好的文件中 Copy .\\windows\\CommonSettings.props.example to .\\windows\\CommonSettings.props 打开该配置文件，按自己的电脑情况对GPU支持，CuDNN及Python支持进行配置。由于我的破本本没有独显，所以只能用CPU了。。 12&lt;CpuOnlyBuild&gt;true&lt;/CpuOnlyBuild&gt;&lt;UseCuDNN&gt;false&lt;/UseCuDNN&gt; 使用VS打开sln 文件，我的是VS2017版本而官网要求的是13或15版本，暂时不知后面将会遇到什么 问题。。 对项目的错误检查做一下设置，VS的报错有多烦人。。用过的都知道。。libcaffe项目→属性→C/C++→常规→将警告视为错误 设置为否。如果不设置的话在编译boost库的时候会由于文字编码的警告而报错。选择编译环境为Release，x64","text":"捣腾了一晚上的caffe。。环境配置什么的，真的是很容易上头。 官方安装文档 以下为踩坑过程。 【如果你的VS是2017版本，请直接看下一部分】 首先下载windows适用的caffe版本 在下载好的文件中 Copy .\\windows\\CommonSettings.props.example to .\\windows\\CommonSettings.props 打开该配置文件，按自己的电脑情况对GPU支持，CuDNN及Python支持进行配置。由于我的破本本没有独显，所以只能用CPU了。。 12&lt;CpuOnlyBuild&gt;true&lt;/CpuOnlyBuild&gt;&lt;UseCuDNN&gt;false&lt;/UseCuDNN&gt; 使用VS打开sln 文件，我的是VS2017版本而官网要求的是13或15版本，暂时不知后面将会遇到什么 问题。。 对项目的错误检查做一下设置，VS的报错有多烦人。。用过的都知道。。libcaffe项目→属性→C/C++→常规→将警告视为错误 设置为否。如果不设置的话在编译boost库的时候会由于文字编码的警告而报错。选择编译环境为Release，x64 在libcaffe上右键生成，进行编译。有点小激动，究竟能不能成功呢？。。 有惊无险 ，虽然全程都在 Unknown compiler version - please run the configure tests and report the results 接着再编译caffe，果然真正的快乐是无法持续的。。 报错：fatal error LNK1104: 无法打开文件“libboost_date_time-vc140-mt-gd-1_59.lib 应该是VS版本的问题了。 搜索了一圈解决方案，都是要改 build_win.cmd 文件的，而这个windows版本并没有这个文件，正如一开始说，必须使用 VS2013或VS2015 而我，是绝对不想再重新安装一个VS的，别问我为什么。。所以只能，重新来过。。 本部分参考文章 找到另一个windows可用的版本，源码地址 安装Cmake 教程 比较重要的是Python的配置，miniconda相关操作 在安装了miniconda之后，以管理员方式运行cmd 12conda install --yes numpy scipy matplotlib scikit-image pippip install protobuf 在第二条命令时，遇到一大串红字。 1234567891011121314151617181920212223242526272829303132333435363738Traceback (most recent call last): File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\cli\\base_command.py\", line 153, in _main status = self.run(options, args) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\commands\\install.py\", line 382, in run resolver.resolve(requirement_set) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\legacy_resolve.py\", line 201, in resolve self._resolve_one(requirement_set, req) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\legacy_resolve.py\", line 365, in _resolve_one abstract_dist = self._get_abstract_dist_for(req_to_install) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\legacy_resolve.py\", line 313, in _get_abstract_dist_for req, self.session, self.finder, self.require_hashes File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\operations\\prepare.py\", line 194, in prepare_linked_requirement progress_bar=self.progress_bar File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\download.py\", line 465, in unpack_url progress_bar=progress_bar File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\download.py\", line 316, in unpack_http_url progress_bar) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\download.py\", line 551, in _download_http_url _download_url(resp, link, content_file, hashes, progress_bar) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\download.py\", line 253, in _download_url hashes.check_against_chunks(downloaded_chunks) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\utils\\hashes.py\", line 80, in check_against_chunks for chunk in chunks: File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\download.py\", line 223, in written_chunks for chunk in chunks: File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\utils\\ui.py\", line 160, in iter for x in it: File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\download.py\", line 212, in resp_read decode_content=False): File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_vendor\\urllib3\\response.py\", line 564, in stream data = self.read(amt=amt, decode_content=decode_content) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_vendor\\urllib3\\response.py\", line 529, in read raise IncompleteRead(self._fp_bytes_read, self.length_remaining) File \"C:\\ProgramData\\Miniconda2\\lib\\contextlib.py\", line 35, in __exit__ self.gen.throw(type, value, traceback) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_vendor\\urllib3\\response.py\", line 439, in _error_catcher raise ReadTimeoutError(self._pool, None, \"Read timed out.\")ReadTimeoutError: HTTPSConnectionPool(host='files.pythonhosted.org', port=443): Read timed out. pip show pip setuptools 查看pip版本是19.3.1 setuptools 是41.4.0 我怀疑是pip调用路径的问题，于是在用户环境变量中删除了本来安装的python3.5的路径 C:\\Users\\18771\\AppData\\Local\\Programs\\Python\\Python35\\Scripts\\ C:\\Users\\18771\\AppData\\Local\\Programs\\Python\\Python35\\ 重启一下，然后换用conda install protobuf命令，安装成功。 但是，为了少点坑，看了别人的博客写的，又多装了几个包 conda install --yes six pyyaml pydotplus graphviz 用VS打开sln, 重定解决方案为v141 接下来跟第一部分的操作一样，先不抱任何指望地编译libcaffe。。。 果然报错 ：无法打开包括文件: “pyconfig.h”: No such file or directory (编译源文件 ....\\src\\caffe\\layer_factory.cpp) 打开CommonSettings.props将 D:\\Anaconda3\\ 改为自己的python路径 C:\\ProgramData\\Miniconda2 编译成功。 再不抱任何指望地编译caffe。。。成功一个，失败一个 报错：fatal error LNK1181: 无法打开输入文件“cufft.lib” 打开 CommonSettings.props 将&lt;CudaDependencies&gt;cufft.lib&lt;/CudaDependencies&gt; 改成 &lt;CudaDependencies&gt;&lt;/CudaDependencies&gt; 再次尝试，报错 LINK : fatal error LNK1104: 无法打开文件“libboost_python-vc141-mt-1_65_1.lib” 这应该是VS版本的问题了，vc141就是2017的， 把 thirdparty\\Boost\\lib64-msvc-14.0 中所有的140改成141 试一下，caffe 可以编译了。 然后右键重新生成解决方案，开始全部编译。 终于 ========== 全部重新生成: 成功 16 个，失败 0 个，跳过 0 个 ========== 所有编译成功和运行需要的dll文件都会存储在Build\\x64\\Release 下 激动哭了。。 感谢前面的踩坑大佬 验证编译结果。尝试在python中调用 打开anaconda的命令行，进入caffe的examples目录，运行jupyter notebook 在打开的notebook中打开caffe自带的例子 00-calssification.ipynb 运行后 报错：ModuleNotFoundError: No module named ‘caffe._caffe’ 根据源码中readme提示操作 set PythonPath environment variable to point to &lt;caffe_root&gt;\\Build\\x64\\Release\\pycaffe, or copy folder &lt;caffe_root&gt;\\Build\\x64\\Release\\pycaffe\\caffe under &lt;python_root&gt;\\lib\\site-packages. 我选择了第二种，copy到了C:\\Users\\18771\\Anaconda3\\Lib\\site-packages中 重新运行，还是不行。突然意识到是不是python版本不一样，因为编译用的是miniconda用的是2.7，而anaconda默认的是3.7 于是copy到了C:\\ProgramData\\Miniconda2\\Lib\\site-packages中(顺带在caffe27的虚拟环境中也copy了一份..)，直接命令行运行python，import caffe 由于我比较喜欢在虚拟环境中跑程序，于是再尝试在caffe27的虚拟环境下运行，先安装numpy、 scikit-image 、protobuf包，再进入python命令行，输入import caffe, 同样运行成功。 环境配置，总算告一段落了。。","categories":[{"name":"DL","slug":"DL","permalink":"http://vergessenwang.github.io/categories/DL/"}],"tags":[{"name":"Caffe","slug":"Caffe","permalink":"http://vergessenwang.github.io/tags/Caffe/"}]},{"title":"沉默为敌","slug":"沉默为敌","date":"2019-12-03T12:45:45.000Z","updated":"2019-12-03T14:19:50.783Z","comments":true,"path":"posts/life/2019-12-03-沉默为敌.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2019-12-03-沉默为敌.html","excerpt":"辩论赛打输了，挺难受的。确实一开始就没对队友报太大希望，结果真的也没让我”失望”。 安排的一辩，上去东拉西扯3分钟，我在后面听了都觉得尴尬，不知所云，然后留给我的二辩时间不够，稿子念了不到三分之二。一辩在自由辩论的环节，也没有回答任何问题。我的室友，回答了一个问题，我已经很满足了。还有一个女生，从头到尾，一言不发。就我跟师兄在那，尽力去反驳对方观点。我觉得好累啊。怎么能这样？ 最后53:57输了。我原本对这个辩题信心十足的，可是对于队友的表现，我真的非常非常失望。 结束后一辩过来跟我道歉，我跟他说：没事。看着他愧疚的样子，我也说不出别的话来。 早两周让他们准备好反方论点，以及反驳的例子，结果昨天晚上才发来材料，短短几段。我就知道要凉了。 结束了，看着我的三页材料，特意买的一本书，觉得好气啊，又无处发作。很想问我是来请你们看戏的吗？转念一想，算了算了，一场辩论赛而已，也不是八强淘汰课。可能就是，只有我和师兄俩看得比较重要吧，其他三人都觉得无所谓。 长叹一声，没办法，人只能控制自己的行为，而无法控制别人的态度。 所以还是只能万事准备好PlanB。","text":"辩论赛打输了，挺难受的。确实一开始就没对队友报太大希望，结果真的也没让我”失望”。 安排的一辩，上去东拉西扯3分钟，我在后面听了都觉得尴尬，不知所云，然后留给我的二辩时间不够，稿子念了不到三分之二。一辩在自由辩论的环节，也没有回答任何问题。我的室友，回答了一个问题，我已经很满足了。还有一个女生，从头到尾，一言不发。就我跟师兄在那，尽力去反驳对方观点。我觉得好累啊。怎么能这样？ 最后53:57输了。我原本对这个辩题信心十足的，可是对于队友的表现，我真的非常非常失望。 结束后一辩过来跟我道歉，我跟他说：没事。看着他愧疚的样子，我也说不出别的话来。 早两周让他们准备好反方论点，以及反驳的例子，结果昨天晚上才发来材料，短短几段。我就知道要凉了。 结束了，看着我的三页材料，特意买的一本书，觉得好气啊，又无处发作。很想问我是来请你们看戏的吗？转念一想，算了算了，一场辩论赛而已，也不是八强淘汰课。可能就是，只有我和师兄俩看得比较重要吧，其他三人都觉得无所谓。 长叹一声，没办法，人只能控制自己的行为，而无法控制别人的态度。 所以还是只能万事准备好PlanB。 接下来反思一下自己：首先不够镇定，念稿子的时候手有点抖。。其次，临场反应能力还不够，有几个问题一下子没有想到反驳的点，还有就是只敢看对方，不敢看观众，至于其他的，都是超常发挥了。。 之后跟师兄交流，他说感觉我们这一届普遍比上一届沉默，微信大群都没有人说话，让他觉得有点可怕。不像他们的群，非常活跃。我一开始也认为是不是本科计算机和软件的同学都是这样，也默认了他们话都比较少。所以一开始也理解他们的性格，尝试带下节奏，就让他们好好准备，到时候能说一点是一点了。但万万没想到，会是这样的结果。 这次事件，可以说彻底改变了我对沉默群体的看法。 有人说，当你特别讨厌一种特质的时候，在你自己的身上，一定也有这个问题。确实，我承认我内向，但也不是不分场合。 我终于知道为什么人们更喜欢外向的人了，内向给人的感觉不仅是难当大任，而且是当他们因性格问题无法做好一些事情的时候，你根本无从责备，那种憋屈，真的太难受了。 纵使你有万般学识，无法表达，别人永远看不到你的内在。人们只会看到你在这件事情上失败了，并由此怀疑你是否真的有责任心和能力。虽然以前老爸也这样教育过我，但我都只是当耳边风。 感谢这场辩论赛，让我真正认识到内向与沉默的坏处。 从此以后，再不想列沉默之席。再不想交内向之友。 不快的事情，写完就忘掉吧。","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[{"name":"以人为镜","slug":"以人为镜","permalink":"http://vergessenwang.github.io/tags/以人为镜/"}]},{"title":"空心","slug":"空心","date":"2019-12-02T02:01:46.000Z","updated":"2019-12-02T07:27:11.207Z","comments":true,"path":"posts/life/2019-12-02-空心.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2019-12-02-空心.html","excerpt":"认真准备了两天系统建模的期中考试，结果简单地一匹。不过总算有时间清空一下脑子，想点别的东西了。 回顾这三个月，真快，最大的感受莫过于：东西没怎么学到，各种群倒是加了一大堆。。 人把自己置身忙碌之中，有一种麻木的充实，但是丧失了真实，你的青春不过也只有这些日子。 没错了，是被各种deadline推着走的。 看系统建模的PPT时，我注意到下面的脚注写了一个：2003 。 真可笑，十几年前的东西，我学这些究竟有什么意义？ 想想自己的时间都去了哪里？上课，简单的不想听，难的跟不上…；写作业，磨磨唧唧；写实验，全靠悟性；看工程实践的东西，理论弄了一大堆，真正要开始做了，又觉得前面的工作跟本没有抓住核心；确定了自己的方向，而没有对应的计划；说着要提高编程能力，然而跟我一年前刚拿起数据结构开始看的时候根本没有什么区别…所以，我究竟在干什么…？ 还有不分主次，不求甚解的恶习。总是把简单的先斗志昂扬地做完了，剩下看不懂的困难的一直拖一直拖，最后虎头蛇尾。 赵老师在高网考试完，同学们纷纷吐槽题目太难时曾说： 工作以后，大多数人才会发现考试、读书都是相对简单的，因为都是在跟随学习。难的是有些工作，有些设计，你首先得先想出来这是个什么性质的问题，什么范畴的问题，再去找参考。跟着别人做，或者做既定的工作很简单，自己独当一面时，才是真正的动脑筋。","text":"认真准备了两天系统建模的期中考试，结果简单地一匹。不过总算有时间清空一下脑子，想点别的东西了。 回顾这三个月，真快，最大的感受莫过于：东西没怎么学到，各种群倒是加了一大堆。。 人把自己置身忙碌之中，有一种麻木的充实，但是丧失了真实，你的青春不过也只有这些日子。 没错了，是被各种deadline推着走的。 看系统建模的PPT时，我注意到下面的脚注写了一个：2003 。 真可笑，十几年前的东西，我学这些究竟有什么意义？ 想想自己的时间都去了哪里？上课，简单的不想听，难的跟不上…；写作业，磨磨唧唧；写实验，全靠悟性；看工程实践的东西，理论弄了一大堆，真正要开始做了，又觉得前面的工作跟本没有抓住核心；确定了自己的方向，而没有对应的计划；说着要提高编程能力，然而跟我一年前刚拿起数据结构开始看的时候根本没有什么区别…所以，我究竟在干什么…？ 还有不分主次，不求甚解的恶习。总是把简单的先斗志昂扬地做完了，剩下看不懂的困难的一直拖一直拖，最后虎头蛇尾。 赵老师在高网考试完，同学们纷纷吐槽题目太难时曾说： 工作以后，大多数人才会发现考试、读书都是相对简单的，因为都是在跟随学习。难的是有些工作，有些设计，你首先得先想出来这是个什么性质的问题，什么范畴的问题，再去找参考。跟着别人做，或者做既定的工作很简单，自己独当一面时，才是真正的动脑筋。 可以说是一语点醒。我好像还是从前本科时候那种节奏和思维方式，殊不知工科是有极大不同的，你一个点没有理解到位，后面的就都是臆想。不像商科，正着反着说两句，怎么也能自圆其说。 我曾觉得有确定性的东西，更值得付出精力，现在才发现，你得深入到了一定的程度，才能获得这种确定性。或者换句话说，最本质的东西，从来不是简简单单就能看透的。 然而，其实这些都不是真正的问题。 真正的问题，是那种时时席卷而来的虚无感，淹没了一切的意义。 我好像从来没有很执着于什么东西，初时是靠的热情，后来靠惯性，能做得下去自然是好事，不想做了也可以轻易的放弃。 我从没有感觉过于淡漠是什么问题，或者说，只是因为我从来没有正视过它。 在知乎盲目搜了一下，得知一个词：感情淡漠症。 填了一个心理测试，重度，呵呵。再百度一波应该就可以准备写遗书了。 不管怎么说，确实挺符合，但我拒绝认为这是病症，只是一种处事方式。 然后，突然想到一些事情。 大概还是在小学，爷爷下葬那天，人好多，我爸骑着自行车赶过来的时候，看见我在门口哭得好大声，然后抱着我一起哭。后来，他老用这件事来证明我小时候对人感情多么深厚。他永远不会知道，我那时哭，只是一种模仿。我知道在那样的环境下，应该那样做。 高中之前，与父母待过的时间并不长。后来他们总拿小时候那几件具有共同回忆的事情来反复咀嚼，这让我经常不耐。但我从来没有说过一句埋怨的话，到了嘴边全都咽回肚子。那种在时间的长河里无法弥补的缺陷，并不是他们的错，这正是让我最感无力的地方。 我意识到，我很少与人交心，并不是因为不信任，而是根本没有心，没有什么重要的东西放在心里，也就没什么好说的，偶尔郁闷又说不出原因，所幸的是过一段时间自动会好。 不表达感情，不是因为那个人对我不重要，而是根本不懂怎样才算发自内心。正因为重视，不能像以前那样全然靠模仿，我不能在这段感情里添上虚伪的东西，最终就什么也没做了。 就像晴子生日的时候，她要我给她写一段祝福的话。我可以浮夸的写很多，但觉得太假，最后就什么也没写。 我做过太多这样伤人的事情了。 感谢那些大浪淘沙，在感情的荒漠里留下来陪我的朋友。如果不是她们主动维持，真的是不用风吹就散了。 可是，明明我看一些电影，文学作品也会流泪；看到喜欢的东西也会开心；被误解也会一直生闷气，但为什么就是无法用最正常最自然地方式去表达情感呢？ 这种事情，还可以靠后天学会吗？ 哈哈，想不到我一个研究生了，还得补小学的课。 令人窒息，不写了。 在周围所有人的哭泣、哀叹、惊慌失措中，他努力装出一副悲伤和恐惧的样子——一想起自己这种丑陋的、罪孽深重的行为，他就心如刀割。 关于这件事，你完全没有感觉。对活下来的喜悦也好，对死者的哀悼也好，你完全没有。而对于这一点你怀有强烈的罪恶感。你知道自己的没有感觉，是现代社会伦理所不容许的事情。 他想，这时候是不是应该生气，应该激动。但是他只是想想，没有实际行动。因为他既没有生气，也没有激动。 ​ —— 《悲鸣传》西尾维新","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[{"name":"真实的自我","slug":"真实的自我","permalink":"http://vergessenwang.github.io/tags/真实的自我/"}]},{"title":"BM算法","slug":"BM算法","date":"2019-11-27T15:43:22.000Z","updated":"2019-11-27T15:44:38.402Z","comments":true,"path":"posts/Algorithm/2019-11-27-BM算法.html","link":"","permalink":"http://vergessenwang.github.io/posts/Algorithm/2019-11-27-BM算法.html","excerpt":"我表示看完这两个匹配算法，头顶有点凉… BM算法与KMP算法的主要区别在于：采用从右向左进行字符的匹配比较。 BM算法中的关键问题是， 如何确定目标串中的下一轮匹配的开始位置？即如何决定目标串中指针向右跳跃的距离？——利用P中的重复模式 和 T中的失配字符 假设出现失配时， T[i]≠P[k]。则 此时坏字符为x(=T[i])，好后缀P’=P[(k+1) … (len(P)-1)]（好后缀，是已匹配的部分字符串） 如何确定目标串中查找指针的移动距离dist[i]？ 采用2种启发式方法：无需检查目标串中的所有字符即可查找到是否存在匹配子串。 启发式方法#1： 跳过字符（“坏字符”规则） CharJump[x]：依据T中的坏字符x，计算T中查找指针的跳跃距离 启发式方法#2： 重复模式（“好后缀”规则） MatchJump[k] ： 依据P中的失配位置k， 计算T中查找指针的跳跃距离","text":"我表示看完这两个匹配算法，头顶有点凉… BM算法与KMP算法的主要区别在于：采用从右向左进行字符的匹配比较。 BM算法中的关键问题是， 如何确定目标串中的下一轮匹配的开始位置？即如何决定目标串中指针向右跳跃的距离？——利用P中的重复模式 和 T中的失配字符 假设出现失配时， T[i]≠P[k]。则 此时坏字符为x(=T[i])，好后缀P’=P[(k+1) … (len(P)-1)]（好后缀，是已匹配的部分字符串） 如何确定目标串中查找指针的移动距离dist[i]？ 采用2种启发式方法：无需检查目标串中的所有字符即可查找到是否存在匹配子串。 启发式方法#1： 跳过字符（“坏字符”规则） CharJump[x]：依据T中的坏字符x，计算T中查找指针的跳跃距离 启发式方法#2： 重复模式（“好后缀”规则） MatchJump[k] ： 依据P中的失配位置k， 计算T中查找指针的跳跃距离 基本步骤Step1：对于模式串P，计算CharJump[x]和MatchJump[k]。Step2: 将T与P的第一个字符对齐。Step3: T与P进行从右向左的逐字符比较 ，直至找到一个不匹配字符或者P中所有字符都匹配成功。Step4: 若出现失配，即存在T[i]≠P[k]，此时坏字符x=T[i]，好后缀P’=P[(k+1) … (len(P)-1)]。按如下规则计算 目标串T中查找指针向右移动dist[i]： 若此时T与P已有部分字符匹配（即存在“好后缀” ） 时， BM算法将采用2种启发式方法（即坏字符规则 和好后缀规则 ） ，计算dist[i]=max(CharJump[x],MatchJump[k])。 若不存在“好后缀”，则必定是在模式串P的最后一个字符处出现失配。此时应采用启发式方法#1： 跳过字符规则（“好后缀”规则），计算设置dist[i] =CharJump[x]。 Step5: 若(i+dist[i])≤Len(T)-1，则移动模式字符串P，使之与T[i+dist[i]]右对齐，重复Step3；否则，认为T中不存在与P匹配的子串，返回匹配失败。 坏字符的两种情况 如果模式串中没有出现坏字符，那么从字符x开始的Len(P)个字符显然不可能与P匹配成功， 使目标串中查找指针直接跳过Len(P) 个字符。 即将模式串整体挪到该字符之后 如果坏字符x在模式P中出现(假设P[j]==x)，则将目标串中查找指针移动CharJump[x]，使得下一轮匹配中将字符P[j]与坏字符x进行对齐。即该坏字符与模式串中最后出现该字符的位置对齐——因为是从右向左匹配 关键问题是计算CharJump[x] 若x在P中出现，假设p[j]==x，则CharJump[x]=Len(P)-max(j)-1 —— max计算最后位置 否则， CharJump[x]=Len(P); 注意： 模式串P右移距离shift=dist[i]-Len(u)= CharJump[x]- (Len(P)-1-k) 个字符。 在第二种情况下，无法保证模式串一定是向右移动的，匹配可能会倒退，甚至进入死循环，使匹配一直无法结束。如坏字符出现在已经匹配的部分——于是需要配合好后缀来保证向前滑动。 若利用“坏字符规则，目标串中查找指针的移动距离dist=0，那么此时失配处必定不是在模式串的最后一个字符处，即此时必定存在“好后缀” 好后缀的三种情况 好的后缀可以在模式串的后缀之前位置的字符串中找到，且该字符串的前一个字符≠P[k] ——中间重合 好后缀的的后缀子串是模式串的前缀——首尾重合 模式串中找不到子串和好后缀子串前缀, 将模式串整体挪到该字符之后 关键问题： 如何计算目标串中查找指针的移动距离MatchJump? T中查找指针的移动距离dist≠模式串P的移动距离shift T中查找指针的移动距离dist=模式串P的移动距离shift+好后缀的长度 —— 打破循环Step1: MatchJump数组初始化：——默认不存在重复模式 MatchJump[k]=2*Len(p)-k-1 = Len(p)-k-1+Len(p);（k∈[0,Len(P)-2]）—— 已匹配部分长度 + 模式串长度 MatchJump[Len(P)-1] = 1，最后一个特殊处理，即第一个失配因此只移动一位（意味着：此时没有好后缀） Step2:若存在好后缀，则依据“好后缀规则 ” ， 重新调整MatchJump[k]（k∈[0,Len(P)-2]） （假定：好后缀P’为P[k+1]…P[Len(p)-1] ） 规则1：若好后缀P’在P中存在重复模式(注意是完全重复！)，且重复模式的前一个字符不等，即P[t +1]…P[Len(p)-1-k+t ]== P[k+1]…P[Len(P)-1]且P[t]≠P[k]，则MatchJump(k)=[Len(P)-1-k]+min(k-t)——要求计算重复模式的最小间隔，是因为可能有多个重复模式 —— 已匹配部分长度 + 不等字符间距 规则2：若不满足规则1，且P的前缀 为好后缀P’中的某个子后缀P”的重复模式(部分重复)，即(P”=P[t] … P[Len(p)-1]==P[0] … P[Len(p)-1-t]（t&gt;k+1)，则MatchJump(k)=[Len(P)-1-k]+min(t) 都不满足：MatchJump[k]=2*Len(p)-k-1 = Len(p)-k-1+Len(p); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;#define SIZE 256 //字符集字符数void generateBadChar(char *b, int m, int *badchar)//(模式串b，模式串长度m，模式串的哈希表)&#123; int i, ascii; for (i = 0; i &lt; SIZE; ++i) &#123; badchar[i] = -1;//哈希表初始化为-1 &#125; for (i = 0; i &lt; m; ++i) &#123; ascii = int(b[i]); //计算字符的ASCII值 badchar[ascii] = i;//重复字符被覆盖，记录的是最后出现的该字符的位置 &#125; // 打印一下badchar for (int j = 0; j &lt; m; ++j) &#123; int pos,jump; ascii = int(b[j]); pos = badchar[ascii] + 1; if (pos != 0) jump = m - pos; else jump = m; printf(\"模式串%s中第 %d 个字符 %c 最后出现的位置是 %d，charjmp值为%d\\n\", b, j + 1, b[j], pos,jump ); &#125;&#125;void generateGS(char *b, int m, int *suffix, bool *prefix)//预处理模式串，填充suffix，prefix&#123; int i, j, k; for (i = 0; i &lt; m; ++i)//两个数组初始化 &#123; suffix[i] = -1; prefix[i] = false; &#125; for (i = 0; i &lt; m - 1; ++i)//b[0,i] &#123; j = i; k = 0;//公共后缀子串长度(模式串尾部取k个出来，分别比较) while (j &gt;= 0 &amp;&amp; b[j] == b[m - 1 - k])//与b[0,m-1]求公共后缀子串 &#123; --j; ++k; suffix[k] = j + 1; //相同后缀子串长度为k时，该子串在b[0,i]中的起始下标 // (如果有多个相同长度的子串，被赋值覆盖，存较大的) &#125; if (j == -1)//查找到模式串的头部了 prefix[k] = true;//如果公共后缀子串也是模式串的前缀子串 &#125;&#125;int moveByGS(int j, int m, int *suffix, bool *prefix)//传入的j是坏字符对应的模式串中的字符下标&#123; int k = m - 1 - j;//好后缀长度 if (suffix[k] != -1)//case1，找到跟好后缀一样的模式子串（多个的话，存的靠后的那个（子串起始下标）） return j - suffix[k] + 1; for (int r = j + 2; r &lt; m; ++r)//case2 &#123; if (prefix[m - r] == true)//m-r是好后缀的子串的长度，如果这个好后缀的子串是模式串的前缀子串 return r;//在上面没有找到相同的好后缀下，移动r位，对齐前缀到好后缀 &#125; return m;//case3,都没有匹配的，移动m位（模式串长度）&#125;int str_bm(char *a, int n, char *b, int m)//a表示主串，长n; b表示模式串,长m&#123; int *badchar = new int[SIZE];//记录模式串中每个字符最后出现的位置 generateBadChar(b, m, badchar); //构建坏字符哈希表 int *suffix = new int[m]; bool *prefix = new bool[m]; generateGS(b, m, suffix, prefix); //预处理模式串，填充suffix，prefix int i = 0, j, moveLen1, moveLen2;//j表示主串与模式串匹配的第一个字符 while (i &lt; n - m + 1) &#123; for (j = m - 1; j &gt;= 0; --j) //模式串从后往前匹配 &#123; if (a[i + j] != b[j]) break; //坏字符对应模式串中的下标是j &#125; if (j &lt; 0) //匹配成功 &#123; delete[] badchar; delete[] suffix; delete[] prefix; return i + 1; //返回主串与模式串第一个匹配的字符的位置 &#125; //这里等同于将模式串往后滑动 j-badchar[int(a[i+j])] 位 moveLen1 = j - badchar[int(a[i + j])];//按照坏字符规则移动距离 moveLen2 = 0; if (j &lt; m - 1)//如果有好后缀的话 &#123; moveLen2 = moveByGS(j, m, suffix, prefix);//按照好后缀规则移动距离 &#125; i = i + max(moveLen1, moveLen2);//取大的移动 &#125; delete[] badchar; delete[] suffix; delete[] prefix; return -1;&#125;int main()&#123; string a , b ; cin &gt;&gt; a; // 目标串 cin &gt;&gt; b; // 子串 cout &lt;&lt; a &lt;&lt; \"中第一次出现\" &lt;&lt; b &lt;&lt; \"的位置(从0开始)是：\" &lt;&lt; str_bm(&amp;a[0], a.size(), &amp;b[0], b.size()); system(\"pause\"); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://vergessenwang.github.io/categories/Algorithm/"}],"tags":[{"name":"BM","slug":"BM","permalink":"http://vergessenwang.github.io/tags/BM/"}]},{"title":"KMP算法","slug":"KMP算法","date":"2019-11-26T14:48:10.000Z","updated":"2019-11-27T12:15:30.828Z","comments":true,"path":"posts/Algorithm/2019-11-26-KMP算法.html","link":"","permalink":"http://vergessenwang.github.io/posts/Algorithm/2019-11-26-KMP算法.html","excerpt":"为了避免朴素匹配算法需要向左回溯导致效率较低的缺点，引进了无需回溯的KMP算法。 KMP算法利用模式串P自身的重复模式 关注： 匹配失败，是否发生在P的第一个字符处？ 若当前轮匹配在进行第一个字符比较时就失败，那么下一轮应该是比较T[i+1]和P[1] P中是否有重复模式？ 若P中在当前轮成功匹配的子串的后缀与子串的前缀无重复模式，那么下一轮应该是比较T[i]和P[1] 若P中在当前轮成功匹配的子串的后缀与子串的前缀有重复模式，那么下一轮应该是比较T[i]和P[next[j]] 模式串的next[j] = ？ next[j]就是第j个元素前j-1个元素首尾重合部分个数加1 规定任何一个串，next[1]=0 next[i]= [P串中前 i-1 子串首尾最长匹配数 + 1] —— 首尾重合不包括本身 其他情况，next[i]= 1","text":"为了避免朴素匹配算法需要向左回溯导致效率较低的缺点，引进了无需回溯的KMP算法。 KMP算法利用模式串P自身的重复模式 关注： 匹配失败，是否发生在P的第一个字符处？ 若当前轮匹配在进行第一个字符比较时就失败，那么下一轮应该是比较T[i+1]和P[1] P中是否有重复模式？ 若P中在当前轮成功匹配的子串的后缀与子串的前缀无重复模式，那么下一轮应该是比较T[i]和P[1] 若P中在当前轮成功匹配的子串的后缀与子串的前缀有重复模式，那么下一轮应该是比较T[i]和P[next[j]] 模式串的next[j] = ？ next[j]就是第j个元素前j-1个元素首尾重合部分个数加1 规定任何一个串，next[1]=0 next[i]= [P串中前 i-1 子串首尾最长匹配数 + 1] —— 首尾重合不包括本身 其他情况，next[i]= 1 匹配过程：若某轮匹配失败，则利用next数组分别计算下一轮匹配时目标串和模式串的开始位置 若是T[i]≠P[j]导致当前轮的匹配失败，则按照下列规则开始下一轮匹配： 若next[j] ≠ 0，则将T[i..]与P[next[j]..]匹配 若next[j]==0，则将T[(i+1)..]与P[1..]匹配 nextval数组什么情况下有改进的空间？ 假设T[i] ≠P[j]导致失配 。若P[j]==P[next[j]]，此时若向右移动模式串P，将T[i]与P[next[j]]对齐进行比较必然是无意义的，因为此时T[i]必定≠P[next[j]]。 如何改进？用nextval数组代替next数组。 nextval[1]=0; for(j&gt;1;j&lt;=n;j++)若P[j]==P[next[j]]，则nextval[j]=nextval[next[j]];若P[j]≠P[next[j]]，则nextval[j]=next[j];若某轮匹配失败，则利用nextval数组计算下一轮匹配时的目标串和模式串的开始位置（类似next数组的应用） 一直比到相等为止 KMP算法近似时间复杂度为O(n+m),其中O(n)表示比较的时间， O(m)表示计算next数组的时间. 若每轮中模式串与目标串之间的不匹配都发生在模式串的第一个字符处，则KMP算法会退化到朴素模式匹配算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;void get_next(char *t, int *next)&#123; int len = strlen(t + 1); int i = 1, j = 0; next[i] = j; // 数组第二个元素设为next数组第一个值 while (i &lt; len) &#123; if (j == 0 || t[i] == t[j])//j==0是用来设置第二个值；t[i] == t[j] 是比较后缀的单个字符与前缀的单个字符？ &#123; ++i; ++j; next[i] = j; &#125; else j = next[j]; &#125; for(int k=1;k&lt;=len;++k) cout&lt;&lt;next[k]&lt;&lt;\" \"; cout&lt;&lt;endl; return;&#125;void get_nextval(char *t, int *nextval)&#123; int i = 1, j = 0; nextval[1] = 0; int len = strlen(t + 1); while (i &lt; len) &#123; if (j == 0 || t[i] == t[j]) &#123; ++i; ++j; if (t[i] != t[j])//若当前字符与前缀字符不相等 nextval[i] = j;//则当前的j为nextval在i位置的值（即next[i]） else//若当前字符与前缀字符相等 nextval[i] = nextval[j];//则将前缀字符的nextval的值赋值给nextval[i],即nextval[i]=next[next[i]]; &#125; else j = nextval[j]; &#125; for(int k=1;k&lt;=len;k++) cout&lt;&lt;nextval[k]&lt;&lt;\" \"; cout&lt;&lt;endl;&#125;//返回子串t在主串s中第pos个字母后的位置int kmp_next(char *s, char *t, int pos)&#123; int next[105]; memset(next, 0, sizeof(next)); get_next(t, next); int i = pos; int j = 1; int len_s = strlen(s + 1); int len_t = strlen(t + 1); while (i &lt;= len_s &amp;&amp; j &lt;= len_t) &#123; if (j == 0 || s[i] == t[j]) &#123; ++i; ++j; &#125; else j = next[j]; &#125; if (j &gt; len_t)//表示t串匹配成功 return i - len_t; else return 0;&#125;int kmp_nextval(char *s, char *t, int pos)&#123; int nextval[105]; memset(nextval, 0, sizeof(nextval)); get_nextval(t, nextval); int i = pos; int j = 1; int len_s = strlen(s + 1); int len_t = strlen(t + 1); while (i &lt;= len_s &amp;&amp; j &lt;= len_t) &#123; if (j == 0 || s[i] == t[j]) &#123; ++i; ++j; &#125; else j = nextval[j]; &#125; if (j &gt; len_t) return i - len_t; else return 0;&#125;int main()&#123; char t[105], s[105]; int pos; scanf(\"%s%s%d\", s + 1, t + 1, &amp;pos); // 目标串，模式串，开始查找位置 printf(\"%d\\n\", kmp_next(s, t, pos)); printf(\"%d\\n\", kmp_nextval(s, t, pos)); system(\"pause\"); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://vergessenwang.github.io/categories/Algorithm/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://vergessenwang.github.io/tags/KMP/"}]},{"title":"Java第10章 泛型","slug":"Java第10章-泛型","date":"2019-11-07T12:19:35.000Z","updated":"2019-11-07T12:21:22.822Z","comments":true,"path":"posts/Java/2019-11-07-Java第10章-泛型.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2019-11-07-Java第10章-泛型.html","excerpt":"泛型的目的是为了实现类型的通用性，那为什么不用 Object 向上转型的方法呢？如果集合里面数据很多，某一个数据转型出现错误，在编译期是无法发现的。但是在运行期会发生java.lang.ClassCastException。泛型一方面让我们只能往集合中添加一种类型的数据，同时可以让我们在编译期就发现这些错误，避免运行时异常的发生，提升代码的健壮性。 Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数 对于泛型，只是允许程序员在编译时检测到非法的类型而已。但是在运行期时，其中的泛型标志会变化为 Object 类型。 泛型方法泛型方法既可以存在于泛型类中，也可以存在于普通的类中。如果使用泛型方法可以解决问题，那么应该尽量使用泛型方法。 定义泛型方法的规则： 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前 如 public static &lt; E &gt; void printArray( E[] inputArray ){} 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等） 123Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, 'a'); // compile-time errorPair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, 'a');Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(Integer.valueOf(8), new Character('a'));","text":"泛型的目的是为了实现类型的通用性，那为什么不用 Object 向上转型的方法呢？如果集合里面数据很多，某一个数据转型出现错误，在编译期是无法发现的。但是在运行期会发生java.lang.ClassCastException。泛型一方面让我们只能往集合中添加一种类型的数据，同时可以让我们在编译期就发现这些错误，避免运行时异常的发生，提升代码的健壮性。 Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数 对于泛型，只是允许程序员在编译时检测到非法的类型而已。但是在运行期时，其中的泛型标志会变化为 Object 类型。 泛型方法泛型方法既可以存在于泛型类中，也可以存在于普通的类中。如果使用泛型方法可以解决问题，那么应该尽量使用泛型方法。 定义泛型方法的规则： 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前 如 public static &lt; E &gt; void printArray( E[] inputArray ){} 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等） 123Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, 'a'); // compile-time errorPair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, 'a');Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(Integer.valueOf(8), new Character('a')); 不能实例化类型参数 1234public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;E elem = new E(); // compile-time errorlist.add(elem);&#125; 不能将静态成员的类型声明为类型参数 如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 不能创建类型参数数组 1List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2]; // compile-time error 类型参数不能进行catch、throw等异常处理 有界的类型参数: 限制被允许传递到一个类型参数的类型种类范围。要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。 如 public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z){} 泛型类泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。最典型的就是各种容器类，如：List、Set、Map。 例如： 1234567891011121314151617181920public class Box&lt;T&gt; &#123; private T t; public void add(T t) &#123; this.t = t; &#125; public T get() &#123; return t;&#125; //调用 Box&lt;Integer&gt; integerBox = new Box&lt;&gt;(); //右边尖括号无需再声明类型，因为编译器可以进行推断// 参数还可以是参数化类型 OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p = new OrderedPair&lt;&gt;(\"primes\", new Box&lt;Integer&gt;(...));// 没有实际参数是原生类型 Box rawBox1 = new Box();// 可以将参数化类型赋值给原生类型，但不能反过来 Box rawBox2 = integerBox; // ok Box&lt;Integer&gt; intBox = rawBox1; // error// 原生类型绕过了泛型类型检查，因此要避免使用 rawBox1.set(8); // warning: unchecked invocation to set(T) 泛型类最常用的使用场景就是“元组”的使用。我们知道方法return返回值只能返回单个对象。如果我们定义一个泛型类，定义2个甚至3个类型参数，这样我们return对象的时候，构建这样一个“元组”数据，通过泛型传入多个对象，这样我们就可以一次性方法多个数据了。 泛型接口定义： 123public interface Generator&lt;T&gt; &#123; public T next();&#125; 泛型接口未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中。 123456class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125; 如果泛型接口传入类型参数时，实现该泛型接口的实现类，则所有使用泛型的地方都要替换成传入的实参类型。 123456class DataHolder implements Generator&lt;String&gt;&#123; @Override public String next() &#123; return null; &#125;&#125; 泛型类或接口可以被继承，如： interface PayloadList&lt;E,P&gt; extends List&lt;E&gt; { } 类型通配符容器中的类型之间存在继承关系，但是两个容器之间是不存在继承关系的。因此需要用到通配符? The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return typeThe wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype 类型通配符一般是使用?代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是List,List 等所有List&lt;具体类型实参&gt;的父类 。无界通配符 意味着可以使用任何对象，因此使用它类似于使用原生类型。原生类型可以持有任何类型，而无界通配符修饰的容器持有的是某种具体的类型。此处’？’是类型实参，而不是类型形参 。 如 public static void getData(List&lt;?&gt; data) {} 含通配符上限, 用 extends，如 public static void getUperNumber(List&lt;? extends Number&gt; data) {} 如此定义就是通配符泛型值接受Number及其下层子类类型。但是set() 方法会失效—— 可能是类型擦除的原因？get()方法仍可用，可能是因为获取出来的我们都可以隐式的转为其基类（或者Object基类）。所以上界描述符Extends适合频繁读取的场景。 多通配：&lt;T extends B1 &amp; B2 &amp; B3&gt; 类要在接口的前面 通配符下限, 用 super ， 如 List&lt;? super Number&gt; 表示类型只能接受Number及其三层父类类型，如 Object 类型的实例 下界通配符&lt;? super T&gt;不影响往里面存储，但是读取出来的数据只能是Object类型。原因是：下界通配符规定了元素最小的粒度，必须是T及其基类，那么我往里面存储T及其派生类都是可以的，因为它都可以隐式的转化为T类型。但是往外读就不好控制了，里面存储的都是T及其基类，无法转型为任何一种类型，只有Object基类才能装下。 PECS原则 上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。 下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。 泛型擦除Java语言泛型在设计的时候为了兼容原来的旧代码，Java的泛型机制使用了“擦除”机制。 编译器虽然会在编译过程中移除参数的类型信息，但是会保证类或方法内部参数类型的一致性。泛型参数将会被擦除到它的第一个边界（边界可以有多个，重用 extends 关键字，通过它能给与参数类型添加一个边界）。在运行过程中，编译器事实上会把类型参数替换为它的第一个边界的类型。如果没有指明边界，那么类型参数将被擦除到Object。最后需要写入时，编译器会进行一次类型转换 12345Class&lt;?&gt; class1=new ArrayList&lt;String&gt;().getClass();Class&lt;?&gt; class2=new ArrayList&lt;Integer&gt;().getClass();System.out.println(class1); //class java.util.ArrayListSystem.out.println(class2); //class java.util.ArrayListSystem.out.println(class1.equals(class2)); //true 由以上例子可以看出，Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 泛型类型不能显式地运用在运行时类型的操作当中，例如：转型、instanceof 和 new。因为在运行时，所有参数的类型信息都丢失了。 解决办法 命名传统• E - Element (used extensively by the Java Collections Framework)• K - Key• N - Number• T - Type• V - Value• S,U,V etc. - 2nd, 3rd, 4th types","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"泛型","slug":"泛型","permalink":"http://vergessenwang.github.io/tags/泛型/"},{"name":"通配符","slug":"通配符","permalink":"http://vergessenwang.github.io/tags/通配符/"}]},{"title":"高网第5章 IP交付与路由","slug":"高网第5章-IP交付与路由","date":"2019-11-06T15:09:26.000Z","updated":"2019-11-06T15:11:12.674Z","comments":true,"path":"posts/network/2019-11-06-高网第5章-IP交付与路由.html","link":"","permalink":"http://vergessenwang.github.io/posts/network/2019-11-06-高网第5章-IP交付与路由.html","excerpt":"网络层本质上一个软件包 —— 所以对我们来说，网络并不是完全抽象的 在异构的网络中，通信能力、分组长度限制和时延都是不一样的，所以采用面向连接的方式比较困难—— IP协议，无连接，尽最大努力交付，适合异构网络互连 对于路由器而言，其功能由于采用end - to - end 原则而被简化，只能尽最大努力交付，只关注与它相邻的路由 —— 进步空间：更多跳的路由 交付(delivery)——物理层和链路层 用分组目的IP地址查路由表 Forwarding : 目的IP &amp; 路由表项的掩码 ==？ 路由表项的IP地址 找出匹配项中下一跳IP地址的物理地址：下一跳IP地址–&gt; ARP –&gt; 目的物理地址 ARP： 将IP与MAC地址进行绑定，完成从网络层到链路层的切换 将IP分组和目的物理地址一起交给链路层 一次交付过程包含0或多个间接交付+1个直接交付（最后的交付） 分组:（源IP地址，目的IP地址）保持不变 帧:（源物理地址，目的物理地址）逐跳改变 通过上面的两种地址，解决了网关IP和目的IP冲突的问题","text":"网络层本质上一个软件包 —— 所以对我们来说，网络并不是完全抽象的 在异构的网络中，通信能力、分组长度限制和时延都是不一样的，所以采用面向连接的方式比较困难—— IP协议，无连接，尽最大努力交付，适合异构网络互连 对于路由器而言，其功能由于采用end - to - end 原则而被简化，只能尽最大努力交付，只关注与它相邻的路由 —— 进步空间：更多跳的路由 交付(delivery)——物理层和链路层 用分组目的IP地址查路由表 Forwarding : 目的IP &amp; 路由表项的掩码 ==？ 路由表项的IP地址 找出匹配项中下一跳IP地址的物理地址：下一跳IP地址–&gt; ARP –&gt; 目的物理地址 ARP： 将IP与MAC地址进行绑定，完成从网络层到链路层的切换 将IP分组和目的物理地址一起交给链路层 一次交付过程包含0或多个间接交付+1个直接交付（最后的交付） 分组:（源IP地址，目的IP地址）保持不变 帧:（源物理地址，目的物理地址）逐跳改变 通过上面的两种地址，解决了网关IP和目的IP冲突的问题 转发(forwording)设计原则：使用尽可能少的信息实现转发 子网作为路由表项：节约路由表的存储空间，提高查表效率 还可进一步路由聚合，同时实现了隐藏网络结构的作用，自主管理网络边界使用路由器与外界相连，在不改变原有IP地址范围的条件下，网络内部任意划分子网、改变拓扑结构等，都不会影响外部的路由器选路表项 —— 应用：ISP分级路由，对于ISP 运营商来说便于管理，对于用户来说有了一个IP池可以动态分配IP 只路由到下一跳：简化路由表，每个路由器独立选路 问题：只有最后一个路由器才知道目的主机是否存在，可能造成网络震荡 —— 解决：TTL，限制生存时间 默认路由：目的IP和掩码为全0——减少占用空间，交给功能更强的路由器(可能出现路由环路，如两个路由器分别设置对方为默认路由器)，还有出于安全考虑隐藏路径的作用 特殊主机路由：使用完整IP地址作为表项，出于安全性、时延等需求—— 由此可见，特殊的需求可能违背最初的设计原则 匹配方式 分类地址可能有A、B、C类多个转发表；无分类，直连 –&gt; 非直连最长匹配 对于P2P网络：如果被指派了IP地址，那么在路由表中有表项；如果采用unnumbered P2P line编址方案，则不是IP网络，不在路由表中 NAT10.10…. 192.168… 是只在局域网使用的特殊地址 例如，科大的网站都是219.219…. 这些网站在子网内部会有一个虚拟端口 ，用于区别不同的主机 ，数据报到达局域网后会重新打包，加上主机的真正端口 —— 这些网站对外会映射为同一IP, 通过虚拟端口号来进行区分 其他之前还有一个QoS协议，用特殊的bit位来标识报文优先级，但是如果每个用户都对该位置进行设置的话，其实是无用的 笔记本无线网卡的两种模式 infrastructure Ad-hoc 可以提供自助路由功能","categories":[{"name":"network","slug":"network","permalink":"http://vergessenwang.github.io/categories/network/"}],"tags":[{"name":"IP","slug":"IP","permalink":"http://vergessenwang.github.io/tags/IP/"},{"name":"路由","slug":"路由","permalink":"http://vergessenwang.github.io/tags/路由/"}]},{"title":"Java第9章 异常处理","slug":"Java第9章-异常处理","date":"2019-11-05T15:22:54.000Z","updated":"2019-11-05T15:24:30.755Z","comments":true,"path":"posts/Java/2019-11-05-Java第9章-异常处理.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2019-11-05-Java第9章-异常处理.html","excerpt":"Java的异常处理本质上是抛出异常(创建异常对象，交给运行系统处理)和捕获异常。—— 针对可恢复异常 调用栈：main –&gt; method with an exception handler –&gt; method without an exception handler –&gt; method where error occurred 当错误发生时(异常抛出)，会被反向传递至类型匹配的 exception handler 进行处理(捕获异常), 无法捕获将终止程序 使用异常处理的好处：将正常代码与错误处理代码分离开；通过调用栈传递错误对象；对错误类型进行组织和区分 异常分类三种类型的异常： 检查性异常(编译异常)：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。—— IOException， 常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等 运行时异常： 这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，但是程序员也可以根据需要进行捕获抛出。Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。—— RuntimeException，常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等。 错误： 是指程序无法处理的错误，由 Java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。例如jvm运行时出现的OutOfMemoryError以及Socket编程时出现的端口占用等程序无法处理的错误。—— Error","text":"Java的异常处理本质上是抛出异常(创建异常对象，交给运行系统处理)和捕获异常。—— 针对可恢复异常 调用栈：main –&gt; method with an exception handler –&gt; method without an exception handler –&gt; method where error occurred 当错误发生时(异常抛出)，会被反向传递至类型匹配的 exception handler 进行处理(捕获异常), 无法捕获将终止程序 使用异常处理的好处：将正常代码与错误处理代码分离开；通过调用栈传递错误对象；对错误类型进行组织和区分 异常分类三种类型的异常： 检查性异常(编译异常)：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。—— IOException， 常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等 运行时异常： 这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，但是程序员也可以根据需要进行捕获抛出。Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。—— RuntimeException，常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等。 错误： 是指程序无法处理的错误，由 Java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。例如jvm运行时出现的OutOfMemoryError以及Socket编程时出现的端口占用等程序无法处理的错误。—— Error 异常体系结构 把人绕晕的几个名词： 检查性异常: 不处理编译不能通过—— 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于检查异常，当程序中可能出现这类异常，要么使用try-catch语句进行捕获，要么用throws子句抛出，否则编译无法通过。 非检查性异常:不处理编译可以通过，如果有抛出直接抛到控制台 运行时异常: 就是非检查性异常 非运行时异常: 就是检查性异常 内置异常类 try-catch-fianllyfinally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。finally 是防止资源泄露的有效工具 try…catch…; try….finally……; try….catch…finally… catch块可以有多个，注意try块只能有一个,finally块是可选的。在有多个catch块的时候，是按照catch块的先后顺序进行匹配的，一旦异常类型被一个catch块匹配，则不会与后面的catch块进行匹配。 catch 不能独立于 try 存在 try语句可以被嵌套, 每次进入try语句，异常的前后关系都会被推入堆栈 在 try/catch 后面添加 finally 块并非强制性要求的。 try 代码后不能既没 catch 块也没 finally 块。 try, catch, finally 块之间不能添加任何代码 try…catch…. 捕获异常时，大的异常(Exception类)放在下方，小的异常放在上方，否则，在异常捕获时，小的异常将不能被捕获，因为全在大的异常类中捕获到。 一个典型的例子： 123456789try&#123; //待捕获代码 &#125;catch（Exception e）&#123; System.out.println(\"catch is begin\"); return 1 ；&#125;finally&#123; System.out.println(\"finally is begin\"); return 2 ;&#125; 以上代码会返回2，catch中的return语句会被跳过，所以注意千万不要在finally块中使用return 但是也有特殊：finally不一定被执行，例如 catch 块中有退出系统的语句 System.exit(-1); finally就不会被执行 throw跟throws的区别如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。 123public void test() throws Exception &#123; throw new Exception();&#125; throws表示一个方法声明可能抛出一个异常，throw表示此处抛出一个已定义的异常（可以是自定义需继承Exception，也可以是java自己给出的异常类）。用throw手动抛出一个异常对象 throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由方法去处理异常，真正的处理异常由此方法的上层调用处理。 如果是不受检查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。必须声明方法可抛出的任何检查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误 自定义异常在 Java 中你可以自定义异常。 所有异常都必须是 Throwable 的子类。 如果希望写一个检查性异常类，则需要继承 Exception 类。—— 一般情况下不自定义检查异常。 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类 自定义异常并使用： 1234567891011121314151617181920212223242526class MyException extends Exception &#123; private int detail; MyException(int a)&#123; detail = a; &#125; public String toString()&#123; return \"MyException [\"+ detail + \"]\"; &#125;&#125;public class TestMyException&#123; static void compute(int a) throws MyException&#123; System.out.println(\"Called compute(\" + a + \")\"); if(a &gt; 10)&#123; throw new MyException(a); &#125; System.out.println(\"Normal exit!\"); &#125; public static void main(String [] args)&#123; try&#123; compute(1); compute(20); &#125;catch(MyException me)&#123; System.out.println(\"Caught \" + me); &#125; &#125;&#125; 有些程序员认为检查异常是程序里的瑕疵，试图通过非检查异常来绕过，并不推荐这种做法。 方法覆盖在当前方法被覆盖时，覆盖他的方法必须抛出相同的异常或异常的子类 父类的方法没有声明异常，子类在重写该方法的时候不能声明异常； 如果父类的方法声明一个异常exception1，则子类在重写该方法的时候声明的异常不能是exception1的父类； 如果父类的方法声明的异常类型只有非运行时异常（运行时异常），则子类在重写该方法的时候声明的异常也只能有非运行时异常（运行时异常），不能含有运行时异常（非运行时异常 一篇详细的文章","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"异常","slug":"异常","permalink":"http://vergessenwang.github.io/tags/异常/"}]},{"title":"NLP预处理语言模型演进","slug":"NLP预处理语言模型演进","date":"2019-11-03T14:36:12.000Z","updated":"2019-11-03T14:46:26.504Z","comments":true,"path":"posts/NLP/2019-11-03-NLP预处理语言模型演进.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-11-03-NLP预处理语言模型演进.html","excerpt":"在进行核心步骤关系抽取之前，还需要经历一系列基础的NLP处理环节。 模型的预训练最初被用在图像和视频领域的深度学习中，能有效解决训练数据少的问题，同时还能极大加快任务训练的收敛速度。经过预处理后的数据再用于下游的分词、命名实体识别等任务时可以取得更好的效果。 语言模型是一串词序列的概率分布。具体来说，语言模型的作用是为一个长度为m的文本确定一个概率分布P，表示这段文本存在的可能性。在实践中，如果文本的长度较长，P(wi | w1, w2, . . . , wi−1)的估算会非常困难。因此，研究者们提出使用一个简化模型：n元模型（n-gram model）。在n元模型中，传统的方法一般采用频率计数的比例来估算n元条件概率。当n较大时，机会存在数据稀疏问题，导致估算结果不准确。为了缓解n元模型估算概率时遇到的数据稀疏问题，Bengio在2003年提出了神经网络语言模型（NLM），是为Word Embedding的想法的雏形。 Word Embedding作为NLP里的早期预训练技术，词嵌入（Word Embedding）或者分布式向量（Distributional Vectors）是将自然语言表示的单词转换为计算机能够理解的向量或矩阵形式的技术。有了一个词的向量之后，各种基于向量的计算就可以实施，如用向量之间的相似度来度量词之间的语义相关性。其基于的分布式假设就是出现在相同上下文的词意思应该相近。Word Embedding也有其局限性，比如：难以对词组做分布式表达；无法解决多义词问题，这对情感分析任务的影响非常大。此外，Word Embedding对于应用场景的依赖很强，所以针对特殊的应用场景可能需要重新训练，这样就会很消耗时间和资源。","text":"在进行核心步骤关系抽取之前，还需要经历一系列基础的NLP处理环节。 模型的预训练最初被用在图像和视频领域的深度学习中，能有效解决训练数据少的问题，同时还能极大加快任务训练的收敛速度。经过预处理后的数据再用于下游的分词、命名实体识别等任务时可以取得更好的效果。 语言模型是一串词序列的概率分布。具体来说，语言模型的作用是为一个长度为m的文本确定一个概率分布P，表示这段文本存在的可能性。在实践中，如果文本的长度较长，P(wi | w1, w2, . . . , wi−1)的估算会非常困难。因此，研究者们提出使用一个简化模型：n元模型（n-gram model）。在n元模型中，传统的方法一般采用频率计数的比例来估算n元条件概率。当n较大时，机会存在数据稀疏问题，导致估算结果不准确。为了缓解n元模型估算概率时遇到的数据稀疏问题，Bengio在2003年提出了神经网络语言模型（NLM），是为Word Embedding的想法的雏形。 Word Embedding作为NLP里的早期预训练技术，词嵌入（Word Embedding）或者分布式向量（Distributional Vectors）是将自然语言表示的单词转换为计算机能够理解的向量或矩阵形式的技术。有了一个词的向量之后，各种基于向量的计算就可以实施，如用向量之间的相似度来度量词之间的语义相关性。其基于的分布式假设就是出现在相同上下文的词意思应该相近。Word Embedding也有其局限性，比如：难以对词组做分布式表达；无法解决多义词问题，这对情感分析任务的影响非常大。此外，Word Embedding对于应用场景的依赖很强，所以针对特殊的应用场景可能需要重新训练，这样就会很消耗时间和资源。 ELMo Word Embedding本质上是个静态的方式，即训练完了单词的表达就固定了，不会跟着上下文场景的变化而改变。为了解决这个问题，出现了ELMO（Embedding from Language Models）的训练方案。ELMO采用了典型的两阶段过程，第一个阶段是利用语言模型进行预训练；第二个阶段是在做下游任务时，从预训练网络中提取对应单词的网络各层的Word Embedding作为新特征补充到下游任务中。通过加入双层双向的LSTM网络结构，ELMo引入上下文动态调整单词的embedding后，多义词问题得到了解决。但是ELMo的缺点在将LSTM作为特征抽取器时抽取能力不够强。 GPT除了以ELMo为代表的这种基于特征融合的预训练方法外，NLP里还有一种典型做法，称为“基于Fine-tuning的模式”，而GPT就是这一模式的典型开创者，用到了目前NLP里最强的特征提取器Transformer。Transformer 是谷歌大脑在2017年底发表的论文 attention is all you need中所提出来的seq2seq模型，是一个叠加的自注意力机制（Self Attention）构成的深度网络。相比于LSTM的迭代训练，Transformer的训练是并行的，使用了位置嵌入来理解语言的顺序，使用自注意力机制和全连接层来进行计算。 GPT（Generative Pre-Training）是指生成式的预训练，也采用两阶段过程，第一个阶段是利用语言模型进行预训练，第二阶段通过Fine-tuning的模式解决下游任务。GPT的预训练虽然仍然是以语言模型作为目标任务，但是采用的是单向的语言模型，这限制了其在更多应用场景的效果，比如阅读理解这种任务。 BERT针对GPT单向模型的限制，出现了被大为追捧的BERT模型。BERT模型的全称是双向transformer编码表达，BERT采用和GPT完全相同的两阶段模型，首先是语言模型预训练；其次是使用Fine-Tuning模式解决下游任务。和GPT的最主要不同在于在预训练阶段采用了类似ELMO的双向语言模型，当然另外一点是语言模型的数据规模要比GPT大。BERT最大优势在于，可以对具体任务进行特征步充，因此几乎可以做任何NLP的下游任务，具备很强的普适性。 参见之前写的 参考链接1 参考链接2","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"Word Embedding","slug":"Word-Embedding","permalink":"http://vergessenwang.github.io/tags/Word-Embedding/"},{"name":"BERT","slug":"BERT","permalink":"http://vergessenwang.github.io/tags/BERT/"}]},{"title":"NLTK+LTP进行中文处理","slug":"NLTK-LTP进行中文处理","date":"2019-11-02T01:08:09.000Z","updated":"2019-11-02T01:09:36.905Z","comments":true,"path":"posts/NLP/2019-11-02-NLTK-LTP进行中文处理.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-11-02-NLTK-LTP进行中文处理.html","excerpt":"安装NLTKNLTK是一个NLP工作平台，可以和一些NLP库配合使用。 激活虚拟环境，因为原本已经安装了 pyltp ，不想再开新的环境了… 继续安装： 1234pip install numpyconda install scipypip install Tornadopip install nltk 前两个是高性能数学计算软件包，第三个是网络包 作为一个非洲人，果然安装nltk的过程并不顺利 报错信息： 12Could not find a version that satisfies the requirement nltk (from versions: )No matching distribution found for nltk 切换成 conda 命令，居然好了…本非颇为不适","text":"安装NLTKNLTK是一个NLP工作平台，可以和一些NLP库配合使用。 激活虚拟环境，因为原本已经安装了 pyltp ，不想再开新的环境了… 继续安装： 1234pip install numpyconda install scipypip install Tornadopip install nltk 前两个是高性能数学计算软件包，第三个是网络包 作为一个非洲人，果然安装nltk的过程并不顺利 报错信息： 12Could not find a version that satisfies the requirement nltk (from versions: )No matching distribution found for nltk 切换成 conda 命令，居然好了…本非颇为不适 在pycharm新建一个项目，指定解释器，新建py文件，执行如下代码： 1234567import sysimport osimport nltkfrom importlib import reloadreload(sys)nltk.download() 然后出现了 WinError10060错误 ，血统纯正。 只能手动下数据包了，git地址 后面的过程老是导入出错，卡了好久，把网上所有的方法试了一遍，最后居然是因为。。没有重启pycharm试试，之前一直在解释器中运行的，后来用脚本就可以了。也不知道是重启还是脚本的原因，反正数据本身是没有问题的，如果导入出错，一定是路径设置的不对！ 把packages中的文件解压，文件件重命名为nltk_data , 放在C 盘根目录下…是的，就是这么粗暴… 设置用户变量NLTK_DATA C:\\nltk_data 运行脚本 123import nltknltk.data.find('C:\\\\') # 设置路径from nltk.book import * 解决方法参考 导入LTP语言处理模型之前已经安装过pyltp自然语言处理库, 这里只需要导入模型。 安装可参看之前写的 在ltp模型 下载v3.4.0.zip版本, 在KGQA目录下，修改ltp.py里的ltp模型文件的存放目录 分词实现用的是CRF模型 测试代码 1234567891011121314import sysimport osfrom importlib import reloadfrom pyltp import Segmentorreload(sys)model_path = \"C:\\\\Users\\\\18771\\\\Desktop\\\\data\\\\ltp_data_v3.4.0\\\\cws.model\"segmentor = Segmentor() # 实例化分词模块segmentor.load(model_path) # 加载分词库words = segmentor.segment(\"晚秋的哀牢山宛如一个成熟的睡美人，轻柔的晨风从身边掠过，拂遍林海奇峰，挽起霞霭，任南迁的候鸟洗礼，猿啸与松涛齐鸣，青山共斜阳万里。\")print(\"|\".join(words)) 输出结果 1晚秋|的|哀牢山|宛如|一个|成熟|的|睡美人|，|轻柔|的|晨风|从|身边|掠过|，|拂|遍|林海|奇峰|，|挽|起|霞霭|，|任|南迁|的|候鸟|洗礼|，|猿啸|与|松涛|齐鸣|，|青山|共|斜阳|万|里|。 词性标注及命名实体识别词性标注依旧用的是CRF算法，遵从北大词性标注规范。 测试代码 12345678910111213141516171819202122import sysimport osfrom importlib import reloadfrom pyltp import *reload(sys)sent = \"晚秋|的|哀牢山|宛如|一个|成熟|的|睡美人|，|轻柔|的|晨风|从|身边|掠过|，|拂|遍|林海|奇峰|，|挽|起|霞霭|，|任|南迁|的|候鸟|洗礼|，|猿啸|与|松涛|齐鸣|，|青山|共|斜阳|万|里|。\"model_path = \"C:\\\\Users\\\\18771\\\\Desktop\\\\data\\\\ltp_data_v3.4.0\\\\pos.model\"model_path2 = \"C:\\\\Users\\\\18771\\\\Desktop\\\\data\\\\ltp_data_v3.4.0\\\\ner.model\"words = sent.split(\"|\")postagger = Postagger() # 实例化词性标注类postagger.load(model_path)postags = postagger.postag(words)recongnizer = NamedEntityRecognizer() # 实例化命名实体识别类recongnizer.load(model_path2)netags = recongnizer.recognize(words,postags)for word,postag,netag in zip(words,postags,netags): print(word+\"/\"+postag + \"/\" + netag) 识别出： 1哀牢山/ns/S-Ns 依存句法树结合使用NLTK和LTP可以构造依存句法树 测试代码 12345678910111213141516171819202122232425262728293031323334import sysimport osfrom importlib import reloadfrom pyltp import *import nltkfrom nltk.tree import Tree # 导入nltk treefrom nltk.grammar import DependencyGrammar # 导入依存句法包from nltk.parse import *import rereload(sys)words = \"苏州 的 拙政园 是 旅游胜地 。\".split(\" \")model_path = \"C:\\\\Users\\\\18771\\\\Desktop\\\\data\\\\ltp_data_v3.4.0\\\\pos.model\"model_path2 = \"C:\\\\Users\\\\18771\\\\Desktop\\\\data\\\\ltp_data_v3.4.0\\\\parser.model\"postagger = Postagger() # 实例化词性标注类postagger.load(model_path)postags = postagger.postag(words)parser = Parser() # 将词性标注和分词结果都加入分析器进行句法解析parser.load(model_path2)arcs = parser.parse(words,postags)arclen = len(arcs)conll = \"\"for i in range(arclen): # 构建conll标准数据结构 if arcs[i].head == 0: arcs[i].relation = 'ROOT' conll += \"\\t\" + words[i] + \"(\" + postags[i] + \")\" + \"\\t\" + postags[i] + \"\\t\" + str(arcs[i].head) + \"\\t\" + arcs[i].relation + \"\\n\"print(conll)conlltree = DependencyGraph(conll) # 转换为依存句法图tree = conlltree.tree() # 构建树结构tree.draw() # 显示输出的树 会在NLTK中输出一个依存树的图，我就不贴图了。。不会传图。。","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"NLTK","slug":"NLTK","permalink":"http://vergessenwang.github.io/tags/NLTK/"},{"name":"LTP","slug":"LTP","permalink":"http://vergessenwang.github.io/tags/LTP/"}]},{"title":"遥远的BERT模型...","slug":"遥远的BERT模型","date":"2019-11-01T01:22:22.000Z","updated":"2019-11-01T01:23:45.168Z","comments":true,"path":"posts/NLP/2019-11-01-遥远的BERT模型.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-11-01-遥远的BERT模型.html","excerpt":"Transformer 是谷歌大脑在2017年底发表的论文 attention is all you need 文章解读 中所提出来的seq2seq模型，BERT就是从transformer 中衍生出来的预训练语言模型。 现在很多处理效果非常好的模型，都融合了BERT , 模型排名 transformer原理相比于LSTM的迭代训练，transformer的训练是并行的，使用了位置嵌入来理解语言的顺序，使用自注意力机制和全连接层来进行计算。 主要分为两部分： 编码器：把自然语言序列映射成隐藏层的数学表达 字向量与位置嵌入：由于没有迭代计算需要提供每个字的位置信息，从而让模型学到位置之间的依赖关系和自然语言的时序特征 自注意力机制：求词向量的点积，即余弦距离，最后得到 N * N 注意力矩阵，第 i 行表示第 i 个字 与 每一个字的相关程度，沿着最后一个维度做softmax归一化，是概率之和为1形成概率分布。 注意力矩阵的作用就是得到一个权重的概率分布，然后用其点乘词向量，就可以得到加权后的线性组合，使得每个字向量都含有当前句子内所有字向量的信息 残差连接：避免梯度消失 归一化：把隐藏层归一为标准正态分布，加速收敛 前馈：进行两层线性映射并用激活函数激活；然后重复3、4 解码器：把隐藏层映射为自然语言序列，用于下游的命名实体识别、语义关系抽取、摘要生成、情感分类等","text":"Transformer 是谷歌大脑在2017年底发表的论文 attention is all you need 文章解读 中所提出来的seq2seq模型，BERT就是从transformer 中衍生出来的预训练语言模型。 现在很多处理效果非常好的模型，都融合了BERT , 模型排名 transformer原理相比于LSTM的迭代训练，transformer的训练是并行的，使用了位置嵌入来理解语言的顺序，使用自注意力机制和全连接层来进行计算。 主要分为两部分： 编码器：把自然语言序列映射成隐藏层的数学表达 字向量与位置嵌入：由于没有迭代计算需要提供每个字的位置信息，从而让模型学到位置之间的依赖关系和自然语言的时序特征 自注意力机制：求词向量的点积，即余弦距离，最后得到 N * N 注意力矩阵，第 i 行表示第 i 个字 与 每一个字的相关程度，沿着最后一个维度做softmax归一化，是概率之和为1形成概率分布。 注意力矩阵的作用就是得到一个权重的概率分布，然后用其点乘词向量，就可以得到加权后的线性组合，使得每个字向量都含有当前句子内所有字向量的信息 残差连接：避免梯度消失 归一化：把隐藏层归一为标准正态分布，加速收敛 前馈：进行两层线性映射并用激活函数激活；然后重复3、4 解码器：把隐藏层映射为自然语言序列，用于下游的命名实体识别、语义关系抽取、摘要生成、情感分类等 BERT语言模型就是用来求一个句子出现的概率 BERT模型的全称是双向transformer编码表达。 只用到了编码器的部分，在每句话的句头添加一个特殊字符，让句子中的所有信息向这个字符汇总，就可以根据这个字符的hidden state 完成一些分类。 训练： MASKED LM : 随机遮盖或替换任意字词，让模型通过上下文的理解预测，做Loss时只计算被遮盖部分的Loss Next Sentence Prediction : 在句子中加特殊符号判断是否上下文相关，实际是一个分类问题 参数： 看到作者这句 但是经过我的实际测试, 结合我目前正在研究的命名实体识别, 语义分析, 关系抽取和知识图谱的需求, 发现其实这个参数比较过剩, 把参数缩减到2千万, 但即使这样, 使用一块11GB显存的2080Ti显卡, 训练维基百科语料的BERT也需要一周的时间 2千万。。。一周。。。11GB显存。。。感觉可以告辞了呢。。。 在数据集不够的情况下，使用BERT这种参数这么多的模型，训练会产生严重过拟合，泛化能力差的情况 就我们的项目而言，在现有条件下，基本可以告别这种方法了吧。。。 序列模型的深度学习建议使用PyTorch","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"BERT","slug":"BERT","permalink":"http://vergessenwang.github.io/tags/BERT/"},{"name":"Transformer","slug":"Transformer","permalink":"http://vergessenwang.github.io/tags/Transformer/"}]},{"title":"HMM与Viterbi算法","slug":"HMM与Viterbi算法","date":"2019-10-30T16:17:44.000Z","updated":"2019-10-30T16:25:30.761Z","comments":true,"path":"posts/NLP/2019-10-31-HMM与Viterbi算法.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-31-HMM与Viterbi算法.html","excerpt":"HMM作为一个生成式概率图模型，可以被用来处理序列标注的问题，如分词、词性标注，以及命名实体标注。 它把分词问题转为字的分类问题(序列标注问题)——由字构词，不依赖事先编制好的词表，但仍然需要分好词的训练语料 ，单字S，开始B-中间M-结尾E ， 已知观察序列求对应的形式化序列 HMM描述的是一个从 隐状态序列(如实体标记，所属集合是N种标签) 生成 可观测结果(如可读文本，所属集合是M个汉字) 的过程 第一假设是第 t 个时刻的隐状态只跟前一时刻 t - 1 时刻的隐状态有关，计算一个转移概率 —— N * N 的转移概率矩阵 第二个假设是观测独立，任意时刻观测 $o_t$ 只依赖 当前时刻的 隐状态 $i_t$, 计算一个发射概率—— N * M 的发射概率矩阵","text":"HMM作为一个生成式概率图模型，可以被用来处理序列标注的问题，如分词、词性标注，以及命名实体标注。 它把分词问题转为字的分类问题(序列标注问题)——由字构词，不依赖事先编制好的词表，但仍然需要分好词的训练语料 ，单字S，开始B-中间M-结尾E ， 已知观察序列求对应的形式化序列 HMM描述的是一个从 隐状态序列(如实体标记，所属集合是N种标签) 生成 可观测结果(如可读文本，所属集合是M个汉字) 的过程 第一假设是第 t 个时刻的隐状态只跟前一时刻 t - 1 时刻的隐状态有关，计算一个转移概率 —— N * N 的转移概率矩阵 第二个假设是观测独立，任意时刻观测 $o_t$ 只依赖 当前时刻的 隐状态 $i_t$, 计算一个发射概率—— N * M 的发射概率矩阵 那么如何用HMM来解决序列标注问题呢？ 首先是通过监督学习的方式获取参数，即首先有一些文本和标注对应的现有数据，然后训练一个HMM来拟合这些数据。最简单的方式是直接用极大似然估计来估计参数 假设我们已经通过建模学习到了初始概率、转移概率和发射概率这三大参数，就可以通过文本倒推出标记。 很显然，从HMM的假设和计算过程可以看出，求得的只是当前时刻的最优标注，不一定能得出全局最优序列路径 —— 解决： 维特比算法 维特比算法使用了动态规划算法来解决类似HMM和CRF的预测问题，找到概率最大路径，即文本处理中最优的实体标注序列。 它的简单原理可理解为：在每一个时刻，计算当前时刻落在每种隐状态的最大概率，并记录这个最大概率是从前一时刻哪一个隐状态转移过来的，最后再从结尾达到最大概率的那个隐状态回溯，就可以得到最有可能的最优路径。 有两个 N * M 的矩阵，第一个行 i 表示隐状态，列 j 表示时刻，矩阵单元表示第 j 时刻落到隐状态 i 的最大可能概率；第二个矩阵记录的是这个最大可能概率是从第 i - 1 时刻的哪一个隐状态 i 转移过来的， 即 最大可能概率的转移路径 关键在于计算最大可能概率。需要用到第一个矩阵，与HMM中的另外三个矩阵进行运算获得。 最优路径：假设有一条最优路径在 t 时刻通过一个隐状态 $i_t$ , 那么从 $i_t$ 到最优路径终点 $i_T$ 相对于 这段距离里所有可能出现的路径，也必须是最优的。 因此：从最后一步达到的最大概率的隐状态，根据第二个矩阵记录的转移状态向前回溯至第一时刻，就可以找到最优路径了。由此可以看出，第一个矩阵只用到了最后一列，在实际中可以用不断覆盖的方式的减少存储占用。 很显然，相对于HMM，Viterbi算法增加了一个时刻的概念，我的理解是这样其实是在求平均值…所以算法的复杂度为 $O(TN^2)$ 在实际的预测中，为了防止计算结果的下溢，将乘法变为取对数之后的加法 学习来源及git源码","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"HMM","slug":"HMM","permalink":"http://vergessenwang.github.io/tags/HMM/"},{"name":"Viterbi算法","slug":"Viterbi算法","permalink":"http://vergessenwang.github.io/tags/Viterbi算法/"}]},{"title":"KG子任务划分","slug":"KG子任务划分","date":"2019-10-30T08:32:26.000Z","updated":"2019-10-30T08:33:40.318Z","comments":true,"path":"posts/NLP/2019-10-30-KG子任务划分.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-30-KG子任务划分.html","excerpt":"首先我们需要考虑的是目前的搜索存在的问题。 当我们打开一个搜索引擎的时候，目前其实是想得到答案。然而，现在的互联网是一个基于HTML的网页结构以及相互直接通过URL相互链接。这种链接中有太多的无用信息，在其中寻找所需的信息往往是一个费时费力的过程。基于知识图谱的问答或搜索系统，可以从一定程度上解决这个问题。 KG的本质 Web角度：像建立文本之间的超链接一样建立数据之间的语义链接，并支持语义搜索 NLP视角：怎样从文本中抽取语义和结构化数据 KR视角：怎样利用计算机符号来表示和处理知识 AI视角：怎样利用知识库来辅助理解人的语言 DB视角：用图的方式去存储知识 传统KE的问题传统知识工程在规则明确、边界清晰、应用封闭的应用场景取得了巨大成功。缺点是体系是自上而下的：严重依赖专家和人的干预 。 解决方式：大规模自动知识获取 。基于大数据、ML，充分利用现代计算机的强大算力，从大量数据中自动进行信息挖掘。 这种数据驱动的知识获取是自下而上的，以维基百科页面内容为例： graph LR A[Wikipedia] -->B(预处理器 schema定义训练数据构造) B --> C{是否分类} C -->|未分类| D[分类器文本,句法分类] C -->|已分类| E[抽取器CRFmodel] D --> E E --> F[infobox] 以其为基础建立的数据库有：YAGO、 CN-DBpedia(以后仔细学习下API)等 知识图谱富含实体、概念(is)、属性(has)、关系等信息。以RDF或图的形式存储","text":"首先我们需要考虑的是目前的搜索存在的问题。 当我们打开一个搜索引擎的时候，目前其实是想得到答案。然而，现在的互联网是一个基于HTML的网页结构以及相互直接通过URL相互链接。这种链接中有太多的无用信息，在其中寻找所需的信息往往是一个费时费力的过程。基于知识图谱的问答或搜索系统，可以从一定程度上解决这个问题。 KG的本质 Web角度：像建立文本之间的超链接一样建立数据之间的语义链接，并支持语义搜索 NLP视角：怎样从文本中抽取语义和结构化数据 KR视角：怎样利用计算机符号来表示和处理知识 AI视角：怎样利用知识库来辅助理解人的语言 DB视角：用图的方式去存储知识 传统KE的问题传统知识工程在规则明确、边界清晰、应用封闭的应用场景取得了巨大成功。缺点是体系是自上而下的：严重依赖专家和人的干预 。 解决方式：大规模自动知识获取 。基于大数据、ML，充分利用现代计算机的强大算力，从大量数据中自动进行信息挖掘。 这种数据驱动的知识获取是自下而上的，以维基百科页面内容为例： graph LR A[Wikipedia] -->B(预处理器 schema定义训练数据构造) B --> C{是否分类} C -->|未分类| D[分类器文本,句法分类] C -->|已分类| E[抽取器CRFmodel] D --> E E --> F[infobox] 以其为基础建立的数据库有：YAGO、 CN-DBpedia(以后仔细学习下API)等 知识图谱富含实体、概念(is)、属性(has)、关系等信息。以RDF或图的形式存储 领域知识图谱的三个问题： 需要哪些业务知识？ ——分析实际应用需求 已有知识如何用最好的方式在计算机中存储？——建立从数据到知识库中实体、概念、关系的映射 如何基于问题寻求答案？—— 利用知识库中实体、概念、 关系解释现象的过程 知识表示怎样用计算机符号来表示人脑知识，及如何用符号运算进行推理 基于数理逻辑的知识表示现在主流的是RDF: RDF三元组语义模型 RDF图：有向标记图——存整图(多元关系) RDFS: 更加细分 通过OWL(本体论)对RDF模式进行拓展，能表示更复杂的类和属性 基于向量空间学习的分布式知识表示在保留语义的同时，将KG中的实体和关系映射到连续的稠密和低维向量空间。 KG-Emdedding: 要用到张量分解、神经网络、距离模型等知识 知识抽取 文本预处理 分词，词性标注，语法解析，依存分析 命名实体识别，实体链接 关系抽取，事件抽取 抽取方法 知识工程： 用正则表达式、模板匹配、规则约束——人工干预较多 基于本体的抽取：对应KR中的图、Embedding—— 主要是为了后续知识推理 基于模型的抽取：模型有SVM/Logistic/CRF/LSTM 等，训练有有监督学习、无监督聚类、远程监督——自学习 知识存储用关系型数据库存抽取完的三元组数据，然后导入到图数据库中是主流做法，不做深入对比。 知识问答问句 –&gt; 语义解析 –&gt; 问题语义表示 语义表示方法： 基于符号 基于问题模板 基于子图 基于分布式 知识推理有些问题并不是一步就可以获得答案的，需要进行多步推理才能知道。 按解决方法分类： 基于描述逻辑：本体推理 基于统计规则挖掘 基于路径排序学习方法(PRA) 基于关联规则挖掘犯法(AMIE) 基于表示学习与神经网络: 将实体和关系都表示为向量，用向量计算代替图遍历","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"KG","slug":"KG","permalink":"http://vergessenwang.github.io/tags/KG/"}]},{"title":"LSTM模型浅析","slug":"LSTM模型浅析","date":"2019-10-28T16:07:36.000Z","updated":"2019-10-28T16:09:33.769Z","comments":true,"path":"posts/NLP/2019-10-29-LSTM模型浅析.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-29-LSTM模型浅析.html","excerpt":"在对神经网络类算法模型一无所知的时候，我就曾想过信息与时序的问题，并陷入混乱中…今天开始看BiLSTM的原理时，才发现早就有了相应的解决方案… 神经网络的灵感来自于人脑神经元的工作方式，然而为了在计算机中实现，依然是个跟加权有关的数学问题，权重决定了信息的重要程度。每个节点虽然有多个输入输出，但是一种状态下只是二值问题。神经网络的隐藏层越多，处理复杂问题的能力也就越强。 历史模型的局限普通的神经网络(NN)：各输入层之间没有运算连接，无法表示上下文关系 $h_t = sigmoid(W_x * x_t + b)$ 循环神经网络(RNN): 其实比较类似于进位加法链，上一次运算的结果会加入到下一次运算中。这种基于时序的处理，只包含了上文信息，而忽略了下文信息。如果用增加依赖步数的方式，会导致把精力都集中在记忆大量的输入信息上，从而使建模能力下降。还有一个问题是RNN比较难以训练，逐步求导的梯度下降方式可能产生梯度爆炸问题 $h_t = tanh(W_x x_t + W_h h_{t-1} +b)$ 双向循环神经网络(BRNN): 再增加一个向后的网络，使得未来信息被包含进来。然而，仍然存在存取的上下文信息范围有限的问题，随着网络环路的不断递归，隐含层的影响是会不断衰减的，即长期依赖问题，这就引出了关于权重的考虑，什么样的信息是重要的，需要在后续的计算中一直保留呢？ 于是出现了 LSTM 长短期记忆(LSTM): 核心是基于门函数的自我衡量的机制，通过记忆门与遗忘门来控制之前的影响，相比于RNN，多了一个输入和输出，它们控制的是长期记忆。LSTM用细胞状态来表示内部复杂的处理过程。 双向长短期记忆(BiLSTM): 即增加一个反向的LSTM。两个方向的结果拼接后得最终结果。 门控循环单元（GRU）：将忘记和输入门结合成一个“更新门”，它还合并了单元状态和隐藏状态，并做了一些其他更改。由此产生的模型比标准的LSTM模型更简单，并且越来越受欢迎。","text":"在对神经网络类算法模型一无所知的时候，我就曾想过信息与时序的问题，并陷入混乱中…今天开始看BiLSTM的原理时，才发现早就有了相应的解决方案… 神经网络的灵感来自于人脑神经元的工作方式，然而为了在计算机中实现，依然是个跟加权有关的数学问题，权重决定了信息的重要程度。每个节点虽然有多个输入输出，但是一种状态下只是二值问题。神经网络的隐藏层越多，处理复杂问题的能力也就越强。 历史模型的局限普通的神经网络(NN)：各输入层之间没有运算连接，无法表示上下文关系 $h_t = sigmoid(W_x * x_t + b)$ 循环神经网络(RNN): 其实比较类似于进位加法链，上一次运算的结果会加入到下一次运算中。这种基于时序的处理，只包含了上文信息，而忽略了下文信息。如果用增加依赖步数的方式，会导致把精力都集中在记忆大量的输入信息上，从而使建模能力下降。还有一个问题是RNN比较难以训练，逐步求导的梯度下降方式可能产生梯度爆炸问题 $h_t = tanh(W_x x_t + W_h h_{t-1} +b)$ 双向循环神经网络(BRNN): 再增加一个向后的网络，使得未来信息被包含进来。然而，仍然存在存取的上下文信息范围有限的问题，随着网络环路的不断递归，隐含层的影响是会不断衰减的，即长期依赖问题，这就引出了关于权重的考虑，什么样的信息是重要的，需要在后续的计算中一直保留呢？ 于是出现了 LSTM 长短期记忆(LSTM): 核心是基于门函数的自我衡量的机制，通过记忆门与遗忘门来控制之前的影响，相比于RNN，多了一个输入和输出，它们控制的是长期记忆。LSTM用细胞状态来表示内部复杂的处理过程。 双向长短期记忆(BiLSTM): 即增加一个反向的LSTM。两个方向的结果拼接后得最终结果。 门控循环单元（GRU）：将忘记和输入门结合成一个“更新门”，它还合并了单元状态和隐藏状态，并做了一些其他更改。由此产生的模型比标准的LSTM模型更简单，并且越来越受欢迎。 英文参考文章 中文参考文章 LSTM的应用领域 one to many: 如给出一个图片，生成描述语句；由一个单词写出一篇诗 many to one : 如 视频分类 many to many: 结构对应如手写识别 或 不对应 如给一个视频生成描述 总之，与序列有关的都可以用该模型来处理，特别是上下文有关的情况 在实践中，一般先用CNN抽取特征，再用LSTM进行序列学习 神经网络是一个工具，很多库都已经实现了，不用多度担心其中的数学问题和实现难度，更应该关心的是你的问题到底适应什么样的网络结构，训练数据多大，能承受多深的神经网络。这考验的其实是工程能力 实现LSTM的训练对内存要求较高，训练一般就是10~20 的序列长度, 预测的长度没有太大限制。参数设置就是炼丹… 了解一种DL框架，如TensorFlow , PyTorch, 内部都已经集成了LSTM，知道如何调用就行","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"CNN","slug":"CNN","permalink":"http://vergessenwang.github.io/tags/CNN/"},{"name":"LSTM","slug":"LSTM","permalink":"http://vergessenwang.github.io/tags/LSTM/"}]},{"title":"KBQA中的一些问题","slug":"KBQA中的一些问题","date":"2019-10-27T16:57:09.000Z","updated":"2019-10-27T17:06:58.328Z","comments":true,"path":"posts/NLP/2019-10-28-KBQA中的一些问题.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-28-KBQA中的一些问题.html","excerpt":"QA知识来源：结构化知识(KB)、半结构化知识、非结构化知识、文本摘要、机器翻译 这里的KB主要有：Freebase,DBPedia,Yago 等现有知识库 知识库KB：RDF + SPARQL，问题—在高异质性的KB中写SPARQL语句很困难 KBQA : 由于缩写、同义词、数学换算等可能导致失配 —&gt; 同义转换 —&gt; 用CRF 计算候选匹配排名 —&gt; 有反馈的特定排名(要与用户交互，实现困难) 统计方法和神经学习方法的主要区别： 统计：人工设计规则和特征；从数据中学习权重 神经：特征和权重都是从数据中学习来的，需要极大的训练数据集 同义问题转换：从原始问句中抽象出实体(基于主题实体和上下文寻找抽象)，将含抽象实体的问题通过重排转为已有问题模板。通过问题类型接口（基于Bi-LSTM）获取答案。","text":"QA知识来源：结构化知识(KB)、半结构化知识、非结构化知识、文本摘要、机器翻译 这里的KB主要有：Freebase,DBPedia,Yago 等现有知识库 知识库KB：RDF + SPARQL，问题—在高异质性的KB中写SPARQL语句很困难 KBQA : 由于缩写、同义词、数学换算等可能导致失配 —&gt; 同义转换 —&gt; 用CRF 计算候选匹配排名 —&gt; 有反馈的特定排名(要与用户交互，实现困难) 统计方法和神经学习方法的主要区别： 统计：人工设计规则和特征；从数据中学习权重 神经：特征和权重都是从数据中学习来的，需要极大的训练数据集 同义问题转换：从原始问句中抽象出实体(基于主题实体和上下文寻找抽象)，将含抽象实体的问题通过重排转为已有问题模板。通过问题类型接口（基于Bi-LSTM）获取答案。 答案的扩展：给出直接和相关答案。 —&gt; 深拷贝？(这里没看懂) 冷启动问题：众包…(告辞) QA进化：生成富多样性的问题集，依旧需要众包干预 总结：这篇论文讲的主要是在已有的知识库查询中，如何提高自然语句转为SQL语句准确率，由于我们并不打算在项目中用SQL语句，故不对实现做深入了解。后面还有根据问题对相应网页进行操作如填写表单，这种高级内容就不看了吧…也许以后的百度音箱能实现… 思考：也许需要重新审视一下端到端这个概念了，真正含义是给出一个复杂的包含各种条件约束的自然语句问题，直接给出确切答案。那么很显然传统的语句查询无法同时处理这么多的条件，而在KB中我们可以沿着关系用一种传递的方式去查询，那么问题来了，如果确定关系约束的先后顺序，不至于由于顺序错误中断查询过程，似乎是一个难度较大的问题。所以，我们的项目只能尽量简化问题了… 值得进一步学习：Bi -LSTM模型, CRF模型 本文内容学习自：CCKS19_ATT_XifengYan","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"QA","slug":"QA","permalink":"http://vergessenwang.github.io/tags/QA/"}]},{"title":"Socket编程实践","slug":"Socket编程实践","date":"2019-10-26T11:30:03.000Z","updated":"2019-10-26T11:33:14.658Z","comments":true,"path":"posts/network/2019-10-26-Socket编程实践.html","link":"","permalink":"http://vergessenwang.github.io/posts/network/2019-10-26-Socket编程实践.html","excerpt":"之前写过socket编程的原理 , 正好高级网络实验课要写socket程序，故总结一下实践中的一些问题。 Winsock实现由于我的系统是windows，所以采用Winsock接口。 MFC提供了两个类用以封装Windows Sockets API CAsyncSocket类：具有一定网络编程经验的开发人员 CSocket类：由CAsyncSocket类派生，简化网络编程 需要包含Winsock2.h，Winsock32.dll和ws2_32.lib 端口选择：端口1024以前的端口号都是系统保留的或是作为公共服务的，应尽量选择大于1024的端口号 WinSock初始化Windows 下的 socket 程序依赖 Winsock.dll 或 ws2_32.dll，必须提前加载。 调用任何一个Winsock函数之前都必须检查协议栈安装情况，使用函数WSAStartup() 调用winsock DLL","text":"之前写过socket编程的原理 , 正好高级网络实验课要写socket程序，故总结一下实践中的一些问题。 Winsock实现由于我的系统是windows，所以采用Winsock接口。 MFC提供了两个类用以封装Windows Sockets API CAsyncSocket类：具有一定网络编程经验的开发人员 CSocket类：由CAsyncSocket类派生，简化网络编程 需要包含Winsock2.h，Winsock32.dll和ws2_32.lib 端口选择：端口1024以前的端口号都是系统保留的或是作为公共服务的，应尽量选择大于1024的端口号 WinSock初始化Windows 下的 socket 程序依赖 Winsock.dll 或 ws2_32.dll，必须提前加载。 调用任何一个Winsock函数之前都必须检查协议栈安装情况，使用函数WSAStartup() 调用winsock DLL 1234567891011121314151617181920212223#include &lt;WinSock2.h&gt;#pragma comment(lib, \"ws2_32.lib\") //加载 ws2_32.dllvoid main()&#123; WORD wVersionRequested; //指定使用的版本号 WSADATA wsaData; //返回关于Winsock实现的详细信息 wVersionRequested = MAKEWORD(2, 2); // 用宏获得版本号 if (WSAStartup(wVersionRequested, &amp;wsaData) != 0)//初始化ws2_32.dll动态库 &#123; printf(\"WSAStartup() failed!\\n\");//Winsock初始化错误 exit(-1); &#125; if (wsaData.wVersion != wVersionRequested) &#123; printf(\"The version of Winsock is not suited!\\n\");//Winsock版本不匹配 WSACleanup();//结束对ws2_32.dll的调用 exit(-1); &#125; //说明ws2_32.dll正确加载 printf(\"Load ws2_32.dll successfully!\\n\"); system(\"pause\");&#125; 创建套接字当type指定为SOCK_STREAM或SOCK_DGRAM时，因为系统已明确使用tcp和udp来工作，protocol可指定为0 123456789101112#define SERV_PORT 6789 // 定义端口#define SERV_IP \"127.0.0.1\" //定义IP/* 创建套接字*/SOCKET ssock = socket(AF_INET, SOCK_STREAM, 0); // 设置IP地址族，socket类型，协议类型,创建一个套接字//初始化socket addr_in结构sockaddr_in server;memset(&amp;server, 0, sizeof(server)); //数据清零server.sin_family = AF_INET; // IP地址类型server.sin_addr.s_addr = inet_addr(SERV_IP); //将IP转成网络字节序server.sin_port = htons(SERV_PORT); //将端口号转为网络字节序printf(\"Socket OK!\\n\"); 编译时报错：Use inet_pton() or InetPton() instead or define _WINSOCK_DEPRECATED_NO_WARNINGS to disable deprecated API warnings 问题的解决：1、用所提示的新函数代替inet_addr函数。2、修改VS配置，告诉它我就要旧函数，修改方法：项目-&gt;属性-&gt;C/C++-&gt;常规-&gt;SDL检查，将“是”改为“否”，即可 主机序与网络字节序主机序：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序。分为大端和小端两种方式 测试主机序 1234567891011121314#include &lt;stdio.h&gt;//判断本机的字节序//返回true表为小段序。返回false表示为大段序bool am_little_endian ()&#123; unsigned short i=1; return (int)*((char *)(&amp;i)) ? true : false;&#125;int main()&#123; if(am_little_endian()) printf(\"本机字节序为小段序!\\n\"); else printf(\"本机字节序为大段序!\\n\"); return 0;&#125; 本机测试结果为：小端序 网络字节序：TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian排序方式。 于是，在数据处理时涉及到字节顺序转换的问题。这里用inet_addr htons 处理 绑定端口(服务器)123456789/*绑定套接字和端口 */int iSockErr =0;//建立一个绑定，参数类型需要强转,中间的参数表示指向SOCKADDR结构的地址iSockErr = bind(ssock, (struct sockaddr*)&amp;server, sizeof(sockaddr)); if (iSockErr == SOCKET_ERROR) &#123; WSAGetLastError();//根据不同的错误类型进行不同的处理 exit(1);&#125;printf(\"Bind OK!\\n\"); 监听端口(服务器)1234567/* 监听连接请求 */ iSockErr = listen(ssock, 128); // 限定同时建立连接的客户端数量 if (iSockErr == SOCKET_ERROR) &#123; WSAGetLastError();//根据不同的错误类型进行不同的处理 exit(1); &#125; printf(\"Listenning......\\n\"); 发起连接(客户端)在客户端使用connect请求建立连接时，将激活建立连接的三次握手，用来建立一条到服务器TCP的连接。 1234567/* 发起连接请求*/int iSockErr = 0;iSockErr = connect(sock, (struct sockaddr*)&amp;server, sizeof(sockaddr));if (iSockErr == SOCKET_ERROR) &#123; WSAGetLastError();//根据不同的错误类型进行不同的处理 exit(1);&#125; 处理连接请求(服务器)accept用于面向连接的服务器端，在IP协议族中，只用于TCP服务器端 accept接受一个socket的连接请求，同时返回一个新的socket，新的socket用来在服务器与客户端之间传递和接收信息 此时socket表示处于监听状态的socket，地址是客户机的IP地址 12345/*阻塞等待客户端发起连接，三次握手成功建立连接后会返回一个新的文件描述符指向客户端socket,用于真正数据传输*/ SOCKADDR client; int nSize = sizeof(SOCKADDR); SOCKET csock = accept(ssock, (SOCKADDR*)&amp;client, &amp;nSize); printf(\"Connect OK!\\n\"); 获取客户端的数据并处理(服务器)12345678910111213141516171819202122232425262728293031// 客户端 while (1) &#123; char buffer[1024] = \"\\0\"; printf(\"Input the string you want transfer-------------\\n\"); scanf(\"%s\", buffer); if (send(sock, buffer, sizeof buffer, 0) != SOCKET_ERROR) &#123; if (recv(sock, buffer, sizeof buffer, 0) != SOCKET_ERROR) printf(\"Received datagram from TCP server:%s\\n\", buffer); &#125; &#125;// 服务器 while (1) &#123; char buffer[1024] = \"\\0\"; printf(\"Waiting for message from client-------------\\n\"); if (recv(csock, buffer, sizeof buffer, 0) != SOCKET_ERROR) //从recv缓冲区读入数据，没有数据会阻塞 &#123; for (int i = 0; i &lt; sizeof buffer; i++) &#123; char ch = buffer[i]; if (ch &gt;= 'a'&amp;&amp;ch &lt;= 'z') buffer[i] = ch - 32; &#125; ////给cilent发转为大写的数据 send(csock, buffer, sizeof buffer, 0); &#125; Sleep(500); &#125; 关闭套接字123456//关闭套接字closesocket(ssock);closesocket(csock);//终止 DLL 的使用WSACleanup(); Linux实现Windows 下的 socket 程序和 Linux 思路相同，但细节有所差别： 1) Windows 下的 socket 程序依赖 Winsock.dll 或 ws2_32.dll，必须提前加载。 2) Linux 使用“文件描述符”的概念，而 Windows 使用“文件句柄”的概念；Linux 不区分 socket 文件和普通文件，而 Windows 区分；Linux 下 socket() 函数的返回值为 int 类型，而 Windows 下为 SOCKET 类型，也就是句柄。 3) Linux 下使用 read() / write() 函数读写，而 Windows 下使用 recv() / send() 函数发送和接收。 4) 关闭 socket 时，Linux 使用 close() 函数，而 Windows 使用 closesocket() 函数。 服务器端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt; // 包含 sockaddr_in 结构体#include &lt;ctype.h&gt; // 大小写转换#include &lt;string.h&gt; // 包含bzero#define SERV_PORT 6666#define SERV_IP \"127.0.0.1\"int main() &#123; int lfd,cfd; struct sockaddr_in serv_addr,client_addr; socklen_t client_addr_len,client_IP_len; char buf[BUFSIZ],client_IP[BUFSIZ]; int n,ret; lfd = socket(AF_INET, SOCK_STREAM, 0); //创建一个套接字，返回文件描述符指向服务器socket if (lfd == -1) &#123; perror(\"socket error\"); // 如果在连接状态先关掉server，那么并不会真正关闭，端口还占用，下一次启动就会出现问题 exit(1); &#125; //结构体初始化 bzero(&amp;serv_addr, sizeof(serv_addr)); // 缓冲区清零 serv_addr.sin_family = AF_INET; // IP地址类型 serv_addr.sin_port = htons(SERV_PORT); //将端口号转为网络字节序 serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); //将IP转成网络字节序，INADDR_ANY自动获取当前网卡上有效IP ret = bind(lfd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)); //建立一个绑定，参数类型需要强转 if (ret == -1) &#123; perror(\"bind error\"); exit(1); &#125; ret = listen(lfd, 128); // 限定同时建立连接的客户端数量 if (ret == -1) &#123; perror(\"listen error\"); exit(1); &#125; client_addr_len = sizeof(client_addr); //阻塞等待客户端发起连接，三次握手成功建立连接后会返回一个新的文件描述符指向客户端socket,用于真正数据传输 cfd = accept(lfd, (struct sockaddr*)&amp;client_addr, &amp;client_addr_len); if (cfd == -1) &#123; perror(\"accept error\"); // 如果在连接状态先关掉server，那么并不会真正关闭，端口还占用，下一次启动就会出现问题 exit(1); &#125; printf(\"client IP：%s,client port:%d\\n\", inet_ntop(AF_INET, &amp;client_addr.sin_addr.s_addr,client_IP,sizeof(client_IP), ntohs(client_addr.sin_port)); while (1) &#123; n = read(cfd, buf, sizeof(buf)); //从read缓冲区读入数据，没有数据会阻塞 for (int i = 0; i &lt; n; i++) &#123; buf[i] = toupper(buf[i]); &#125; write(cfd, buf, n); // socket双向通信，故有两个缓冲区，双向全双工 // read 和 write 缓冲区在内核中， 而char buf[] 是用户定义的，在stack中 &#125; close(lfd); close(cfd); return 0;&#125; 客户端 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; // memset 的头文件#include &lt;arpa/inet.h&gt; // 包含 sockaddr_in 结构体#define SERV_PORT 6666#define SERV_IP \"127.0.0.1\"int main() &#123; int cfd; struct sockaddr_in serv_addr; // socklen_t serv_addr_len; char buf[BUFSIZ]; int n; cfd = socket(AF_INET, SOCK_STREAM, 0); //结构体初始化 memset(&amp;serv_addr,0,sizeof(serv_addr); // 指针清空，防止默认取随机值 serv_addr.sin_family = AF_INET; // IP地址类型 serv_addr.sin_port = htons(SERV_PORT); //将端口号转为网络字节序 inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr); connect(cfd,(struct sockaddr*)&amp;serv_addr,sizeof(serv_addr)); // linux 会隐式bind while (1) &#123; fgets(buf, sizeof(buf), stdin);//输入要处理的数据，没有数据会阻塞 write(cfd, buf, strlen(buf); // 将从键盘接收的数据写入write n = read(cfd, buf, sizeof(buf)); write(STDOUT_FILENO, buf, n); &#125; close(cfd); return 0;&#125;","categories":[{"name":"network","slug":"network","permalink":"http://vergessenwang.github.io/categories/network/"}],"tags":[{"name":"C/S","slug":"C-S","permalink":"http://vergessenwang.github.io/tags/C-S/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://vergessenwang.github.io/tags/TCP-IP/"},{"name":"Socket","slug":"Socket","permalink":"http://vergessenwang.github.io/tags/Socket/"}]},{"title":"不能用一种猛兽克制另一种猛兽","slug":"不能用一种猛兽克制另一种猛兽","date":"2019-10-16T14:08:32.000Z","updated":"2019-10-16T14:12:36.299Z","comments":true,"path":"posts/life/2019-10-16-不能用一种猛兽克制另一种猛兽.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2019-10-16-不能用一种猛兽克制另一种猛兽.html","excerpt":"","text":"可能我身体里的电池是二手的，新奇和幻灭交织着，加剧了消耗，在极短时间将其拔空。 在椅子上呆坐了一会，预感到它即将从虚空的深渊里爬出来。 我们不能看到一个人生命中全部的雪，每个人都在他自己的生命里，孤独地过冬。 我坐在从起点站出发去往市里的公车上，头倚着窗户，脑海里盘旋着这句话。 我喜欢坐起点出发的公车，喜欢在非节假日，一个人逛街。当我的情绪被耗干的时候。 车上零星的上来几个老头老太太，到小学门口下车，挤成一团，早早地等着他们的小祖宗。路过很多绿河青柳，桥的名字都一律地很有诗意。很有人间气息，可我面无表情。 要飘到高空的时候，得用什么东西把自己绑住。于是我在一个个商场里进进出出。为了克制一只猛兽，我放出了另一只猛兽。它沉沉压着我的双肩，像浸过水的稻草。直到连体力都被抽干。 它们嗅了嗅干枯的躯壳，终于渐渐离去了。 坐着等公交的时候，心算了一下好像被多收了钱。可是完全不想动。最终还是回去找了她们重算，这样多的钱就可以打滴滴了。 总是这样，用各种莫名其妙的借口。消耗。 重又坐到宿舍的椅子上，反思着白天发生的事情。 每个人都是一个正弦波，频率和相位一致，才能共振。否则，要么充斥着恼人的冲突，要么甚至合为一条无波的曲线。 我的振幅太小了，大概始终只能当个谐波。被迫提高振幅，就会加剧消耗。又给自己找了一个完美借口。 八点了，想起来还没吃饭。拖着游魂般的步子，路过玩滑板的少年。 真实的灵魂，不能直视。 明日又在大地中完整，这才是我打碎一切的真情。","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[{"name":"脱缰时刻","slug":"脱缰时刻","permalink":"http://vergessenwang.github.io/tags/脱缰时刻/"}]},{"title":"Anaconda、py2neo和Neo4j搭建KG简单环境","slug":"Anaconda、py2neo和Neo4j搭建KG简单环境","date":"2019-10-12T15:57:30.000Z","updated":"2019-10-12T16:01:03.973Z","comments":true,"path":"posts/NLP/2019-10-12-Anaconda、py2neo和Neo4j搭建KG简单环境.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-12-Anaconda、py2neo和Neo4j搭建KG简单环境.html","excerpt":"安装Anaconda官网下载地址 安装时不勾选Add Anaconda to my PATH environment variable因为勾选将会影响其他程序的使用 勾选Register Anaconda as my default Python 3.6 常用命令参考 在Anaconda Prompt中输入 conda list ，可以查看已经安装的包名和版本号 创建虚拟环境conda create -n &lt;env_name&gt; &lt;package_names&gt; 如 conda create -n KGQA python=3.5 激活环境activate &lt;env_name&gt; 退出deactivate 在当前环境中安装包 conda install &lt;package_name&gt; , 然鹅很多包都没法用conda渠道安装，还是要用pip才行。根据本项目安装了flask、py2neo、pyltp和bs4 还可以用requirement.txt文件来批量安装依赖包conda install --yes --file requirements.txt pyltp包安装出错解决期间报错 1PackagesNotFoundError: The following packages are not available from current channels: - pyltp 换成 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyltp 命令进行安装 ，仍然不行, 说是找不到wheels 找到了一个py3.5版本wheels源码链接, 参看 将下载好的文件放在此时Prompt命令行对应的文件夹中，如我的是 (KGQA) C:\\Users\\18771 然后执行pip install pyltp-0.2.1-cp35-cp35m-win_amd64.whl 即可安装成功wheels文件 输入conda list 发现有了pyltp安装包","text":"安装Anaconda官网下载地址 安装时不勾选Add Anaconda to my PATH environment variable因为勾选将会影响其他程序的使用 勾选Register Anaconda as my default Python 3.6 常用命令参考 在Anaconda Prompt中输入 conda list ，可以查看已经安装的包名和版本号 创建虚拟环境conda create -n &lt;env_name&gt; &lt;package_names&gt; 如 conda create -n KGQA python=3.5 激活环境activate &lt;env_name&gt; 退出deactivate 在当前环境中安装包 conda install &lt;package_name&gt; , 然鹅很多包都没法用conda渠道安装，还是要用pip才行。根据本项目安装了flask、py2neo、pyltp和bs4 还可以用requirement.txt文件来批量安装依赖包conda install --yes --file requirements.txt pyltp包安装出错解决期间报错 1PackagesNotFoundError: The following packages are not available from current channels: - pyltp 换成 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyltp 命令进行安装 ，仍然不行, 说是找不到wheels 找到了一个py3.5版本wheels源码链接, 参看 将下载好的文件放在此时Prompt命令行对应的文件夹中，如我的是 (KGQA) C:\\Users\\18771 然后执行pip install pyltp-0.2.1-cp35-cp35m-win_amd64.whl 即可安装成功wheels文件 输入conda list 发现有了pyltp安装包 在Pycharm中切换解释器在pycharm中将项目解释器切换到上面新建的环境 settings -&gt; project interpreter -&gt; add local -&gt; 找到Anconda3文件夹 -&gt; envs -&gt; KGQA -&gt; python.exe 图数据库neo4j的使用对比于关系型数据库，图数据库的最大好处在于，跨表检索时不需要复杂的连接操作——而我个人的理解是，这种操作的复杂性被转移到了图数据库的最初设计中，所以知识图谱问题的本质，其实是一个数据库设计的问题，这其中涉及到我们要用什么——应用需求，存什么——概念设计，怎么存——逻辑和物理设计，怎么呈现——问答可视化 存储类型实体(节点)——实体分类 关系(边)——关系类型 实体和关系的属性——以键值对存储 下载安装Neo4j官网下载速度真令人崩溃 国内镜像及文档——然而好像也打不开 还好找到一个云盘链接 新建环境变量：变量名NEO4J_HOME 路径C:\\Users\\18771\\Desktop\\知识图谱\\neo4j-community-3.5.5-windows\\neo4j-community-3.5.5 Win+X+A快捷键以管理员身份运行命令行，切换到bin所在目录，输入neo4j.bat console 启动服务，运行端口为7474 在浏览器中打开，默认的可视乎host是bolt://localhost:7687，默认的用户是neo4j，默认的密码是：neo4j，第一次成功connect到Neo4j服务器之后，需要重置密码。 进入界面后就可以开始编写Cypher语句创建数据了 py2neo将数据导入Neo4jPycharm上运行起github上一个KG的demo 修改neo_db目录下的配置文件config.py,设置图数据库的账号和密码。 切换到neo_db目录下，执行python create_graph.py 建立知识图谱 此时报错 1py2neo cannot import name 'NodeSelector' 尝试 pip install git+https://github.com/nigelsmall/py2neo.git#egg=py2neo 不行。这个github上给的解决方法是升级到v3 , 而实际上我目前的py2neo版本已经是4.3.0版本 解决：将 NodeSelector 改为 NodeMatcher 接着运行，又报错 1FileNotFoundError: [Errno 2] No such file or directory: './raw_data/relation.txt' 因为windows父级目录是 ../ 再次运行，又粗线了… 1UnicodeDecodeError: 'gbk' codec can't decode byte 0x96 in position 15: illegal multibyte sequence 更改一下打开格式 with open(&quot;../raw_data/relation.txt&quot;) as f: 改为 with open(&quot;../raw_data/relation.txt&quot;, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f: 这下运行导入成功了，在localhost:7687可以看到导入的数据","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"Anaconda","slug":"Anaconda","permalink":"http://vergessenwang.github.io/tags/Anaconda/"},{"name":"py2neo","slug":"py2neo","permalink":"http://vergessenwang.github.io/tags/py2neo/"},{"name":"pyltp","slug":"pyltp","permalink":"http://vergessenwang.github.io/tags/pyltp/"},{"name":"Neo4j","slug":"Neo4j","permalink":"http://vergessenwang.github.io/tags/Neo4j/"}]},{"title":"Java前四章笔记","slug":"Java前四章笔记","date":"2019-10-11T12:33:53.000Z","updated":"2019-10-11T12:35:20.161Z","comments":true,"path":"posts/Java/2019-10-11-Java前四章笔记.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2019-10-11-Java前四章笔记.html","excerpt":"CH1文档 参考书：Java编程思想(英文版第 4版) Java 核心技术(英文版第 9版） 补充知识：JavaEE 数据库 软件设计 Java虚拟机原理 Leetcode刷题 .java -&gt; (编译器) -&gt; .class -&gt; (Java虚拟机) -&gt; 机器码程序 编译：javac HelloWorldApp.java 运行：java HelloWorldApp arg1 arg2 JRE 只包含虚拟机，没有编译器 文档型注释：/* documentation / main方法public static void main(String[] args) 以上写法只是通常用的：public和static的位置可以交换；args 可以任意命名，如argv； 作为程序入口，必须是public 才能在任意地方被访问到 由于在启动程序时还没有任何对象，所以只能static方法——无需使用对象就可以调用静态方法 每个类可以有一个main方法，这是一个常用于对类进行单元测试的技巧。当该类所属的应用程序的main方法被执行时，该类本身的main将不会被执行","text":"CH1文档 参考书：Java编程思想(英文版第 4版) Java 核心技术(英文版第 9版） 补充知识：JavaEE 数据库 软件设计 Java虚拟机原理 Leetcode刷题 .java -&gt; (编译器) -&gt; .class -&gt; (Java虚拟机) -&gt; 机器码程序 编译：javac HelloWorldApp.java 运行：java HelloWorldApp arg1 arg2 JRE 只包含虚拟机，没有编译器 文档型注释：/* documentation / main方法public static void main(String[] args) 以上写法只是通常用的：public和static的位置可以交换；args 可以任意命名，如argv； 作为程序入口，必须是public 才能在任意地方被访问到 由于在启动程序时还没有任何对象，所以只能static方法——无需使用对象就可以调用静态方法 每个类可以有一个main方法，这是一个常用于对类进行单元测试的技巧。当该类所属的应用程序的main方法被执行时，该类本身的main将不会被执行 一些细节Java不只是一种语言，而是一个包含各种可重用代码的库以及安全性、可移植性、垃圾回收机制的平台。 相比于C++,java没有头文件、指针运算、结构、联合、操作符重载、虚基类等。 程序设计语言的成功更多取决于其支撑系统的能力，而不是优美的语法。 访问修饰符用于控制程序的其他部分对这段代码的访问级别。 将类作为一个加载程序逻辑的容器，程序逻辑定义了应用程序的行为。Java中的全部内容都必须放在类中，所有的函数都属于某个类的方法，因此main方法必须有一个外壳类而且必须是静态的。 类名采用驼峰命名法，且文件名要与公共类名相同。 Java中所有数据类型所占的字节数是与平台无关的，也没有无符号类型。绝大多数应用程序都采用double类型来表示浮点数。没有f或F后缀的浮点数默认为double类型。 检验一个值是否为NaN, 不能用 x == NaN ,因为所有非数值的值都是不相同的。 但是可用 Double.isNaN(x) 方法 CH2 OOP对象：实例域值(状态) + 方法(行为) 优点：模块化、信息隐藏、代码重用、易维护 设计：首先从设计类开始，然后再往每个类中添加方法。分析问题时名词对应数据域，动词对应方法 原则 数据封装(data encapsulation)：隐藏内部状态，所有对象之间的交互通过方法来实现；同时可以完全改变存储数据的方式，而不会影响外部使用 继承 ：可以通过扩展一个类来创建一个新类，并自定义方法和数据域。但是只能有一个父类——单继承 class Cat extends Animals 接口接口不是类，而是类的功能的描述，并不给出每个功能的具体实现。接口中所有方法默认属于public，但是在类中实现时必须显式声明为public 接口中可以定义常量，接口中的域默认为public static final。不能含有实例域或静态方法——接口没有实例，可以将接口看做没有实例域的抽象类 。但是一个类可以实现一个或多个接口——接口相比于抽象类的优势，类只能单继承。接口可以提供多继承的好处，并同时避免其复杂性和低效性 1234567891011121314151617//接口声明interface Bicycle&#123; void changeGear(int newValue); void speedUp(int increment);&#125;//类实现class ACMEBicycle implements Bicycle&#123; int speed = 0; int gear = 0; public void changeGear(int newValue)&#123; gear = newValue; &#125; public void speedUp(int increment)&#123; speed = speed + increment; &#125;&#125; 类必须实现接口中的所有方法，否则会出现编译错误 Interfaces form a contract between the class and the outside world, and this contract is enforced at build time by the compiler 接口不能用new运算符，但是可以声明一个接口类型的变量，该变量必须引用实现了接口的类对象 12Bicycle mybike;mybike = new ACMEBicycle(...) 接口也可以被扩展 Java8 之后，可在接口中实现简单静态方法了，但是这些方法不能引用实例域。这样就无需为该接口编写伴随类了——面向接口编程.. 考虑一个问题：当接口中新增方法时，是否所有伴随类都要对应改变——接口扩展或default方法(接口演化) default方法出现在Java8 之后，实不实现都可以，主要是为了兼容以及按需实现 超类优先——接口与超类的冲突：如果一个类从超类继承的方法与它所实现的接口中的某个默认方法同名，那么实际上只有超类的方法有效——主要是为了与Java7兼容 接口之间的冲突：需要重写 包 A package is a namespace that organizes a set of related classes and interfaces 使用包的主要原因是确保类名的唯一性，建议将域名逆序作为包名。 CH3 Java基础变量 实例变量——放在heap 类变量：静态变量，仅有一个，类和所有对象共享——放在方法区的静态域 局部变量：方法内部定义的变量，只对该方法可见。编译器不会给局部变量设置默认值，故一定要初始化——放在stack 参数 命名变量：单个词全小写gear 多个词从第二个单词开始首字母大写 gearRatio 常量全大写，_隔开 NUM_GEARS 类名：每个单词的首字母大写 方法名：第一个单词为小写动词 Java内存区域划分 栈：在函数中定义的基本类型变量和对象的引用变量都在函数的栈内存中分配。栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。 堆：通过new生成的对象都存放在堆中，对于堆中的对象生命周期的管理由Java虚拟机的垃圾回收机制GC进行回收和统一管理。优点是可以动态分配内存大小，缺点是由于动态分配内存导致存取速度慢。 方法区：是各个线程共享的内存区域，它用于存储class二进制文件，包含了虚拟机加载的类信息、常量(常量池)、静态变量(静态域)、即时编译后的代码等数据。包括： 常量池：常量池在编译期间就将一部分数据存放于该区域，包含以final修饰的基本数据类型的常量值、String字符串。 静态域：存放类中以static声明的静态成员变量。 程序计数器：当前线程所执行的行号指示器。通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。 更多关于Java内存分配内容参看 关键字及保留字 不太熟悉的关键字： 关键字 含义 assert 用来进行程序调试 finally 用于处理异常情况，用来声明一个基本肯定会被执行到的语句块 native 用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的 strictfp 用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范 synchronized 表明一段代码需要同步执行 transient 声明不用序列化的成员域 volatile 表明两个或者多个变量必须同步地发生变化 基本数据类型 boolean : true and false 整型值和布尔值不能相互转换 byte – short – int – long(字面量加L) 没有unsigned类型，字面量0x 十六进制 0b 二进制 float – double 字面量加F或D或用科学计数法 要求极高精度时，用java.math.BigDecimal class 所有数值类型所占据的字节数与平台无关 char : 16 bit Unicode ‘\\u0000’ ~’\\uffff’ —— 建议不要使用，用java.lang.String class抽象类型来处理 为了可读性，经常会在数值字面量中加入‘_’ 。但是要注意只能放在数字之间，不能用于： At the beginning or end of a number —— 数字首末 Adjacent to a decimal point in a floating point literal ——小数点前后 Prior to an F or L suffix —— F/L 之前，x/b 前后 In positions where a string of digits is expected —— 字符型数字 数组内置方法 长度：.length 复制：System class 中有 public static void arraycopy(Object src, int srcPos,Object dest, int destPos, int length) java.util.Arrays class 提供的方法 Searching an array for a specific value to get the index at which it is placed (the binarySearch() method). Comparing two arrays to determine if they are equal or not (the equals() method). Filling an array to place a specific value at each index (the fill() method). Sorting an array into ascending order. This can be done either sequentially, using the sort() method, or concurrently, usingthe parallelSort() method introduced in Java SE 8 位运算符对整数的二进制位进行处理，得到某个位的值。 &amp; and | or ^ xor ~ not >&gt;&gt; 无符号右移，高位补0 &gt;&gt; 高位补符号位 没有无符号左移 利用&amp;结合使用适当的2的幂，可以用掩码技术把其他位掩掉，只保留其中的某一位 如n &amp; 0b1000 注意： &amp; 和 | 不采用短路方法 控制语句在for循环中：If the variable that controls a for statement is not needed outside of the loop, it’s best to declare the variable in the initialization expression. for(int i = 1; i &lt; n; i++) 枚举循环 for(int item : numbers) 加了标签的break或 continue 语句可以同时跳出多层循环 CH4 类和对象构造器不要在构造器中定义与实例域重名的局部变量，因为会屏蔽实例域，而这些局部变量只能在构造器内部访问。当被屏蔽时可用this.来访问实例域 ，如 this.name = name this还可以用来调用同一类的另一个构造器，这样可以减少构造器公共部分的代码 Java允许重载任何方法，而不仅仅是构造器方法 仅当类没有提供任何构造器时，系统才会提供一个默认的无参构造器 调用构造器的具体步骤：—— 一般也应按以下顺序声明类，构造器通过new运算符调用，正因为构造器与类名一样，new才知道调用哪个，构造完毕返回一个引用 所有数据域被初始化为默认值(0,false,null) 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块——只要构造类的对象，这些块就会被执行。编译器会把初始化块(包括static初试化块)复制到每一个构造器中，因此可以实现复用 如果构造器第一行调用了第二个构造器，则执行第二个构造器 执行这个构造器的主体 参数传递可以传基本数据类型、引用数据类型，但是不允许传方法——可以传对象，再调用对象的方法 基础类型参数传值，实际上在方法内部复制了一份，内部改变对外部传入的原始值没有影响。随着方法执行完毕，这份复制也随之消失。 引用类型参数也是传的值，只不过这个值是引用，即地址。复制的也是地址，指向同一个区域，可以对所指对象进行修改。 方法返回值返回值声明为类时，可返回该类及其子类——也可以重写一个方法，使它返回子类，此为协变返回类型 ​ 具体来说：协变返回类型（Covariant Return Type），指的是当一个类被继承之后，该类中方法的返回类型变成子类对应的类型，这个改变后的返回类型就叫协变返回类型。—— 在方法重写中常用 返回值声明为接口时，可返回实现了该接口的类 this关键字this指向被构造的对象 当实例域被构造器或方法的参数屏蔽时，可在构造器和方法的内部用this关键字访问对象的实例域——还有个方法就是参数直接起不一样的名字 this关键字还可以用在构造器的第一行，用来调用该类的另一个构造器，称之为显式构造方法的调用——这样可以省略构造器的公共部分，如 123public Rectangle(int width, int height)&#123; this(0, 0, width, height);&#125; 访问修饰符默认为package-private 类修饰符有public和默认，成员另还有private和protected protected 能被本包所有类及其他包中该类的子类访问 static修饰符属于类且不属于类对象的变量和函数，建议用类名直接访问 一个常用的静态常量System.out: 1234public class System&#123; ... public static final PrintStream out = ...;&#125; 其中用static使得不需要创建对象就可以调用，final 用来防止被修改 静态方法没有this参数，所以不能访问实例域，但是可以访问自身类中的静态域，或者通过对象引用间接访问实例域和实例方法 使用静态方法的情况：无需访问实例域；只需访问静态域 嵌套类作用：加强封装，对只在一个地方使用的类进行合理的组织 嵌套类作为外围类的成员，因此可以被声明为private或protected 非静态嵌套类——内部类：可以访问外围类的所有成员，包括私有的。由此可见，内部类具有访问特权。在创建内部类实例之前，必须首先创建外围类的实例。 OuterClass.InnerClass innerObject = outerObject.new InnerClass(); 编译器修改了所有内部类的构造器，添加一个外围类引用的参数，用来访问外围类 静态嵌套类不能访问外部类的其他成员，而且跟静态方法一样，通过外围类名进行访问。静态类可以有静态域和方法——只隐藏即可，无需访问外部 局部类：不用public或private访问说明符声明，可以对外部世界完全隐藏 。不仅可以访问外围类，还可以访问final类的局部变量。局部类访问final局部变量或外围类参数的过程，称为变量捕获？—— 编译器在检测到对局部变量的访问之后，会在局部类的构造器中中拷贝一份局部变量，为了保证数据的一致性，所以必须为final 局部类和内部类都不能定义或声明静态方法，如果有静态域，必须是final的 匿名类：声明和实例化同时进行，而且仅创建这个类的一个对象，因此不用命名。可以实现接口，也可以是对超类进行扩展。因为没有名字，所以没有构造器，只能将构造器参数传递给超类构造器—— 访问权限及内部成员限制跟局部类一样 12345678// 实现接口,接口没有构造器，不能传参new InterfaceType()&#123; methods and data&#125;// 扩展超类new SuperType(construction parameters)&#123; inner class methods and data&#125; 枚举类型通过enum关键字来定义，如 1public enum Day &#123; SUNDAY, MONDAY, TUESDAY, WEDNESDAY,THURSDAY, FRIDAY, SATURDAY &#125; 枚举类型有一系列预定义的常量实例，也可以添加构造器、方法和域。比较时用== 不用equals() 所有枚举类型都是Enum类的子类，继承的方法有 String toString()——返回枚举常量名 static Enum valueOf(Class enumClass,String name) ——返回指定名字、给定类的枚举常量 values() ——返回一个包含全部枚举值的数组 如Day[] values = Day.values() int ordinal() 返回枚举常量在enum声明中的位置，从0开始计数 int compareTo(E other) 判断次序 通常与for......each 结合用来遍历","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"基本语法","slug":"基本语法","permalink":"http://vergessenwang.github.io/tags/基本语法/"}]},{"title":"NER中的编码转换","slug":"NER中的编码转换","date":"2019-10-10T15:57:45.000Z","updated":"2019-10-10T16:02:23.714Z","comments":true,"path":"posts/NLP/2019-10-10-NER中的编码转换.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-10-NER中的编码转换.html","excerpt":"命名实体识别(NER)的作用：关系抽取、事件抽取、知识图谱(分构建和应用两个方向，构建目前人工干预还是需要很多)、问答系统、机器翻译… 通用实体分类：人名、地名、组织机构名、日期时间、专用名词 学术上的分类： 三大类：实体类、时间类、数字类 七小类：人名、地名、组织机构名、时间、日期、货币、百分比 相关算法早期：基于字典，基于规则 传统ML：HMM MEMM CRF DL: RNN-CRF CNN-CRF 学术界近期方法：注意力模型，迁移学习，半监督学习 —— 有时间了解下 BiLSTM + CRF 从双向神经网络输出的结果为什么还要经过CRF的处理？—— 输出的是一系列标签的概率，而且每个字之间是相互独立的，利用CRF的条件转移概率矩阵，可以改善输出结果 本次主要学习实体抽取前对中文字的词性标注后的编码转换，这是进行更深入信息抽取的基础工作","text":"命名实体识别(NER)的作用：关系抽取、事件抽取、知识图谱(分构建和应用两个方向，构建目前人工干预还是需要很多)、问答系统、机器翻译… 通用实体分类：人名、地名、组织机构名、日期时间、专用名词 学术上的分类： 三大类：实体类、时间类、数字类 七小类：人名、地名、组织机构名、时间、日期、货币、百分比 相关算法早期：基于字典，基于规则 传统ML：HMM MEMM CRF DL: RNN-CRF CNN-CRF 学术界近期方法：注意力模型，迁移学习，半监督学习 —— 有时间了解下 BiLSTM + CRF 从双向神经网络输出的结果为什么还要经过CRF的处理？—— 输出的是一系列标签的概率，而且每个字之间是相互独立的，利用CRF的条件转移概率矩阵，可以改善输出结果 本次主要学习实体抽取前对中文字的词性标注后的编码转换，这是进行更深入信息抽取的基础工作 加载数据获取训练数据集：采用github上的中文NER数据 数据导入 1234567891011121314151617181920212223def load_sentences(path): # 存放数据集 sentences = [] # 临时存放每一个句子 sentence = [] for line in codecs.open(path, 'r', encoding='utf8'): # 去掉两边空格 line = line.strip() if not line: # 是否读完一个句子 if len(sentence) &gt; 0: sentences.append(sentence) sentence = [] else: if line[0] == \" \": continue else: word = line.split() assert len(word) &gt;= 2 sentence.append(word) # 确保最后一个句子被读入 if len(sentence) &gt; 0: sentences.append(sentence) return sentences 首先检查是否为BIO编码格式，如 123456789101112开 O始 O修 O建 O莫 B-LOC斯 I-LOC科 I-LOC到 O圣 B-LOC彼 I-LOC得 I-LOC堡 I-LOC BIO检验先进行检验，如果不符合，做相应的处理进行转换 123456789101112131415161718def check_bio(tags): # 检查输入的编码是否符合BIO编码，如I一定在B之后;不符合则进行调整 for i, tag in enumerate(tags): if tag == 'O': continue tag_list = tag.split(\"-\") if len(tag_list) != 2 or tag_list[0] not in set(['B', 'I']): return False if tag_list[0] == 'B': continue elif i == 0 or tags[i-1] == 'O': # 前一位置为O，且当前位置不为B,则转换为B,即I-ORG转为B-ORG tag[i] = 'B' + tag[1:] elif tags[i-1][1:] == tag[1:]: # 判断尾部三位是否合法 continue else: # 如果编码类型完全不一致，则从B开始编码 tags[i] = 'B' + tag[1:] return True 转为BIOES格式然后将BIO格式转为BIOES格式 12345678910111213141516171819def bio_to_bioes(tags): new_tags = [] for i, tag in enumerate(tags): if tag == 'O': new_tags.append(tag) elif tag.split('-')[0] == 'B': # 若不是最后一个，且后面一个开头为I，则是一个正确的开头 if i + 1 &lt; len(tags) and tags[i+1].split('-')[0] == 'I': new_tags.append(tag) else: new_tags.append(tag.replace('B-','S-')) # 不是开头，则换成单字 elif tag.split('-')[0] == 'I': if i + 1 &lt; len(tags) and tags[i+1].split('-')[0] == 'I': # 是正确的中间字 new_tags.append(tag) else: new_tags.append(tag.replace('I-','E-')) # 不是中间，换成结尾 else: raise Exception('非法编码') return new_tags 综合处理 123456789101112131415161718def update_tag_scheme(sentences, tag_scheme): # 编码更新 for i, s in enumerate(sentences): tags = [w[-1] for w in s ] # 取出标记部分 if not data_utils.check_bio(tags): s_str = \"\\n\".join(\" \".join(w) for w in s) raise Exception(\"输入的句子应为BIO编码，请检查输入句子%i:\\n%s\" % (i, s_str)) if tag_scheme == \"BIO\": for word,new_tag in zip(s,tags): word[-1] = new_tag if tag_scheme == 'BIOES': new_tags = data_utils.bio_to_bioes(tags) for word,new_tag in zip(s,new_tags): # 重组 word[-1] = new_tag else: raise Exception(\"非法目标编码\")","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"NER","slug":"NER","permalink":"http://vergessenwang.github.io/tags/NER/"},{"name":"BIOES编码","slug":"BIOES编码","permalink":"http://vergessenwang.github.io/tags/BIOES编码/"}]},{"title":"VMware无法在Windows运行问题解决","slug":"VMware无法在Windows运行问题解决","date":"2019-10-08T16:22:50.000Z","updated":"2019-10-08T16:24:14.464Z","comments":true,"path":"posts/OS/2019-10-09-VMware无法在Windows运行问题解决.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2019-10-09-VMware无法在Windows运行问题解决.html","excerpt":"今天，想用虚拟机看下没有联网的主机的路由器是什么样的。对着VMware的图标，一阵猛戳，然鹅，无事发生。 首先，回忆了一下这阵时间我都做了什么特别的操作。 之前关闭了系统ASRL , 会不会是跟共用内存有什么关闭，恢复ASRL，不行。 然后查看了一下系统服务，发现VM的四个服务都是开启的，重启试试，不行。 会不会是BIOS的问题，然而最近我并没有修改，也没有更新过，排除。 难道是之前没有正常退出？仔细回忆，并没有这种情况。 准备卸载重装，发现有个修复工具，修复完还是老样子。 折腾了半天，卸载了原来的VM，顺便安装了最新的15版本。美滋滋的优雅双击，……我%&amp;@#！*&amp;#@","text":"今天，想用虚拟机看下没有联网的主机的路由器是什么样的。对着VMware的图标，一阵猛戳，然鹅，无事发生。 首先，回忆了一下这阵时间我都做了什么特别的操作。 之前关闭了系统ASRL , 会不会是跟共用内存有什么关闭，恢复ASRL，不行。 然后查看了一下系统服务，发现VM的四个服务都是开启的，重启试试，不行。 会不会是BIOS的问题，然而最近我并没有修改，也没有更新过，排除。 难道是之前没有正常退出？仔细回忆，并没有这种情况。 准备卸载重装，发现有个修复工具，修复完还是老样子。 折腾了半天，卸载了原来的VM，顺便安装了最新的15版本。美滋滋的优雅双击，……我%&amp;@#！*&amp;#@ 于是依旧不能以正确方式上网的我，开始在百度以浪费生命流搜索姿势寻求解决方案，果然啊……浪费生命 这时，我的鼠标开始随机游走。终于，不知为何，它来到了右下角，点开了带有小月亮的消息栏，一排跟VM有关的通知栏点亮了这个又冷又饿的夜晚。 VMware Workstation Pro 无法在 Windows 上运行 要是我没有关系专注模式，应该早就发现了这个问题。但是，弹消息很烦…….以防万一，还是打开了通知模式。 具体的问题是：微软的新发布的一个更新（KB4524147），微软目前似乎并没有推出补丁来修复这个问题，只能将这个补丁卸载并暂停windows更新 这万恶的自动更新，停都停不掉。 解决：控制面板 -&gt;程序与功能 -&gt; 左上角 查看已安装的更新 -&gt; 发现我是10月5号更新的 ，卸载这个KB4524147 这都更新了些啥啊，卸载重启老半天。 另外：关闭自动更新，居然显示最多只能暂停35天…好吧，还挺牛…为啥每次重启完电脑风扇就狂转？服了这小破电脑了 颤抖小手，再次双击，成功辣！ 又要重新新建虚拟机…明天再弄吧…","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://vergessenwang.github.io/tags/虚拟机/"},{"name":"Windows更新","slug":"Windows更新","permalink":"http://vergessenwang.github.io/tags/Windows更新/"}]},{"title":"KG简要构建流程","slug":"KG简要构建流程","date":"2019-10-06T13:43:07.000Z","updated":"2019-10-06T13:44:26.374Z","comments":true,"path":"posts/NLP/2019-10-06-KG简要构建流程.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-06-KG简要构建流程.html","excerpt":"知识图谱可以简单理解为语义网络或多关系图——图结构 涉及技术数据获取 爬虫抓取自己所需的数据——公开或半公开数据 数据库读取已有数据——业务数据 API——第三方数据 所有的数据需要整合到MySQL之类的数据库中——数据持久化 数据预处理 数据清洗：去掉无关信息，提前做字段对齐(数据融合中要用到) 知识抽取：从非结构化文本抽取关键信息 消歧分析：实体统一——比较关键的步骤","text":"知识图谱可以简单理解为语义网络或多关系图——图结构 涉及技术数据获取 爬虫抓取自己所需的数据——公开或半公开数据 数据库读取已有数据——业务数据 API——第三方数据 所有的数据需要整合到MySQL之类的数据库中——数据持久化 数据预处理 数据清洗：去掉无关信息，提前做字段对齐(数据融合中要用到) 知识抽取：从非结构化文本抽取关键信息 消歧分析：实体统一——比较关键的步骤 导入数据到知识图谱 数据筛选——业务所需的知识 知识图谱设计——类似于数据库设计，需要耗费较多时间 批量导入——高效导入历史数据，此时数据已经处理为node-relationship 格式 MySQL -&gt; MySQL Connector -&gt; APOC -&gt; Neo4j 可用neo4j数据库从MySQL中导入数据 可用APOC插件，可实现功能 索引管理：加快查找 图算法：PR 、中心算法 、社区检测 实用函数：域名提取，时间和日期，数字格式转换等 空间函数：地理编码、位置计算、空间与时间搜索等 数据集成：JSON、JDBC、CSV等数据加载——数据传导 图形重构：节点合并、属性规范化与分类等 虚拟节点/关系：创建虚拟图——类似于虚表 Cypher操作：Cypher语句和脚本运行 触发器 增量导入——实时导入更新数据 基于Canal的数据库增量日志解析 Canal Server -&gt; Canal Client -&gt; Kafka producer 基于Kafka的实时分布式消息 Kafka producer -&gt; Kafka -&gt; Kafka consumer -&gt; Neo4j Driver 应用层的搭建基于业务需求在分布式或微服务平台上搭建数据模型 Neo4j -&gt; Restful API 或 Spark Graph X 如抽取实体的相关特征，构建特征工程 基于特征工程用逻辑回归(常用于二分类问题)、GBDT、SVM、神经网络等方法搭建模型——更复杂的模型如DL，需要更多的数据。 定义目标函数：模型的实例化 优化目标函数：训练模型——梯度下降法(迭代比较低效)，随机梯度下降法(参数更新只依赖一个样本，非常高效) 优化目标函数 模型评估：准确率(存在样本不均衡问题，两种错误代价相同问题)、AUC 微服务：将功能按进行细分，每个功能对应一个服务，运行在独立的进程，服务间采用轻量级的通信机制，通常是基于HTTP协议的RESTful API ——基于协议的通信方式，与语言无关。但是不要多度拆分","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"KG","slug":"KG","permalink":"http://vergessenwang.github.io/tags/KG/"}]},{"title":"Jieba分词包使用","slug":"Jieba分词包使用","date":"2019-10-04T09:01:01.000Z","updated":"2019-10-05T14:10:15.777Z","comments":true,"path":"posts/NLP/2019-10-04-Jieba分词包使用.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-04-Jieba分词包使用.html","excerpt":"目前来说，分词和词性标注一般都是同时完成的，而且技术已经相对成熟。 今天来学习下Python里面Jieba库的使用，下一步重点要解决的是命名实体识别的问题。 安装Jieba包安装：命令行pip install jieba pip用于安装及维护Python包。 然后因为特殊原因并不能连上，我真的是笑嘻嘻 换上清华的镜像 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jieba 光速安装完毕 顺便升级下pip python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip 所用算法基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图 (DAG) 采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合 对于未登录词，采用了基于汉字成词能力的 HMM 模型 可以看出，是一种词典和统计相结合的分词方法 jieba原理","text":"目前来说，分词和词性标注一般都是同时完成的，而且技术已经相对成熟。 今天来学习下Python里面Jieba库的使用，下一步重点要解决的是命名实体识别的问题。 安装Jieba包安装：命令行pip install jieba pip用于安装及维护Python包。 然后因为特殊原因并不能连上，我真的是笑嘻嘻 换上清华的镜像 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jieba 光速安装完毕 顺便升级下pip python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip 所用算法基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图 (DAG) 采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合 对于未登录词，采用了基于汉字成词能力的 HMM 模型 可以看出，是一种词典和统计相结合的分词方法 jieba原理 分词模式 精确模式，试图将句子最精确地切开，适合文本分析——默认 jieba.cut 方法接受三个输入参数: 需要分词的字符串；cut_all 参数用来控制是否采用全模式；HMM 参数用来控制是否使用HMM 模型 全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义——列出所有可能的分词 搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词——更适合用于专门文本分析，如特征向量分析 jieba.cut_for_search 方法接受两个参数：需要分词的字符串；是否使用 HMM模型。该方法适合用于搜索引擎构建倒排索引的分词，粒度比较细——搜索引擎模式 jieba.cut以及 jieba.cut_for_search 返回的结构都是一个可迭代的 generator，可以使用 for循环来获得分词后得到的每一个词语(unicode)，或者用jieba.lcut 以及jieba.lcut_for_search 直接返回list 词性标注使用jieba.posseg模块来进行词性标注，利用了HMM和viterbi算法 12345import jieba.posseg as pseg#查看词性words = pseg.cut(\"国庆节快乐\")for word, flag in words: print('%s %s' % (word, flag)) 输出 12国庆节 t快乐 a ICTCLAS 汉语词性标注集 自定义词典 加载自定义词典： jieba.load_userdict(file_name)file_name 为文件类对象或自定义词典的路径 。词典格式和 dict.txt一样，一个词占一行；每一行分三部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。file_name若为路径或二进制方式打开的文件，则文件必须为 UTF-8 编码。 jieba.del_word(&quot;XXX&quot;) 使得某个词语不会出现 jieba.add_word(&quot;XXX&quot;) 添加新词到字典中 jieba.suggest_freq(&quot;XXX&quot;, True) 调整某个词语的词频，使得其在设置的词频高是能分出，词频低时不能分出 分词器更改分词器（默认为jieba.dt）的 tmp_dir 和 cache_file属性，可分别指定缓存文件所在的文件夹及其文件名，用于受限的文件系统 新建自定义分词器：jieba.Tokenizer(dictionary=DEFAULT_DICT) ，可用于同时使用不同词典。jieba.dt 为默认分词器，所有全局分词相关函数都是该分词器的映射。","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"Jieba","slug":"Jieba","permalink":"http://vergessenwang.github.io/tags/Jieba/"},{"name":"分词","slug":"分词","permalink":"http://vergessenwang.github.io/tags/分词/"},{"name":"词性标注","slug":"词性标注","permalink":"http://vergessenwang.github.io/tags/词性标注/"}]},{"title":"实用算法前三章笔记","slug":"实用算法前三章笔记","date":"2019-10-02T13:42:35.000Z","updated":"2019-11-12T15:37:43.290Z","comments":true,"path":"posts/data-structure/2019-10-02-实用算法前三章笔记.html","link":"","permalink":"http://vergessenwang.github.io/posts/data-structure/2019-10-02-实用算法前三章笔记.html","excerpt":"CH0参考书： 《程序员实用算法》 《编程珠玑》(第二版) 《算法导论》 课前：阅读代码并验证其性能，调研STL库 课后：加深对算法设计思想的理解。(自己理解了一个问题跟用自己的话向别人解释是有很大区别的) 本课程的重点：依据问题定义、输入数据的特征和要求输出的数据的特征，分析广泛的解决方案（数据结构+算法），并选择最佳的解决方案 CH1 绪论重点：算法的概念、算法与相关术语的关联难点：算法时间复杂度的估算","text":"CH0参考书： 《程序员实用算法》 《编程珠玑》(第二版) 《算法导论》 课前：阅读代码并验证其性能，调研STL库 课后：加深对算法设计思想的理解。(自己理解了一个问题跟用自己的话向别人解释是有很大区别的) 本课程的重点：依据问题定义、输入数据的特征和要求输出的数据的特征，分析广泛的解决方案（数据结构+算法），并选择最佳的解决方案 CH1 绪论重点：算法的概念、算法与相关术语的关联难点：算法时间复杂度的估算 什么是算法： 描述了特定问题的有限求解步骤； 指为了解决特定问题，而操作数据的方式； 指求解问题的策略 五大特征：有穷性、确定性、可行性、零或多个输入、一或多个输出 五大要求：正确性、可读性、健壮性、高效率、低存储 程序： 指为计算机处理问题而编制的一组指令 算法 + 数据结构 = 程序 数据结构 性质相同的数据元素的有限集合及其上的关系的有限集合（数据+结构） 是描述现实世界实体的数据模型及其上的操作在计算机上的表示和实现 包括逻辑结构和存储结构/物理结构 数据类型：系统定义的int, char等，用户自定义的struct类型。也可采用typedef将类型名重命名，以增加代码的可读性。 数据结构的选择是与具体问题以及相应的约束密切相关的。 而且有时候采用一些特殊的存储结构，可以使得解决算法相当巧妙。 时间复杂度一般我们用大O来进行比较，但是这只是一个大致的比较，在相差比较大的时候很有用。如果两个算法的大O是一样，则还要从实际运算时间去比较，因为可能有的语句涉及到了调用，本身需要多步执行，这样在实际运行的时候就会有很大的差异。 另外数据本身的规律也会影响时间复杂度，如在排序算法中经常会比较最好和最坏情况。 空间复杂度内存 + 栈空间 经典的节省空间方法：bitmap 通过在C++中对分配空间后的地址进行计算，可得知每次分配的内存实际上都是大于数据类型本身的大小的。在这里，是直接算的首末地址的差值，注意与用sizeof的时候涉及的数据对齐问题相区别。 申请1~8B：实际分配32B；申请9~16B：实际分配40B；申请17~24B：实际分配48B。申请分配内存空间1次，额外开销为： 24~31B 由此看见，每一次分配内存实际都会有额外的开销，会降低Cache的存储密度从而降低算法的执行性能，同时内存的分配和销毁也是一个耗时的工作。要尽量减少分配内存的次数，可以用内存池等方法来解决。 代码优化 尽量减少输入输出 扩展缓冲区 减少函数调用的次数 限制计算密集型操作（浮点运算，除法运算）； 确定最耗时的操作，并提高其性能 可用测量和跟踪工具（如， Profiler，AQTime） 影响选择算法的决定性因素 问题时间和空间的约束 存何种信息，数据结构 输入输出数据的特征 CH2 线性表参考: 实用算法第2章 编程珠玑 1.4 13.4 重点：理解线性表的逻辑特点；掌握线性表两种存储结构的特点、实现（C定义）及其基本操作的实现、适用范围；掌握算法的描述方法：伪代码和算法流程图；会粗略分析算法的时间复杂度（三种情况下）和内存开销。 难点：对于给定的应用需求——设计数据结构的一般过程 判断是否需要用到DS？——操作对象为：取值为同种类型的很多数据，且这些数据间存在某种关系 或者 某些共性操作 判断是否适合用线性表来刻画同类数据之间的关系？（逻辑结构）——被操作的数据之间没有天然的一对多 和 多对多的关系 ；对已存储的数据进行处理时，处理顺序 有明显的唯一的先后次序关系 设计线性表的存储结构（包括：存储哪些数据（包括数据类型和取值）？顺序存储/链式存储的选择？） （数据+存储结构）——取决于数据处理时的最频繁操作，为静态操作，还是动态操作？ 编码实现数据的存储结构—— 学会画图设计DS并实现 利用线性表的基本操作来解决问题 四类数据结构： 集合：元素间无任何关系，即关系集合是空集： S={} 如C中的枚举 线性：1:1 树形：1:n 图形：n:n 图形渲染的例子： 红 —— 线性 紫—— 树形 基本操作 创建空的线性表 销毁已有线性表 查找直接后继和直接前驱 插入一个元素 删除一个元素 存储结构：顺序表和链表两种方式 健壮性：从数据操作的位置 和 空间是否上溢或下溢 两个方面来考虑 顺序表在内存中连续存储的线性表 ，用下标来表明线性特征 静态定义：数组12345#define List_Size 100/*分配空间的大小*/Typedef Struct&#123;int elem[List_Size ]; /*存储空间*/int len; /*实际长度*/&#125;SqList_static; 类似STL:vector 在编译的时候， 系统在函数栈中分配连续的内存空间。当静态顺序表所在的函数执行完毕后，由系统来回收所开辟的内存空间。 缺点：空间分配不够灵活 动态定义：指针123456#define List_Size 100 /*分配空间的大小*/typedef struct&#123;int *elem; /*顺序表的存储空间*/int len; /*实际长度*/int ListSize ; /*当前分配的空间大小*/&#125; Sqlist; 用malloc() realloc() free() 手动管理空间分配，实现了灵活，但增加了开销——CH1 中的内容可知，每次分配内容都是有额外开销的 malloc原理 关于malloc之后再仔细研究一下 初始化 123456789int InitSqList(SqList *L)//构造一个空的顺序表L&#123;L-&gt;elem=(int *) malloc(List_Size *sizeof(int));if (L-&gt;elem==NULL)exit(EXIT_FAILURE);L-&gt;len=0;L-&gt;ListSize =List_Size;return 1;&#125; 静态 VS 动态都是连续的空间，增、删、查的方式一样；区别在于对内存的分配和回收方式上 由此可以看出：数组≠顺序表 并不是只有链表中才能有指针 不要建立 “数组形式即为顺序表，有指针即为链表的刻板印象” 插入元素12345678910111213141516171819Status ListInsert_Sq( SqList &amp;L, int i, ElemType e)&#123;// 位置合法性的判断if ( i&lt;1 || i&gt;L.len +1 ) return 0;// 上溢时增加空间的分配if( L.len &gt;= L.listsize)&#123;newbase = (ElemType *) realloc(L.elem,(L.listsize+ LISTINCREMENT)*sizeof(ElemType));if ( newbase == NULL ) exit(OVERFLOW);L.elem = newbase;L.listsize += LISTINCREMENT;&#125;// 插入元素for ( j = L.len; j &gt;= i; j--) L.elem[j] = L.elem[j-1];L.elem[i-1] = e;L.len++;return 1;&#125; 删除元素12345678Status ListDelete_Sq( SqList &amp;L, int i) &#123;// 位置合法性的判断if ( i&lt;1 || i&gt;L.len ) return 0;// 删除for ( j = i; j &lt; L.len ; j++) L.elem[j-1] = L.elem[j];L.len--;return 1;&#125; 链表用链来表明线性特征 123456struct Node&#123;int data;struct Node *next&#125;;&#125;;Typedef struct Node *Link;Link head; 插入算法有头结点1234567891011121314Status ListInsert(LinkList &amp;L, int i, ElemType e)&#123;// 有头结点，无须对i为1的插入位置作特殊处理p = L; j = 0; // 对p,j初始化; *p为L的第j个结点while( p != NULL &amp;&amp; j&lt;i-1)&#123; p = p-&gt;next; j++; // 寻找第i-1个结点的位置&#125;if( p == NULL || j&gt;i-1) return ERROR;// i小于1或大于表长s = (LinkList )malloc(sizeof(LNode)); // 生成新结点if ( s == NULL ) exit(OVERFLOW);// 空间分配不成功，报错返回s-&gt;data = e; s-&gt;next = p-&gt;next; // 插入L中p-&gt;next = s;return OK;&#125; 无头结点123456789101112131415161718192021Status ListInsert(LinkList &amp;L, int i, ElemType e) &#123;// 无头结点，须对i为1的插入位置作特殊处理if ( i==1)&#123;s = (LinkList )malloc(sizeof(LNode)); // 生成新结点if ( s == NULL ) exit(OVERFLOW); // 空间分配不成功，报错返回s-&gt;data = e; s-&gt;next = L; // 插入到链表L中L = s; // 修改链头指针L&#125;else&#123;p = L; j = 1; // 对p,j初始化; *p为链表的第j个结点while( p != NULL &amp;&amp; j&lt;i-1)&#123;p = p-&gt;next;j++; // 寻找第i-1个结点的位置&#125;if( p == NULL || j&gt;i-1) return ERROR;// i小于1或大于表长s = (LinkList )malloc(sizeof(LNode)); // 生成新结点*sif ( s == NULL ) exit(OVERFLOW); // 空间分配不成功，报错返回s-&gt;data = e; s-&gt;next = p-&gt;next; // 插入到链表L中p-&gt;next = s;&#125;return OK;&#125; 区别在于是否对i为1的插入位置作特殊处理 ,实际上是对于第一个结点而言是否有前驱结点 STL:list 是一个双向链表 12345678910Struct Node&#123;ElemType data;struct Node *prior;struct Node *next;&#125;;typedef struct Node * Link;typedef struct &#123;Link head, tail;int len;&#125;DLinkList;","categories":[{"name":"data_structure","slug":"data-structure","permalink":"http://vergessenwang.github.io/categories/data-structure/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://vergessenwang.github.io/tags/数据结构/"},{"name":"线性表","slug":"线性表","permalink":"http://vergessenwang.github.io/tags/线性表/"},{"name":"算法","slug":"算法","permalink":"http://vergessenwang.github.io/tags/算法/"}]},{"title":"几种分词算法对比","slug":"几种分词算法对比","date":"2019-10-01T15:17:25.000Z","updated":"2019-10-05T11:39:34.744Z","comments":true,"path":"posts/NLP/2019-10-01-几种分词算法对比.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-01-几种分词算法对比.html","excerpt":"句法语义分析：对于给定的句子，进行分词、词性标记、命名实体识别和链接、句法分析、语义角色识别和多义词消歧 信息抽取：从给定文本中抽取重要的信息。比如时间、地点、人物、事件、原因、结果、数字、日期、货币、专有名词等。涉及到实体识别、时间抽取、因果关系抽取等关键技术 文本挖掘：包括文本聚类、分类、信息抽取、摘要、情感分析，以及对挖掘的信息和知识的可视化、交互化表达界面。目前主流的技术都是基于统计机器学习的 问答系统(我目前研究的方向)： 对一个自然语言表达的问题，由问答系统给出一个精准的答案。需要对自然语言查询语句进行某种程度的语义分析，包括实体链接、关系识别，形成逻辑表达式，然后到知识库中查找可能的候选答案并通过一个排序机制找出最佳的答案——目前基于知识图谱的问答系统还是挺好用的 分词是中文NLP的基础。","text":"句法语义分析：对于给定的句子，进行分词、词性标记、命名实体识别和链接、句法分析、语义角色识别和多义词消歧 信息抽取：从给定文本中抽取重要的信息。比如时间、地点、人物、事件、原因、结果、数字、日期、货币、专有名词等。涉及到实体识别、时间抽取、因果关系抽取等关键技术 文本挖掘：包括文本聚类、分类、信息抽取、摘要、情感分析，以及对挖掘的信息和知识的可视化、交互化表达界面。目前主流的技术都是基于统计机器学习的 问答系统(我目前研究的方向)： 对一个自然语言表达的问题，由问答系统给出一个精准的答案。需要对自然语言查询语句进行某种程度的语义分析，包括实体链接、关系识别，形成逻辑表达式，然后到知识库中查找可能的候选答案并通过一个排序机制找出最佳的答案——目前基于知识图谱的问答系统还是挺好用的 分词是中文NLP的基础。 基于词表的分词算法基于词典的分词过度依赖词典和规则库，因此对于歧义词和未登录词的识别能力较低；其优点是速度快，效率高 正向最大匹配法正向最大匹配法，对于输入的一段文本从左至右、以贪心的方式切分出当前位置上长度最大的词。正向最大匹配法是基于词典的分词方法，其分词原理是：单词的颗粒度越大，所能表示的含义越确切。 12345678910111213141516171819202122def cut_words(raw_sentence, word_dic): max_length = max(len(word) for word in words_dic) # 统计词典中最长的词 sentence = raw_sentence.strip() words_length = len(sentence) cut_word_list = [] # 存储切分好的词 while words_length &gt; 0: max_cut_length = min(max_length,words_length) subsentence = sentence[0:max_cut_length] while max_cut_length &gt; 0: if subsentence in words_dic: cut_word_list.append(subsentence) break elif max_cut_length == 1: cut_word_list.append(subsentence) break else: max_cut_length -= 1 subsentence = subsentence[0:max_cut_length] sentence = sentence[max_cut_length:] words_length -= max_cut_length words = \"/\".join(cut_word_list) return words 逆向最大匹配法从右至左。 只需改变切分方式 subsentence = sentence[-max_cut_length:] sentence = sentence[0:-max_cut_length] 并将切分好的序列逆序 cut_word_list.reverse() , 再join即可 结果分析 1234请输入您要分词的序列我毕业于中南财经政法大学金融系，现在在中国科技大学学软件工程。分词结果我/毕业/于/中南财经政法大学/金融系/，/现在/在/中国/科技/大/学学/软件工程/。 可以看出：从后向前的分词方法有很大的缺陷 FMM和BMM难以解决歧义问题——解决：双向最大匹配法 双向最大匹配算法 双向最大匹配法是将正向最大匹配法得到的分词结果和逆向最大匹配法的到的结果进行比较，从而决定正确的分词方法。 启发式规则： 如果正反向分词结果词数不同，则取分词数量较少的那个——单词的颗粒度越大，所能表示的含义越确切 如果分词结果词数相同 分词结果相同，就说明没有歧义，可返回任意一个 分词结果不同，返回其中单字较少的那个 实现：将FMM和BMM的返回值改为切分好的序列，经比较之后返回更为准确的分词结果 123456789101112131415161718192021222324252627282930import FMM2import BMM2def bimm_cut_words(raw_sentence, words_dic): fmm_word_list = FMM2.cut_words(raw_sentence, words_dic) bmm_word_list = BMM2.cut_words(raw_sentence, words_dic) fmm_word_list_len = len(fmm_word_list) bmm_word_list_len = len(bmm_word_list) if bmm_word_list_len != fmm_word_list_len: if bmm_word_list_len &lt; fmm_word_list_len: return bmm_word_list else: return fmm_word_list else: fsingle = 0 bsingle = 0 issame = True for i in range(len(fmm_word_list)): if fmm_word_list[i] != bmm_word_list[i]: issame = False if len(fmm_word_list[i]) == 1: fsingle += 1 if len(bmm_word_list[i]) == 1: bsingle += 1 if issame: return fmm_word_list elif fsingle &gt; bsingle: return bmm_word_list else: return fmm_word_list 基于词典的问题：即使只是去切分一个句子，仍然需要2~3秒的处理时间，这在处理大文本的时候，很显然将成为性能的瓶颈。 分析算法可知，基于词典的遍历，在匹配时也是用的蛮力搜索，可以说是相当的暴力，基本上没有任何优化，只实现了基本的功能。 基于统计模型的分词算法基于N-gram语言模型的分词方法利用统计信息找出一条概率最大的路径。 当样本量很大的时候，基于大数定律，一个短语或者词语出现的概率可以用其频率来表示。——用统计方法的前提是有大量的样本。同时基于1阶马尔科夫假设：一个词wi出现的概率只与它前面的wi-1有关 $P(w_i | w_{i-1}) = count (w_i,w_{i-1})/count(w_{i-1})$ 基于序列标注的分词算法基于HMM的分词方法(生成式)把分词问题转为字的分类问题(序列标注问题)——由字构词，不依赖事先编制好的词表，但仍然需要分好词的训练语料 单字S，开始B-中间M-结尾E ， 已知观察序列求对应的形式化序列 基于CRF的分词方法(判别式)同HMM一样，也是基于序列标注，但它是一个判别式模型。不仅考虑了文字词语出现的频率信息，同时考虑上下文语境，具备较好的学习能力，因此其对歧义词和未登录词的识别都具有良好的效果；其不足之处是训练周期较长，计算量较大 分词所使用的是Linear-CRF，它由一组特征函数组成，包括权重λ和特征函数f，特征函数f的输入是整个句子s、当前posi、前一个词位li-1，当前词位li HMM VS 最大熵 VS CRF CRF， HMM都常用来做序列标注的建模，像分词、词性标注，以及命名实体标注 隐马模型一个最大的缺点就是由于其输出独立性假设，导致其不能考虑上下文的特征，限制了特征的选择 最大熵隐马模型则解决了隐马的问题，可以任意选择特征，但由于其在每一节点都要进行归一化，所以只能找到局部的最优值，同时也带来了标记偏见的问题，即凡是训练语料中未出现的情况全都忽略掉 条件随机场则很好的解决了这一问题，他并不在每一个节点进行归一化，而是所有特征进行全局归一化，因此可以求得全局的最优值。 基于深度学习的端到端的分词方法需要大量的语料 输入层是一个embedding层，经过双向LSTM网络编码，输出层是一个CRF层。经过双向LSTM网络输出的实际上是当前位置对于各词性的得分， CRF层的意义是对词性得分加上前一位置的词性概率转移的约束，其好处是引入一些语法规则的先验信息 学习来源：网页云课堂《动手学中文分词》","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"HMM","slug":"HMM","permalink":"http://vergessenwang.github.io/tags/HMM/"},{"name":"词典","slug":"词典","permalink":"http://vergessenwang.github.io/tags/词典/"},{"name":"CRF","slug":"CRF","permalink":"http://vergessenwang.github.io/tags/CRF/"}]},{"title":"NLP知识简要梳理","slug":"NLP知识简要梳理","date":"2019-09-29T14:29:06.000Z","updated":"2019-10-06T14:35:56.999Z","comments":true,"path":"posts/NLP/2019-09-29-NLP知识简要梳理.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-09-29-NLP知识简要梳理.html","excerpt":"等我草草刷完一遍NLP领域的相关知识，才发现工程实践的综合性太强了，几乎涉及到了NLP的所有！核心知识！而且还要结合KG!暴风哭泣，我好害怕做到一半做不出来。。。啊，我好菜啊。。。我怎么什么都不懂。。。 自然语言：语音、文字 NLP：研究语言能力和语言应用的模型，建立算法框架来实现这样的语言模型，并完善和评测。最终用于设计各种实用系统。 是语言学、计算机科学、统计学的交叉学科。属于AI领域的子领域。 处理粒度：文档库 -&gt; 文章 - &gt; 段落 -&gt; 句子 -&gt; 词 发展历程以语言学为基础：建立基本语言规则，使用数理逻辑进行推理，建立模型或理解语言——语法语义，形式语言理论 以统计学为基础(目前)：在足够大的数据的基础上，分析规则，产生智能。业务知识相对不重要——对材料的数量有要求 未来的趋势是深度学习等AI最新技术","text":"等我草草刷完一遍NLP领域的相关知识，才发现工程实践的综合性太强了，几乎涉及到了NLP的所有！核心知识！而且还要结合KG!暴风哭泣，我好害怕做到一半做不出来。。。啊，我好菜啊。。。我怎么什么都不懂。。。 自然语言：语音、文字 NLP：研究语言能力和语言应用的模型，建立算法框架来实现这样的语言模型，并完善和评测。最终用于设计各种实用系统。 是语言学、计算机科学、统计学的交叉学科。属于AI领域的子领域。 处理粒度：文档库 -&gt; 文章 - &gt; 段落 -&gt; 句子 -&gt; 词 发展历程以语言学为基础：建立基本语言规则，使用数理逻辑进行推理，建立模型或理解语言——语法语义，形式语言理论 以统计学为基础(目前)：在足够大的数据的基础上，分析规则，产生智能。业务知识相对不重要——对材料的数量有要求 未来的趋势是深度学习等AI最新技术 NLP的研究内容 信息检索：搜索引擎，要求分词歧义处理、文档质量判断、去重 机器翻译 文档分类：基于距离的文本聚类 问答系统：基于答案库 信息过滤 自动文摘 信息抽取：将无结构的数据整理成结构化的数据以供检索——命名实体抽取 文本挖掘 舆情分析：情感分析——基于监督的文本分类 词库匹配 基于正负样本构建分类器 机器写作：形式语言处理 如自动股评：先分为行情和预测两部分，每一部分都可以有多种文法来自动生成句子 文稿机器校对 OCR或语音识别 困难场景：语言的多样性、多变性、歧义性 学习：数学模型——概率图模型、隐含马尔科夫过程、最大熵模型、条件随机场 语料：定义、作用、获得途径 基于语言学的理论描述语言的三种途径：穷举法、文法(产生式系统描述)、自动机法 形式语言 集合论 字符串——语言是一定规律的字符串的有限或无限的集合 连接 集合乘积 闭包 图论(离散数学) 形式语法是一个四元组(非终结符，终结符，产生式(推理规则)，初始符) ==&gt; 句子 推导 规约——中间有多次推导 文法的构造：一般来说，根据语言构造文法没有太直接的方法可用，它需要构造者本人所具有的经验。同一种语言可有多种文法。 形式语言的应用： 一些结构化语言：如SQL语法图 机器写作 自动机理论四型文法：——类似于数据库的设计范式 正则文法——3型文法，顺序线性产生 左右线性正则文法是等价的 上下文无关文法——2型文法 上下文有关文法——1型文法 无约束文法——0型文法 越规范越易于处理 有限自动机(DFA)： M 五元组 (输入符号，状态集合，映射，初始状态，终止状态) 对于任意一个正则文法，总可以确定一个对应的DFA 下推自动机(PDA)： 可看成一个带有附加下推存储器(一个堆栈)的有限自动机 七元组 对于上下文无关文法，可以构造一个下推自动机。由于正则文法是上下文无关文法的子集，因此也可以出离正则文法 线性界限自动机——对应上下文有关文法 图灵机——对应无约束文法 自动机的应用： 单词自动查错纠正 编辑距离 词性消歧 状态转换机 形式语言的缺陷 对于汉语这样的大型自然语言系统，难以构造精确的文法 语法正确的句子可能是无意义的 解决：基于大量预料，采用统计学手段建立模型 统计自然语言处理只有在数据不够充足的情况下，我们才需要更加借助业务知识。 n元语言模型通过概率，计算某个句子的概率。——条件概率，为了简化计算并减少空间占用，只计算与前一个字有关的概率 一般步骤 收集大量语料：基础工作，工作量最大 对语料进行统计分析，得出知识(概率)——例如n元文法 针对场景建立算法 ，即使是计算简单的概率也有很多复杂的算法可以运用，有些可以直接标注 解释或应用结果 性能评价常用指标：交叉熵、困惑度 数据平滑：加法平滑、古德-图灵估计法、Jelinek-Mercer平滑方法 语言模型的缺陷 在训练语言模型时所采用的的语料往往来自多种不同的领域，这些综合型语料难以反映不同领域之间在语言使用规律上的差异，而语言模型恰恰对于训练文本的类型、主题和风格都非常敏感——非常依赖语料库，数据来源是多领域而应用比较专业时效果往往比较差 n元语言模型的独立性假设前提是当前词出现的概率仅与前面的n-1个词相关，这种假设比较脆弱 应用：——选择最高概率的做出结果输出 语音识别歧义消除 汉语分词问题 概率图模型基于图的概率表示，计算联合分布的概率 有向图——贝叶斯网； 无向图——马尔科夫网 不同视角： 图 -&gt; 图导出的独立关系 -&gt; 图导出的因子分解 An Introduction to Conditional Random Fields 分类器产生式模型：朴素贝叶斯——先估算联合概率密度，再用贝叶斯公式，在少量样本情况下，可以取得更好的精确率 判别式模型：logistics回归——直接估算，在样本增加的情况下，逐渐逼近前者的精确率 两者关系 朴素贝叶斯 -&gt;(序列化) -&gt; 隐马尔可夫 -&gt;(去掉一些限制条件) -&gt; 条件随机场 logistics回归 -&gt;(序列化) -&gt; 条件随机场 马尔科夫及HMM马尔科夫链的应用： 压缩算法 排队论 语言识别 基因预测 搜索引擎鉴别网页质量的RP值 隐马尔可夫的应用： 语音识别 分词 缺陷： 只能根据顺序(马尔科夫性)来计算，有些特征没有办法刻画——解决最大熵 生成式模型，需要给出状态和符号之间的联合概率分布，把观察符号割裂为相互独立的验资结构，无法提现依赖关系，标注偏置——解决：条件随机场 最大熵模型在只掌握了未知分布的部分信息的情况下，符合已知知识的可能有多个，但是熵值最大的概率分布最真实地反映了事件的分布情况 数学表达：特征 参数估计：GIS算法 最大熵马尔科夫模型：因为加入了特征，克服了马尔科夫只能适应线性的缺陷 条件随机场(最难理解)给定随机变量X的条件下，随机变量Y的马尔科夫随机场。 参数化形式 特征模板 前向-后向算法 具体理论部分以后细看吧…这会真滴看不懂 CRF应用：把NLP问题转为标注问题——命名实体识别，标注，句法分析，词法分析 收集大量已经标注好的语料 建立特征模板，由软件系统自动扫描语料并按模板生成特征函数。对重复出现的特征进行强化 训练，参数估计，确立模型 给模型输入观测序列，模型预测其标注序列 汉语分词自动分词，命名实体识别，词性标注 存在的问题分词规范问题：切分粒度 歧义切分问题：交集型、组合型、多义组合型——问题不大 未登陆词问题：人名、地名、组织名、术语、术语、新词——占比98%，主要关注问题 分词发展基于词典 -&gt; 最少词数分词 -&gt; 用统计模型解决分词歧义 -&gt; 无词典统计方法分词 词典：——精度不高，但简单性能好 正向最大匹配法、逆向最大匹配法、双向匹配法 逐词遍历法 基于词表的分类法 实现：树、散列表、布隆过滤器 统计方法： N-最短路径方法 基于词的n元语法模型——语言模型 由字构词——把分词问题看成标注问题，即CRF——不适用于海量数据 基于词感知机算法 生成式和判别式相结合 词典其实可以看成一种没有上下文关系，只有词的特殊语料库。 性能指标 精确率 召回率 $F$值——前两个指标的调和平均 中文分词十年回顾 命名实体识别(发展较差) 基于多特征的命名实体识别模型 基于CRF 未登录词处理方法(重要)基于规则的方法、机器学习方法 词性标注汉语语法分析“三姐妹”：分词(较成熟)、实体命名识别(发展较差)、词性标注(较成熟)。 在工程实现里，词性标注和分词同时完成 基于HMM的方法——相比于CRF对语料的要求更宽松，基于较少的标注就可以得到不错的结果，速度也更快 文本分类选取适当的特征及权重，将文本量化映射为样本空间中的样本。 通过在样本空间构建适当的分类器或聚类解决文本分类问题，通过计算向量余弦计算文本相似度。 文本特征选择方法 基于文本频率的特征提取方法——太高太低都不行 信息增益法——熵的差值 $X^2$统计量——关联程度 互信息法——共现程度 LDA模型(较难)抽词建立文档 分类器性能评测 应用： 网页自动分类 判断垃圾邮件 情感分析 句法分析 基于PCFG——上下文无关 结构分析 浅层句法分析——完全句法分析的简化版，包括语块识别与分析和语块依附关系两部分 baseNP —— 转成标注问题 依存关系——以动词为中心 判别式 序列标注 语义分析语义消歧 篇章分析指代消解——技术难度极高 自动抽取文摘—— 给句子打分，抽取每段中的高分句子。句子之间必须做篇章衔接性的处理，即句子消融。过程：对原文进行分词 -&gt; 特征分析统计 -&gt; 计算词的权重 -&gt; 根据主题词计算句子的权重 -&gt; 根据摘要句生成摘要 基于LDA的单文档摘要 多文档摘要：基于单文档抽取的句子，如何解决排列问题，如何上下文融合 问答系统问题分析 + 信息检索 + 答案抽取 基于问题-答案对的问答系统——根据日常经验形成的有问题-答案数据库 基于自由文本的问答系统——只有知识库，没有标准答案对。对答案进行分析后，知识库抽取信息对原问题中的句子进行替换，这可能会产生多个句子，所以还需要将这些句子拿去与原文匹配，找出存在的证据。每找出一次证据，给句子加分，最后选出得分最高的句子。 极其复杂，几乎用到了NLP中所有技术 问题分析：问句分类，主题识别，语法分析，指代消解，命名实体识别，名词短语，动词短语抽取 信息检索：文本检索，隐语义析取，相似度计算 答案提取：文档摘要 工具中文分词工具 语料库： LIAVC：香港城市大学建立 LDC中文树库 WordNet FrameNet EDR 北京大学综合型知识语言库 知网 概念层次网络 词性标注： tagger 语言模型： SRILM HMM: HTK: 主要用于大规模语音识别系统 最大熵： openNLP：有java的API MALLET NLTK：python CRF: CRF++ 分词： ICTCLAS/NLPIR Jieba——python 庖丁解牛——java 命名实体识别： Stanford NER: 英文，CRF 问答机器人： 图灵机器人 关于语料：要么提供明确的业务逻辑，比如在信息的哪一个部分能够提取到所需的信息；或者提供一个词典，词典中的都是想摘取的信息；要不基于大量标注好的学习材料，建立一个学习模型 顶尖会议及人物中文信息学会 ccks 赵海 有兴趣可以参加会议相关比赛…","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"分词","slug":"分词","permalink":"http://vergessenwang.github.io/tags/分词/"},{"name":"问答系统","slug":"问答系统","permalink":"http://vergessenwang.github.io/tags/问答系统/"},{"name":"命名实体识别","slug":"命名实体识别","permalink":"http://vergessenwang.github.io/tags/命名实体识别/"}]},{"title":"高级网络前四章笔记","slug":"高级网络前四章笔记","date":"2019-09-26T13:50:24.000Z","updated":"2019-09-26T13:58:17.075Z","comments":true,"path":"posts/network/2019-09-26-高级网络前四章笔记.html","link":"","permalink":"http://vergessenwang.github.io/posts/network/2019-09-26-高级网络前四章笔记.html","excerpt":"在赵老师的第一节高级网络结束之后，各位同学表示很开心，能学到很多前沿的东西，了解计算机网络的核心。他们兴致冲冲的说：”要不，咱们回去退课吧！….” 不过三周的学习过后，暂时还跟得上，可能因为还在讲一些基础的内容。 CH0教材《TCP/IP协议族》然而教材只包含上课内容的极小一部分，很多东西要自己拓展学习。 其他参考书：《计算机网络自顶向下》 《TCP/IP详解》 社区：http://www.ietf.org/rfc.html 基础 硬件：网卡(适配器)的原理——加上MAC地址，串并转换 软件： 查看端口情况 netstat -ano 列出运行中的端口 TASKLIST /FI &quot;PID eq 1048&quot; 查询使用端口的程序名 taskkill /f /t /im 程序名 终止进程 netstat -aon|findstr &quot;端口号&quot; 查询是哪个进程在占用端口 tasklist|findstr &quot;进程号&quot; 查询是哪个程序在占用 taskkill /pid 进程号 /f 终止进程 网络分层协议","text":"在赵老师的第一节高级网络结束之后，各位同学表示很开心，能学到很多前沿的东西，了解计算机网络的核心。他们兴致冲冲的说：”要不，咱们回去退课吧！….” 不过三周的学习过后，暂时还跟得上，可能因为还在讲一些基础的内容。 CH0教材《TCP/IP协议族》然而教材只包含上课内容的极小一部分，很多东西要自己拓展学习。 其他参考书：《计算机网络自顶向下》 《TCP/IP详解》 社区：http://www.ietf.org/rfc.html 基础 硬件：网卡(适配器)的原理——加上MAC地址，串并转换 软件： 查看端口情况 netstat -ano 列出运行中的端口 TASKLIST /FI &quot;PID eq 1048&quot; 查询使用端口的程序名 taskkill /f /t /im 程序名 终止进程 netstat -aon|findstr &quot;端口号&quot; 查询是哪个进程在占用端口 tasklist|findstr &quot;进程号&quot; 查询是哪个程序在占用 taskkill /pid 进程号 /f 终止进程 网络分层协议 分析：用抓包软件获取数据报并分析其二进制对应的内容 高级： 多线程时，如何处理线程与端口的对应关系 proxy 代理的原理 协议4.4BSD 源码分析 Hourglass模型：简化核心网 软件定义网络SDN (如OpenFlow) 集中式可编程管控——复杂路由,数据平面和控制平面分离 网络虚拟化 NFV ，云化池化虚拟 TCP/IP 向 RCP 演进的趋势——重新给路由器将入处理功能，内容区块作为连接 对网络设备潜力进行开发的智能应用，如无线结点用于导航 新的应用需求和通信技术对协议的推进 课程要求 学会将C/S 、P2P 模型与Socket、以太网等观点有机结合起来理解 熟悉TCP/IP 协议 、 网络体系结构、 擅长Socket 编程 CH1发展简史 第一个网络ARPANET——冷战产物——不同主体之间通信采用的协议不同，比较复杂——网络 第一个协议NCP(复杂链路) -&gt; TCP/IP(简单链路)——协议 第一个无线网络Aloha, 解决了信道碰撞冲突 -&gt; 以太网 UNIX 学术版发布 ——OS ISPs 创立 —— 运营 InternetInternet(因特网)是Internet(网际网)的子集，产生于协议、技术和应用需求的多重推动。 基于TCP/IP协议 体系结构：主机连到某一物理网络，各物理网络通过路由器互连，国际ISP通过NAP(network access point)互连 Internet标准—— RFC（Request For Comments）——如一些常见的协议： 0791 Internet Protocol 1256 ICMP Router Discovery Messages 1460 Post Office Protocol 1788 ICMP Domain Name Messages 标准的种类：Required、Recommended 、Elective 、Limited use 、Not recommended 分析协议的角度 三个要素：Syntax 语法、Semantics 语义 、Timing 时序 依赖于哪些技术 应用的驱动力是什么，对于新的需求有无更好的策略 可以想象一下协议运行的过程，用到什么算法，时序是怎样的，时间复杂度是多少，还有无改进之处 例如语言、交通规则都可视为一种协议，可尝试理解这里面的要素 课堂例子：一个工作10年的建筑系女生最后去了硅谷…她会经常用自己的话去描述学到的东西。转专业的同学，要学会发挥自己的专业优势 如何阅读和评论文献关注领域顶尖组织和会议：了解前沿问题 与自己研究领域直接相关的论文——热点问题或具有首创性和前瞻性 仔细反复阅读 新观点和新技术提出的历史依据和原因 解决方案的价值 Does it solve an important problem? 创新之处 new problem? new solutions? new evaluation methods/techniques? 带来的启发 同时还要找出论文的局限和缺陷(难点) Check assumptions, problem settings Check how fast the solution works, how long the solution can sustain… 如何评论 不要用原文内容，用自己的话进行阐述 3个重点 + 1个缺陷 好的论文结构——具体内容以后写论文时可再回头来研究 Abstract (1/8~1/4 page) Introduction section (1 page) Background section (0.5~0.75 page) Design section (3.5 page) Implementation section (1 page) Evaluation section (3.5 page) Discussion section (0.75 page) Related work section (0.5~0.75 page) Conclusion section (0.25~0.5 page) 反正，多读多看就完事了…看的少也看不出什么缺陷来… CH2 OSI &amp; TCP/IP关于分层 好处：降低复杂性，易拓展等 缺点：效率较低 特征：每层关注自己的细节，并为上层提供服务。通过协议与同层通信 不同节点：层次组成不同，作用不同 横向理解：虚通信，对等实体，协议，PDU 纵向理解：封装与解封，服务，接口 OSI七层概念模型各层功能 物理层：bit传输 链路层：hop - to - hop 网络层：host - to - host 传输层：end - to - end 可靠 会话层：SYN同步 表示层：编/解码，加/解密，数据压缩/解压缩 TCP/IP 四层模型中的协议族 应用层：注意端口号 基于TCP: FTP HTTP SMTP DNS? 基于UDP: DNS TFTP SNMP (socket) 传输层：TCP-6 UDP-17——封装端口号 网络层：IP(IPV4 -&gt; IPV6) ICMP IGMP ARP RARP——封装IP 网际层：LANs MANs WANs——封装MAC 注意区别 OSI vs. ISO Physical address vs. MAC address —不是很能区别 Network address vs. IP address CH3 底层网络技术传输介质UTP双绞线：五种质量型号 差别在于单位距离上的螺旋的数目 第三类：传输频率为16MHz，主要用于10base-T 第四类：传输频率为20MHz，主要用于10/100base-T 第五类：外套一种高质量的绝缘材料,传输频率为100MHz。主要用于100base-T和10base-T网络，这是最常用的以太网电缆 为什么帧的最小长度为64KB，这与10Base - T 的物理媒介有关——那么，到底为什么？ 同轴电缆 基带电缆：50Ω，可传输数字信号 宽带电缆：75Ω，可传输模拟信号，远距离传输 ——物理学证明了视频信号最优化的衰减特性发生在77 欧姆 光纤 全反射，传输速率受到光/电转换速率的制约 单模光纤：激光源，可远距离传输 多模光纤：发光二极管 LAN(局域网)技术：Ethernet, Token Ring, FDDI, WLAN 由于局域网中物理线路是直连的，故是一个冲突域，可能发生碰撞冲突 帧格式：结合教材 WAN(广域网)技术： 点对点WAN: PPP —— 一种数据链路层协议 ADSL PPP工作的点对点链路可能是串行的拨号电话线、SONET/SDH链路、X.25连接或者ISDN电路。 PPP也是点对点隧道协议（PPTP）和第二层隧道协议（L2TP）的基础，这些协议可用于创建虚拟专用网。如VPN 交换 WAN: Frame Relay -帧中继(虚电路), ATM(面向连接的分组交换) —— 宽带交换技术 还有一些早期技术：PSTN(电路) X.25(虚电路) DDN(电路) ISDN(电路) FR -&gt; SMDS(无连接，分组) -&gt; ATM 同步传输 SONET/SDH ——物理层协议 这些技术其实还没弄很懂…. 交换的三种类型：报文、电路、分组(数据报、虚电路) 一个典型的计算题：分组交换中35个用户同时有11个及以上用户在传输的概率 从35中选11个*(0.1)^(11)​….我不会输这个公式，对不起！得出的概率小于0.0004 在拥塞发生之后，任何剩余用户均不能传输，所有情况综合起来的条件概率为1，所以并不包含二项分布的第二部分 物理设备 Repeater 转发器/ Hub 集线器 Bridge 网桥/ L2 switch 二层交换机 Router 路由器/ L3 switch 三层交换机 Gateway 网关 —— 所有层，在异构传输层中间作为代理 区别：Default gateway vs. Gateway—— 默认网关是一个路由器？ CH4 IP编址分类IP地址：涉及到类型判断和网络号提取，主要是二/十进制转换的计算 特殊地址： 全1：表示当前网络的受限广播地址，当一个报文的目的地址为该地址时，这个报文将会被发送给本网络中的所有主机。但是路由器并不会将该报文转发到该网络外，故称为受限广播地址。 全0 ：表示本网络上的本主机地址，当一个主机刚加入网络时还没有IP地址，这时它将以全0地址作为源地址，全1 地址作为目的地址，向全网广播一个报文，DHCP服务器收到这样的报文之后就会进行IP分配的相关应答 网络号不为全0或全1 ，主机号全1：直接广播地址，用于标识对特定网络的广播。当一个路由器将报文的目的地址设置为该地址时，这个报文将会被发送给该地址对应的特定网络中的所有主机。该特定网络中的所有主机都会接收这个报文 网络号不为全0或全1 ，主机号全0：网络地址，用来标识这个网络，包含这个网络中的所有主机 网络号全0，主机号不为全0或全1 ：本网特殊主机地址，可作为目的地址向本网特定主机发送报文，因为本网内主机的网络号必然是相同的，仅通过主机号就可以对不同主机进行区分。 网络号为127，主机号任意：环回地址，一般用作测试，报文以该地址作为目的地址时，报文将只会在机器内部进行接收和处理，而不会被发送到外部网络上。自己发自己收，所以是环回 10.+ 24位 , 172.16~172.31 + 16位 , 192.168 + 16位：专用地址，仅在局域网内部使用，无法被外部访问。可用来节省IP地址，或者保证局域网的安全性 路由器的一个接口能连多个IP网(集线器，总线型)，但是多个接口不能连同一IP网——后者因为接口用IP来唯一标识？ P2P WAN :避免直连端口构成的子网浪费地址，解决方法 把两个路由器当做一个虚拟路由器，互连端口作为内部总线 把路由器当做交换机，分配同一子网的IP 工业界：IP地址借用，多端口共用IP，路由器内部多了报文流量但节省了地址空间 分类IP编址容易造成地址的浪费 -&gt; 无类IP编址——涉及掩码问题、子网划分 在分配子网和主机时，要考虑到全0和全1 的特殊情况。子网所需 IP = 主机数 + 路由器接口数 + 2 要点 确定掩码 确定每个网络的IP地址范围 128，192，224，240，248，252，254，255 /1， /2， /3， /4， /5， /6， /7， /8 路由聚合 -&gt; 超网","categories":[{"name":"network","slug":"network","permalink":"http://vergessenwang.github.io/categories/network/"}],"tags":[{"name":"IP","slug":"IP","permalink":"http://vergessenwang.github.io/tags/IP/"},{"name":"读文献","slug":"读文献","permalink":"http://vergessenwang.github.io/tags/读文献/"}]},{"title":"虚拟机安装Deepin","slug":"虚拟机安装Deepin","date":"2019-09-23T16:07:14.000Z","updated":"2019-09-23T16:08:44.385Z","comments":true,"path":"posts/OS/2019-09-24-虚拟机安装Deepin.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2019-09-24-虚拟机安装Deepin.html","excerpt":"今天在学习一个项目的时候要用到虚拟机开数据库服务器，于是打开了我很久以前安装的虚拟机，发现里面是CentOS系统。看起来真的没有什么使用的欲望…可能是我没花太多心思去配置，但是怎么说呢，就是感觉有点原始…于是寻思着换个操作系统试试，之前的台式安过Ubuntu了，所以干脆试试国产的Deepin 安装Deepin操作系统首先，在VMware的虚拟机管理中删掉现在的虚拟机。我文件夹地址是C:\\Users\\18771\\Documents\\Virtual Machines 里面有一个虚拟机文件夹，突然发现这个机器占了7GB外加，心疼我仅100G可用的SSD… 下载完Deepin镜像后，新建虚拟机 -&gt; 自定义 -&gt; 下一步 -&gt; 稍后安装操作系统 -&gt; Linux Ubuntu64 -&gt; 下一步… -&gt; 创建新的虚拟盘 -&gt; 将虚拟盘存储为单个文件 -&gt; 下一步.. -&gt; 完成 -&gt; 编辑虚拟机设置 -&gt; 使用ISO镜像，选择下载好的Deepin -&gt; 开机 -&gt; 完成相应配置，用户名 ve**en 密码 123456 安装完，界面确实挺惊艳的。","text":"今天在学习一个项目的时候要用到虚拟机开数据库服务器，于是打开了我很久以前安装的虚拟机，发现里面是CentOS系统。看起来真的没有什么使用的欲望…可能是我没花太多心思去配置，但是怎么说呢，就是感觉有点原始…于是寻思着换个操作系统试试，之前的台式安过Ubuntu了，所以干脆试试国产的Deepin 安装Deepin操作系统首先，在VMware的虚拟机管理中删掉现在的虚拟机。我文件夹地址是C:\\Users\\18771\\Documents\\Virtual Machines 里面有一个虚拟机文件夹，突然发现这个机器占了7GB外加，心疼我仅100G可用的SSD… 下载完Deepin镜像后，新建虚拟机 -&gt; 自定义 -&gt; 下一步 -&gt; 稍后安装操作系统 -&gt; Linux Ubuntu64 -&gt; 下一步… -&gt; 创建新的虚拟盘 -&gt; 将虚拟盘存储为单个文件 -&gt; 下一步.. -&gt; 完成 -&gt; 编辑虚拟机设置 -&gt; 使用ISO镜像，选择下载好的Deepin -&gt; 开机 -&gt; 完成相应配置，用户名 ve**en 密码 123456 安装完，界面确实挺惊艳的。 网络连接功能美滋滋的打开设置，结果没有WIFI模块，什么鬼，这我怎么快乐的网上冲浪？不行，我要冲浪 由于某种特殊的原因，最近不能愉快的上谷歌，只能在百度查，那查的真是令人感觉在浪费生命… 如何把Windows里的文件直接拖到虚拟机kali——即安装VMware tools 我可以直接拖文件了，舒服了 在虚拟机里查了半天，并没有查到无线网卡信息… 两个小时过去了，这时我已经有点出离愤怒… 会不会是因为无线网卡已经被本机占用了呢？于是我关闭了本机的WIFI，并重启了虚拟机，好像有点眉目了… 盲生似乎已经发现了华点。 首先在本机的设备器中，确认有VMnet1 和 VMnet8，因为用的无线所以没选桥接模式，用VMnet8的NAT模式 在VM的编辑中选择虚拟网络编辑器，点击左下角的恢复默认。重新将网络适配器设置NAT模式，重启了一下虚拟机。 啊！我的天啦，我真的有网了！我真的好开心啊！(黄晓明版杨过夸张大笑) 冷静下来的我，意识到当我第一次装CentOS的时候，装好了就有网了。所以这里的原因很就是：用NAT方式只能同时让一台虚拟机上网，新的机器需要重新配置 划重点：在VM的编辑中选择虚拟网络编辑器，点击左下角的恢复默认 其实，这个问题纠结的原因就在于我没有理解虚拟机的工作原理，把在一个电脑上安装Deepin和在虚拟机中安装Deepin这两个问题弄混了，所以才浪费了很多时间。 重要的不是对解决方案的积极寻找，而是首先深入理解你面临的问题。 三个小时过去了，我可以睡觉了…","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"Deepin","slug":"Deepin","permalink":"http://vergessenwang.github.io/tags/Deepin/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://vergessenwang.github.io/tags/虚拟机/"}]},{"title":"工程实践申请成功啦，开熏","slug":"工程实践申请成功啦，开熏","date":"2019-09-23T06:17:50.000Z","updated":"2019-10-05T11:27:46.277Z","comments":true,"path":"posts/Project/2019-09-23-工程实践申请成功啦，开熏.html","link":"","permalink":"http://vergessenwang.github.io/posts/Project/2019-09-23-工程实践申请成功啦，开熏.html","excerpt":"申请成功的感想今天和两个组员一起去见了孟老师，老师人很nice , 对我们几个基本没啥经验的同学没有过多的质疑。不过老师考虑到了我们目前的编程能力去做这个一个大型的知识图谱自动化项目还是有点难度，最终的项目内容可能有点区别。 如果你想做自己喜欢的东西，就要主动做出选择；如果你对这个选择没有足够的信心，就要做好充分的准备。大不了失败了再尝试一次。 同时还是要感谢老爹的鼓励，前几天跟他视频时讲到这个问题，我还怕我把课题讲出来他不太懂，果然还是低估了老爹的理解能力。他强调一定要做一份类似可能性计划书的重要性，好吧，我信了。（其实，我就是把看资料的笔记重新改了改，论记笔记的重要性…) 他还说，不要太担心，这种实践性的项目就是让人练手的，基本都会通过的，好吧… 不管怎样，还是拿到了自己喜欢的课题，很开心。","text":"申请成功的感想今天和两个组员一起去见了孟老师，老师人很nice , 对我们几个基本没啥经验的同学没有过多的质疑。不过老师考虑到了我们目前的编程能力去做这个一个大型的知识图谱自动化项目还是有点难度，最终的项目内容可能有点区别。 如果你想做自己喜欢的东西，就要主动做出选择；如果你对这个选择没有足够的信心，就要做好充分的准备。大不了失败了再尝试一次。 同时还是要感谢老爹的鼓励，前几天跟他视频时讲到这个问题，我还怕我把课题讲出来他不太懂，果然还是低估了老爹的理解能力。他强调一定要做一份类似可能性计划书的重要性，好吧，我信了。（其实，我就是把看资料的笔记重新改了改，论记笔记的重要性…) 他还说，不要太担心，这种实践性的项目就是让人练手的，基本都会通过的，好吧… 不管怎样，还是拿到了自己喜欢的课题，很开心。 以下是之前准备的一些内容 准备方向关于项目 目前国内知识图谱的应用现状是怎样的 相关理论在这个项目中的具体体现，还有哪些同层次的实现方法 项目从数据获取到最终应用的运行流程 技术选型(细节这块不是很懂) 目前项目的要求有什么缺陷和问题 关于自己 为什么对这个方向感兴趣 是否有相关经验，可结合个人经历说些开发经验，毕竟我觉得这是一个偏工程多点的项目 如无，今后的发展方向是什么，将在小组内担任何种角色 课题理解目前知识图谱普遍采用了语义网框架中RDF(Resource Description Framework,资源模式框架)模型来表示数据。语义网是万维网之父蒂姆·伯纳斯-李(Tim Berners-Lee)在1998年提出的概念，其核心是构建以数据为中心的网络，即Web of Data；这是相对于我们目前的万维网是Web of Pages而提出的。 爬虫抓取原始数据 从半结构化网页中诱导通用模板 待爬队列，已爬队列 DPS OR BPS 采用Scrapy引擎(或其他)处理后获得预处理数据，存储在Mysql数据库(或其他)中 后续更新：新的网站URL加入待爬队列——可能涉及到跟已有数据的一致性验证问题 预处理后的数据转成三元组 指代消解：最大熵模型、SVM模型 识别命名实体及关系抽取： CRF-SVM联合分类器(或其他)——适合半结构化数据 条件随机场：识别属性和尾实体 支持向量机：判断三元组的语义关系 抽取后的数据存在图数据库Neo4j(或其他三元组数据库)——该数据库提供可视化接口 如果是多数据源，还涉及到知识融合问题 实体名称匹配，可采用相似度匹配 余弦相似 欧氏距离 编辑距离 属性融合——消除歧义 属性相似度 自动生成问题和答案——知识推理 整理该应用领域常见的问题 将问题转为图数据库查询语句SPARQL(或其他) 在图数据库中搜索答案 基于 Elasticsearch(或其他)搭建一个简易实体语义搜索引擎 平台化 用户登录验证 数据导入 默认自动生成的问题 自定义查询接口: 构建中英文知识问答模块 对答案进行可视化渲染后呈现 清空数据 现有工具(部分开源，这里仅了解到的一小部分) 本体知识建模(schema): Protégé 三元组数据库：Apache Jena、RDF4J 、gStore 、AllegroGraph 、GraphDB 三元组抽取： DeepDive 、Reverb 、OLLIE 、Wandora 知识融合：LIMES 、Dedupe 、SILK 、RIMOM 、Falcon-AO 、 Lily 知识图谱推理：Jena 、Drools 语义搜索: Elasticsearch 知识问答系统： gAnswer","categories":[{"name":"Project","slug":"Project","permalink":"http://vergessenwang.github.io/categories/Project/"}],"tags":[{"name":"面谈准备","slug":"面谈准备","permalink":"http://vergessenwang.github.io/tags/面谈准备/"}]},{"title":"中秋记叙","slug":"中秋记叙","date":"2019-09-15T17:06:17.000Z","updated":"2019-09-15T17:07:47.631Z","comments":true,"path":"posts/life/2019-09-16-中秋记叙.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2019-09-16-中秋记叙.html","excerpt":"","text":"一月的时候，我背着穿到上海的四件毛衣，在微雨而几乎无人的下午，独自一人在拙政园里闲逛。空气潮湿而阴冷，墙愈白，瓦愈黑。地上的树叶落了一层，塘里枯败的荷枝耷拉着，几只灰褐的鸳鸯自顾戏水。一整个的园子，仿佛从没人来过。 留得残荷听雨声，大概是这样的意境。 而今中秋同瑞哥还有时节再游一趟，却又是另一种心情。 强烈的日光照的云天通透，园里的树叶郁郁葱葱，掩去了大半的热浪，到底是古人避暑的地方。小孩子指着鱼儿叽叽喳喳，风伴着阵阵蝉鸣。田田荷叶簇拥着接近成熟的莲蓬的高枝，偶尔在边缘遇见几朵睡过头而迟来的荷花。 水光潋滟晴方好，大概是这样的意境。 而后还有留园的青苔古树，窗里春秋；网师园的游园惊梦，灯影风声；苏博的吴地遗珍；裕兴记的六月黄面；松鹤楼的松鼠桂鱼，还有苦乐共享的夜谈。 一个人独自生活的时候，其实是很坚强的，一旦被感情包裹，就会变得很脆弱，因为对信任的人打开了门。很多遥远而隐秘的事情，拿来作为笑谈，倒也很有意思。 大概所有觉得幸运的时刻，此后都要用寂寞来偿还。 送走二人后，一个人回到学校，默默喝了两瓶豆奶。 一瓶敬友情，一瓶敬明天。","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[{"name":"中秋","slug":"中秋","permalink":"http://vergessenwang.github.io/tags/中秋/"}]},{"title":"自我表达与被认同感","slug":"自我表达与被认同感","date":"2019-09-10T03:44:37.000Z","updated":"2019-09-10T03:45:51.619Z","comments":true,"path":"posts/movie/2019-09-10-自我表达与被认同感.html","link":"","permalink":"http://vergessenwang.github.io/posts/movie/2019-09-10-自我表达与被认同感.html","excerpt":"开学五门考试终于完了，想来赵振刚老师和郭燕老师真是神仙老师啊，一个给我们布置了五次作业还在Q群里语音讲题，一个专门录了一套视频放到B站上，平时学习的较深，但是考试的时候都是很基础很细节的东西，教育不只为通过考试，这大概也是学习的真正意义。 于是有点放飞自我，翻了翻以前想看的电影，看完了《波西米亚狂想曲》和《鸟人》 听着皇后乐队的现场版，敲着这篇文章 一个一口豁牙不自觉露出傻笑然后用抿紧嘴巴羞涩低头的野路子歌手，出道之路凭借超强的个性和天赋顺风顺水，偶尔遇到与制作人意见不合，没关系，冒险的结果是好的。乐队内部矛盾的激化，最后弗雷迪再经历一系列打击之后明白了谁是真正重要的人，虽然他最终为自己的出格付出了生命的代价，但总体来说这算是一个励志喜剧了，他的人生停在了辉煌的顶点。","text":"开学五门考试终于完了，想来赵振刚老师和郭燕老师真是神仙老师啊，一个给我们布置了五次作业还在Q群里语音讲题，一个专门录了一套视频放到B站上，平时学习的较深，但是考试的时候都是很基础很细节的东西，教育不只为通过考试，这大概也是学习的真正意义。 于是有点放飞自我，翻了翻以前想看的电影，看完了《波西米亚狂想曲》和《鸟人》 听着皇后乐队的现场版，敲着这篇文章 一个一口豁牙不自觉露出傻笑然后用抿紧嘴巴羞涩低头的野路子歌手，出道之路凭借超强的个性和天赋顺风顺水，偶尔遇到与制作人意见不合，没关系，冒险的结果是好的。乐队内部矛盾的激化，最后弗雷迪再经历一系列打击之后明白了谁是真正重要的人，虽然他最终为自己的出格付出了生命的代价，但总体来说这算是一个励志喜剧了，他的人生停在了辉煌的顶点。 一个有隔空移物超能力但除了用来开门没啥卵用的导演兼演员，本来靠演爆米花电影在好莱坞有了一席之地，却打算在百老汇也实战一番拳脚，他改编了卡佛的原著，并找到一个以体验为名行流氓之事的有那么一点点才华的配角，然而事情并没有那么顺利，作为电影情节来说，这是必然的。他似乎有轻微的精神分裂，或者说过去的成就对他影响太大，正如那位极有艺术家气质的女评论家所言，好莱坞就是请几个猴子去拍也会有大把的人涌进电影院去看，而戏剧不一样，它是艺术。最终，他穿着一条短裤跑过人潮汹涌的街区，并用自己鼻子上的鲜血换来了那位评论家所著的头条。这部电影的奥妙之处在于，一种电影现实与真实现实，被迫行为和神经质内心的交织。 我喜欢把事物进行对比，这次也一样，虽然只是两部随机选择的电影。 音乐和戏剧是两种比较典型而且个性较强的艺术形式，必然会带来个人情感表达与大众认同之间的冲突。 弗雷迪不是一个好儿子，作为从印度来的移民，他的父亲始终恪守着“善言，善思，善行”的正派言行，而他似乎在最后生命即将终结的时候才浪子回头，请求朋友的原谅，参加为非洲筹款的慈善演唱。然而，从头到尾，你对他的那些可恶行径恨不起来，天才往往比较自我，他很有才华，That’s him , 想反还会为他的误入歧途感到惋惜。 里根也不是一个好父亲，他一心只想着挽救自己过气的事业，忽略了进过戒毒所的女儿。一开始他的演技平平无奇，自我怀疑让他几近崩溃，最终他把一个真实的自己展现在舞台上，他举着手型的枪，一本正经的说着台词，一开始你觉得很滑稽，然而你会幡然醒悟，他在说自己，明白他说：我只想成为你希望的样子，我现在每分钟都祈祷能成为别人，只要不是我自己…我不存在，我甚至不在这里…一切都不重要了… 时意味着什么。 很多人隐藏着真实的自己，因为害怕被大众所遗弃，那种真实的丑陋，也许会带来骂名。这两部电影很好的融合了自我表达与被认同感之间的矛盾。有勇气揭露真实的人，才能让作品直指人心，这种勇气本身就已经值得钦佩。 迎合大众的人往往带着面具，表达自我的大多有段曲折凄凉的经历。 名利与真实，只是一个选择问题。 关键是，你想成为谁。 命运青睐勇者。 —— 布莱恩·辛格 《波西米亚狂想曲》","categories":[{"name":"movie","slug":"movie","permalink":"http://vergessenwang.github.io/categories/movie/"}],"tags":[{"name":"真实的自我","slug":"真实的自我","permalink":"http://vergessenwang.github.io/tags/真实的自我/"}]},{"title":"组成原理","slug":"组成原理","date":"2019-09-09T15:24:53.000Z","updated":"2019-09-09T15:26:18.919Z","comments":true,"path":"posts/CS/2019-09-09-组成原理.html","link":"","permalink":"http://vergessenwang.github.io/posts/CS/2019-09-09-组成原理.html","excerpt":"作业一：什么是计算？什么是计算机？计算机和计算机理论之间的关系？现代计算机和理论如何联系起来？ 计算理论的发展计数和进制：起源于农业生产的需要，在中西方同时诞生了十进制，使人能用手指进行计数。中国古代还有八卦——二进制，算盘——十六进制，天干地支——十二进制和六十进制。玛雅日历——二十进制。 数学第一个突破：把连续的实变问题转换成数学可以表达的问题。 第二个突破：用离散的数字计算机来求解这些问题。 可计算性：衡量一个问题是否可以求解，标准是能不能通过图灵机分解成有穷的步骤从而再现出来。 把质的复杂转换成量的复杂 解析函数在基础系{1,$x$, $x^2$,….} 下的表示 可积函数在某个正交系下的Fourier级数表示 拓扑空间中用一簇集开集表示一个点 连续问题离散化的标准基表示，如有限元方法，图像处理中的小波变换 二进制：布尔代数，香农把数字继电器电路和二进制统一起来“A Symbolic Analysis of Relay and Switching Circuits”","text":"作业一：什么是计算？什么是计算机？计算机和计算机理论之间的关系？现代计算机和理论如何联系起来？ 计算理论的发展计数和进制：起源于农业生产的需要，在中西方同时诞生了十进制，使人能用手指进行计数。中国古代还有八卦——二进制，算盘——十六进制，天干地支——十二进制和六十进制。玛雅日历——二十进制。 数学第一个突破：把连续的实变问题转换成数学可以表达的问题。 第二个突破：用离散的数字计算机来求解这些问题。 可计算性：衡量一个问题是否可以求解，标准是能不能通过图灵机分解成有穷的步骤从而再现出来。 把质的复杂转换成量的复杂 解析函数在基础系{1,$x$, $x^2$,….} 下的表示 可积函数在某个正交系下的Fourier级数表示 拓扑空间中用一簇集开集表示一个点 连续问题离散化的标准基表示，如有限元方法，图像处理中的小波变换 二进制：布尔代数，香农把数字继电器电路和二进制统一起来“A Symbolic Analysis of Relay and Switching Circuits” 计算工具的演进帕斯卡的自动进位加法器：从驱动方式来说是靠人力拨动的外动力机械加法器，从进位和计算的机制上来说是靠发条和齿轮进位的内动力加法器。没有程序存储的概念 巴贝奇的差分机：基于提花织布机改进，完全实现了程序存储的概念，可以进行对数、微积分等函数的运算。包括存储室、运算室、控制室、打印机。编程卡是外部输入 图灵机：把一个数字问题用机械可求解可穷尽的过程再现出来的理论模型。最初发明是为了解决希尔伯特二十三个问题之一：用公理化的方法证明一个问题是可解的。图灵机从行为层面模拟人脑 图灵机停机：取决于两个因素1.计算完成 2.控制器中预存的状态被满足。停机并不意味着可计算性的成立，可能代表着某种条件已穷尽 图灵测试：通过对某种行为的测试来判断是否为智能体。 数字计算机：从功能层面模拟人脑。 ENIAC：采用十进制，用于计算火炮的弹道运算速度，电子管。用开关、插头和插座来编程。 冯·诺依曼机：用存储程序的方式实现更高效的编程，让程序可以自动执行。采用二进制电路更简单，指令和数据混合存储——普林斯顿结构（分开存储——哈佛结构） 冯·诺依曼结构冯·诺依曼结构采用存储程序的工作方式，在不需人工干预的条件下，自动取值和执行，因此必须具备功能模块： 将程序和原始数据输入计算机——输入→指令由操作码和地址码组成 以二进制形式存储程序和数据——主存→按地址访问，线性编址(当时主要是穿孔纸带，故速度很慢) 逐条取指令和操作数执行——控制器CU→控制流由指令流产生 算术和逻辑运算——运算器ALU→核心部件 运算结果输出——输出 操作人员通过I/O设备与主机进行通信。 现代计算的改进在内存容量指数级提升后，CPU和内存之间的数据传输带宽成为了瓶颈。 现代计算机为了实现并行，进行了很多的优化： 以存储器为核心，并采用层次化的寄存器—cache—主存—辅存结构 指令流水线和分支预测 多核CPU 更高速的I/O方式：程序中断、DMA、通道等 各部件通过总线连接 其实，以上的所有改进都可以总结为：如何充分利用CPU的处理能力，如何加快数据在各部件之间的传输 拓展：为何不采用哈佛结构？哈佛体系实际上将存储时简化的复杂度转移到了程序运行时，对程序和数据的动态链接和物理映射需要更多的硬件支持，内部也要采用两套总线。 在实际运用中，简单的DSP嵌入式应用因为不需要运行太多的任务多采用哈佛结构，多用于安全性较高的工控领域。 在现代计算机中，CPU内部的Cache是有L1-I和L1-D的哈佛结构的。 所以说冯`诺依曼机采用普林斯顿结构只是用整体层面而言的。 存储器数据的表示ASCII码表：0–48(0011 0000); 大写A–65(0100 0001)；小写a–97(0110 0001) 数制转换：整数除二取余，小数乘二取整 原码 补码：用模实现加减法的统一，多表示一个数 反码：负数 补码 - 1 移码：比较大小，符号与补码相反 IEEE 754标准：阶码 +127 数据的存储从什么地方开始存—大/小端：现代网络通信中一般采用大端模式，即对一个主存字中的多个字节，按从高位字节到低位字节存放—看主存地址而不是数据的高位 如何便于存取——数据对齐：编译器和链接器划分的最小存储单元确定对齐方式，如双字节、四字节对齐。注意：如果是结构体整体，那么以最长成员作为结构体本身的对齐方式 其他LOAD直接寻址的访存次数：一般情况下需要先取指令再访存取数，但是LOAD指令可以同时进行，故只需访存一次。 配置实验环境安装masm5用于搭建汇编环境 我安装在E盘 安装DosBox和Debug工具DosBox用于在64系统下使用masm5 将debug.exe放在某盘如E盘的根目录下，然后运行dosbox, 会发现它默认有一个虚拟的Z盘。 输入mount c e:\\ 表示在dosbox 中虚拟出一个C盘，然后把本机的E盘挂载上去，就可以访问本机的文件了。 -&gt; c: -&gt;dir -&gt; masm5 即可查看本机E盘中的masm相关文件, 常用指令 编译：masm file.asm 链接：link file.obj 运行：file.exe 返回根目录 -&gt;debug 出现 -_ 光标表示debug程序成功开始运行","categories":[{"name":"CS","slug":"CS","permalink":"http://vergessenwang.github.io/categories/CS/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"http://vergessenwang.github.io/tags/硬件/"},{"name":"底层原理","slug":"底层原理","permalink":"http://vergessenwang.github.io/tags/底层原理/"}]},{"title":"中断、异常和系统调用","slug":"中断、异常和系统调用","date":"2019-09-07T16:33:11.000Z","updated":"2019-09-07T16:34:38.129Z","comments":true,"path":"posts/OS/2019-09-08-中断、异常和系统调用.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2019-09-08-中断、异常和系统调用.html","excerpt":"这三者都是应用程序和操作系统内核之间的接口。 作用和区别当硬件外设与计算机的交互的时候，为了快速响应，需要中断机制。 在程序执行中出现了一些程序设计人员没有预料到的情况，如除0，导致当前指令执行失败，为了解决这种错误，需要异常处理机制。 在保证系统安全性的同时为用户应用程序提供灵活的访问接口，需要系统调用机制。应用程序主动向OS发出服务请求 响应和处理中断：异步，持续进行，应用程序并不会感知到中断的存在，对用户透明 异常：同步，必须当前错误处理完了才能继续执行，处理方式是杀死或重新执行指令 系统调用：同步或异步，等待和持续","text":"这三者都是应用程序和操作系统内核之间的接口。 作用和区别当硬件外设与计算机的交互的时候，为了快速响应，需要中断机制。 在程序执行中出现了一些程序设计人员没有预料到的情况，如除0，导致当前指令执行失败，为了解决这种错误，需要异常处理机制。 在保证系统安全性的同时为用户应用程序提供灵活的访问接口，需要系统调用机制。应用程序主动向OS发出服务请求 响应和处理中断：异步，持续进行，应用程序并不会感知到中断的存在，对用户透明 异常：同步，必须当前错误处理完了才能继续执行，处理方式是杀死或重新执行指令 系统调用：同步或异步，等待和持续 中断处理机制实际上是对三种方式的统称。 硬件处理 CPU初始化时设置中断使能标志 依据内部或外部事件设置中断标志 依据中断向量调用相应中断服务例程 中断：设备驱动 异常：异常服务例程 系统调用：系统调用表 -&gt; 系统调用实现 此时三种情况都会索引中断向量表，根据自身的所需的处理转到不同的例程，及软件处理 内核软件处理 现场保存(编译器): 汇编语言过程保存寄存器值并设置新的堆栈 中断服务处理(服务例程) 清除中断标记(服务例程) 现场恢复(编译器) 中断嵌套硬件中断服务例程可被打断，中断请求会保持到CPU做出响应 不同中断源优先级不同，比如有更高速设备的请求 有时需要临时禁止中断请求，比如电源处理 异常服务例程可被打断 硬件中断优先级更高，如执行缺页处理时有磁盘I/O中断 异常本身也可嵌套，如缺页处理时又出现缺页 系统调用与函数调用系统调用：INT 和 IRET 指令 ，调用时会有堆栈和特权级的切换，因此开销更大，具体开销有： 切换引导机制 建立内核堆栈 验证参数 内核态映射到用户态的地址空间 内核态独立地址空间 函数调用：CALL 和 RET 指令，没有堆栈切换 堆栈切换的意思是用户态和内核态使用不同的堆栈 基于X86的中断处理中断和异常在不同的CPU上有不同的表现形式，X86分成中断和异常两种类型，但在实现方式上是统一的 中断源中断 外部中断：串口、硬盘、网卡、时钟… 软件中断：THE INT n 指令，通常用于系统调用(陷入) 异常 程序错误 软件异常：INTO INT 3 BOUND 机器检查出的异常 CPU与OS的中断处理每个中断或异常关联一个中断服务例程ISR, 关系存储在中断描述符表IDT中，IDT的起始地址和大小保存在中段描述符表寄存器IDTR中 1. 确定ISR的地址(中断初始化) CPU在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中中断控制器（如：8259A）是否发送中断请求过来，如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量； CPU根据得到的中断向量（以此为索引）到IDT中找到该向量对应的中断描述符，中断描述符里保存着中断服务例程的段选择子； CPU使用IDT查到的中断服务例程的段选择子从GDT中取得相应的段描述符，段描述符里保存了中断服务例程的段基址和属性信息，此时CPU就得到了中断服务例程的起始地址，并跳转到该地址 2. 切换到ISR段描述符中会设定ISR的特权级，如CS的低两位00 代表内核态，33 代表用户态 产生中断之后都会转为内核态，对于内核态 -&gt; 内核态 与 用户态 -&gt; 内核态 处理方式略有区别，前者只需压入EIP CS EFLAGS；后者有堆栈和特权级的切换,因此还要把用户态的堆栈地址ESP SS压到内核态堆栈 需要理解的一点是，程序的状态，实际上就是各个寄存器中的值，保存了这些值也就保存了程序的状态。 具体流程参见中断处理 保护端点和保护现场的区别这是一个困扰了我很久的问题，硬件处理中的保护断点与软件处理中的保护现场究竟有什么区别？ 保护断点：由系统自动完成，方便中断服务程序执行完后，可以返回到断点处继续运行。这里的断点指的是PC寄存器的内容，因为转入中断服务程序需要装载新的指令地址，一般是压栈。 保护现场：指的是进入中断服务程序或子程序后，由于寄存器有限，主程序和中断服务程序或子程序中用到相同的寄存器，所以为防止冲突，在中断服务程序前或在子程序前用进栈指令保护那些可能受到冲突的寄存器，然后在返回前恢复。也就是说，一个程序的运行状态，是用各种寄存器中的值来描述的，现场信息一般指的是PSW 、中断屏蔽寄存器和CPU 中某些寄存器的值。","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"中断","slug":"中断","permalink":"http://vergessenwang.github.io/tags/中断/"},{"name":"系统调用","slug":"系统调用","permalink":"http://vergessenwang.github.io/tags/系统调用/"}]},{"title":"进程fork的原理","slug":"进程fork的原理","date":"2019-09-07T16:06:25.000Z","updated":"2019-09-09T16:09:33.516Z","comments":true,"path":"posts/OS/2019-09-08-进程fork的原理.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2019-09-08-进程fork的原理.html","excerpt":"创建新进程需要创建新进程的场景： 系统初始化 执行创建新进程的系统调用 用户请求创建 初始化批处理任务 Unix 系统调用：fork/exec 先用fork() 复制出一个不同PID的子进程，然后用exec()重写当前新创建的子进程。之所以要安排两步，是为了在fork之后允许子进程处理父进程的文件描述符，这就可以完成对标准I/O文件和标准错误文件的重定向。","text":"创建新进程需要创建新进程的场景： 系统初始化 执行创建新进程的系统调用 用户请求创建 初始化批处理任务 Unix 系统调用：fork/exec 先用fork() 复制出一个不同PID的子进程，然后用exec()重写当前新创建的子进程。之所以要安排两步，是为了在fork之后允许子进程处理父进程的文件描述符，这就可以完成对标准I/O文件和标准错误文件的重定向。 具体来说 fork() 创建一个继承的子进程 复制父进程所有变量和内存。只读的内存区是共享的 复制父进程除区分PID的寄存器以外所有的寄存器 子进程返回0，父进程返回子进程PID,这个返回值就是childPID 对于新创建的子进程来说，它的子进程PID就是0 注意：fork()循环两次会产生四个进程！而不是三个！ 对于内核线程共享地址空间，对于用户进程是直接复制。 exec() 重写子进程 在pid = = 0 的条件下执行，即要先验证是否为新创建的子进程 第一个参数为将要执行的文件名/bin/** ,第二个参数为指向变量数组的指针，第三个参数为指向环境变量数组的指针用于将终端类型和根目录等信息传给程序 执行会把整个地址空间内容改变 对于父进程，满足pid &gt; 0 它会执行waitpid系统调用，等待直至子进程终止。 可以看出，这两步操作中，第一步的复制是开销昂贵且没有的必要的。于是有了改进：vfork() 加快对exec 的调用。 现在的系统支持写时复制(COW)技术，即把复制延迟到某一进程想要对共享的内存进行改写时才进行。 init特殊进程因为用到了fork() 很容易想到鸡生蛋蛋生鸡的问题，第一个进程到底是怎么产生的呢？ 用户态进程创建之前，首先要创建一个内核态init进程，然而这个init进程是系统中的第二个进程即1号进程，它产生于0号进程idle 进程。 这个内核态的kernel_init 执行init函数转成用户态的第一个进程，读入一个说明终端数量的文件，然后为每个终端创建一个新的进程，就可以运行各种用户态的进程了。 上述过程可描述为：0号进程-&gt;1号内核进程-&gt;1号用户进程（init进程）-&gt;getty进程-&gt;shell进程 参见：Linux下1号进程的前世(kernel_init)今生(init进程) 代码例子1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#define SIZE 5int nums[SIZE] = &#123;0,1,2,3,4&#125;;int main()&#123;int i;pid_t pid;pid = fork();if( pid == 0)&#123;for(i = 0; i &lt; SIZE; i++)&#123; nums[i] *= -i ; printf(\"CHILD:%d\", nums[i]); &#125;&#125;else if (pid &gt; 0)&#123; wait(NULL); for(i = 0; i &lt; SIZE; i++)&#123; printf(\"PARENT:%d\",nums[i]); &#125;&#125;return 0;&#125; 上述代码最终的输出结果为： CHILD:0 CHILD:-1 CHILD:-4 CHILD:-9 CHILD:-16 PARENT:0 PARENT:1 PARENT:2 PARENT:3 PARENT:4 很明显可以看出子进程是在一块新的内存区域对数据进行改写，所以父进程的数组内容不会受到影响","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"进程创建","slug":"进程创建","permalink":"http://vergessenwang.github.io/tags/进程创建/"}]},{"title":"数据库概念","slug":"数据库概念","date":"2019-09-07T04:16:18.000Z","updated":"2019-09-09T15:39:46.177Z","comments":true,"path":"posts/database/2019-09-07-数据库概念.html","link":"","permalink":"http://vergessenwang.github.io/posts/database/2019-09-07-数据库概念.html","excerpt":"概论DB、DBMS与DBS的概念区别数据：载荷信息的符号。如数字、文字、图像、音频、视频等 数据库：长期储存在计算机内、有组织的(数据模型、冗余度小、独立性高、易拓展)、可共享的大量数据的集合。 数据库管理系统：用户和OS之间用于管理数据的基础软件，包括数据定义、组织、存取、联系、操纵、事务管理和运行管理(安全性保护、完整性检查、并发控制、数据库恢复)等功能 数据库系统：DB + DBMS + DBA + 应用程序 数据独立性物理独立性：应用程序与物理存储——外模式/模式映像(模式修改时对应改变映像，基于外模式的应用无需修改) 逻辑独立性：应用程序与逻辑结构——模式/内模式映像(同理) 从底层保证了应用程序的稳定性","text":"概论DB、DBMS与DBS的概念区别数据：载荷信息的符号。如数字、文字、图像、音频、视频等 数据库：长期储存在计算机内、有组织的(数据模型、冗余度小、独立性高、易拓展)、可共享的大量数据的集合。 数据库管理系统：用户和OS之间用于管理数据的基础软件，包括数据定义、组织、存取、联系、操纵、事务管理和运行管理(安全性保护、完整性检查、并发控制、数据库恢复)等功能 数据库系统：DB + DBMS + DBA + 应用程序 数据独立性物理独立性：应用程序与物理存储——外模式/模式映像(模式修改时对应改变映像，基于外模式的应用无需修改) 逻辑独立性：应用程序与逻辑结构——模式/内模式映像(同理) 从底层保证了应用程序的稳定性 数据模型对现实世界的模拟/抽象，容易为人理解且易在计算机上实现。数据模型是数据库系统的核心和基础 概念模型(现实 - &gt; 信息)：信息模型，数据库设计人员从用户角度进行数据库设计，要有较强的语义表达能力 E-R——要会根据描述信息画E-R图 联系本身也是一种实体型，也可以有属性 逻辑模型和物理模型(信息 -&gt; 机器) 逻辑模型：数据库设计人员借助工具从计算机系统的角度建模，用于DBMS实现 物理模型：物理存取方式，由DBMS完成 数据模型的组成要素 数据结构(静态特征)：对象和联系 数据操作(动态特征)：值的操作 数据完整性约束：制约和依存规则 常用的数据模型 层次：树，一对多，记录必须按路径查看完整意义。如IBM的IMS数据库 完整性约束与树结构有关 用冗余节点法(复制)和虚拟结点法(引用)将多 - 多 转成 一 - 多 存储结构：顺序邻接法，子女-兄弟链接法，层次序列链接法(深度优先遍历) 查询效率优于关系，不低于网状—-于此同时，更新效率较低 网状模型的一个特例 网状：间接表示多对多，如BDTG系统 一对实体间可以有多种联系 用联结记录法将多 - 多 转成 一 - 多 链表存储 操作语言复杂 关系 一个关系对应一张表(不允许嵌套)，一个主码确定一个元组，元组中每一个分量必须是不可分的数据项 关系模式即表头，是对表格的描述 存取路径对用户透明，利于开发但查询效率较低——查询请求优化 数据库系统结构开发人员角度 三级模式(二级映像) 外模式(子模式/用户模式)——View 局部数据或对同一数据的约束不同，跟具体应用有关的逻辑表示 一个应用只有一个外模式 模式(逻辑模式)——数据库的中心，应最先确定 对所有用户共享全部数据的逻辑结构和特征的描述 一个数据库只有一个模式，一个模式可有多个外模式 内模式(存储模式) 数据库内部的表示方法，如存储方式、索引组织、压缩加密等 一个数据库只有一个内模式 模式(Schema)对应抽象的型，实例对应具体的值。 最终用户角度 单用户 主从式 分布式 客户/服务器 浏览器/服务器 数据库系统组成DB + DBMS + Application + DBA + Hardware(内存、磁盘、传输率) + Software + User/Developer DBA职责 决定信息内容和结构，存储结构和存取方式，安全性要求和完整性约束条件——设计 监控数据库的使用和运行，如周期转储，故障恢复，监视审计文件——运维 调优、重组织、重构——优化 关系数据库关系建立在集合代数的基础上，是笛卡尔积的子集 笛卡尔积：所有域的所有取值的不重复组合，可表示为一个二维表，行为元组，列为域 域：当域的范围相同时，可以用属性名来进行区别 码：候选码可以唯一标识一个元组，对应一个主属性；所有属性都是候选码称为全码；可选定一个候选码为主码 三类关系 基本表：实际存在，数据的逻辑表示。最基本的一条性质：分量必须取原子值 查询表：临时表 视图表：虚表/导出表 关系模式是型，关系是值。笼统称为关系，用上下文区别 关系模式形式化表示：R(U,D,DOM,F) DOM是U = {A1,A2,A3...}中的属性向域D的映象集合，如DOM(Student-Person)=Person，映象通常直接说明为属性的类型、长度，F是属性依赖关系的集合 关系操作集合操作方式。 查询：选择、投影、连接、除、并、差、交、笛卡尔积 更新：插入、删除、修改 SQL具有关系代数(关系运算)和关系演算(用谓词)的双重特点 关系代数(重要) 集合运算符：只能行操作，要求属性的个数和域相同(笛卡尔积除外） $U$ 并 $-$ 差 ：由于不能做≠ 判断，所以一般借助差来实现诸如 “没有”之类的条件 $∩$ 交 $×$ 笛卡尔积：{m目k1个元组的集合} × { n目k2个元素的集合} = k1 × k2 个 m + n 目新元组 专门关系运算符：行列操作 具体运算参考 $σ$ 选择：行，在对列的范围进行控制的情况下选出行 $π$ 投影：列，投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行） $⋈$ 连接：结果来自多个关系 注意区分自然连接(去掉重复属性)和等值连接(对重复属性按表进行区分) 含空值的称为悬浮元组 $÷$ 除 象集的概念 先找出某值的象集，再看该象集是否真包含右边的关系 简单理解：假设集合A中有属性a,b ,集合B有属性b, 则找出的是，B中所有的b都在A中有等值b的对应a。前提是有公共属性 常用于“全部”，先用投影找出全部信息作为被除数；“至少”，一般是至少一个的情况 综合操作是先用连接确定要从哪些表中获取信息，然后对属性的域进行控制选择满足条件的行，再用投影选出所需的属性，生成特定的视图表 交、连接、除可用其余5种运算代替，但是引入可以简化表达 关系演算语言(了解，反正也看不懂..)刻画客体的性质或几个客体间关系的模式叫谓词 元组关系演算语言 ALPHA 域关系演算语言 QBE 元组演算和关系代数对比应用的例子 真的给我整蒙了… 完整性约束 实体完整性：主属性not null且unique，必须满足的不变性 参照完整性：外码是对应其他表(被参照关系)主码的本表(参照关系)非主码属性，取空值或被参照表的主码，foreign key reference,必须满足的不变性 用户定义完整性：具体领域的语义约束，结合实际情况 如 CHECK (Ssex=&#39;女&#39; OR Sname NOT LIKE &#39;Ms.%&#39;) SQL命令一览 SQL是关系数据库语言的工业标准。 分为数据定义、数据查询、数据更新、数据控制四大部分 定义模式定义模式：CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; 实际上定义了一个命名空间，可包含基本表、视图、索引等数据库对象 删除模式：DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt; CASCADE全部删除，RESTRICT还有对象时无法执行 创建对象时如果没有指定模式，默认根据搜索路径SHOW search_path;使用模式列表的第一个模式 基本表涉及多个属性列的完整性约束条件要定义在后面的表级完整性约束条件，如对外键的约束FOREIGN KEY (外键属性名) REFERENCES 参照表名(参照表的主键) 或有多个主键 PRIMARY KEY (主键1 ，主键2) 视图特点： 虚表，是从一个或几个基本表（或视图）导出的表 只存放视图的定义，不存放视图对应的数据 基表中的数据发生变化，从视图中查询出的数据也随之改变 作用： 视图能够简化用户的操作——基于视图的视图 视图使用户能以多种角度看待同一数据 ——数据库共享 视图对重构数据库提供了一定程度的逻辑独立性——无需改变外模式就实现某些使用需求 视图能够对机密数据提供安全保护 适当的利用视图可以更清晰的表达查询 创建CREATE VIEW &lt;视图名&gt; [(&lt;列名&gt; [,&lt;列名&gt;]…)] AS &lt;子查询&gt; [WITH CHECK OPTION]; WITH CHECK OPTION 代表对视图进行UPDATE，INSERT和DELETE操作时要保证更新、插入或删除时的行仍然满足视图定义中的子查询中的条件表达式 DBMS实现视图查询的方法：视图消解法，一般转换成等价的对基本表的查询 删除DROP VIEW &lt;视图名&gt;[CASCADE]; 索引从如何加快查询速度的角度去考虑，很多算法题也会涉及到这些思路。 顺序文件：按序排列，一个索引对应一条记录 B+树：动态平衡，一个索引对应一个块，索引记录该块内最大值 散列：查找快，但是仅能用于判断存在性，不能按范围查找。有同位冲突问题 位图 CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名)&gt;[&lt;次序&gt;],....); 次序为升序ASC或降序DESC,默认为升序 DMBS自动选择合适索引作为存取路径，用户不能显式地选择索引 适合建立索引的列：经常被使用，如WHERE 或 ORDER BY ; 主键或外键；值唯一 查询单表SELECT..COUNT/AVG/SUM/MIN/MAX..FROM...AS...WHERE...GROUP BY....HAVING.../ORDER BY...ASC|DESC; WHERE 和 HAVING 的区别：WHERE 用于从基表或视图选择满足条件的元组，HAVING 用于从组中选择满足条件的组 常用条件 DISTINCT 去掉重复行 [NOT] BETWEEN...AND... [NOT] LIKE &#39;匹配字符串&#39;字符匹配 % _ 如果字符串本身有% 或_ , 要在前面加 \\ 并在后面加上一句ESCAPE&#39;\\&#39; [NOT] IN(value1,value2...) IS [NOT] NULL IS不能用等号代替 AND OR NOT 还有一些比较运算符&lt; = &gt; &lt;= &gt;= !=... 连接连接条件中字段类型必须是可比的，但名字不必相同 等值与非等值对同名列要根据 表名.列名 的形式进行区分 连接执行方法 嵌套循环法：穷举 排序合并法：先排序再merge 索引连接：只与索引字段比较 自然连接根据两个表中同名的列而进行连接的，当列不同名时，自然连接将失去意义。且语法中没有on 即在等值连接的基础上把重复列去掉 自身连接属性自相关 如：查间接先修课(先修课的先修课)SELECT FORST.Cno,SECOND.Cpno FROM Course FIRST,Course SECOND WHERE FIRST.Cpno = SECOND.Cno; 要对属性起别名进行区分 外连接不满足条件的也输出 ，如连接的某表中有些属性是空值。 可有左外连接和右外连接 例：SELECT Student.Sno,Sname,Sage,Cno,Grade FROM Student LEFT OUT JOIN SC ON(Student.Sno = SC.Sno); 嵌套 含IN的子查询：SELECT Sno FROM SC WHERE Cno IN(SELECT Cno FROM Course WHERE Cname = &#39;计算机&#39;); 含比较运算符：SELECT Sno,Cno FROM SC X WHERE Grade &gt;= (SELECT AVG(Grade) FROM SC Y WHERE Y.Sno = X.Sno); 当子查询对父查询有依赖关系时，会将外层查询的元组的属性按顺序传给内层去处理 含ANY/SOME/ALL：与比较运算符搭配使用，放在子查询括号之前。有时候可以用聚集函数MAX/MIN代替实现ANY/ALL之类的查询 含[NOT] EXISTS : 上面的三种都可以用某种形式的EXISTS来实现 子查询不能使用ORDER BY 如果嵌套有很多层的话，其实用连接查询更简单 子查询还可以用在FROM子句中，这时生成的临时派生表是主查询对象 集合参与查询的列数必须相同，对应的数据类型也相同 UNION [ALL] 并集，加上ALL保留重复元组 INTERSECT 交集 EXCEPT 差集 更新插入插入元组：INSERT INTO &lt;表名&gt; [(&lt;属性列1&gt;[,&lt;属性列2 &gt;…)] VALUES (&lt;常量1&gt; [,&lt;常量2&gt;]… ); 插入子查询：例如 12345INSERTINTO Dept_age(Sdept,Avg_age) SELECT Sdept，AVG(Sage) FROM Student GROUP BY Sdept; 修改UPDATE &lt;表名&gt; SET &lt;列名&gt;=&lt;表达式&gt;[,&lt;列名&gt;=&lt;表达式&gt;]…[WHERE &lt;条件&gt;]; 主码不允许修改 删除DELETE FROM &lt;表名&gt; [WHERE &lt;条件&gt;]; 空值约束条件： 有NOT NULL约束条件的不能取空值 加了UNIQUE限制的属性不能取空值 码属性不能取空值 空值与另一个值（包括另一个空值）的算术运算的结果为空值；空值与另一个值（包括另一个空值）的比较运算的结果为UNKNOWN。 完整性 正确性：符合实际 相容性：符合逻辑 例子： 1234567891011121314CREATE TABLE SC ( Sno CHAR(9) NOT NULL， Cno CHAR(4) NOT NULL， Grade SMALLINT, PRIMARY KEY(Sno,Cno)， FOREIGN KEY (Sno) REFERENCES Student(Sno) ON DELETE CASCADE /*级联删除SC表中相应的元组*/ ON UPDATE CASCADE, /*级联更新SC表中相应的元组*/ FOREIGN KEY (Cno) REFERENCES Course(Cno) ON DELETE NO ACTION /*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/ ON UPDATE CASCADE /*当更新course表中的cno时，级联更新SC表中相应的元组*/ ); 完整性约束命名子句：CONSTRAINT &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt; 对约束命名更利于后续操作，如删除ALTER TABLE Student DROP CONSTRAINT C4; 断言CREATE ASSERTION&lt;断言名&gt;&lt;CHECK 子句&gt;可以定义涉及多个表的或聚集操作的比较复杂的完整性约束 例 12345CREATE ASSERTION ASSE_SC_CNUM2 CHECK(60 &gt;= ALL (SELECT count(*) FROM SC GROUP by cno,TERM) ); 触发器一种特殊的存储过程，当表中发生特殊事件时执行。触发器主要用于保证数据的完整性。 只能定义在基本表上，不能定义在视图上 12345CREATE TRIGGER &lt;触发器名&gt; &#123;BEFORE | AFTER&#125; &lt;触发事件&gt; ON &lt;表名&gt; REFERENCING NEW|OLD ROW AS&lt;变量&gt; FOR EACH &#123;ROW | STATEMENT&#125; [WHEN &lt;触发条件&gt;]&lt;触发动作体&gt; 安全性实现方法 用户身份鉴别 存取控制技术 自主存取控制：限制存取权限 强制存取控制：数据本身设置安全性标记 TS&gt;=S&gt;=C&gt;=P 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体 仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体 视图技术 审计技术 数据加密存储和加密传输 授权1234GRANT &lt;权限&gt;[,&lt;权限&gt;]... ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]…TO &lt;用户&gt;[,&lt;用户&gt;]...[WITH GRANT OPTION]; 全部权限：ALL PRIVILIGES 全部用户：PUBLIC 允许再授权：WITH GRANT OPTION 不允许循环授权 权限回收 123REVOKE &lt;权限&gt;[,&lt;权限&gt;]... ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…FROM &lt;用户&gt;[,&lt;用户&gt;]...[CASCADE | RESTRICT]; 也可以定义一个具有某种权限角色CREATE ROLE &lt;角色名&gt;，直接将角色赋给用户 范式 1NF: 每个分量必须是不可分开的数据项 2NF: 每一个非主属性都完全函数依赖于任何一个候选码(不存在对主键的部分函数依赖) 解决：对部分依赖属性分解成多个表 3NF: 不存在属性对主键的传递依赖 BCNF: 不存在主属性对码的部分依赖和传递依赖——即不能由属性反推出主码 如果一个关系数据库中的所有关系模式都属于BCNF，那么在函数依赖范畴内，它已实现了模式的彻底分解，达到了最高的规范化程度，消除了插入异常和删除异常 不能说规范化程度越高的关系模式就越好。 数据库设计数据库设计分6个阶段 需求分析 概念结构设计 逻辑结构设计 物理结构设计 数据库实施 数据库运行和维护 联系转换方法： 法一：新建一个联系表，要建立联系的表中的属性组成联系表的主键——多用于多对多 法二：主键+联系写到另一个要联系的表中——外键，多用于一对一，一对多 数据库恢复事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 事务是恢复和并发控制的基本单位 事务的ACID特性： 原子性（Atomicity）:操作要么都做，要么都不做 一致性（Consistency）:事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态 隔离性（Isolation）:一个事务的执行不能被其他事务干扰 持续性（Durability ）:一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。 利用存储在后备副本、日志文件和数据库镜像中的冗余数据来重建数据库 恢复策略： 事务故障：反向扫描文件日志，对该事务的更新操作执行逆操作 系统故障：正向扫描日志文件，重做(REDO) 和撤销 (UNDO) 介质故障：重装数据库，重做已完成的事务 并发控制事务是并发控制的基本单位 主要任务 对并发操作进行正确调度 保证事务的隔离性 保证数据库的一致性：避免发生丢失修改(修改覆盖)、不可重复读(有改删增)、读脏数据(有回滚) 主要技术 封锁 排它锁(X)：写锁，其他事务不能读或改 共享锁(S)：读锁，其实事务可读不可改，读锁上可再加读锁 封锁协议 一级：修改加X, 避免丢失修改 二级：一级 + 读数加S读完就释放 ，避免丢失修改和读脏数据 三级：一级 + 读数加S事务完才释放，进一步避免了不可重复读 避免活锁(类似饥饿)：FCFS 避免死锁： 死锁预防：一次封锁法–效率低；顺序封锁法–难实现 诊断(超时法–可能误判，不够及时；等待图法检测回路)并解除死锁(kill或抢占) 时间戳 乐观控制法 多版本并发控制 冲突可串行化一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是冲突可串行化的调度。 冲突可串行化调度是可串行化调度的充分条件","categories":[{"name":"database","slug":"database","permalink":"http://vergessenwang.github.io/categories/database/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://vergessenwang.github.io/tags/数据库/"},{"name":"SQL","slug":"SQL","permalink":"http://vergessenwang.github.io/tags/SQL/"},{"name":"数据模型","slug":"数据模型","permalink":"http://vergessenwang.github.io/tags/数据模型/"}]},{"title":"传输层&网络层","slug":"传输层-网络层","date":"2019-09-04T14:12:41.000Z","updated":"2019-09-04T14:14:16.156Z","comments":true,"path":"posts/network/2019-09-04-传输层-网络层.html","link":"","permalink":"http://vergessenwang.github.io/posts/network/2019-09-04-传输层-网络层.html","excerpt":"基本概念协议定义了在两个或多个对等通信实体之间交换的报文格式和顺序，以及发收报文或其他事件所采取的动作。 语法：传输数据的格式、信号电压 语义：要完成的控制信息、响应、差错控制等功能 时序：执行顺序、条件 协议是水平的，服务是垂直的。 边缘网接入技术家庭接入：DSL(利用数字电话线)、电缆(利用电视线)、FTTH(光纤到户)、拨号(传统电话线，速度慢)和卫星、以太网、WIFI HFC(混合光纤同轴)：是在电缆接入的主干线上用光纤传输，用户共享传输速率。电缆调制调解器会将HFC网络分为上行和下行两个信道，所以不会产生碰撞。 公司接入：以太网(用户接入速率100Mbps~1Gbps, 服务器1Gbps~10Gbps)和WIFI 广域无线接入：3G、4G(第四代广域无线网络)、LTE(长期演进，源于3G)","text":"基本概念协议定义了在两个或多个对等通信实体之间交换的报文格式和顺序，以及发收报文或其他事件所采取的动作。 语法：传输数据的格式、信号电压 语义：要完成的控制信息、响应、差错控制等功能 时序：执行顺序、条件 协议是水平的，服务是垂直的。 边缘网接入技术家庭接入：DSL(利用数字电话线)、电缆(利用电视线)、FTTH(光纤到户)、拨号(传统电话线，速度慢)和卫星、以太网、WIFI HFC(混合光纤同轴)：是在电缆接入的主干线上用光纤传输，用户共享传输速率。电缆调制调解器会将HFC网络分为上行和下行两个信道，所以不会产生碰撞。 公司接入：以太网(用户接入速率100Mbps~1Gbps, 服务器1Gbps~10Gbps)和WIFI 广域无线接入：3G、4G(第四代广域无线网络)、LTE(长期演进，源于3G) 核心网交换技术分组交换：需要存储转发机制和路由选择协议的支持。按需分配 时延：处理时延 + 排队时延(变动的) + 传输时延 + 传播时延 流量强度：La/R 吞吐量：多段链路的吞吐量取决于瓶颈链路 总共有M个用户时，同时有N个用户在发送数据的概率 电路交换：需要TDM和FDM复用技术。连接稳定 因特网结构接入ISP + 区域ISP + IXP + 第一层ISP + 内容提供商 对等层ISP不相互结算，通过IXP接入高层ISP费用更低，这两种方式可以减少费用。 内容提供商的数据中心更靠近低层ISP，绕开高层ISP，可以在减少延迟的同时也降低费用 报文&amp;报文段&amp;数据报&amp;帧 应用层报文指的是在端系统的应用程序之间按照某种协议进行信息交换的分组. 运输层报文段指的是通过TCP/UDP等运输层协议对应用层报文进行封装后所形成的分组, 报文段对报文的传输参数进行了一定的设置, 使其具有了某种特性, 比如面向连接, 确保传递等. 网络层数据报是对运输层报文段和目的地址进行封装后产生的分组. 数据报确定了分组的目的地, 使得分组可以通过网络层从发送方传送到接收方. 链路层帧是对网络层数据报的封装, 它添加了下一个节点的具体地址, 使得分组能够传递到下一个节点 传输层UDP基于IP协议增加： 复用/分用 简单的错误校验 source port + dest port + length + checksum checksum发送方校验和计算：计算所有16位整数的和，进位加在和后面，结果按位取反；接收方检验时将所有字节与检验和相加结果应该为全1 提供”Best effort”服务，UDP段可能丢失或非按序到达 优点：无建立连接的延迟，无需维护连接状态，头部开销少，没有拥塞控制应用程序可更好的控制自己的发送时间和速率 应用：流媒体(现在的语音和图像其实更多是用TCP，因为大多数防火墙会拦截UDP)，DNS，SNMP(简单网络管理协议)——适用于实时服务，且能容忍一定的分组丢失 TCP可靠数据传输协议(rdt)在不可靠的底层信道上实现可靠信道 数据单向传输，控制信息双向流动 可能产生位错误：接收方利用校验和检测位错误，利用确认机制在错误发生(NAK)时要求重传分组,ARQ协议——0-1停等协议 可能ACK/NAK本身有错误，导致重复传递分组，接收方无法对新发来的分组进行判断：增加序列号，接收方丢弃重复分组，而且可以省去NAK(收到重复ACK时代表出错) 可能丢包(数据报或ACK）：需要定时器，发送方等待合理时间之后重传，即使由于延迟最后又到了也能用序号机制处理重复分组。即使知道RTT，对于每一个分组也仍然需要定时器来记录对应的时间。 停等协议中发送方利用率(L/R)/(RTT+ L/R)极低，网络协议限制了物理资源的利用 流水线机制与滑动窗口协议利用等待时间，在收到ACK之前连续发送多个分组 窗口：更大的序列号范围，更大的存储空间缓存分组 滑动窗口：随着协议的运行，窗口在序列号空间内向前滑动(窗口数 &lt; 序列号数) 滑动窗口协议：GBN ，SR Go-Back-N 协议 ACK(n): 到n(包含n)之前的分组均已被正确接收——累积确认机制 多个分组共用一个timer,发送base分组时启动 超时Timeout(n)：重传序列号 &gt;= n 的还未收到ACK的所有分组——可能造成资源浪费 接收方没有缓存，乱序到达的分组直接丢弃，重新确认序列号最大的按序到达分组 缺陷：重传分组太多 Selective Repeat 协议基于GBN修改确认机制和对乱序分组的处理 接收方对每个分组单独确认 接收方缓存乱序到达分组 每个分组有一个timer 避免序列号重叠问题：$N_S+ N_R &lt;= 2^K$ 窗口长度必须&lt;=序号空间大小的一半 TCP原理TCP在IP层提供的不可靠服务基础上实现可靠数据传输。用到了上述的：*流水线机制，累积确认，单一重传定时器，超时或收到重复ACK时触发重传结合了GBN和SR的优点 段结构 序列号：segment第一个字节的编号 ACKs: 希望接收到的下一个字节的序列号，采用累计确认 定时器超时时间的设置：$EstimatedRTT$ + 安全边界 $EstimatedRTT = (1 - \\alpha)EstimatedRTT + \\alphaSampleRTT$ 用多个SampleRTT的指数加权移动平均求估计RTT $\\alpha$ 一般取0.125 $DevRTT = (1 - \\beta)DevRTT + \\beta|SampleRTT-EstimatedRTT|$ 用方差求RTT的变化值即安全边界，$\\beta$ 一般取0.25 $TimeoutInterval = EstimatedRTT + 4*DevRTT$ 快速重传机制：即在定时器超时之前重传，因为真正发生超时的时候，根据上述的计算公式timeoutinterval也会变得很大，所以在收到重复的三个ACK之后，马上重传，每次重传后将超时时间加倍 流量控制：接收方通过在segment头部字段将rcvwindow告诉发送方，发送方据此控制发送数据量 $rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]$ 三次握手四次挥手看图示流程更好理解，注意各个步骤中SYN ACK FIN 等信号的区别 拥塞控制原理相比于可靠数据传输对端到端的传输控制，拥塞控制更多的考虑整个网络的全局性问题。相比于流量控制考虑的是接收方的处理能力，拥塞控制考虑的是整个网络的处理能力 主要表现为分组丢失和排队延迟过大。由于分组丢失和定时器超时都会重发，导致有效分组更少，整体吞吐量进一步下降。同时，在多跳传输中，当分组被dropd掉时，任何用于该分组的上游处理全都白费了，这是对整个网络资源的另一种浪费，在这种情况下，当每个路由器都在做无用功时，吞吐量趋近0。 控制方法： 端到端：端系统通过观察loss , delay 等网络行为判断是否发生拥塞——TCP采用 网络辅助：路由器向发送方反馈网络拥塞信息 ——ATM(异步传输模式) TCP拥塞控制 拥塞窗口：$CongWin &gt;= LastByteSend - LastByteAcked$ 则发送速率为 $rate ≈ CongWin / RTT$ 可以看到拥塞窗口是可以动态调整的 感知拥塞：发送loss事件(timeout或3个重复的ACK)之后，发送方降低速率。速率调整的方法： 加性增-乘性减(AIMD) 每个RTT将CongWin增大一个MSS(TCP一次能传输的数据的最大值，不包括协议头开销)——谨慎增加，拥塞避免 发生loss后将CongWin减半 慢启动(SS) 收到每个ACK将CongWin翻倍，指数型增长 综合运用 设置一个慢启动阈值变量 ssthresh，用来控制是采用SS还是AIMD 开始用SS, 达到ssthresh后改为AIMD 当收到3个重复ACK时，CongWin/2并且将ssthresh更新为前CongWin/2，即又开始线性增长 当发生timeout事件时，直接将CongWin设为1并且将ssthresh更新为前CongWin/2 ，然后开始SS——因为超时表明拥塞更加严重 平均吞吐量计算：期间发送的总MSS数量 / 耗费的RTT数 MSS数量跟发送窗口数W有关 网络层核心功能：转发和路由 路由算法确定通过网络的端到端路径，转发表确定本路由器如何转发分组。 两类分组交换网络服务模型：无连接的数据报网络和连接的虚电路网络 相比于传输层，网络层服务是在网络核心实现的主机到主机服务 虚电路一条从源主机到目的主机类似于电路的逻辑连接，与电路交换的区别是，采用分组交换且每个分组在传输时会利用链路的全部带宽。但同时也具备了电路交换预分配资源的优点，从而使得服务性能有一定的保证 每个分组携带虚电路标识VCID 而不是目的主机地址。同一条虚电路在不同链路段上的VCID 可能是不同的 经过的每个网络设备会维护每条经过它的虚电路连接状态，利用VC转发表记录、改写输入输出VCID 信令协议在建立时一次性确定路径 应用：ATM 、帧中继网络等 数据报无连接，分组携带目的地址。由于路径是不确定的，所以需要路由算法构建转发表。 转发时并不是针对某一具体地址，而是一个地址范围，相当于对转发表进行聚合。最长前缀匹配优先 端系统更为智能，可以自适应、性能控制和差错恢复。(VC的端系统为电话机、传真机) 可以理解为技术进步带来的功能转移，更复杂的处理放到上层去做——简化网络，复杂边缘 应用：Internet IP协议首部结构理解各字段的含义 版本号：一般为IPv4, 即 4H 首部长度：占4位，以4字节为单位。一般不含可选字段时首部长度为20字节，即首部字段为5H 服务类型：一般不使用，00H 总长度：占16位，指的是首部+数据的长度。因此最长数据为 65535B - 20B = 65515B，但是链路层有MTU限制，而且不同链路的MTU也会不同，所以还需要分片和重组机制，路由器只分不装，目的主机负责重组 标识：和源IP目的IP共同标识一个IP分组，取原IP分组的标识 标志位：占3位，保留位 + DF(Don’t Fragment) +MF(More Fragment) 片偏移：相对原IP分组的偏移量，以8字节为单位，每个片长是8的整数倍，计算时要注意取整 生存时间TLL：剩余跳数，转发一次减1，为0 时路由器将其丢弃同时向源主机发送一个ICMP报文 协议：TCP为6 UDP为17 首部校验和：同UDP, 只对首部校验，由于TLL等字段会发生变化，所以要逐跳校验 IP地址IP子网：具有相同网络号的设备接口，彼此间不跨越路由器(第三层及上层网络设备)就可以进行物理联通 有类编址 A类(50%): 子网占8位，最高位固定为0 ，0.0.0.0~127.255.255.255 B类(25%): 子网占16位，最高两位固定为10，128.0.0.0~191.255.255.255 C类(12.5%): 子网占24位，最高三位固定为110，192.0.0.0~223.255.255.255 D类(6.25%): 子网占32位，最高四位固定为1110，224.0.0.0~239.255.255.255 E类(6.25%): 子网占32位，最高四位固定为1111，240.0.0.0~255.255.255.255 A、B、C类可以分配做主机IP地址，注意一些全0(本机)或全1(广播)或127(环回)的特殊地址 还有一部分保留的私有地址(可复用): A类 10 B类 172.16~172.31 C类 192.168.0~192.168.255 子网划分借用主机号的一部分，用子网掩码按位与来提取子网地址 无类域间路由(CIDR)地址格式：a.b.c.d/x 可以将多个子网聚合成一个较大的子网，构成超网，这种路由聚合可以大幅减少路由表内容 IPv6(128bit)更多地址，同时改进首部格式以快速处理转发数据报和支持QoS 首部长度固定40字节——不含可选区，但基本首部之外可含无需路由器处理的拓展首部 版本、优先级、流标签 载荷长度、下一个首部、跳步限制 源地址、目的地址 不允许分片——要分只能在源主机分 不含校验和域，加快处理速度 新版ICMP,：新增 如 包过大的ICMP报文，多播组管理功能 不使用掩码，采用CIDR的...../x 形式表示地址前缀 格式：16bit 4个16进制数一组，共8组。可多个0可省略 过渡技术： 隧道：IPv6封装到IPv4数据部分，完成封装的路由器支持双协议栈 DHCP获取IP地址硬编码：静态配置 DHCP协议：动态主机配置协议，租赁IP地址。服务器为客户配置IP、掩码、默认网关和DNS，即插即用，允许地址重用 要接入的主机广播 DHCP discover 源端口0.0.0.0 68 目的端口255.255.255.255 67 DHCP服务器利用 DHCP offer 响应 主机请求IP DHCP request DHCP服务器分配IP DHCP ack DHCP采用C/S模式，用UDP封装，服务器默认端口67 网络地址转换(NAT)节省IPv4地址，内外IP变动相互隔离，只需通过NAT转换表重定向，增加内部设备的安全性。 争议：要对端口进行处理，违背了层次关系 NAT穿透：如何访问位于内网的服务器或主机 静态配置NAT, 来自特定端口被转发给服务器 利用即插即用互联网网关设备协议IGD 自动配置 中继服务器桥接 ICMP协议差错报告报文：目的不可达，源抑制，超时，参数问题，重定向 网络探询报文：回声请求与应答报文——ping，时间戳请求与应答报文 不发送的情况： 对ICMP报文本身不发 只对第一个IP数据报分片发送，后续分片不发 多播IP数据报不发 特殊地址 如0.0.0.0 或 127.0.0.0 不发 封装到IP数据部分 Traceout 是ICMP的一个应用，通过逐渐增加TTL，依次获得该路径上的路由器名称和IP，选择一个不被使用的端口这样到达目的主机后会返回一个目的端口不可达ICMP报文，终止跟踪。 路由算法静态路由: 手工配置, 更新慢，优先级高 动态路由：及时更新 基于全局信息：链路状态路由算法——OSPF(TCP) 基于Dijkstra算法(单源最短路径) 可能存在震荡现在：由于动态更新，路径一直变来变去 基于局部信息：距离 - 向量路由算法——RIP(最多15跳的内部路由,UDP) 基于Bellman-Ford方程(动态规划) 根据邻居信息和局部链路费用变化异步更新，有变化时才告知邻居 无穷计数问题：好消息传的快，坏消息传的慢，因为要参考未变化的邻居发来的信息 解决方法：毒性逆转 重点 时延计算 socket 通信步骤 可靠数据传输，FSM描述不想看了.. 往返时间估计 TCP/IP五层协议：应用-运输-网络-链路-物理 OSI七层参考模型：应用-表示-会话…. CRC校验码: 原m 位信息左移 生成多项式最高阶 位低位补0，与生成多项式对应的除数进行异或，得到的余数为冗余码 海明码 子网划分：在主机号上进行划分，注意点分十进制与二进制的转换，变长子网划分类似于变长指令拓展，或同一子网由两个不同区间拼接 IP数据报分片: 注意每个分片都要加上首部，片偏移要用起始位 / 8 TCP和UDP的特点和区别 TCP滑动窗口 发送窗口： 已发送并收到确认 || 已发送未收到确认 | 可用窗口 || 不允许发送 接收窗口：已确认并交付主机 || 允许接收的序号 || 不允许接收 拥塞控制及快速重传：区分超时和3个重复ACK时拥塞窗口的变化，注意阈值可能 &lt; 慢启动的$2^n$ TCP的三次握手及四次挥手 握手：SYN = 1, seq = x –&gt; SYN =1, ACK =1 ,seq = y , ack = x +1 –&gt; ACK =1 ,seq = x + 1, ack = y + 1 为什么要四次挥手客户端要等待2MSL：保证最后一个确认报文段无法到达时可以重传；使本次连接所产生的所有报文从网络消失，防止出现已失效的连接请求占用资源。由此可见客户端更早请求关闭，实际上更晚真正关闭 路由选择(距离-向量法) 添加没有的路由，注意跳数 + 1 替换已有的较长路由 更新过时路由","categories":[{"name":"network","slug":"network","permalink":"http://vergessenwang.github.io/categories/network/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://vergessenwang.github.io/tags/TCP-IP/"},{"name":"传输层","slug":"传输层","permalink":"http://vergessenwang.github.io/tags/传输层/"},{"name":"网络层","slug":"网络层","permalink":"http://vergessenwang.github.io/tags/网络层/"}]},{"title":"数据结构与C语言","slug":"数据结构与C语言","date":"2019-09-01T15:23:25.000Z","updated":"2019-09-01T15:51:02.041Z","comments":true,"path":"posts/data-structure/2019-09-01-数据结构与C语言.html","link":"","permalink":"http://vergessenwang.github.io/posts/data-structure/2019-09-01-数据结构与C语言.html","excerpt":"基于实验楼 C语言实验语言热度排行 果然是犹豫不决学Java… “不管你懂多少延续、闭包、异常处理，只要你不能解释为什么 while(*s++=*t++); 的作用是复制字符串，那你就是在盲目无知的情况下编程，就像一个医生不懂最基本的解剖学就在开处方” Linux 不以文件后缀来区分可执行文件，Linux 下的可执行文件后缀理论上是可以任意更改的。 C语言教程 基本命令编译：gcc -c **.c 生成对象文件 链接：gcc -o ** **.o 生成没有后缀的可执行文件 同时进行：gcc -o ** **.c 执行：./**","text":"基于实验楼 C语言实验语言热度排行 果然是犹豫不决学Java… “不管你懂多少延续、闭包、异常处理，只要你不能解释为什么 while(*s++=*t++); 的作用是复制字符串，那你就是在盲目无知的情况下编程，就像一个医生不懂最基本的解剖学就在开处方” Linux 不以文件后缀来区分可执行文件，Linux 下的可执行文件后缀理论上是可以任意更改的。 C语言教程 基本命令编译：gcc -c **.c 生成对象文件 链接：gcc -o ** **.o 生成没有后缀的可执行文件 同时进行：gcc -o ** **.c 执行：./** 数据类型gcc 编译器为每个int类型分配四个字节（32 个二进位）。在存储单元中的存储方式是：用整数的补码形式存放。所以当 4 个字节的整数类型取值范围是 -2^31 到（2^31-1）。无符号的基本整型表示为 unsigned int，和 int 类型占有的字节数相同，取值范围是 0 到（2^32-1） 字符型数据在存储时，并不是把该字符本身存放到内存单元中，而是把该字符相应的 ASCII 码值存放到该存储单元中。——真正代表了数据含义的是数据类型，而不是二进制本身。用小写表示的字符的 ASCII 码比用大写表示的 ASCII 码大 32。 存储字符串常量时还要自动在其末尾加上 ‘\\0’ 作为字符串结束的标志，所以&quot;b&quot;会占用两个字节而&#39;b&#39;是一个字节 要将一个字符串存放在变量中，必须使用字符数组。C 语言中没有字符串类型，字符串都是存储在字符型数组中的。处理字符串时要加上string.h头文件 在强制类型转换时，得到一个所需类型的中间数据，而原来变量的类型未发生变化 C 库&lt;stdlib.h&gt;中的函数 int atoi(const char *str)把参数 **str** 所指向的字符串转换为一个整数（类型为 int 型） atoi(),itoa() 与强制类型转换的区别atoi(),itoa()是整型数和字符串表示的整型数字之间的转换，是函数调用实现的。对内建基本类型之间的强制类型转换是在编译时实现的，对数值可能会截断、重新解释（不能用(int)直接把表示数字的字符串转成数字，好像要 -&#39;0&#39;) 运算符自增运算符 (++) 和自减运算符 (–) 只能用于变量，而不能用于常量或表达式。如 5++ 或者 (a+b)++ 都是不合法的 字符 (char) 型数据和整形数据进行运算，就是把字符的 ASCII 代码与整形运算 输入输出在 printf 函数中，在格式符 “f” 的前面加 “7.2”。表示的意思是在输出时，指定数据占 7 列，其中小数占 2 列。主要是使小数点对齐，输出时更加美观 %d：按照整型数据的实际长度输出。 %md：以m指定的字段宽度输出，右对齐。加 -左对齐 %ld：输出长整型数据。 %mld：输出指定宽度的长整型数据。 在输入函数时，用 %c 格式声明输入字符时，空格字符和转义字符都是作为有效字符输入，所以输入时中间不要有空格 main函数的参数argc和argvint main(int argc,char *argv[]) = int main(int argc,char **argv)其参数argc和argv用于运行时,把命令行参数传入主程序 int argc英文名为arguments count(参数计数)。运行程序传送给main函数的命令行参数总个数,包括可执行程序名,其中当**argc=1时表示只有一个程序名称,此时存储在argv[0]**中. char **argv:英文名为arguments value/vector(参数值)。用来存放指向字符串参数的指针数组！指针数组！指针数组！不是字符串本身每个元素指向一个参数,空格分隔参数,其长度为argc. argv[0] 指向程序运行时的全路径名 argv[1]指向程序在DOS命令中执行程序名后的第一个字符串 argv[2] 指向执行程序名后的第二个字符串 argv[argc]为NULL 参考Eastmount的博客 命令行运行程序时，要在可执行文件名后加上参数 条件语句while和do…while和 while 语句不同， do...while 语句中的 while（）；后面是有“；”的 另外，当 while 后面的表达式的第一次值为“真”时，两种循环得到的结果是相同的；否则，二者结果不相同(do…while会先执行一次） 要注意的细节 #include&lt;stdio.h&gt;不要忘记写#和.h scanf()函数中的表列是地址表列，要加&amp;，数组不用加 float的精度只有6~7位，double是15~16位，long double是18~19位 在 Linux 系统下，Ｃ 源文件若调用了 math 库里的函数，则编译时要加上-lm（是字母 l ，不是数字１），表示链接到 math 库。 打印数组时要换行可以用一个全局变量整除来控制 C语言知识点字符 c = getchar(); putchar(c); 输入结尾判定getchar() != EOF 通过getchar()获得的数字实际上是一个该数字的ASCII码，用于数值计算时要用c - &#39;0&#39; 数组 a == &amp;a[0] 每个元素是同一数据类型，只能逐个引用(常用for循环)，不能一次引用整个数组。 编译器会为数组分配一段连续内存，二维数组先行后列 定义可以用常量和符号常量，如#define SIZE 10 int a[SIZE];,但一定不能包含变量(访问可用变量)。为了便于后续更改，一般采用符号常量 定义的同时对全部元素赋初值，可以不指定数组长度，如int a[] = {0,1,2,3,4}; 对于二维数组，第一维可以不指定但第二维必须指定 （emmm，发布博文时报错，可能是双大括号的原因，这里删去了，试下能发布的话就是这个原因） 一维数组用例：冒泡排序 二维数组用例：矩阵最大值及行列号——打擂台法 字符数组与字符串 字符数组：char a[] = {&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;}; 长度为4 字符串：char a[] = &quot;abcd&quot;; 以双引号赋值时，系统自动加上&#39;\\0&#39;结束符，长度为5 &lt;string.h&gt; gets(str); puts(str); strcat(str1,str2); strlen(str); strcpy(str1,str2); strcmp(str1,str2); 函数化结构 在程序中用到的所有函数，必须“先定义，后使用” 自定义的函数要在main函数调用之前声明或定义。 函数声明的作用是把有关函数的信息（函数名、函数类型、函数参数的个数与类型）通知编译系统，在进行到 main 函数调用时知道他们是函数而不是变量或其他对象。 有参函数在调用函数时，主调函数通过参数向被调函数传输数据，要注意被调用函数返回值的类型 在定义函数中指定的形参，在未出现函数调用时，他们并不占内存中的存储单元。在发生函数调用时，函数形参被临时分配内存单元；调用结束，形参单元被释放。所以要注意函数内部变量的作用域 C语言中函数不能嵌套定义，但是可以嵌套调用 要访问其他源文件的变量：extern ——用头文件的方式更好#ifndef....#define....#endif 要自己的变量不被访问：static 初始化一次，一直占用空间，循环调用时会共享 指针 变量是对程序中数据存储空间的抽象 指针变量的类型，是指针变量所指向的变量的类型，而不是自身的类型 注意：多维数组中指针的各种运算 数据结构数据结构实验 时空复杂度在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 T(n) 的同数量级（它的同数量级有以下：1，log(2)n，n，n log(2)n ，n 的平方，n 的三次方，2 的 n 次方，n!），找出后，f(n) = 该数量级，若 T(n)/f(n) 求极限可得到一常数 c，则时间复杂度 T(n) = O(f(n))。 计算空间复杂度主要看可变部分，包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。一个算法所需的存储空间用 f(n)表示：S(n)=O(f(n))。其中 n 为问题的规模，S(n)表示空间复杂度。 线性表 集合中必存在唯一的一个”第一个元素”； 集合中必存在唯一的一个”最后的元素”； 除最后元素之外，其它数据元素均有唯一的”后继”； 除第一元素之外，其它数据元素均有唯一的”前驱”。 线性表有顺序和链式两种存储结构 顺序表易随机存取，已使用的空间存储密度大；不易增删，空间固定难扩充 123456typedef struct&#123; Elemtype *elem; //存储空间基址 int length; //当前长度 int size; //当前分配的表长大小&#125;SqList; 插入：先判断表是否已满 –&gt; 判断插入位置是否越界 –&gt; 从最后一个元素开始向后移动一位 –&gt; 插入值，length + 1；平均移动一半元素 T(n) = O(n) 归并算法T(n) = O(n + m) 12345678910void merge(SqList *A,SqList *B,SqList *C)&#123; int i=1,j=1,k=1; while(i &lt;= A-&gt;length &amp;&amp; j &lt;= B-&gt;length) if(A-&gt;elem[i] &lt;= B -&gt;elem[j]) C-&gt;elem[k++] = A-&gt;elem[i++]; else C-&gt;elem[k++] = B-&gt;elem[j++]; while(i &lt;= A-&gt;length) C-&gt;elem[k++] = A-&gt;elem[i++]; while(i &lt;= B-&gt;length) C-&gt;elem[k++] = B-&gt;elem[j++]; C-&gt;length = A-&gt;length + B-&gt;length;&#125; 链表12345typedef struct LNode&#123; ElemType data; // 数据域 struct LNode *next; // 指针域&#125;LNode, *LinkList; LinkList h头指针数据域为空，指针域指向单链表的第一个节点，可以避免对链表的第一个结点做特殊处理。因为对于无头结点的空表，插入值时可以直接对第一个结点的数据域赋值，而无需新建一个结点，或者直接改变第一个指针指向的地址为新结点 尾结点指针域为NULL LNode *p; 常用指向结点的指针变量p，一般直接赋值为某个已存在结点 p = (LinkList)malloc(sizeof(LNode)); free(p); 为要插入的新结点分配空间，删除某结点要释放空间 相比于头插法，尾插法需要多一个尾指针 另外，对于删除操作，可以使用一个暂存已删除结点的avail链表，下次分配时先用链表中的结点，并可以用指针操作在O(1)的复杂度实现整个链表的删除 反转链表由于链表不支持随机访问，所以交换头尾值的方法并不可行，最好还是直接改变指针域方向 123456789101112LNode reverseList(LinkList head) &#123; LNode next = null; LNode pre = null while (head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre;&#125; 循环链表通常只设一个尾指针 连接两个单循环链表：O(1) 1234p = RA -&gt; next; // 找到A的头结点RA -&gt; next = RB -&gt; next -&gt; next; //A尾连B的第一个结点，注意不是头结点free(RB -&gt; next); //记得删除B的头结点RB -&gt; next = p; //B尾连A头 双向链表12345typedef struct dlnode&#123; ElemType data; struct dlnode *prior,*next;&#125;DLNode,*DLinkList; 删除结点 123p -&gt; prior -&gt; next = p -&gt; next;p -&gt; next -&gt; prior = p -&gt; prior;free(p); 双向循环链表没有空指针域 栈和队列(受限线性表)栈通常我们称表尾端为栈顶，表头端为栈底。栈上溢是一种出错状态，下溢则是一种正常状态，常用作程序转移控制条件 可以解决例如数值转换、括号匹配、迷宫求解、表达式求值和汉诺塔等等问题。 也有顺序存储结构和链式存储结构两种表示方法 顺序实现结构体： 12345typedef struct&#123; SElemType *base; //栈尾指针 SElemType *top; //栈顶指针 int size; //栈的大小&#125;SqStack; 链式实现结构体： 1234typedef struct node&#123; ElemType data; struct node *next;&#125;StackNode; 对于链栈，若新申请一个结点时t = NULL 则表示链满；申请成功用头插法插入到top结点前并更新top 多栈共享存储空间：两个栈的栈底分别设在存储空间的两端，向中间延伸，相遇时溢出。 队列允许插入元素的一端称为队尾，允许删除元素的一端称为队头 应用于操作系统调度任务队列。 顺序实现： 1234typedef struct&#123; ElemType elem[MAXSIZE]; int rear,front;&#125;SeQueue; 由于队首指针会不断向后移动，前面空间无法利用，造成一种假溢出，于是可以将首尾连起来，构成循环队列。为了区分队满队空，要留出一个空间，队空 sq -&gt; front == sq -&gt; rear 队满sq -&gt; front == (sq -&gt; rear + 1) % MAXSIZE 链表实现： 123456789typedef struct QNode&#123; QElemType data; struct QNode *next;&#125;QNode, *QueuePtr;typedef struct&#123; QueuePtr front; //队头指针 QueuePtr rear; //队尾指针&#125;LinkQueue; 入队时空链表要特殊处理，因为此时都指向同一个结点(对头指针多做一个指向p结点的操作)： 12345678void In_LQueue(LQueue *Lq,ElemType x)&#123; QNode *p; p = (QNode*)malloc(sizeof(QNode)); p -&gt; data = x; p -&gt; next = NULL; if(Lq -&gt; rear == NULL) Lq -&gt; front = Lq -&gt; rear = p; else &#123;Lq -&gt; rear -&gt; next = p; Lq -&gt; rear = p;&#125;&#125; 出队时同理，当成为空表时，对尾结点多做一个指向新的头结点的操作。 树用孩子兄弟法将任意的一棵树转成一个没有右孩子二叉树。 树不能为空，二叉树可以为空。二叉树左右子树不能交换，而树的左右子树可以交换 二叉树重要性质 第 i 层最多 $2^{i-1}$ 个结点 k 层树最多 $2^k-1$ 个结点 $n_0 = n_2 + 1$ 完全二叉树性质假设对各节点从上到下，从左到右依次编号1~n,则对任意节点a编号i，有 ： 当n为偶数时，n1=1，n为奇数时，n1=0 如果i=1,则节点i是根节点，无双亲 如果i&gt;1,则节点i的双亲节点为$\\lfloor i/2\\rfloor$ 如果2i&lt;=n，则i的左孩为2i，如果2i&gt;n，则i无左孩 如果2i+1&lt;=n,则i的右孩为2i+1，否则i无右孩 顺序存储：由于位置隐含了亲子关系，故可用顺序存储的索引来表示关系，元素按在完全二叉树的顺序存储。问题是有很多空闲空间且不便于修改 二叉链式存储： 12345typedef struct BiTNode&#123; TElemType data; //数据 struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree; 三叉链表多一个双亲指针 遍历以递归的方式先序遍历： 123456789Status PreOrderTraverse(BiTree T, void (*visit)(TElemType))&#123; if (T) &#123; visit(T-&gt;data); PreOrderTraverse(T-&gt;lchild, visit); PreOrderTraverse(T-&gt;rchild, visit); &#125;&#125; 用栈实现迭代的中序遍历： 123456789101112void iterInorder(treePointer node)&#123; int top = -1; treePointer stack[MAX_STACK_SIZE]; for(;;)&#123; for(;node;node = node -&gt; lchild) push(node); node = pop(); if(!node) break; printf(\"%d\",node -&gt; data); node = node -&gt; rchild; &#125;&#125; 用队列实现层序遍历： 12345678910111213void LevelOrder(BinTree BT) &#123; if (!BT) return; Queue Q; BinTree T; Q = CreatQueue(MaxSize); //创建变初始化队列 Add(Q,BT); while(!IsEmpty(Q))&#123; T = Delete(Q); printf(\"%d \", T-&gt;Data); //访问队列中的结点 if (T-&gt;Left) Add(Q,T-&gt;Left); if (T-&gt;Right) Add(Q,T-&gt;Right); &#125; &#125; 由二叉树的先/后/层序遍历结合一个中序遍历可以唯一确定一个二叉树 递归判断二叉树相等： 123int equal(BinTree first,BinTree second)&#123; return ((!first) &amp;&amp; (!second) || (first &amp;&amp; second &amp;&amp; (first -&gt; data == second -&gt; data) &amp;&amp; equal(first -&gt; lchild,second -&gt; lchild) &amp;&amp; equal(first -&gt; rchild,secnd -&gt; rchild)));&#125; 线索二叉树充分利用空指针域，存放中序遍历的前驱或后继。要设置一个标志位表明存放的是指向孩子的指针还是指向前驱或后继的指针 则可以在O(n)时间内实现中序遍历 堆基于完全二叉树，对关键字值有特殊的约束——可以用数组实现 从堆顶删除，从堆底插入，中途可能要做多次调整 常用来实现OS中的优先级队列 插入大顶堆： 12345678910111213void insert_max_heap(element item,int *n)&#123; int i; if(HEAP_FULL(*n))&#123; fprintf(stderr,\"the heap is full.\\n\"); exit(1); &#125; i = ++(*n); while((i !=1)&amp;&amp;(item.key &gt; heap[i/2].key))&#123; heap[i] = heap[i/2]; // 比待插入元素值小则下沉到左子树 i /= 2; &#125; heap[i] = item;&#125; 最大-最小堆各层交替为最小层和最大层，根结点位于最小层 插入删除操作检查从根到待插入位置路径上的相关结点，根据值大小进行相关调整 应用：双端优先队列 双端堆根结点无元素，左子树是最小堆，右子树是最大堆 若 i 是最小堆中的一个结点，则在最大堆中对应的同一位置结点是 $ i + 2^{\\lfloor log_2 i \\rfloor -1}$ 对应位置相互移动时无需调整，在插入时要用这种方式腾出一个位置 二叉搜索树 所有关键字都不同(所以在插入操作中要先判断是否重复)，中序遍历有序 迭代查找： 12345678tree_pointer search(tree_pointer tree,int key)&#123; while(tree)&#123; if(key == tree -&gt; data) return tree; else if (key &lt; tree -&gt; data) tree = tree -&gt; left_child; else tree = tree -&gt; right_child; &#125; return null;&#125; 删除有两个子树的非叶结点：用左子树中最大元素或右子树中最小元素代替被删除结点位置——不同于AVL树，没有平衡要求 平衡二叉树对树高有约束的二叉搜索树，左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树 构造与调整方法平衡二叉树的常用算法有红黑树、AVL、Treap 等。 最小二叉平衡树的节点的公式如下 $F(n)=F(n-1)+F(n-2)+1$ 这个类似于一个递归的数列，可以参考 Fibonacci 数列，1 是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量 哈弗曼树也称最优二叉树，它是带权路径长度最小的二叉树。 常用于解决最短、最少类构造问题 败者树(选择树)每个父结点记录较小子树，一直向上比较，直至根结点表示所有记录中最小的结点——区别于堆，非叶结点并不是记录，而是比较结果 常用于外部排序的有序段多路平衡归并，可大幅减少比较次数。$O(nlog_2 k)$ 森林转为二叉树：先将每个树转成二叉树，再把后一个树挂在前一个树的右孩子位置 树的后根遍历—森林中序遍历—二叉树中序遍历 ，先序三者对应 并查集指针由孩子结点指向父亲结点 由于没有重复元素，可以用数组实现，索引表示元素值，值域表示其双亲结点，根结点父亲用-1表示 合并：让一棵树的根指针直接指向另一个树的根 合并可能产生退化问题，优化方式： 加权规则：结点数多的做父亲 路径压缩 应用：等价类 图在有向图的邻接表存储中，链表代表的是该顶点的出边表 ，逆邻接表存储入边表 1234567891011121314151617181920/* * 邻接表存储结构 */typedef struct EdgeNode&#123; int adjvex; //顶点的位置 struct EdgeNode *next; //指向下一条边的指针&#125;EdgeNode, *EdgeLink;typedef struct VexNode&#123; VexType data; //顶点数据 EdgeNode *firstEdge; //指向第一条依附该顶点的边的指针&#125;VexNode, AdjList[MAX_NUM];typedef struct&#123; AdjList adjList; int vexNum, edgeNum; //顶点数和边数&#125;ALGraph; DFS&amp;BFS深度优先搜索是树的先根遍历的推广，广度优先搜索是树的按层次遍历的推广。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* * 递归从第i个结点深度优先遍历图 */void DFS(ALGraph G, int i)&#123; EdgeLink p; visited[i] = TRUE; printf(\"%c \", G.adjList[i].data); p = G.adjList[i].firstEdge; while (p) &#123; if (!visited[p-&gt;adjvex]) &#123; DFS(G, p-&gt;adjvex); &#125; p = p-&gt;next; &#125;&#125;/* * 深度优先遍历 */Status DFSTraverse(ALGraph G)&#123; int i; for (i = 0; i &lt; MAX_NUM; i++) &#123; visited[i] = FALSE; &#125; for (i = 0; i &lt; G.vexNum; i++) &#123; if (!visited[i]) &#123; DFS(G, i); &#125; &#125; return OK;&#125;/* * 广度优先遍历 */Status BFSTraverse(ALGraph G)&#123; int i; EdgeLink p; LinkQueue Q; InitQueue(&amp;Q); for (i = 0; i &lt; MAX_NUM; i++) &#123; visited[i] = FALSE; &#125; for (i = 0; i &lt; G.vexNum; i++) &#123; if (!visited[i]) &#123; visited[i] = TRUE; printf(\"%c \", G.adjList[i].data); EnQueue(&amp;Q, i); while (!IsEmpty(Q)) &#123; DeQueue(&amp;Q, &amp;i); p = G.adjList[i].firstEdge; while (p) &#123; if (!visited[p-&gt;adjvex]) &#123; visited[p-&gt;adjvex] = TRUE; printf(\"%c \", G.adjList[p-&gt;adjvex].data); EnQueue(&amp;Q, p-&gt;adjvex); &#125; p = p-&gt;next; &#125; &#125; &#125; &#125; return OK;&#125; 无向图中的极大连通子图称为连通分量，如果是有向图中的任意一对顶点都有路径，那么这个就是强连通图，相应的它的极大连通子图就称为强连通分量。 一个连通图的一个极小连通子图，它包含所有顶点，但足以构成一棵树的 n-1 条边，加一条边必定会形成环，这个就称为生成树 关节点：删除该点及关联边后的新图至少含两个连通分支 双连通图：不含关节点的连通图 最小生成树权值最小的生成树为最小生成树，可以用 kruskal（克鲁斯卡尔）算法：按权值递增加边，保证加入后不构成环路——中间可能构成森林 Prim（普里姆）算法：从单一节点树开始加边并构成一个树——中间始终是一个树 Sollin算法：第一步形成包含所有树的森林，之后每一步为每棵树选一条边——森林融合成树 单源多目标最短路径Dijkstra 算法采用的是贪心策略 ，具体实现 完全最短路径法一：多次调用Dijkstra 算法 法二：计算代价矩阵 判断任意两个顶点之间是否存在一条路径，可以通过传递闭包矩阵和自反传递闭包矩阵解决 说实话这部分，没看太懂…开学考试完了再回头好好理解一下 算法汇总最大子序和12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#define SIZE 13int longestsum(int n[]);int main()&#123; int a[SIZE]; int i,rs; printf(\"please input %d number:\\n\",SIZE); for(i =0;i &lt; SIZE;i++)&#123; scanf(\"%d\",&amp;a[i]);&#125; rs = longestsum(a); printf(\"The longest subquence sum is %d\",rs); return 0;&#125;int longestsum(int n[])&#123; int thissum=0,i,maxsum; maxsum = n[0]; for(i =0;i &lt; SIZE;i++)&#123; thissum += n[i]; if(thissum &gt; maxsum)&#123;maxsum = thissum;&#125; else if(thissum &lt; 0)&#123;thissum = 0;&#125; &#125; return maxsum;&#125; 更多常规算法 一元多项式相加 O(m + n)特别注意：两系数之和为0的情况 12345678910111213141516171819202122232425262728293031323334353637383940int poltn_add(Node *&amp;A,Node *&amp;B)&#123; Node *p,*q,*p1,*m; p=A-&gt;next; p1=A; q=B-&gt;next; while (p&amp;&amp;q) &#123; if (p-&gt;exp &lt; q-&gt;exp) &#123; p = p-&gt;next; p1 = p1-&gt;next; &#125; else &#123; if (p-&gt;exp &gt; q-&gt;exp) &#123; m = q; q = q-&gt;next; m-&gt;next = p; p1-&gt;next = m; p1 = m; &#125; else &#123; p-&gt;coef = p-&gt;coef + q-&gt;coef; if (p-&gt;coef != 0) &#123; p = p-&gt;next; p1 = p1-&gt;next; m = q; m = q; q = q-&gt;next; free(m); &#125; &#125; &#125; &#125; return 0;&#125; 如果是更多的多项式相加，可以创建中间多项式，用两两相加实现 多项式相乘，也可以分解成一系列的加法运算 更详细解法 等价关系和等价类定义：集合S上的关系≡≡,称为S上为等价关系，当且仅当它在S上是对称的，自反的，传递的。 时间和空间的开销是O(m+n). 关键步骤： 12345678910111213141516171819202122232425262728printf(\"Enter a pair of numbers (-1 -1 to quit):\" );//循环输入等价关系的元素对scanf(\"%d%d\",&amp;i,&amp;j);while(i&gt;=0)&#123; x=(node_pointer)malloc(sizeof(node)); if(IS_FULL(x)) &#123; fprintf(stderr,\"the memory is full\\n\"); exit(1); &#125; //插入到第i个链表的前端 x-&gt;data=j; x-&gt;link=seq[i]; seq[i]=x; x=(node_pointer)malloc(sizeof(node)); if(IS_FULL(x)) &#123; fprintf(stderr,\"the memory is full\\n\"); exit(1); &#125; //插入到第j个链表的前端 x-&gt;data=i; x-&gt;link=seq[j]; seq[j]=x; printf(\"Enter a pair of numbers (-1 -1 to quit):\" ); scanf(\"%d%d\",&amp;i,&amp;j);&#125; 分别插入到对方的链表中。输出时每遍历到一个新的位置，改变其标志位，以后不再输出。 稀疏矩阵十字链表存储 O(max{col,row} + terms)多种存储方式 在十字链表中，数组的每一行的非零元素结点构成一个带头结点的循环链表，每一列的非零元素结点也构成一个带头结点的循环链表，这种组织方法使同一非零元素结点既处在某一行的链表中，又处在某一列的链表中。因此非零元素结点中设有两个指针域：指针域down指向其同列的下一个非零元素的结点，right域指向其同行的下一个非零元素结点。除这两个域外，结点中还应设有存放该非零元素的行值、列值、元素值的域。 结构体： 12345678910typedef int ElemType;typedef struct OLNode&#123; int row, col; union &#123; struct OLNode *next; //表头结点使用next域 ElemType e; //表中元素结点使用e域 &#125;uval; struct OLNode *down, *right;&#125;OLNode,*OLink; 详细解释 用三元组法比较简单可用数组实现，转置时直接在新的数组中交换原来的行列即可。这种转置的复杂度很高 O(row col terms) 改进：先确定原矩阵中每列非零元素对应转置矩阵的每行非零元素位置，就可以从起始位置开始处理 矩阵乘法：…以后再看 迷宫问题回溯法 字符串匹配对朴素串匹配 O( n * m)进行改进：可以先比较第一个和最后一个字符，可以在一定程度上减少比较次数 KMP算法O( n + m)：主串不回退，模式串的后缀与前缀在多大程度上重合，next数组首位为0，第二位为1，之后是前后缀匹配的长度或将前后缀匹配数组后移一位，next数组首位置-1","categories":[{"name":"data_structure","slug":"data-structure","permalink":"http://vergessenwang.github.io/categories/data-structure/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://vergessenwang.github.io/tags/数据结构/"},{"name":"C语言","slug":"C语言","permalink":"http://vergessenwang.github.io/tags/C语言/"},{"name":"树","slug":"树","permalink":"http://vergessenwang.github.io/tags/树/"},{"name":"栈和队列","slug":"栈和队列","permalink":"http://vergessenwang.github.io/tags/栈和队列/"}]},{"title":"进程同步和通信","slug":"进程同步和通信","date":"2019-08-24T15:33:47.000Z","updated":"2019-08-24T15:35:35.145Z","comments":true,"path":"posts/OS/2019-08-24-进程同步和通信.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2019-08-24-进程同步和通信.html","excerpt":"信号量与管程互斥只是进程间关系的一个方面，很多时候，进程间还需要进行同步和通信，因此就需要更高级的同步互斥方法。 信号量(抽象数据类型) 一个整型sem , 两个原子操作 P() : sem - 1 , 若 sem &lt; 0 等待，否则继续 V()：sem + 1, 若 sem &lt;= 0 , 唤醒一个等待的P 互斥：二进制信号量 mutex = new Semaphore(1); 条件同步：计数信号量 fullBuffers = new Semaphore(0); emptyBuffers = new Semaphore(n); 相比于锁机制，可以实现进程的并行。","text":"信号量与管程互斥只是进程间关系的一个方面，很多时候，进程间还需要进行同步和通信，因此就需要更高级的同步互斥方法。 信号量(抽象数据类型) 一个整型sem , 两个原子操作 P() : sem - 1 , 若 sem &lt; 0 等待，否则继续 V()：sem + 1, 若 sem &lt;= 0 , 唤醒一个等待的P 互斥：二进制信号量 mutex = new Semaphore(1); 条件同步：计数信号量 fullBuffers = new Semaphore(0); emptyBuffers = new Semaphore(n); 相比于锁机制，可以实现进程的并行。 实现细节12345678910111213141516171819classSemaphore&#123; int sem; WaitQueue q;&#125;Semaphore::P()&#123; sem--; if(sem &lt; 0)&#123; Add this thread t to q; block(p); &#125;&#125;Semaphore::V()&#123; sem++; if(sem &lt;= 0)&#123; // 由于先释放一个资源，所以要判断= Remove a thread t from q; wakeup(t); &#125;&#125; 存在问题 开发代码时容易出错：使用的信号量已经被占用；忘记释放信号量 不能处理死锁 管程(模块)最初是从编程语言的层面提出的，而不是os层面。通过在高级语言中设计管程机制，简化开发中对同步互斥的操作，实现语言的并发机制。 可以把管程理解成一个特殊的空间。 一个Lock ：指定临界区, 还没有拿到锁的进程挂在entry queue上，等待进入管程 0或n个条件变量：已进入管程的进程在并发访问临界区时所受到的约束，等待进程挂在对应条件变量的等待队列(queues associated with x,y….conditions)上 wait()：释放锁进入睡眠 signal() 实现细节12345678910111213141516171819class Condition&#123; int num Waiting = 0; WaitQueue q;&#125;Condition::Wait(lock)&#123; numWaiting++; Add this thread t to q; release(lock); //释放锁，允许其他进程进入管程执行(要是先睡眠就没有办法释放了) schedule(); // 当前进程睡眠，调度一个就绪进程继续执行 require(lock); // 再次获得锁才能再次进行wait循环&#125;Condition::Signal()&#123; if(numWaiting &gt; 0)&#123; Remove a thread t from q; wakeup(t); // 将一个睡眠进程置为就绪状态 numWaiting--; &#125;&#125; 区别于信号量的V操作，signal不一定会做减法。 例：生产者消费者问题12345678910111213141516171819202122classBoundedBuffer&#123; Lock lock；// 拿到锁才能进入管程访问临界区，同一时刻只有一个进程可以进入,不管是生产者还是消费者 int count = 0；// 缓存区占用空间 Condition notFull,notEmpty;&#125;BoundedBuffer::Deposite(c)&#123; lock -&gt; Acquire(); while(count == n) notFull.Wait(&amp;lock); // 区满等待 Add c to the buffer; count++; notEmpty.Signal(); // 唤醒一个消费者 lock -&gt; Release();&#125;BoundedBuffer::Remove(c)&#123; lock -&gt; Acquire(); while(count == 0) notEmpty.Wait(&amp;lock); Remove c from buffer; count--; notFull.Signal(); lock -&gt; Release();&#125; 存在的问题当一个正在执行的进程A发出signal操作后，将会调度一个就绪的进程B，那么这个时候到底要执行那一个进程呢？ Hansen方法：让进程A继续执行，完成release操作，这个时候可能存在多个就绪进程去抢占lock Hoare方法：让进程B继续执行，此时不会有抢占问题。用if代替while 经典同步问题的实现读者写者问题读者优先已经有读者时，下一个读者也可以进入，只是需要用原子操作来改变count变量。可能造成写者一直等待 写者 123sem_wait(WriteMutex);write;sem_post(WriteMutex); 读者 1234567891011sem_wait(CountMutex);if(Rcount == 0) sem_wait(WriteMutex);++Rcount;sem_post(CountMutex);read;sem_wait(CountMutex);--Rcount;if(Rcount == 0) sem_post(WriteMutex);sem_post(CountMutex); 写者优先同理，写者之间不互斥 哲学家就餐问题思路一：先拿左再拿右。可能同时拿左，造成死锁 思路二：右边不在把左边放回，随机等待一会再重复。可能造成饥饿 思路三：将就餐的的动作视为互斥。每次允许一人吃饭，效率降低，有三个叉子浪费了 思路四：要么不拿要么拿两把，把状态当临界资源，改变状态是一个互斥操作。 我正学到这，老爸走进来，我跟他说了这个问题，他说这还不好办，把筷子从中间一砍啊！ 真妙啊….. 1234567891011121314151617181920212223242526272829303132333435void philosopher(int i)&#123; while(true) &#123; think(); take_forks(i); eat(); put_forks(i); &#125;&#125;void take_forks(int i)&#123; P(mutex); state[i] = hungry; test_take_left_right_forks(i); V(mutex); P(s[i]); // 没拿到叉子就阻塞&#125;void test_take_left_right_forks(int i)&#123; if(state[i] == hungry &amp;&amp; state[left] != eating &amp;&amp; state[right] != eating)&#123; // 判断可否同时拿到两把叉子 state[i] = eating; v(s[i]); &#125;&#125;void put_fork(int i)&#123; P(mutex); state[i] = thinking; test_take_left_right_forks(left); // 奥妙之处，帮助邻居判断，满足条件把叉子给邻居并其唤醒 test_take_left_right_forks(right); V(mutex);&#125; 进程通信(IPC)为了解决进程间竞争关系（间接制约关系）而引入进程互斥；为了解决进程间松散的协作关系( 直接制约关系)而引入进程同步； 为了解决进程间紧密的协作关系而引入进程通信。互斥是一种特殊的同步，进程同步是一种进程通信。 进程之间互相交换信息的工作称之为进程通信IPC （InterProcess Communication）（主要是指大量数据的交换）。进程同步往往只有传递信号的作用，不能传递数据。 详见：进程的同步、互斥、通信的区别 从发送路径上看，可分为：直接通信和间接通信(通过一个消息队列发送和接收消息) 从对是否正确发送消息的处理方式来看，可分为：同步阻塞(直到正确发送才进行下一步)和异步非阻塞 进程间的通信可以分为两种模型，分别为： 共享内存(Shared Memory): 直接通信。开辟一段新的贡献资源段，然后两个进程之间进行数据信息等的交互，该过程不受CPU的控制。 消息传递(Message Passing)：间接通信。将相关的信息传给内核，然后内核将其转发 信号类似于一种异步打断机制，用软件中断通知事件处理。 具体实现：需要接受信息的应用程序会在OS中注册一个handler函数，在收到传来的信号时，OS从内核态返回用户态，并把应用程序的堆栈指针设置为handler函数的入口地址 信号与信号量的区别： 信号(signal)：是一种处理异步事件的方式。信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程外，还可以发送信号给进程本身。linux除了支持unix早期的信号语义函数，还支持语义符合posix.1标准的信号函数sigaction。 信号量(Semaphore)：进程间通信处理同步互斥的机制。在多线程环境下使用，它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。 信号比较高效但不能传数据。 管道|可以进行数据交换。一个进程的输出作为另一个的输入，完成重定向。 管道是一种虚文件，实际上是内核的一块缓存区，之所以称之为虚文件，因为对于左边进程而言它就像一个接收文件，对右边进程而言它就像一个数据发送文件。 具体实现：创建管道，创建两个新的进程，由于子进程继承父进程的文件描述符，这时把管道当做一种文件来处理，并分别设置两个子进程的管道写端和管道读端 消息队列管道的建立依赖于进程间的父子关系，而且传输的数据是字节流，没有结构化关系。消息队列可以解决这两个问题，将消息作为字节序列存储在消息数组中 共享内存管道和消息队列都是间接通信。共享内存实现的是直接通信，可以快速大量地传输数据，但是会有一致性问题。 SOCKET更多用在网络进程通信。相关内容以前已经写过。","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"信号量","slug":"信号量","permalink":"http://vergessenwang.github.io/tags/信号量/"},{"name":"管程","slug":"管程","permalink":"http://vergessenwang.github.io/tags/管程/"},{"name":"读者写者问题","slug":"读者写者问题","permalink":"http://vergessenwang.github.io/tags/读者写者问题/"},{"name":"哲学家就餐问题","slug":"哲学家就餐问题","permalink":"http://vergessenwang.github.io/tags/哲学家就餐问题/"},{"name":"消息传递","slug":"消息传递","permalink":"http://vergessenwang.github.io/tags/消息传递/"},{"name":"共享内存","slug":"共享内存","permalink":"http://vergessenwang.github.io/tags/共享内存/"}]},{"title":"基于MySQL的数据库操作实验","slug":"基于MySQL的数据库操作实验","date":"2019-08-15T15:00:43.000Z","updated":"2019-08-15T15:02:19.500Z","comments":true,"path":"posts/database/2019-08-15-基于MySQL的数据库操作实验.html","link":"","permalink":"http://vergessenwang.github.io/posts/database/2019-08-15-基于MySQL的数据库操作实验.html","excerpt":"安装MySQL在MySQL官网下载社区版，我下载的是8.0.17版本。安装时选择Developer Default 一路执行，可以看到有安装上Server/Workbench/For Excel/Shell/Router 以及 C++/Python/NET等多种语言Connector 默认使用TCP/IP协议，端口为3306 设置超级用户root的密码l**3 创建一个普通用户–我的名字–123456 ，如果把host改成localhost 将只能在本地登录，身份设置为DB Admin windows下服务名为MySQL80 我喜欢手动开启不常用的服务，这里没有选择开机启动 Router暂时用不到，没有配置 安装完毕自动启动了一个shell和一个workbench","text":"安装MySQL在MySQL官网下载社区版，我下载的是8.0.17版本。安装时选择Developer Default 一路执行，可以看到有安装上Server/Workbench/For Excel/Shell/Router 以及 C++/Python/NET等多种语言Connector 默认使用TCP/IP协议，端口为3306 设置超级用户root的密码l**3 创建一个普通用户–我的名字–123456 ，如果把host改成localhost 将只能在本地登录，身份设置为DB Admin windows下服务名为MySQL80 我喜欢手动开启不常用的服务，这里没有选择开机启动 Router暂时用不到，没有配置 安装完毕自动启动了一个shell和一个workbench 基本操作登录workbench→Database→connect to database→输入用户名→store in…输入密码，进入主界面 新建数据库选择schemas中的一个数据库右键create schema ,命名创建 修改数据库选中要修改的数据库，右键alter schema 删除数据库选中要修改的数据库，右键drop schema 新建、修改、删除数据表注意：所有的操作最后都需要进行刷新才能看到效果，右键数据表refresh all 选中要建表的数据库中的tables, 右键新建。点击column name 下的空白格按需求新建表项，Apply之后左侧就会有相应的信息 修改和删除同数据库操作 添加用户选择server→users and privileges →查看已登录账号的Administrative roles中是否有useradmin权限，若有→add acount 安装PowerDesigner一路next，地区选USA，最后覆盖一下dll文件 基本操作新建概念模型右键workspace→new→conceptual data model 新建完之后选中右边的entity, 然后点击中间空白处新建一个Entity ,右键properties进行属性Attributes设置 建立Entity之间的联系，就是用relationship 和inheritance 把关系连起来 注：概念模型与逻辑模型 建立物理模型工具栏tools→generate physical data model →选择相应的DBMS 注意：先建立了概念模型之后才能生成相应的物理模型 生成完毕会多一个物理模型编辑窗口，选中关系连线如relationship，右键properties，可以在preview中查看代码。在join中选择要建立联系的属性 检验模型的正确性tools → check model 配置数据源windows系统 控制面板 — 管理工具 — ODBC数据源 — 用户DSN — 添加 MySQL OBDC 8.0 Unicode Driver 填上名称，主机127.0.0.1 管理员账密 ，用Test测试一下连接 ，不是开机启动的话，要在services.msc 服务中开启 MySQL80 。连接成功后选择一个数据库 由物理模型自动生成MySQL表选中物理模型编辑页，打开工具栏 database → connect →ODBC machine datasource →选择配置的数据源，输入账密。 连接成功后， database → generate database 生成的SQL语句要进行正确性验证之后，才能执行真正生成数据库。打开MySQL workbench , open SQL Script运行 refresh all 即可在MySQL看到来自Powerdesigner的模型生成的数据库 在实验楼中完成操作部分实验 实验中值得注意的地方CHAR 和 VARCHAR 的区别CHAR 的长度是固定的，而 VARCHAR 的长度是可以变化的，比如，存储字符串 “abc”，对于 CHAR(10)，表示存储的字符将占 10 个字节(包括 7 个空字符)，而同样的 VARCHAR(12) 则只占用4个字节的长度，增加一个额外字节来存储字符串本身的长度，12 只是最大值，当你存储的字符小于 12 时，按实际长度存储。 ENUM和SET的区别ENUM 类型的数据的值，必须是定义时枚举的值的其中之一，即单选，而 SET 类型的值则可以多选。 SQL约束MySQL通常的约束：主键(primary key)、默认值(default)、唯一(unique)、外键(foreign key)、非空(not null) 一个表可以有多个外键，每个外键必须 REFERENCES (参考) 另一个表的主键，被外键约束的列，取值必须在它参考的列中有对应值。外键既能确保数据完整性，也能表现表之间的关系。 如 FOREIGN KEY(sid) REFERENCES student(sid) 常用操作语句单表操作123456SELECT name,age FROM employee WHERE age&gt;25 AND age&lt;30; // 不包含边界SELECT name,age FROM employee WHERE age BETWEEN 25 AND 30 ; // 包含SELECT name,age,phone,in_dpt FROM employee WHERE in_dpt IN (&apos;dpt1&apos;,&apos;dpt3&apos;); // 从不连续的范围中找SELECT name,age,phone FROM employee WHERE name LIKE &apos;J%&apos;;SELECT name,age,salary,phone FROM employee ORDER BY salary DESC;SELECT MAX(salary) AS max_salary,MIN(salary) FROM employee; // as重命名 关键字 LIKE 用于实现模糊查询，常见于搜索功能中。和 LIKE 联用的通常还有通配符，代表未知字符。SQL中的通配符是 _ 和 % 。其中 _ 代表一个未指定字符，% 代表不定个未指定字符 默认情况下，ORDER BY 的结果是升序排列，而使用关键词 ASC 和 DESC 可指定升序或降序排序 5 个内置函数： COUNT 函数可用于任何数据类型(因为它只是计数)，而 SUM 、AVG 函数都只能对数字类数据类型做计算，MAX 和 MIN 可用于数值、字符串或是日期时间数据类型 多表操作子查询只有在结果来自一个表时才有用。 1234SELECT of_dpt,COUNT(proj_name) AS count_project FROM project GROUP BY of_dpt HAVING of_dpt IN(SELECT in_dpt FROM employee WHERE name=&apos;Tom&apos;); HAVING 关键字可以的作用和 WHERE 是一样的，都是说明接下来要进行条件筛选操作。区别在于 HAVING 用于对分组后的数据进行筛选 连接查询结果来自多个表时，要进行连接 123456789SELECT id,name,people_numFROM employee,departmentWHERE employee.in_dpt = department.dpt_nameORDER BY id;//orSELECT id,name,people_numFROM employee JOIN departmentON employee.in_dpt = department.dpt_nameORDER BY id; 综合应用例：使用连接查询的方式，查询出各员工所在部门的人数与工程数，工程数命名为 count_project。 1234SELECT name, people_num, COUNT(proj_name) AS count_projectFROM employee, department, projectWHERE in_dpt = dpt_name AND of_dpt = dpt_nameGROUP BY name, people_num; 数据库操作目前 Mysql 没有提供重命名数据库名称的方法。 重命名表名称 12345RENAME TABLE 原名 TO 新名字;ALTER TABLE 原名 RENAME 新名;ALTER TABLE 原名 RENAME TO 新名; 新建：create 删除：drop 列操作123ALTER TABLE 表名字 ADD COLUMN 列名字 数据类型 约束;或：ALTER TABLE 表名字 ADD 列名字 数据类型 约束; 新增加的列，被默认放置在这张表的最右边。如果要把增加的列插入在指定位置，则需要在语句的最后使用AFTER关键词(“AFTER 列1” 表示新增的列被放置在 “列1” 的后面)。如果想放在第一列的位置，则使用 FIRST 关键词 如 ALTER TABLE employee ADD weight INT(4) DEFAULT 120 AFTER age; 删除列: 用drop代替add 重命名: 重命名语句后面的 “数据类型” 不能省略。 1ALTER TABLE 表名字 CHANGE 原列名 新列名 数据类型 约束; 当原列名和新列名相同的时候，指定新的数据类型或约束，就可以用于修改数据类型或约束 另外一种改变数据类型的方式 1ALTER TABLE 表名字 MODIFY 列名字 新数据类型; 值操作12UPDATE 表名字 SET 列1=值1,列2=值2 WHERE 条件;DELETE FROM 表名字 WHERE 条件; 注意都要加上WHERE关键字，不用的话相当于对整个表进行操作，即整列修改或删除表中所有记录 其他操作索引建立索引可以加快查询速度。 12345ALTER TABLE 表名字 ADD INDEX 索引名 (列名);//orCREATE INDEX 索引名 ON 表名字 (列名);//查看索引SHOW INDEX FROM 表名字; 在使用 SELECT 语句查询的时候，语句中 WHERE 里面的条件，会自动判断有没有可用的索引。 视图作为提供给用户的虚拟表。 数据库中只存放了视图的定义，而没有存放视图中的数据，这些数据存放在原来的表中； 使用视图查询数据时，数据库系统会从原来的表中取出对应的数据； 视图中的数据依赖于原来表中的数据，一旦表中数据发生改变，显示在视图中的数据也会发生改变； 在使用视图的时候，可以把它当作一张表。 1CREATE VIEW 视图名(列a,列b,列c) AS SELECT 列1,列2,列3 FROM 表名字; 表的操作语句同样适用于视图。 导入纯数据文件：LOAD DATA INFILE &#39;文件路径和文件名&#39; INTO TABLE 表名字; 导入导出的文件都必须在指定的路径下进行，在 mysql 终端中查看路径变量：show variables like &#39;%secure%&#39;; 在移动至该路径时需要权限，所以实现了安全的导入。 SQL语句：source *.sql 可以在文件中包含更多的操作 导出只保存数据 SELECT 列1，列2 INTO OUTFILE &#39;文件路径和文件名&#39; FROM 表名字; 不能有同名文件 备份与恢复把数据库的结构，包括数据、约束、索引、视图等全部另存为一个文件。 mysqldump 是 MySQL 用于备份数据库的实用程序。它主要产生一个 SQL 脚本文件，其中包含从头重新创建数据库所必需的命令 CREATE TABLE INSERT 等。","categories":[{"name":"database","slug":"database","permalink":"http://vergessenwang.github.io/categories/database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://vergessenwang.github.io/tags/MySQL/"},{"name":"数据库操作","slug":"数据库操作","permalink":"http://vergessenwang.github.io/tags/数据库操作/"}]},{"title":"Python处理数据后用于查看动态排名","slug":"Python处理数据后用于查看动态排名","date":"2019-08-14T14:56:27.000Z","updated":"2019-08-14T14:59:57.251Z","comments":true,"path":"posts/visualization/2019-08-14-Python处理数据后用于查看动态排名.html","link":"","permalink":"http://vergessenwang.github.io/posts/visualization/2019-08-14-Python处理数据后用于查看动态排名.html","excerpt":"利用脚本实现将历史数据排名转化为动态柱状图图表。源码由见奇开发。 在VS Code中配置Python开发环境先检查Python版本和环境变量配置是否可用，命令行输入python --version ，发现不是内部命令，想起来新换的电脑还没有安装。 官网下载最新版本Windows x86-64 executable installer ，安装时记得勾选 add toPATH 在VS Code中安装Python和pylint插件，安装完pylint提示： 12You are using pip version 19.0.3, however version 19.2.2 is available.You should consider upgrading via the &apos;python -m pip install --upgrade pip&apos; command pip是python的包管理工具，按提示升级python -m pip install --upgrade pip","text":"利用脚本实现将历史数据排名转化为动态柱状图图表。源码由见奇开发。 在VS Code中配置Python开发环境先检查Python版本和环境变量配置是否可用，命令行输入python --version ，发现不是内部命令，想起来新换的电脑还没有安装。 官网下载最新版本Windows x86-64 executable installer ，安装时记得勾选 add toPATH 在VS Code中安装Python和pylint插件，安装完pylint提示： 12You are using pip version 19.0.3, however version 19.2.2 is available.You should consider upgrading via the &apos;python -m pip install --upgrade pip&apos; command pip是python的包管理工具，按提示升级python -m pip install --upgrade pip 尝试输入代码，运行成功。 前提：数据第一行为省份，第一列为年份(由远至近)，中间部分为数据 编写Python代码完成csv数据转换123456789101112131415import csvf = open('horse_data.csv','r',encoding = 'gbk')reader = csv.reader(f)province = f.readline()province = province.split(',')f2 = open('horse.csv','w',encoding = 'gbk',newline ='')writer = csv.writer(f2)writer.writerow(['name','type','value','date'])for line in reader: for i in range(1,26) : if line[i]: writer.writerow([province[i],'',line[i],line[0]]) range中的内容根据具体数据文件而定，注意是到第二个参数的前一位。 修改config相关内容，适配自己的数据，达到较好的展示效果。 打开bargraph导入处理好的数据即可。","categories":[{"name":"visualization","slug":"visualization","permalink":"http://vergessenwang.github.io/categories/visualization/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://vergessenwang.github.io/tags/Python/"},{"name":"动态可视化","slug":"动态可视化","permalink":"http://vergessenwang.github.io/tags/动态可视化/"},{"name":"数据处理","slug":"数据处理","permalink":"http://vergessenwang.github.io/tags/数据处理/"}]},{"title":"雀鹰与该隐——《德米安》","slug":"雀鹰与该隐——《德米安》","date":"2019-08-13T14:25:21.000Z","updated":"2019-08-13T14:37:00.939Z","comments":true,"path":"posts/reading/2019-08-13-雀鹰与该隐——《德米安》.html","link":"","permalink":"http://vergessenwang.github.io/posts/reading/2019-08-13-雀鹰与该隐——《德米安》.html","excerpt":"当我渴望离开第一个座位时，我自己也不清楚我要去哪儿。我只知道，我要坐在很后面。 ​ 我不认为自己是个智者。我曾经是一个探索者，现在也还依然是。但是我不在从群星和书本中寻觅，而是开始聆听我血液滂湃不已的教义。 ​ 每个人的生命代表一条通往他自己的道路，代表他在这条路上所做的尝试。 ​ 每个人身上都存留者出生时的痕迹——远古时代的黏液和蛋壳，直至终了为止。有些人从不曾变成人类，而是继续当青蛙、蜥蜴和蚂蚁。人人尝试走出深渊，朝各自的目标努力，我们可以彼此了解，但真正能够深刻了解自己的，却只有每个人本身。","text":"当我渴望离开第一个座位时，我自己也不清楚我要去哪儿。我只知道，我要坐在很后面。 ​ 我不认为自己是个智者。我曾经是一个探索者，现在也还依然是。但是我不在从群星和书本中寻觅，而是开始聆听我血液滂湃不已的教义。 ​ 每个人的生命代表一条通往他自己的道路，代表他在这条路上所做的尝试。 ​ 每个人身上都存留者出生时的痕迹——远古时代的黏液和蛋壳，直至终了为止。有些人从不曾变成人类，而是继续当青蛙、蜥蜴和蚂蚁。人人尝试走出深渊，朝各自的目标努力，我们可以彼此了解，但真正能够深刻了解自己的，却只有每个人本身。 两个世界该隐​ 我们不需要对人畏惧。假如你惧怕某人，那代表你赋予了他这个权利。 ​ 他会用鼓励、警告、嘲笑和讽刺的方式，把我变得更加独立。直到今天我终于了解：人生在世最无聊的是，走在一条由他人引导的自我之路上。 强盗​ 我还看到他异常孤独且沉默的样子，仿佛一颗行星在众人之间，被一股属于自己的气流所包围，运行在自己的轨道上。 ​ 我们常常可以经由仔细观察，正确地知道某人的想法或感觉，多半也能预料他下一刻的行为。 ​ 敏锐的嗅觉是训练出来的。这样一只寻找几公里外的雌蛾的夜蛾如果集中意志力想要飞向一片星辰，是行不通的。它只会寻找对它有意义的、有价值的东西，只会寻找它需要的、必须拥有的东西。只要动物或人类把自己的全部意志集中在特定的事物上，他就能达到目标。 ​ 比起动物，人类拥有更大的空间，具有更强烈的好奇心。不过，相对的，却也局限在一个狭隘的圈圈里，没办法超越。除非我非常重视我的愿望，除非它确实和我合二为一，我才能带着坚定意志完成它。 ​ 当我渴望离开第一个座位时，我自己也不清楚我要去哪儿。我只知道我要坐在很后面。 ​ 我每次都非常坚定地注视他的眼睛。几乎所有人都难以忍受这种凝视，遇到这种情况，都会变得不安。假如你突如其来坚定地注视某人的眼睛，而他却没有丝毫惶恐，那就放弃吧！你绝对无法在他身上达成目的。 ​ 德米安所指的上帝和恶魔、普世认同的神圣世界和禁锢的魔鬼世界，与我的想法不谋而合。原来我的问题是所有人的问题、一切生命和思想的问题。 ​ 生活跟你的想法并不一致。思想只有在付诸生活中实行，才有价值。 ​ 他无法忍受那种为了说话而说话的对谈。他对我的事，除了纯粹好奇之外，还有太多理性激辩和闲聊的玩乐成分，总之，缺乏认真的参与感。他说，机巧的谈论根本没有价值。只会让我们远离自己。远离自己是一种罪过。我们必须完全在自身中爬行，就像一只乌龟一样。 碧翠丝​ 我漠不关心地面对外界，终日只顾谛听内心的声响，这条禁忌的、黑暗的河流在暗地里澎湃奔腾。 ​ 我贪婪地呼吸着湿润的凋零气味，它仿佛在回答、抚慰我的心灵。啊，生命尝起来何等的淡而无味。 ​ 酒醉并不好玩，让人极为痛苦，然而它蕴含某些成分，充满甜美的魅力，既是反叛和疯狂，也是生命和灵魂。 ​ 我的生命没有目标，我鄙视这个世界！我冷漠而盲目地踽踽独行；我的心沉默、怯懦地退缩在角落。 ​ 我从未真正融入同伴之中。置身他们当中，我却依然孤独，并因此更为痛苦。 ​ 上帝借由各种途径使人变得孤独，好让我们可以走向自己。 ​ 现在我有了爱慕和崇拜的对象，我再度拥有梦想，生命再度充满想象，充满色彩，充满神秘的灵感——让我完全无视其他存在。我不再追求不负责任的安全感，而开始肩负责任和自我要求。 ​ 我用碧翠丝的身影布置我的圣坛，让它取代一切。我的目标不在于欲望的满足，而是纯洁；我要的是美和智慧，而非幸运。 ​ 这个画中人，是我的心灵，我的命运，我的魔鬼。我生我死将是如此，我命运之歌的音调和节奏将是如此。 ​ 命运和性格乃思想之名。 ​ 再度相逢，我不再感到任何激动，唯有一股淡淡的和谐、一阵柔情的预感：你我相连在一起，但不是你本人，而是你的形象；你是我命运的一部分。 奋力冲破蛋壳的鸟​ 鸟奋力冲破蛋壳。这颗蛋是这个世界。若想出生，就得摧毁一个世界。这只鸟飞向上帝。这个上帝的名字是阿布拉克萨斯。 ​ 他是上帝，也是魔鬼。 ​ 爱情不再是起初那种让我惊恐的、兽性的、阴暗的性冲动，也不再是我在碧翠丝画中呈现的那种天真、超越世俗的爱慕了。它是天使和撒旦，人类和动物，至高的良善和极端的邪恶。 ​ 只有一点我做不大：撕裂那个暗藏在内心的目标，把自己描绘在什么地方，就像其他人那样。他们很清楚自己想成为教授、法官、医生或艺术家，他们知道需要花多少时间来达成，也知道这将会带给他们何种优势。然而我办不到。也许我还得寻觅，继续探索好几年，最后一事无成，达不成任何目标。 ​ 我只是尝试着过自己想要的生活而已。为何如此艰难呢？ ​ 对她而言，没有所谓的太好和太珍贵，也没有所谓的太坏和太卑劣。 ​ 我总是全神贯注在自己身上。我热切渴望能够真正活过一次，即使只是短暂的一次：我期盼对世界贡献出一些自己的东西，跟这个世界建立关系，并且和它搏斗。 ​ 事实上，并没有所谓的偶然。如果一个人迫切需要某样东西，然后找到了这个东西，那么赋予这种机会的就不是偶然，而是他自己，是他本身的渴望和迫切带领他去找到它。 ​ 眼前这些非理性的、紊乱的、异样的自然形体，究竟来自外在，还是内在的印象。 ​ 所有可能性，诸如愿望、选择，皆与我们同在。 ​ 但是个人的世界又在哪里？假如我们本身已经具备了一切，我们为何还要努力追求？ ​ 这些两脚动物，它们都有成为人类的机会，可是，只有在它们预知这个机会，甚至学习把它转化为自觉，这个机会才属于它们。 雅各的战斗​ 假如大自然把您创造成一只蝙蝠，您就不应该想着变成一只鸵鸟。有时候您觉得自己很特别，有时候您谴责自己选择了跟大部分人不同的路，但您必须学习放弃这种思考方式。您去看看火、看看云吧。 ​ 阿布拉克萨斯从来不反对您的想法，从来不否定您的幻梦。 ​ 假如我们怨恨一个人，我们恨的是在他形象中的某些东西，这些东西也是我们本身所拥有的。凡是我们本身没有的东西，并不能激动我们的心。 ​ 大部分人走的是一条简单的路，我们走的却是一条坎坷的路。但还是要走下去。 ​ 我生活在我的梦中，其他人也生活在梦中，只不过那不是他们自己的梦，差别就在此。 ​ 我开始觉得他很无聊，我也对自己的反应感到吃惊，因为他明显表达了痛苦和绝望，却没有引起我的共鸣，我唯一的感觉只是：我帮不了你。 ​ 假如你无法发现自己，那么你也无法找到灵魂。 ​ 每个人都必须感受一些寂寞的煎熬，大部分人都无法忍受，于是不久又再度和他人建立联系。 ​ 我突然明白，皮斯托利斯对我的意义和他给我的一切，正是他所不能成为或给予自己的东西。他为我指引了一条道路，就连这条道路也必须越过他并离开他，离开这位引导者。 ​ 当我猛力挥击，以为自己打中的是一个强者，一个骁勇善战的人，没想到竟然是一个默默忍耐的人，一个默默投降、无力抵抗的人。 ​ 一个成熟的人没有任何职责，除了：寻找自己。坚定地成为自己，不论走向何方，都往前探索自己的路。 ​ 我不是为了写作、为了布道、为了画画而来，不管是我或任何人都一样。这一切只是附带产生的。每个人的职责只有回归自己。他最后死去时的身份，可以是作家或疯子，可以是先知或罪犯——但这些不是他的职责，无关紧要。他的职责是：找到自己的命运，不是一个随意的命运，而且在那之中尽情生活，全心全意、不受动摇地生活。除此之外，其他一切都不完整，是一种逃避的企图，是想要逃回群体的样板中，是为了适应自己内心的恐惧。 ​ 我没有办法如此赤裸和孤独地生活，我也是一只贫穷、虚弱的狗，这只狗需要温暖和食物，偶尔也想要和同类亲近。任何人如果只要命运，不要其他东西的话，他就不再拥有同类，会变得相当孤独，围绕他身边的只有冰冷的世界。 夏娃夫人​ 到处都有人聚集，到处都是群体生活，到处都有人逃避自己的命运，为了温暖而逃回群体里！ ​ 现在到处都在流行组织、联合群众，没有一处找得到自由和爱。所有这些联合，从学生团体，合唱团，乃至于国家，都是一种强迫性组合，一种出自害怕、畏惧和逃避困境的结盟，而它的内部却是腐败和老旧的，几乎要瓦解了。 ​ 人只有在跟自己本身无法相处时，才会产生畏惧。他们害怕，是因为他们从来不了解自己。 ​ 你只要看看学生们常去的酒馆就知道了！只要看看有钱人常去的娱乐场所就知道了！这些地方毫无希望！亲爱的辛克莱，欢乐不可能来自这一切。这些心生恐惧而彼此联合的人，内心其实充满了害怕和敌意，对彼此不信任。 ​ 他们过度崇拜消失的“自由”、崇拜他们的学生时代，如同作家或浪漫主义者把崇拜献给童年那般。到处都一样！他们在过去四处寻找“自由”和“快乐”，却又感到无比害怕，因为可能会被人提醒自己的职责，被人督促自己该走的路。 ​ 即使你已经获得自己，即使你已经放弃童年的幸福，你还是可以看到世界在闪烁，还是可以品尝孩子专属的天真和惊慌。 ​ 没有一个梦可以永远持续，每个梦都会被新的梦取代，我们不可以想要紧抓任何一个梦。 ​ 欧洲以惊人的毅力，创造出威力强大的新武器，但最后却在深层、巨大的灵魂中萎缩，它赢得了整个世界，却用来毁灭自己。 ​ 我们唯一承认的义务和命运是：每个人应该完全做自己，符合自然在他身上孕育的本质，并服膺这个本质，不确定的未来准许每个人创造它想带给我们的事物。 ​ 他将之视为他的命运，不抱任何希望地爱着一颗星星，因此创造了一套纯粹的生命哲学，涵盖了放弃、沉默和忠贞的痛苦。他向那颗星星跳去。就在这一跳，他的心里闪过一个念头：这是不可能的！他摔得粉身碎骨，躺在沙滩上。他不懂爱。假如在跳的那一刻拥有信心，坚持相信梦想会实现，他就会往天上飞去，和那颗星星结合在一起。 ​ “爱不必请求，”她说，“也不可要求。爱必须成为自己明确肯定的力量。它便不再是被牵引，而是去牵引。” ​ 那是一个绝望的情人，他把自己完全缩回他的内心，因为自己仿佛被爱烧毁了。他失去了这个世界，再也看不到蔚蓝的天空和翠绿的森林。但是他的爱仍在增长，他宁愿死去和毁灭，也不愿放弃拥有他所爱的美人。他的爱烧毁了他心中的其他一切，变得强大异常，一直牵引着。于是她来了。他付出爱，同时也找到自己。而大部分的人，得到爱却失去了自己。 ​ 有时候我清楚地感觉到，是我的本质指引我去追求，并不是她这个人，而她只是我内心的一个象征，唯一的目的是带领我更深入地去寻找自己。 ​ 通过想象，我似乎有些了解，如何可以持续、永恒地拥有爱情了。 ​ 我享受这种远离她所带来的稳定感和独立味道。 结束与新生​ 以前，我经常思考为什么人不能为理想而活。现在，我却看到许多人甚至全部的人为一个理想而死。不过它不是一个个人自由选择的理想，却是大家所共同约定的理想。 ​ 不管这些人相信的是什么，或者想要的是什么，他们都准备好了，他们是有用的，未来将从他们之中成形。 ​ 这些与对象并没有密切关系。他们的杀戮只是内心的抒发、心碎的投射，因而想要发怒、杀人、毁灭和死亡，为的是能够重新诞生。一个巨鸟奋力冲破蛋壳，这颗蛋是这个世界，而世界必须毁灭。","categories":[{"name":"reading","slug":"reading","permalink":"http://vergessenwang.github.io/categories/reading/"}],"tags":[{"name":"黑塞","slug":"黑塞","permalink":"http://vergessenwang.github.io/tags/黑塞/"},{"name":"德米安","slug":"德米安","permalink":"http://vergessenwang.github.io/tags/德米安/"},{"name":"彷徨少年时","slug":"彷徨少年时","permalink":"http://vergessenwang.github.io/tags/彷徨少年时/"},{"name":"天使与魔鬼","slug":"天使与魔鬼","permalink":"http://vergessenwang.github.io/tags/天使与魔鬼/"},{"name":"人生之路","slug":"人生之路","permalink":"http://vergessenwang.github.io/tags/人生之路/"}]},{"title":"临界区互斥的软件及抽象方法","slug":"临界区互斥的软件及抽象方法","date":"2019-08-12T07:57:47.000Z","updated":"2019-08-24T10:03:18.026Z","comments":true,"path":"posts/OS/2019-08-12-临界区互斥的软件及抽象方法.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2019-08-12-临界区互斥的软件及抽象方法.html","excerpt":"临界区在每个进程中，访问互斥资源的代码段称为临界区。为了实现对资源互斥，在每一个时刻，只允许一个进程进入临界区执行相应的代码。如何控制一个进程进入，而其他进程被”卡住”，就是接下来要解决的问题。 互斥的四个条件 忙则等待：任何两个进程不能同时处于临界区 不应对CPU的速度和数量做任何假设 让权等待：临界区外运行的进程不得阻塞其他进程，不能忙等 有限等待：不得使进程无限期等待进入临界区 基本实现机制 基于硬件的禁用中断——无法进行上下文切换，失去了并发，在多CPU中都不能工作。更严重的是，无法限制响应中断所需的时间，因为时钟中断也被屏蔽了，在临界区中的进程无法被停止 基于软件的方法（如Peterson算法） 更高级的抽象（锁，信号量，管程）","text":"临界区在每个进程中，访问互斥资源的代码段称为临界区。为了实现对资源互斥，在每一个时刻，只允许一个进程进入临界区执行相应的代码。如何控制一个进程进入，而其他进程被”卡住”，就是接下来要解决的问题。 互斥的四个条件 忙则等待：任何两个进程不能同时处于临界区 不应对CPU的速度和数量做任何假设 让权等待：临界区外运行的进程不得阻塞其他进程，不能忙等 有限等待：不得使进程无限期等待进入临界区 基本实现机制 基于硬件的禁用中断——无法进行上下文切换，失去了并发，在多CPU中都不能工作。更严重的是，无法限制响应中断所需的时间，因为时钟中断也被屏蔽了，在临界区中的进程无法被停止 基于软件的方法（如Peterson算法） 更高级的抽象（锁，信号量，管程） 软件方法的演进进程临界区处理的抽象结构(此处及以后均用伪代码表达) 123456do&#123; enter section critical section exit section reminder section //提醒其他线程&#125;while(1); 单标志法(交替进入)设置一个共享变量int turn = i; 表示现在轮到哪个进程 对于第i个进程，enter section：while(turn != i)； exit section: turn = j; 缺点：实现了互斥，但不满足前进属性。必须交替执行，违背“空闲让进” 双标志法先检查(先看排队)设置一个数组int flag[n]; 当flag[i] = 1时表示进程 i 有进入临界区的意愿 对于第i个进程，enter section：while(flag[j] == 1)；flag[i]=1; 若无进程进入临界区则置自己的标志位 exit section: flag[i] = 0; 缺点：不满足互斥。可能同时查询同时置位，同时进入临界区。根本原因是置位过程被打断。 双标志法后检查(先抢位置)enter section：flag[i]=1； while(flag[j] == 1); 缺点：满足互斥，但可能死锁。同时置位后都停在while死循环，都无法进入。 Peterson算法(两个进程)同时使用 turn 和 flag enter section：flag[i]=1；turn = j; while(flag[j] == 1 &amp;&amp; turn == j); 先“谦让”一下，让对方先进，如果对方恰好有进入的意愿，则自己保持等待；对方不进则自己进。 Bakery算法(n个进程) 进入临界区之前，进程接收一个数字(请求号)，数字小的进入 若数字相同，比较进程号，i &lt; j 则 i 进 编号方案总是按照枚举的增加序列生成数字 软件方法的缺点 需要进程间共享数据项 while循环需要CPU忙等 实现上需要硬件原子指令LOAD和STORE的支持 更高级的抽象操作系统基于硬件的中断、原语提供更高级的编程抽象来简化并行编程。 硬件基础通过特殊的内存访问电路提供特殊的原子操作指令 TestAndSet：从内存读值判断是否为1，内存值设为1 12345boolean TestAndSet(boolean *target)&#123; boolean rv = *target; *target = True; return rv;&#125; Swap：交换内存中的值 12345viod Swap(boolean *a,boolean *b)&#123; boolean temp = *a; *a = *b; *b = temp;&#125; 以上指令虽然由多条操作组成，但在体系结构中已经被封装成了一条机器指令，由硬件逻辑直接实现，不会被中断。 锁(抽象数据结构)忙等锁 class Lock{int value = 0;} 加锁/解锁 Lock :: Acquire(){while(TestAndSet(value));} 锁被释放前一直等待，直到得到锁 Lock :: Release(){value = 0;} 释放锁，唤醒等待进程 以上方法支持n个进程，但是仍然是忙等，使用忙等方式的锁称为自旋锁 改进： 无忙等锁(增加一个等待队列) class Lock{int value = 0;WaitQueue q;} 123456Lock :: Acquire()&#123; while(TestAndSet(value))&#123; add this TCB to wait queue q; schedule(); &#125;&#125; 12345Lock :: Release()&#123; value = 0; remove one thread t from q; wakeup(t);&#125; 挂到阻塞队列后，睡眠等待，让出CPU。因为有上下文切换的开销，更适用于临界区较长的情况。 基于Swap的锁 共享数据 int lock = 0; enter section：key=1; while(key == 1){Swap(lock,key);} exit section: lock = 0; 只有lock为0时，才能通过Swap使得key为0 ，打破while循环。 可能存在的问题优先级反转造成死锁：若一个低优先级的进程拥有临界区，一个高优先级进程获得CPU并等待临界区，那么低优先级进程就无法获得CPU以继续执行释放锁，导致死锁。根本原因是互斥资源占用顺序和CPU优先级不匹配，解决优先级反转问题有优先级天花板(priority ceiling)和优先级继承(priority inheritance)两种办法，其实就是对低优先级进程的优先级进行提升。 基于忙等的方式都可能存在优先级反转问题，所以还可以用睡眠与唤醒的方式来解决。","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"进程","slug":"进程","permalink":"http://vergessenwang.github.io/tags/进程/"},{"name":"互斥","slug":"互斥","permalink":"http://vergessenwang.github.io/tags/互斥/"},{"name":"Peterson算法","slug":"Peterson算法","permalink":"http://vergessenwang.github.io/tags/Peterson算法/"},{"name":"锁","slug":"锁","permalink":"http://vergessenwang.github.io/tags/锁/"},{"name":"原子操作","slug":"原子操作","permalink":"http://vergessenwang.github.io/tags/原子操作/"}]},{"title":"TCP/IP协议下Socket编程原理","slug":"TCP-IP协议下Socket编程原理","date":"2019-08-11T13:25:57.000Z","updated":"2019-10-26T03:50:34.688Z","comments":true,"path":"posts/network/2019-08-11-TCP-IP协议下Socket编程原理.html","link":"","permalink":"http://vergessenwang.github.io/posts/network/2019-08-11-TCP-IP协议下Socket编程原理.html","excerpt":"在学习Socket编程之前，首先要了解基本的网络体系结构相关知识。参看网络模型对应关系 不同于应用层之上的Web编程，Socket编程处于应用层和网络层之间，这种API本质上是通过应用进程向OS发出系统调用实现的。 典型的网络API Unix的Socket 微软的WINSOCK AT&amp;T的TLI","text":"在学习Socket编程之前，首先要了解基本的网络体系结构相关知识。参看网络模型对应关系 不同于应用层之上的Web编程，Socket编程处于应用层和网络层之间，这种API本质上是通过应用进程向OS发出系统调用实现的。 典型的网络API Unix的Socket 微软的WINSOCK AT&amp;T的TLI Socket最初是面向TCP/IP协议栈接口，目前是事实上的工业标准，通信模型是C/S架构，为应用进程间通信提供抽象。 如果只看应用层，在同一主机上可能同时运行多个应用程序，那么如何确定通信对象呢？这个时候就需要借助传输层协议，形成IP+端口机制。 标识通信端点（对外）：IP地址+端口号 OS/进程管理套接字（对内）：套接字描述符 这种内部套接字管理方式类似于文件的抽象，当应用进程创建套接字时，OS分配一个数据结构并返回套接字描述符，每一个进程维护一张Socket描述符表，表项指向一个Socket数据结构 。 Socket数据结构1234567891011struct sockaddr_in &#123;short int sin_family; /* Address family */unsigned short int sin_port; /* Port number */struct in_addr sin_addr; /* Internet address */unsigned char sin_zero[8]; /* Same size as struct sockaddr */&#125;; sockaddr_in 声明端点地址，TCP/IP协议族的sin_family值为AF_INET Socket API函数常用socket函数 创建：socket(protofamily, type, proto) 返回套接字描述符 protofamily = PF_INET type = SOCK_STREAM/SOCK_DGRAM/SOCK_RAW 其中 流式套接字SOCK_STREAM (TCP)、数据报套接字SOCK_DGRAM (UDP) 工作在传输层，原始套接字SOCK_RAW 工作在网络层。SOCK_RAW 可以处理ICMP、IGMP等网络报文、特殊的IPv4报文、可以通过IP_HDRINCL套接字选项由用户构造IP头，创建时需要特殊权限。 protocol参数一般取0 例如 123struct protoent *p;p = getprotobyname(\"tcp\");SOCKET sd = socket(PF_INET,SOCK_STREAM,p -&gt; p_proto); 关于TCP/IP参数为什么两者不同，理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx。当然AF_INET和PF_INET的值是相同的，混用也不会有太大的问题。关于PF_INET和AF_INET的区别 关闭：int closesocket(SOCKET sd); 与文件类似，当多个进程共享一个套接字，调用后只能将引用计数减1，至0时真正关闭 对于同一进程中的多个线程只计数一次，因此一个线程调用之后其他线程也无法再访问 绑定本地端点地址：int bind(sd, localladdr,addrlen) localaddr对应sockaddr_in 客户程序一般不调用，服务器端需要绑定熟知端口号，同时服务器端由于可能有多个IP地址，还需要一个地址通配符：INADDR_ANY,意即所匹配的任一地址有效，不指定具体IP地址。 在Linux系统中，1024以下的端口只有拥有root权限的程序才能绑定。 监听：int listen(sd,queuesize); 仅用于服务器端的TCP连接 新的Client的连接请求先被放在接收队列中，直到Server程序调用accept函数接受连接请求 连接：connect(sd,saddr,saddrlen); 仅用于客户端，但TCP和UDP均可 saddr即要连接的远程服务器套接字 响应连接请求：newsock = accept(sd, caddr, caddrlen); 仅用于服务器端的TCP连接 从监听状态的连接请求队列取出最前的一个，创建一个新的套接字来描述来与特定的Client交换信息，因为TCP是点对点协议，这样才能实现并发。 接收/发送消息： TCP方式： int send(sd, *buf, len, flags); int recv(sd, *buf, len, flags); UDP方式： int sendto(sd, *buf, len, flags, destaddr, addlen); int recvfrom(sd,*buf, len, flags,senderadde,saddrlen); 由于UDP是无连接的，所以需要指定发送/接收数据的对方 获得或改变socket属性: int getsockopt(int sd, int level, int optname, char *optval, int *optlen); int setsockopt(int sd, int level, int optname, char *optval, int *optlen); 常用属性： SO_RCVTIMEO，SO_SNDTIMEO：获得或设置socket发送/接收的timeout SO_SNDBUF，SO_RCVBUF：获得或设置socket发送/接收的buffer大小 SO_BROADCAST：获得或设置socket状况，使之可以广播发送数据报（只能用于UDP方式） SO_REUSEADDR：设置该socket绑定的端口可以被重用。 网络字节顺序转换 在TCP/IP结构中虽然没有表示层，但是还是要完成相应的数据格式转换功能 htons()–”Host to Network Short” htonl()–”Host to Network Long” ntohs()–”Network to Host Short” ntohl()–”Network to Host Long” 服务器IP地址解析 客户端将服务器域名或十进制IP地址转换成二进制IP地址 inet_addr() 十进制 → 二进制(网络字节顺序) gethostbyname 域名→ 二进制，返回一个指向hostent结构的指针，*h_addr_list 表示的是主机的ip地址，注意，这个是以网络字节序存储的。 1234567struct hostent &#123; char *h_name; /* official name of host */ char **h_aliases; /* alias list */ int h_addrtype; /* host address type */ int h_length; /* length of address */ char **h_addr_list; /* list of addresses */&#125; 同理，还有getservbyname返回一个servent指针实现服务名→端口号；getprotobyname返回protoent指针实现协议名→协议号 Socket TCPsocket调用基本流程 TCP客户端软件流程 确定服务器IP地址与端口号 创建套接字 分配本地端点地址（IP地址+端口号）——由系统自动完成，所以bind一般只用在服务器端 连接服务器（如果是UDP，指定服务器端点地址，构造UDP数据报） 遵循应用层协议进行通信 释放连接 循环TCP服务器流程 创建(主)套接字，绑定熟知端口号 设置(主)套接字为被动监听模式，准备用于服务器 调用accept()函数接受下一个连接请求，创建新套接字用于与该客户建立连接 遵循应用层协议，反复接受客户请求，构造并发送响应 完成为特定客户服务后，关闭与该客户之间的连接，返回步骤3 并发TCP服务器流程主线程： 创建(主)套接字，绑定熟知端口号 设置(主)套接字为被动监听模式，准备用于服务器 调用accept()函数接受下一个连接请求，创建一个新的子线程处理该客户响应 子线程： 创建新的套接字接受一个客户的服务请求 遵循应用层协议，与特定客户进行交互 完成为特定客户服务后，关闭与该客户之间的连接，终止线程 在实际过程中，会有一个主线程和多个子线程同时运行，实现并发。","categories":[{"name":"network","slug":"network","permalink":"http://vergessenwang.github.io/categories/network/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://vergessenwang.github.io/tags/TCP-IP/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://vergessenwang.github.io/tags/计算机网络/"},{"name":"Socket编程","slug":"Socket编程","permalink":"http://vergessenwang.github.io/tags/Socket编程/"}]},{"title":"VUE踩坑记录（一）","slug":"VUE踩坑记录（一）","date":"2019-03-28T02:05:05.000Z","updated":"2020-03-06T12:43:02.110Z","comments":true,"path":"posts/frontend/2019-03-28-VUE踩坑记录（一）.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2019-03-28-VUE踩坑记录（一）.html","excerpt":"Q1：以前的el挂载点是body；但是在Vue2.0中，是一个名为#app的CSS选择器，template是将会替换挂载元素的模板。（官方：不推荐root实例挂载到 或，且所有的挂载元素都会被Vue生成的DOM替换） Q2：旧版中没有router，先重新建一个不含router的项目开始学习。 Q3 ：ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。","text":"Q1：以前的el挂载点是body；但是在Vue2.0中，是一个名为#app的CSS选择器，template是将会替换挂载元素的模板。（官方：不推荐root实例挂载到 或，且所有的挂载元素都会被Vue生成的DOM替换） Q2：旧版中没有router，先重新建一个不含router的项目开始学习。 Q3 ：ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。Q4：自定义标签123456export default &#123; name: &apos;App&apos;, components: &#123; HelloWorld &#125;&#125; Q5: div里面的代表模板，可以访问到12345data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125; 中对应的msg Q6:创建一个组件。首先创建一个.vue文件，分为template、script、style三部分，export导出一个对象，对vue的各自属性进行定义。使用时先用import引用，再用components注册，就可以使用该标签 Q7:webpack原理——了解完了简单配置 Q8：设备像素比devicePixelRatio简单介绍 Q9：SVG图标字体制作 Q10: （已弃用sublime，改用vs code）如何在sublime中新建.vue格式的文件首先安装sublime包插件时出现There are no packages available for installationctrl+`打开控制台找原因：Error downloading channel. HTTP error 404 downloading https://packagecontrol.io/channel_v3.json.找到一个下载地址：https://download.csdn.net/download/ming_221/9944588然后在sublime设置：preferences-&gt;package settings -&gt; package control -&gt; settings-user添加一条本地渠道（该文件绝对路径）：123456&quot;channels&quot;:[ &quot;/Users/18771/AppData/Roaming/Sublime Text 3/channel_v3.json&quot;], 核心问题还是……科学上网啊​ 问题解决，开始安装插件新建文件模板插件 SublimeTmpl：在安装包的templates中新建vue.tmpl一个可用模板参见http://www.imooc.com/article/33817?block_id=tuijian_wzPreferences&gt;Package Settings&gt;SublimeTmpl&gt;Menu中新增vuevue语法高亮插件 Vue Syntax Highlight: 模板绑定语法高亮Preferences&gt;Package Settings&gt;SublimeTmpl&gt;Settings -Users中设置123456&#123; &quot;vue&quot;: &#123; &quot;syntax&quot;: &quot;Packages/vue-syntax-highlight/vue.tmLanguage&quot;, &quot;extension&quot;: &quot;vue&quot; // default_extension &#125;&#125; 但是好像没效果，新版sublime没有文件夹，只有.package文件。也不知道怎么绑定。最后还要手动在右下角选：）所以，我是不是要换一个编辑器了…嗯，换了一个VS code装起插件来简直不要太爽，界面也好看，开心地像个二十几岁的孩子… Q11: 科学上网——已用ss解决 Q12: CSS预编译：stylus，sass, less Q12:前后端分离，通过ajax请求进行交互；对接之前，前端通过Mock模拟后台数据 Q13: vue-cli生成的webpack配置解析中没有-build/dev-server.js: 新版本的vue已将dev-server.js与webpack.dev.conf.js合并了，上面的操作webpack.dev.conf.js中配置就好了 Q14:VS code快速注释，CTRL+k 然后CTRL+c Q15: express is not defined :没有npm installjson-server获取服务器数据只能用get方式，而express支持post方式获取数据。npm install express –-save 具体含义但是安装完了之后，package.js中有了包”express”: “^4.16.4”,，可以仍然显示没有定义：express在4.0之后，需要安装the executable（执行器express-generator）才能执行express命令，npm install express-generator终端运行npm run dev 编译通过，但是api没有配置成功，发现还是新版本webpack.dev.conf.js请求本地数据的配置的问题：参见要添加到devServer中，注意别忘了逗号在8080调用api显示成功，但是不美观，没有格式化。安装Google插件JSON Viewer,接口调用成功 Q16: 整体缩进 Ctrl+】 Q17:在static中将css进行reset Q18: vscode 新建vue模板:user snippets中设置，新建后输入vue按tab键，模板代码就出来了 Q19: 安装 stylus-loader后出现Cannot find module ‘stylus’原因：需要安装stylus 再安装stylus-loader再进行npm install解决：重新安装npm install stylus --save-dev npm install stylus-loader --save-dev Q20:快速复制一行 按住Ctrl+Alt+Down，即可以在下面快速复制一行，按住Ctrl+Alt+Up，即可以在上面快速复制一行。 Q20:Flex布局 实现三等分 Q21:vue-router实现跳转，router.map is not a function报错原因：2.0已经没有map和start方法参考文档将12345678let app = Vue.extend(App);var router = new VueRouter();router.map(&#123; &apos;/goods&apos;: &#123; component: goods &#125;&#125;); 替换为123456789const routes = [ &#123;path: &apos;/goods&apos;, component: goods&#125;, &#123;path: &apos;/ratings&apos;, component: ratings&#125;, &#123;path: &apos;/seller&apos;, component: seller&#125;];const router = new VueRouter(&#123; routes&#125;); 将router.start(app, &#39;#app&#39;);替换为123456789/* eslint-disable no-new */new Vue(&#123; el: &apos;#app&apos;, router, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;); 一个用法的实例编译通过后又出现问题：Failed to resolve directive: link原因：vue的版本升级后，取消了v-link指定，取而代之的为 router-link。router-link组件支持用户在具有路由功能的应用中点击导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的 a标签，可以通过配置 tag 属性生成别的标签。解决：a v-link=”{path:’/goods’}”商品/a替换为router-link to=”/goods”商品/router-link (markdown转义不会弄，没加标签&lt;&gt;)总算路由成功！！！ Q22：在webpack中配置alis可以简化路径 Q23:设置默认路由router.go后页面一直刷新原因：router的设计模式是参考了浏览器的window.history相关API，同history.go, router.go接受的参数应该为Number解决一：不用router.go ,直接在routes中增加 {path: &#39;/&#39;, component: goods},解决二（更好）：用router.push方法 Q24: CSS预编译语法 引用父选择符： &amp; Q25: 标签最好设置为display：block 扩大可点击范围&amp;.router-link格式设置不生效&amp;.active选中标签高亮不生效原因：选择器有点问题。当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名active-class=”activeClass”解决：在router-link中加上tag=”li”，通过&amp; &gt; li将其渲染成li标签来选择router-link。在router中全局配置linkActiveClass: ‘active’重命名激活标签，激活时标签通过&amp;.active来选择 Q26:通过stylus的mixin方法实现通用一像素伪类的绝对定位，同时全局定义base根据不同设备缩放（主要是通过调整scaleY使得DPI*缩放=1）问题：tab-item字体被压扁原因：border-1px那个方法改变了scaleY压缩了字体。用transform做了个3d坐标轴，然后每个轴都要写上文字节点ul，问题是放在三个平面内的文字会跟各自平面一起被变形和压扁解决：不用border-1px方法了… “tab border-1px”还原为tab以后再找解决方法，现在这个不重要，知道保持像素的方法就行 Q27:Vue-resource 实现Ajax请求（vue-resource已经不再是官方推荐的ajax库了，请使用axios）npm install vue-resource –saveVue的每个实例在生命周期中有一个钩子函数created。response.body()返回一个json类型的对象,通过api拿到数据后传给组件，组件通过props接收问题：”TypeError: Cannot read property ‘avatar’ of undefined”原因：页面进行了渲染和请求接口获取数据，异步进行，所以获取数据没有完成时，页面已经进行渲染，所以第一次报使用未定义变量。解决： 父组件 &lt;:src=”seller.avatar”&gt; 子组件 用v-bind: 方法引用问题：图片无法显示原因：if (response.erron === ERR_OK) 改成不等号。检查到头都大了：） Q28:要判断状态码时最好设置为一个常量，便于后续修改","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://vergessenwang.github.io/tags/vue/"}]},{"title":"迟来的2018年感悟","slug":"迟来的2018年感悟","date":"2019-03-27T14:46:19.000Z","updated":"2019-08-27T05:52:09.594Z","comments":true,"path":"posts/life/2019-03-27-迟来的2018年感悟.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2019-03-27-迟来的2018年感悟.html","excerpt":"一切终于尘埃落定，却又不知从何说起了。 感觉很多事情，就像坐滑滑梯。前面长长的攀登，不过是为了滑下去的那快乐或恐惧的几秒钟，尽管短得如同梦中。等你滑到尽头呆坐在地上的时候，才反应过来，哦，原来是这种感觉啊。 “哦，原来是这种感觉。”这就是我所理解的人生的意义。体验，感受，仅此而已。 只为值得的事情去努力，没有那么多两全其美的事情。什么都无法放弃的人，什么都无法改变。","text":"一切终于尘埃落定，却又不知从何说起了。 感觉很多事情，就像坐滑滑梯。前面长长的攀登，不过是为了滑下去的那快乐或恐惧的几秒钟，尽管短得如同梦中。等你滑到尽头呆坐在地上的时候，才反应过来，哦，原来是这种感觉啊。 “哦，原来是这种感觉。”这就是我所理解的人生的意义。体验，感受，仅此而已。 只为值得的事情去努力，没有那么多两全其美的事情。什么都无法放弃的人，什么都无法改变。 我还是很想读书，如今终于得偿所愿，心情却很平和。甚至在复试被老师吐槽编程能力太弱时，会冒出“干脆刷掉我好了”这样的念头，我也不知道为什么，可能是担心这条路太冒险了，会离正常的轨道越来越远吧。哎，真是矛盾啊。理想主义与逃避，往往只有一线之隔。不管怎么说，未来我可以有更多选择。 大概得了一种“崇拜什么，就想把这种东西变成属于自己的东西，得到了又觉得不过如此”的病。不过我对钱没有什么想法，这可能是我是个赚钱废物的原因吧…净整些没用的。瑞哥说她理想的生活是考古和文学，我想了想，说我以后想去山里隐居。她说：那我要去山里把你挖出来。哈哈哈，可爱的瑞哥。隐居是不可能隐居的，有个堆满精装书的小狗窝就满足了。 我大概只是运气好吧，今年扩招了。原来，很多看起来厉害的人，也不过是普通人。“谁终将点燃闪电，必长久如云漂泊。”考前日日复习到一两点的那些天，我已觉得很遥远了，只是它们替我应证了这句格言，没有任何令别人惊讶的成果是可以一蹴而就的。钦慕别人的成就，不如感叹别人的汗水。 说到底，我也放弃了很多，才走到这一步。 只在努力有用的地方努力，不值得的放弃，没用的看天意。这是我在2018年学到的最重要的道理。 赫里内勒多·马尔克斯上校最终失去了与战争的一切关联。曾几何时一段真实的经历，一股青春年代不可抗拒的激情，如今对他而言已经成为遥远的注脚：虚无而已。 ——《百年孤独》","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[{"name":"又是一年","slug":"又是一年","permalink":"http://vergessenwang.github.io/tags/又是一年/"}]},{"title":"我，是一个概率","slug":"我，是一个概率","date":"2019-02-19T15:49:09.000Z","updated":"2019-08-11T18:09:40.302Z","comments":true,"path":"posts/thinking/2019-02-19-我，是一个概率.html","link":"","permalink":"http://vergessenwang.github.io/posts/thinking/2019-02-19-我，是一个概率.html","excerpt":"这个问题得先从人脑说起。 从微观角度来，神经元细胞及相互间错综复杂的神经突触构成神经网络。对于一个神经元细胞而言，尽管有多种输入，但仅有一个输出。同时，连接结构的复杂性导致了网络中必然存在回路。 为了解决这个回路问题，数学家皮茨提出了“模运算” 的方法，这个方法剥离了时间，顺序只有在计算后才能得到，而这个链条本身，成为了一段记忆。基于这种描述，冯·诺依曼提出了程序存储的概念。","text":"这个问题得先从人脑说起。 从微观角度来，神经元细胞及相互间错综复杂的神经突触构成神经网络。对于一个神经元细胞而言，尽管有多种输入，但仅有一个输出。同时，连接结构的复杂性导致了网络中必然存在回路。 为了解决这个回路问题，数学家皮茨提出了“模运算” 的方法，这个方法剥离了时间，顺序只有在计算后才能得到，而这个链条本身，成为了一段记忆。基于这种描述，冯·诺依曼提出了程序存储的概念。然而，我想说的是，也许正是这种剥离，造成了失真，导致了人脑科学与人工智能之间的分歧。假如说一开始人脑和机器都有已经预设好的结构及少量信息，那么最后导致人脑和计算机仍有本质区别的原因是什么？或者说计算机要达到何种程度才会有像人脑一样的性能？ 我觉得关键，不在于信号输入的节点，而在于联系，也及被模运算剥离的那种后验顺序。想象一下，假定只有三个输入节点，但是在时间维度上，每一个刻度都有8种可能的输入，那么这一特定时间点的输出就不会是确定的，而成了一个概率问题。 对机器而言，失去了确定性，机器还能称之为机器吗？这跟古人拜佛求雨、卜龟算卦有什么区别？ 由此可见，逻辑并不是人脑的核心，关系即神经机制才是。本体论仍然划开了人脑与计算机的界限。那种输入的顺序，来自信息并产生信息。信息，又是什么？ 有个问题困惑了我很久：如果所有能证明我身份的东西被付之一炬，我如何证明，我就是我？ 等一下，我好像卡在了这里。好了，我继续。 用基因序列？不同人之间碱基对的构成元素有什么分别吗？如果完全相同的克隆人，放到不同的环境中去，最后拿来比较时，他们相同吗？很显然是不同的。 纯物质角度太过形而上学了。我觉得，是一个个时间截面上的信息状态，组成了人。也就是说，在物质的角度上还必须加上一个时间的维度，四维空间构成了人。类比人脑，物质是逻辑，时间是机制，信息构成人。 物质一般是和空间不可分割的。同样，这是一个概率问题。电子是波函数，函数是同一的。从量子的角度讲，是先有被观测的坍缩，然后才有去描述位置的参照系。 “时间就是不让一切同时发生的那个东西，空间就是不让一切合为一体的东西。不让一切都发生在我身上。” 永远不要过分追求同一性，不然你会发现自己根本不复存在。若只关注构成物质的统一，那么，原来我只是生活在n维空间的四维映射上的一个坍缩…… 以忒修斯之船类比，如果身体的每一个细胞都更新过一次，我还是不是我？ 也就是单纯来看结构关系，去除物质的影响。 突然间，我又困惑了。 或者，这种更新顺序本来就是信息的一部分，即便最终结果完全一样，但是如果中间的过程遗失了，仍然无法做出判断。 也就是说，时空本质上就不可分割。时间没有最小粒度，时间本身也是靠物质变更来观测的，而物质变更是一个概率问题。那么每时每刻唯一确定的，只有概率。 答案找到了，我是一个概率…… “我们所说的真实建立在若干个确凿的观察点上，这些观察点之间都是我们靠想象和理论精心搭建的纸模型 ”——惠勒","categories":[{"name":"thinking","slug":"thinking","permalink":"http://vergessenwang.github.io/categories/thinking/"}],"tags":[{"name":"唯物与唯心","slug":"唯物与唯心","permalink":"http://vergessenwang.github.io/tags/唯物与唯心/"},{"name":"机器与人性","slug":"机器与人性","permalink":"http://vergessenwang.github.io/tags/机器与人性/"}]},{"title":"谁能改变河水的流向","slug":"谁能改变河水的流向","date":"2019-01-13T14:57:37.000Z","updated":"2019-08-11T18:07:55.072Z","comments":true,"path":"posts/life/2019-01-13-谁能改变河水的流向.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2019-01-13-谁能改变河水的流向.html","excerpt":"广州冬天还不算太冷，我把围巾裹了两圈，坐在花城广场的台阶上等着音乐节开场。手里的红茶还是温热的，地板有点凉。周围都是耸入云霄的大厦，这里，像是疲惫的人群喘息的洞口。 乐队登场了。是来自广西的马帮。 主唱戴着一个有原始气息的头冠，黑色的翎毛向天指着，是哪一只鸟的残魂？架子手和吉他已就位，右边是一个留长发的艺术家，前面放着横笛、唢呐和葫芦丝。左边的木鼓我叫不上名字。","text":"广州冬天还不算太冷，我把围巾裹了两圈，坐在花城广场的台阶上等着音乐节开场。手里的红茶还是温热的，地板有点凉。周围都是耸入云霄的大厦，这里，像是疲惫的人群喘息的洞口。 乐队登场了。是来自广西的马帮。 主唱戴着一个有原始气息的头冠，黑色的翎毛向天指着，是哪一只鸟的残魂？架子手和吉他已就位，右边是一个留长发的艺术家，前面放着横笛、唢呐和葫芦丝。左边的木鼓我叫不上名字。一声高亢的呼喊，让人从城市抽离。充满历史感和民族感的节奏敲打着大厦的玻璃。与环境格格不入，却又仿佛与我们一脉相承，只是我们遗忘了。 歌声越欢快，越激昂，我就觉得这风，越冷。冷到骨髓里，冷到心灵颤栗着。我们在文明里面丢失了多少祖先留下的瑰宝？我们在虚荣的追逐里面遗失了多少本来的面貌？这歌声是他们的呼喊，还是我们本身的诉求？雨点般的鼓点，叩问心门。 单薄的衣衫挡不住他们的热情。我想，他们一路走来，走到这里，走到众人面前，大概必定经历过许多孤独彷徨的时刻。在众人簇拥的道路旁，默默走着自己的蹊径。日夜磨炼自己的技艺，谱写自己的乐章。可是那又是多么快乐啊。把自己民族的东西，传递给更多的人，把不能遗失的，小心保存。衬得我们这些走着世俗道路的，不知本心的，迷茫无措的人，是多么的渺小。 他们又唱了一首歌，名叫《不能改变河水的流向》。 我又同时想到，有一个叫新世相的自媒体的宣言是：我们终将改变河流的朝向。 这两者之间矛盾吗？没有。这只乐队说的是历史和自然，那个媒体说的是未来和意志。我歌颂着传统的珍贵，你宣扬着思想的良知。立足于各自的信仰，各自为战。他们可真是幸福的人。 我拍了拍尘土，起身往回走。乐音还在耳后激荡。我望着高远的天空，我的信仰在哪里呢？ 我只知道，我不属于现在。它还在其他的地方。","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[{"name":"信仰何处","slug":"信仰何处","permalink":"http://vergessenwang.github.io/tags/信仰何处/"}]},{"title":"webpack简单配置","slug":"webpack简单配置","date":"2019-01-11T15:15:09.000Z","updated":"2019-08-11T18:14:24.395Z","comments":true,"path":"posts/frontend/2019-01-11-webpack简单配置.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2019-01-11-webpack简单配置.html","excerpt":"创建一个webpack.config.js文件，基于node，所以要遵循CommonJS规范 打包出真实文件，即上线：webpack 开发的时候：webpack-dev-server","text":"创建一个webpack.config.js文件，基于node，所以要遵循CommonJS规范 打包出真实文件，即上线：webpack 开发的时候：webpack-dev-server #基本配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667let path = require(&apos;path&apos;) ; /* node中path 模块提供了一些工具函数，用于处理文件与目录的路径。path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径。 webpack通过require来判断哪些模板在编译打包时需要引用*/let HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); let webpack = require(&apos;webpack&apos;);let ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)let CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)module.exports = &#123; entry:&#123; js1:&apos;path1&apos;, js2:&apos;path2&apos;, &#125;, // 入口 output:&#123; filename:&apos;[name].js&apos;, path:path.resolve(&apos;./build&apos;), // 必须是绝对路径 &#125;, devServer:&#123; contentBase:&apos;&apos;, port:3000, compress:true, // 服务器压缩 open:true, // 自动打开浏览器 hot:true, // 热更新 &#125;， // 开发服务器 module：&#123; rules:&#123; test:/\\.css$/, use:ExtractTextWebpackPlugin.extract(&#123; fallback:&apos;style-loader&apos;, /* 把style-loader传给了fallback，这个配置的基本含义就是， extract默认行为先使用css-loader编译css，如果一切顺利的话， 结束之后把css导出到规定的文件去。*/ use:&#123; loader:&apos;css-loader&apos; &#125; &#125;) &#125; &#125;， plugins:[ new webpack.HotModuleReplacementPlugin(), new CopyWebpackPlugin([&#123; from:&apos;&apos; to:&apos;&apos; &#125;]), new HtmlWebpackPlugin(&#123; filename:&apos;a.html&apos;, template:&apos;&apos;, title:&apos;&apos;, minify:&#123; removeAttributeQuotes:true, //打包到一行 collapseWhitespace:true, hash:true, &#125; chunks:[&apos;js1&apos;] &#125;) ], mode:&apos;development&apos;, // 可以更改模式 resolve：&#123;&#125;， // 配置解析&#125; 要点： 配置开发服务器 webpack-dev-server，安装包的时候也要用开发模式 插件 将html打包到build下可以自动引入生产的js，用插件html-webpack-plugin 多页面（多入口）配合html-webpack-plugin中的chunks Webpack自带的热更新插件，只刷新更改的局部 针对不同的文件类型（style/css/less/sass/stylus），使用不同的loader进行解析。在module中建立匹配规则 同时为了减小文件大小要抽离CSS样式，用extract-text-webpack-plugin，但是会失去热更新功能，故一般上线的时候才抽离。为了解决这个问题，用fallback（保留样式但不抽离） 直接拷贝文件，copy-webpack-plugin插件，from-to路径","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"webpack打包","slug":"webpack打包","permalink":"http://vergessenwang.github.io/tags/webpack打包/"},{"name":"工具设置","slug":"工具设置","permalink":"http://vergessenwang.github.io/tags/工具设置/"}]},{"title":"学习之道-note","slug":"学习之道","date":"2018-09-12T12:59:25.000Z","updated":"2019-08-11T18:11:50.741Z","comments":true,"path":"posts/reading/2018-09-12-学习之道.html","link":"","permalink":"http://vergessenwang.github.io/posts/reading/2018-09-12-学习之道.html","excerpt":"运用回想 读完一页书，看向别处回想主要观点（提取练习）。不要被动重复阅读，不要画过多重点（一定程度上说，一旦在材料中做了标记，就破坏了知识的原貌）。通过回忆得到自己心中的想法。加深回忆的方法：尽可能调动更多的感觉，形成记忆宫殿。 自我测试 用抽认卡片检验记忆。做练习题测试，但前提是已经熟悉过教材，不要本末倒置。练习中有错误不要沮丧，它的目的就是让你在真实环境之前经历失败。","text":"运用回想 读完一页书，看向别处回想主要观点（提取练习）。不要被动重复阅读，不要画过多重点（一定程度上说，一旦在材料中做了标记，就破坏了知识的原貌）。通过回忆得到自己心中的想法。加深回忆的方法：尽可能调动更多的感觉，形成记忆宫殿。 自我测试 用抽认卡片检验记忆。做练习题测试，但前提是已经熟悉过教材，不要本末倒置。练习中有错误不要沮丧，它的目的就是让你在真实环境之前经历失败。 对问题进行组块 类比已有知识（理解问题，使用解释性的提问和简单类比，或情境带入如想象自己是一个晶体管，给抽象概念赋予生命。理解通常是解释的产物）→搭建组块（抽象，如意群和口诀；跳出初始问题，获取背景信息，明白应用场景）→归纳解题方法（应用，系统地理解每个步骤）。首先要梳理一个顺畅的思路，然后将组块一一挂载到逻辑之上。组块过程是至下而上的过程，纵览全局是至上而下的，而背景环境正是交汇之处，意味着要做出恰当的选择。 加强模式识别（建立一个思维方案库，快速读取）：章节→主旨→题型→方法。要刻意关注最棘手的概念和解题环节，有思路前不要看解答。 间隔重复，交叉练习 不同学科交叉学习，每天能处理的某学科的练习量是一定的。在练习中还要交替使用不同解题技巧，如果已经掌握某种方法，就不要再做同一类题。 由难入简 一天中头脑中最清醒的时间，做最困难的事情。开始做题的时候，先做看起来最难的那道。如果一两分钟没有进展，再跳到简单题，让发散思维在后台进行处理。一段时间后再回过头来看，逐步获得进展。就好像同时做很多道菜一样。可以防止陷入思维定势，在更多的题型中获得启示。专注模式只着眼于具体的解题过程（套公式和已有方法），即使犯了很离谱的错误也不会察觉到，要不时换到发散模式从全局角度审题和检查（思考方程的意义，从何而来，适用范围），如量纲分。 方程不只是一个有输入由输出的表达式。它描述了我们物理世界如何运转。理解的关键在于，理解它所描述的故事。对方程的定性理解远比定量计算出答案更重要。 “描述世界解决问题的理论必须建立于它自己的术语之上，能够独立存在，而模型往往依赖于他山之石。它们是将所研究之物于相似之物进行联系的比喻。这些相似都是片面的，因此模型必须对事物进行简化，缩减世界的维度。简单来说，理论告诉事物的本质，而模型仅仅告诉你它像什么。 ——艾曼努尔·德尔曼","categories":[{"name":"reading","slug":"reading","permalink":"http://vergessenwang.github.io/categories/reading/"}],"tags":[{"name":"学习方法","slug":"学习方法","permalink":"http://vergessenwang.github.io/tags/学习方法/"},{"name":"训练","slug":"训练","permalink":"http://vergessenwang.github.io/tags/训练/"}]},{"title":"彷徨","slug":"彷徨","date":"2018-09-09T15:21:42.000Z","updated":"2019-08-11T18:06:15.133Z","comments":true,"path":"posts/poetry/2018-09-09-彷徨.html","link":"","permalink":"http://vergessenwang.github.io/posts/poetry/2018-09-09-彷徨.html","excerpt":"曾迷仗剑执花梦，又耽恓惶怠日终。少年壮志殁荒草，尉为国用笑成空。","text":"曾迷仗剑执花梦，又耽恓惶怠日终。少年壮志殁荒草，尉为国用笑成空。偶闻雾破云开语，欲携玉龙重返疆。闭耳不闻世事嚣，奈何白驹奔如旧。你言光阴倏不待，我道幽井难观天。十年烂柯千年塔，不见鸿雁等归人。世间万般玲珑局，莫执一子空踟躇。凉州道远难顾盼，不若纵马览千山。今朝放下手中剑，年深岁久可相知？","categories":[{"name":"poetry","slug":"poetry","permalink":"http://vergessenwang.github.io/categories/poetry/"}],"tags":[{"name":"醉笑痴狂","slug":"醉笑痴狂","permalink":"http://vergessenwang.github.io/tags/醉笑痴狂/"}]},{"title":"阿里阿德涅之线","slug":"阿里阿德涅之线","date":"2018-09-05T13:26:24.000Z","updated":"2019-08-11T18:05:43.548Z","comments":true,"path":"posts/thinking/2018-09-05-阿里阿德涅之线.html","link":"","permalink":"http://vergessenwang.github.io/posts/thinking/2018-09-05-阿里阿德涅之线.html","excerpt":"克里特岛的迷宫 在迷宫神话中，克里特岛国王的女儿阿里阿德涅给了她爱慕的勇士忒修斯一个线团，他在斩杀了吃童男童女的兽人米诺陶洛斯之后，又靠这个线团原路返回走出了迷宫。 这个故事具有一定的隐喻意义。人类诞生在一个孤独的星球上，在这个无迹可寻的物质世界中，现今的人们对于世界相比于原始人的困惑并不会更少，而且文明一词，本来就是一个相对的概念。人类在所有领域的一切探索，都可以归结到一个总的命题：我们周围的世界，究竟是怎样的？","text":"克里特岛的迷宫 在迷宫神话中，克里特岛国王的女儿阿里阿德涅给了她爱慕的勇士忒修斯一个线团，他在斩杀了吃童男童女的兽人米诺陶洛斯之后，又靠这个线团原路返回走出了迷宫。 这个故事具有一定的隐喻意义。人类诞生在一个孤独的星球上，在这个无迹可寻的物质世界中，现今的人们对于世界相比于原始人的困惑并不会更少，而且文明一词，本来就是一个相对的概念。人类在所有领域的一切探索，都可以归结到一个总的命题：我们周围的世界，究竟是怎样的？ 如果一切是从无到有，那最开始的状态是怎样的？如果背后有一个神秘的创造者，那么万物的规则又是什么？忒修斯代表的是人类，米诺陶洛斯是人类的非理性（实际上，纯粹理性究竟是否存在还是一个问题，基于进化角度的在乎短期利益的非理性似乎更贴近人类的本质），迷宫是经验知识，我们站在中央，被自然科学，社会科学，人文科学，艺术和宗教团团包围。尽管在这些领域都有着各种突破，但它们各自绕成一堆乱麻。即便从因果解释的路径出发，每个岔路口的可能性最终会使可能性累计至无穷。 我们似乎永远连终点都找不到，更别说起点了。亲爱的阿里阿德涅，你在哪？ 在单个领域建立统一规律之后，自然会想到，能否在不同的领域建立一个简约的标准？即使所有的科学都受限于我们这个宇宙的参数。 笛卡尔曾提出的演绎法有一个基本的框架：切中每一个现象的核心，并记下现象的架构。他认为互相关联的真理最后都可以抽象成数学，而且系统性的质疑时学习的首要原则。 然而，数学虽然在架构理论上无懈可击，却是逻辑上的同义反复，即结论实际上和条件是等价的。在现实中，对于复杂系统的研究，整合也比剖析更难。最重要的是：预测的价值。基于普适的数学模型，发展到特殊的物质世界，预测能力到底有多强。 现有的复杂理论发展出分形几何，混沌理论等原理，解释了复杂现象可以经由系统中微小而可测量的变化来决定。可是，并没有太多实际可用于预测的能力。 或许，复杂系统的复杂性就在于：不可预测性。我们清楚生命游戏的原理，却依然为它所产生的美妙结果而惊叹。也许，提出正确的问题比给出正确的答案更为重要。 每个人都活在自己的感官和既有知识构造的世界中，我们尚未感知的，并不一定不存在。 没有完整的世界观，只有不断完善的世界观。 它，就在那里。 “那些死于热诚追寻的人，就像在热血中受了伤，几乎感受不到任何疼痛。”——培根","categories":[{"name":"thinking","slug":"thinking","permalink":"http://vergessenwang.github.io/categories/thinking/"}],"tags":[{"name":"探索的意义","slug":"探索的意义","permalink":"http://vergessenwang.github.io/tags/探索的意义/"}]},{"title":"栈","slug":"栈","date":"2018-09-02T04:10:45.000Z","updated":"2019-09-01T15:36:43.918Z","comments":true,"path":"posts/data-structure/2018-09-02-栈.html","link":"","permalink":"http://vergessenwang.github.io/posts/data-structure/2018-09-02-栈.html","excerpt":"定义 LIFO，仅在表尾进行插入删除操作的一种特殊线性表，是一种逻辑结构，故有多种实现方式。 实现 关键：指针和元素值的对应关系（有时指针指向当前元素——如在数组表示中初始指向-1，有时指向下一个元素——初始指向栈底，视具体情况而定）；指针如何移动（链表实现中）","text":"定义 LIFO，仅在表尾进行插入删除操作的一种特殊线性表，是一种逻辑结构，故有多种实现方式。 实现 关键：指针和元素值的对应关系（有时指针指向当前元素——如在数组表示中初始指向-1，有时指向下一个元素——初始指向栈底，视具体情况而定）；指针如何移动（链表实现中） 顺序栈 结构体 12345#define Maxsize 100typedef struct&#123; ElemType data[Maxsize]; //存放栈中元素，可以是int等类型（int data[Maxsize]) int top;&#125;SqStack; //结构变量对结构成员的访问 : 结构变量.成员名 假设栈指针的初始值为-1（避免浪费一个元素空间的大小） 初始化顺序栈 123456789//考虑空间问题，动态分配void InitStack(SqStack &amp;S)&#123; S.top = (ElemType *)malloc(Maxsize * sizeof(ElemType)); if (!S.top) exit (Overflow);&#125;//静态分配void InitStack(SqStack &amp;S)&#123; S.top = -1; //只须设置指针&#125; 判断栈空(判断指针位置，非引用型) 123bool StackEmpty(S)&#123; (S.top == -1)?true:false;&#125; 进栈 123456 bool Push(SqStack &amp;S，ElemType x)&#123; if (S.top == Maxsize-1) //先判断是否还有空间 return false; S.data[++S.top] = x; //先移动指针，再存数；如果初始值为0，则S.top++ return true;&#125; 出栈（删除栈顶元素） 123456bool Pop(SqStack &amp;S，ElemType &amp;x)&#123; if (S.top == -1) //先判断是否还有元素 return false; x = S.data[S.top--]; //先取数，再移动指针；如果初始值为0，则--S.top return true;&#125; 取栈顶元素（但不删除，非引用型） 123456bool GetTop(SqStack S，ElemType &amp;x)&#123; if (S.top == -1) //先判断是否还有元素 return false; x = S.data[S.top]; //不移动指针 return true;&#125; 基本操作总结 1234int Stack[Maxsize];int top = -1;S.data[++S.top] = x;x = S.data[S.top--]; 链栈 结构体 1234typedef struct LNode&#123; ElemType data; struct Linknode *next;&#125; *LiStack; //使用结构指针对结构成员的访问: 结构指针名-&gt;结构成员 初始化链栈 1234void InitStack(Linknode &amp;S)&#123; S = (LNode *)malloc(sizeof(LNode)); // 假设有头结点，分配空间 S -&gt; next = NULL; //栈空状态&#125; 判断栈空 123bool StackEmpty(LNode S)&#123; (S -&gt; next = NULL)?true:false;&#125; 进栈(离散存储，不用判满) 12345678910 viod Push(LNode &amp;S，ElemType x)&#123; LNode *p; //工作指针, 存储插入元素 p = (LNode *)malloc(sizeof(LNode)); //为进栈元素申请结点空间 p -&gt; next = NULL; //可以不写，但能避免一些错误 //头插法，逆序 p -&gt; data = x; //先存值 p -&gt; next = S -&gt; next; //先连后继指针 S -&gt; next = p; //再连前驱指针 //尾插法， R -&gt; next = p; R = p &#125; 出栈（要判空） 123456789bool Pop(LNode &amp;S，ElemType &amp;x)&#123; LNode *p; if (S -&gt; next = NULL) return false; p = S -&gt; next; //暂存后继结点，防止断链 x = p -&gt; data; //取值 S -&gt; next = p -&gt; next; //连上后继结点 free(p); //释放空间，C需要手动释放 return true；&#125; 基本操作总结 123S -&gt; next = NULL;p -&gt; data = x; p -&gt; next = S -&gt; next; S -&gt; next = p;p = S -&gt; next; x = p -&gt; data; S -&gt; next = p -&gt; next; free(p); 应用括号匹配 原理：栈具有记忆的功能。如果再解决问题的过程中出现了一个子问题，但凭现有条件不能解决它，需要记下，等出现可以解决它的条件后再返回来解决。 思路： 用顺序栈实现 逐个扫描，左括号入栈，右括号与栈顶第一个左括号抵消，若栈已空，出错； 如果有多种括号，右括号与栈顶第一个左括号不一致时出错； 扫描完毕，栈空成功；不空失败拓展：中心对称（回文），前一半元素进栈，匹配剩下的。由于涉及到n/2，要注意指针的位置，奇数时的处理（中间不用比较） 表达式求值 原理：根据算符优先级判断计算顺序，用栈记录顺序 注：此处是指中缀表达式 思路： 用两个工作栈，OPTR用于寄存运算符，OPND用于寄存操作数或运算结果，实现算符优先算法 置OPTR为空栈，OPND的栈底元素为起始运算符# 扫描表达式，操作数进OPTR; 第一个运算符进OPND,用precede比较，后续运算符大于栈顶符号优先级，压栈；相等（只可能是括号匹配）去括号；小于，弹出OPND栈底运算符，再弹出两个操作数，用Operate计算结果，并将计算结果重新压栈 直到OPND栈底和当前扫描符号均为 #细节：熟悉栈内外优先级的判断；运算时注意除数为0的情况拓展：后缀求值的实现（操作数先入栈，每遇到一个运算符出栈两个数，计算后将结果压栈);由中缀表达式输入后缀表达式（去括号，通过改变运算符的顺序来表示机器执行时的顺序） 车辆调度 原理：Y型车道，需要排在前面的不进栈，排在后面的进栈，此时栈中部分起存储作用。前面的都调度完之后，将栈中部分出栈 拓展：此时栈相当于一个中转站，通过它来实现顺序的转换，有点类似Hanoi塔的中间那个柱子 数制转换 原理：N = (N div d) * d + N mod d 从低位到高位的余数，故需要用栈实现输出的逆序。 思路： 做取余运算，将余数进栈 做整除运算，用结果替换N 直到N为0，弹出所有元素拓展：相比于数组实现的好处——利用栈的LIFO特性，不用再去考虑下标增减等细节问题 行编辑 原理：用户输入时可能出错，退格符#删一个，退行符@删一行，输入缓冲区接受一行字符后再存入到用户数据区。 接受的字符不是全文结束符EOF或换行符 #，退栈一个 @ ClearStack 清空 其他情况，正常进栈 全文或每行结束，将栈内容送至调用过程的数据区，清空栈拓展：注意该缓冲区与为解决主机和外设速度不匹配问题的打印数据缓冲区的区别，那个缓存区是用队列实现的，因打印要保证顺序不变；如果这里也要保证顺序不变，那就要加一个队列","categories":[{"name":"data_structure","slug":"data-structure","permalink":"http://vergessenwang.github.io/categories/data-structure/"}],"tags":[{"name":"栈的应用","slug":"栈的应用","permalink":"http://vergessenwang.github.io/tags/栈的应用/"}]},{"title":"基于区块链的信用共识：代码即法律","slug":"基于区块链的信用共识：代码即法律","date":"2018-08-29T05:31:57.000Z","updated":"2019-08-11T18:07:00.581Z","comments":true,"path":"posts/reading/2018-08-29-基于区块链的信用共识：代码即法律.html","link":"","permalink":"http://vergessenwang.github.io/posts/reading/2018-08-29-基于区块链的信用共识：代码即法律.html","excerpt":"从分散到集中 人类社会财产记录方式的发展，与物质的逐步丰盛是密不可分。最开始茹毛饮血的年代，温饱尚成问题，谈不上什么财产拥有权。呐，这个鹿屁股是你的，鹿腿归我，大概就是这样了。随着狩猎工具越来越精巧，以及通过长期观察掌握了自然更替的规律，人类开始从土地获得更为稳定与劳力成正比的耕作物。再不用在一个大锅里较稀稠，个人有了剩余的物质储备，催生了记账的需求。 同时，由于生产力之间的不平衡，物质短缺方和富余方之间还会建立借贷关系。这种互助关系本是出于善意，但是契约之间缺少更多约束，仅能凭借双方各自的人格担保，自然会产生诸多问题。","text":"从分散到集中 人类社会财产记录方式的发展，与物质的逐步丰盛是密不可分。最开始茹毛饮血的年代，温饱尚成问题，谈不上什么财产拥有权。呐，这个鹿屁股是你的，鹿腿归我，大概就是这样了。随着狩猎工具越来越精巧，以及通过长期观察掌握了自然更替的规律，人类开始从土地获得更为稳定与劳力成正比的耕作物。再不用在一个大锅里较稀稠，个人有了剩余的物质储备，催生了记账的需求。 同时，由于生产力之间的不平衡，物质短缺方和富余方之间还会建立借贷关系。这种互助关系本是出于善意，但是契约之间缺少更多约束，仅能凭借双方各自的人格担保，自然会产生诸多问题。 由此可以想到两种解决方案：第一种，找一个大家普遍认可的，具有公信力的第三方，各种借贷交易需要通过这个第三方进行；第二种，每个交易进行时所有人都在场见证，防止日后有一方违约。显然，第二种的成本过高，大家都跑去看人借钱，猪都饿死了。于是，由银行为首的第三方存管机构，辅之以交易所，会计审计等机构开始接管人类社会的借贷交易等记账工作。 记账的核心在于，解决信用共识。既然当初交给第三方是应该公共管理的成本过高，那么一旦成本低于第三方的管理费用，是不是就可以抛弃这种方式，重新回到点对点交易的时代？答案是肯定的。 重回去中心化时代 区块链的本质就是去中心化的分布式账本，能够用基于数学算法的低成本信任机制解决信用共识问题。撇开比特币不谈，因为即使一种载体只要能被大家普通认同是有价值的就能说是有价值的，但是这种每10分钟就产生一些新币，参与者依靠算力或者概率获得新币的增长到底有没有实际价值还是一个值得考虑的问题。与其说新币的拥有是一种价值创造过程，倒不如认为它激励大家普遍参与到达成一致共识这个过程中意图更强一点。 毕竟，记账才是重点，鼓励用户参与验证，保证过往交易历史的不可篡改性才是这种分布式方式的精髓所在。工作量证明，权益证明，Pool验证池等高效共识算法机制，在解决点对点通信中的拜占庭将军问题时，同时将时间控制在一个合适的范围，既不因太短而导致双花问题，也不因太长而影响结算。 同时，文本形式的契约变成了封装区块数据结构的代码和内含于整个系统的构建理念，可以说，代码即是法律，不为任何人或事动摇，比那些偶尔也会堕入腐败的第三方更为可靠。 由此可见，除了去中心化，安全，自治，公开和多备份等特点，低成本的解决信用共识问题也是区块链技术的一大优势。 当面对一项新技术时，不该因其表面的混乱，如比特币作为一种虚拟货币价值暴涨暴跌，就将之视为洪水猛兽。 技术本身，是无罪的。 另外，在2008年中本聪提出比特币基本原则时，也是基于许多前人的研究，任何一项技术，都不会是突然凭空产生的。 1982年，戴维·乔姆提出注重隐私安全的密码学网络支付系统，具有不可追踪性 1990年，莱斯利·兰伯特提出基于消息传递一致性的Paxos算法，解决分布式系统如何就某个值（决议）达成一致 1991年，斯图尔特·哈伯与W.斯科特·斯托尔内塔提出利用时间戳确保数位文件安全 1997年，亚当·巴克发明哈希现金技术，依赖成本函数的不可逆特性，实现容易被验证但是难被破解的特性 1998年，戴伟发表匿名的分散式电子现金系统B-money，强调点对点交易和不可篡改特性。尼克·萨博发表了去中心化的数位货币系统Bit Gold参与者可贡献运算能力解出加密谜题。 哈尔·尼克提出RPOW（可重复使用的工作量证明机制），将B-money和哈希现金结合起来创造了密码学货币 If I have seen further,it is by standing on ye shoulders of Giants","categories":[{"name":"reading","slug":"reading","permalink":"http://vergessenwang.github.io/categories/reading/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://vergessenwang.github.io/tags/区块链/"},{"name":"去中心化","slug":"去中心化","permalink":"http://vergessenwang.github.io/tags/去中心化/"}]},{"title":"信息熵与设计思维","slug":"信息熵与设计思维","date":"2018-08-26T08:42:28.000Z","updated":"2019-08-11T18:10:35.340Z","comments":true,"path":"posts/reading/2018-08-26-信息熵与设计思维.html","link":"","permalink":"http://vergessenwang.github.io/posts/reading/2018-08-26-信息熵与设计思维.html","excerpt":"信息与不确定性 一切不确定性的谜底，只有一个，那就是：信息。 与人交流时，更多的信息加深理解；面对问题时，综合更多的信息才能给出最优的解决方案。语言，文字，声音，甚至龟壳，都能作为信息的载体，创作者于此端编码，接受者于彼端解码，至于究竟采取何种方式，根本无关紧要。一万个猴子用无穷长的时间在打字机上乱敲，也能写出一本《资本论》。","text":"信息与不确定性 一切不确定性的谜底，只有一个，那就是：信息。 与人交流时，更多的信息加深理解；面对问题时，综合更多的信息才能给出最优的解决方案。语言，文字，声音，甚至龟壳，都能作为信息的载体，创作者于此端编码，接受者于彼端解码，至于究竟采取何种方式，根本无关紧要。一万个猴子用无穷长的时间在打字机上乱敲，也能写出一本《资本论》。 先民对预言者的盲目崇拜，表面上是对那种缥缈神力的敬畏，本质上是因为未来已经被剥去了神秘的美妙感，而成为了一种确定的现实。不管当下是光鲜亮丽，还是匍匐前行，好像最终都会到底那里，不如放弃抵抗，找一个皈依，一切推给命运。 未来是不确定的，人才活着；一眼看穿，就早已死去。 那这些与信息有什么关系？不确定性正是信息量的多少，即信息量的度量就是信息熵。消除不确定性，就是寻找相关信息。没有足够的信息量，不管用多么无懈可击的模型，都不可能得出一个确定的结果；更弱的相关性，也会使推论的过程更加曲折。 从某种意义上说，人当下所做的一切，都只是为了在面对未来的时候有更多的把握。听起来好像有点矛盾，更有把握不就是一眼看穿？那我们这么拼命是为了什么？为了死？不是。问题的根本在于，未来的不确定性是无穷的。人之所能掌握的，终究有限。我们能做的，不过在是包含了所有的不确定性的最大熵中，给自己找一个奋不顾身的理由。 在时间和命运的长河中，瞥见惊涛里一颗闪闪发光的钻石，看清自己的局限和向往之后，用生命作筹码，纵身一跃，仅此而已。 脱离这种大的框架，信息熵到底对生活有什么指导意义？ 解题与设计思维 先来说说数学家波利亚的怎样解题的步骤： 第一阶段：理解阶段。观察和发现问题的核心概念和性质。 第二阶段：规划阶段。规划出如何解决问题。 第三阶段：计划实施阶段。执行和验证。 第四阶段：回顾阶段。从解决方案中学习。 他的这种思想推动因素以及提出解决方案的过程——在工程学领域演化为设计思维。 其一，一定要真正理解你的问题——未知的问题是什么？你掌握了哪些数据？这个阶段就是信息收集，很多具体的问题背后，大多都有一个抽象的模型，基于这个模型你了解多少？基于具体问题又有多少已知的信息？如果曾经看过相似的问题，针对细微的区别，该做怎样的调整？如果这是一个新的挑战，能否找到更低一级的模型去支撑？这是一个无限抽象的过程。 其二，发现已有数据和未知问题的关联，即是一个深度具体的过程。基于选定的框架，每一条已知信息都必然可以通过分析，或多或少消除未知问题的一些不确定性。有的问题本身的模型已经足够精确，用极少的条件就可以得出确定的答案；而有的问题，本身定义就非常模糊，往往只能得出一个局部最优解，只有好坏而没有对错之分。 其三，看看能否证明你的想法，如果条件足够，最后的结果和最初的假设必然可以形成一个闭环。一旦出现矛盾，却可能是很多原因导致的。这又是很常见的，解决问题的过程，就是不断推翻假设的过程，修正是必要的环节。 最后，通过观察解决问题的结果和解决问题的过程，巩固知识，提高解决问题的能力。相似的，有确定答案的问题，往往都没有太大的价值。处于个人能力边界但又不算太遥远的问题，更能给人较大的提升，人的知识之网通过拓扑，可以够到那个边缘。即便解决了问题，也不等于万事大吉，完善曾经的模型或者在后续用更优的方案进行更新，问题才得以发挥其最大价值。 再回到人生上，我们总是要在各个阶段基于所掌握的信息，去做大大小小的决策，用更具逻辑性的方法，不断训练自己解决的能力。那我们在面对未来的时候，总归能少那么一丁点的不确定性，对命运多一点信心。","categories":[{"name":"reading","slug":"reading","permalink":"http://vergessenwang.github.io/categories/reading/"}],"tags":[{"name":"信息熵","slug":"信息熵","permalink":"http://vergessenwang.github.io/tags/信息熵/"},{"name":"决策","slug":"决策","permalink":"http://vergessenwang.github.io/tags/决策/"}]}]}