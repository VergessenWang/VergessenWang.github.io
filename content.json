{"meta":{"title":"Anonymous World","subtitle":"迷失仙境","description":"虚己以游世，乘物以游心","author":"Liana_Wang","url":"http://vergessenwang.github.io"},"pages":[{"title":"tags","date":"2019-08-11T13:39:37.000Z","updated":"2019-08-11T13:46:56.688Z","comments":true,"path":"tags/index.html","permalink":"http://vergessenwang.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-11T13:37:11.000Z","updated":"2019-08-11T13:46:50.957Z","comments":true,"path":"categories/index.html","permalink":"http://vergessenwang.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JS进阶：事件循环与代理","slug":"JS进阶：事件循环与代理","date":"2020-06-17T15:03:06.000Z","updated":"2020-06-17T15:04:35.860Z","comments":true,"path":"posts/frontend/2020-06-17-JS进阶：事件循环与代理.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-06-17-JS进阶：事件循环与代理.html","excerpt":"事件循环除了事件，还要保持浏览器执行的其他操作。这些操作被称为任务，并且分为两类：宏任务（或通常称为任务）和微任务。事件循环的实现至少应该含有一个用于宏任务的队列和至少一个用于微任务的队列。两种队列在同一时刻都只执行一个任务 事件循环基于两个基本原则：● 一次处理一个任务。● 一个任务开始后直到运行完成，不会被其他任务中断。 宏任务的例子很多，包括创建主文档对象、解析HTML、执行主线（或全局）JavaScript代码，更改当前URL以及各种事件，如页面加载、输入、网络事件和定时器事件。从浏览器的角度来看，宏任务代表一个个离散的、独立工作单元。运行完任务后，浏览器可以继续其他调度，如重新渲染页面的UI或执行垃圾回收。 而微任务是更小的任务。微任务更新应用程序的状态，但必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。微任务的案例包括promise回调函数、DOM发生变化等。微任务需要尽可能快地、通过异步方式执行，同时不能产生全新的微任务。微任务使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使应用程序的状态不连续。 注意处理宏任务和微任务队列之间的区别：单次循环迭代中，最多处理一个宏任务（其余的在队列中等待），而队列中的所有微任务都会被处理。所有微任务会在下一次渲染之前执行完成，因为它们的目标是在渲染前更新应用程序状态。 如果要达到每秒60帧（60 fps）的速度，理想情况下，单个任务和该任务附属的所有微任务，都应在16ms内完成。 事件监测和添加任务是独立于事件循环的，尽管主线程仍在执行，仍然可以向队列添加任务。","text":"事件循环除了事件，还要保持浏览器执行的其他操作。这些操作被称为任务，并且分为两类：宏任务（或通常称为任务）和微任务。事件循环的实现至少应该含有一个用于宏任务的队列和至少一个用于微任务的队列。两种队列在同一时刻都只执行一个任务 事件循环基于两个基本原则：● 一次处理一个任务。● 一个任务开始后直到运行完成，不会被其他任务中断。 宏任务的例子很多，包括创建主文档对象、解析HTML、执行主线（或全局）JavaScript代码，更改当前URL以及各种事件，如页面加载、输入、网络事件和定时器事件。从浏览器的角度来看，宏任务代表一个个离散的、独立工作单元。运行完任务后，浏览器可以继续其他调度，如重新渲染页面的UI或执行垃圾回收。 而微任务是更小的任务。微任务更新应用程序的状态，但必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。微任务的案例包括promise回调函数、DOM发生变化等。微任务需要尽可能快地、通过异步方式执行，同时不能产生全新的微任务。微任务使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使应用程序的状态不连续。 注意处理宏任务和微任务队列之间的区别：单次循环迭代中，最多处理一个宏任务（其余的在队列中等待），而队列中的所有微任务都会被处理。所有微任务会在下一次渲染之前执行完成，因为它们的目标是在渲染前更新应用程序状态。 如果要达到每秒60帧（60 fps）的速度，理想情况下，单个任务和该任务附属的所有微任务，都应在16ms内完成。 事件监测和添加任务是独立于事件循环的，尽管主线程仍在执行，仍然可以向队列添加任务。 请注意事件处理函数的发生频率以及执行耗时。例如，处理鼠标移动（mouse-move）事件时应当特别小心。因为移动鼠标将导致大量的事件进入队列，因此在鼠标移动的处理函数中执行任何复杂操作都可能导致Web应用的糟糕体验。 setTimeout和setInterval当JavaScript忙于执行时，在浏览器上的用户交互会变得迟钝，甚至无响应。由于当JavaScript执行时，重新渲染页面的更新都被暂停，浏览器将会卡顿，看起来似乎处于假死状态。 计时器能够有效地中止一段JavaScript的执行，直到一段时间之后，还可以把代码的各个部分分解成片段，这些片段的执行消耗时间不足以导致浏览器挂起。 这些方法都是挂载在window对象（全局上下文）的方法。与事件循环类型不同，这些方法不是JavaScript本身定义的，而是由宿主环境提供的（如浏览器或Node.js） 如果队列中已经存在一个间隔计时器，那么就不会创建一个新的间隔计时器。 计时器提供一种异步延迟执行代码片段的能力，至少要延迟指定的毫秒数。因为JavaScript单线程的本质，我们只能控制计时器何时被加入队列中，而无法控制何时执行。 事件代理DOM是元素的分层树，发生在一个元素（target）上的事件通常是通过DOM进行代理的，有以下两种机制。1．捕获——首先被顶部元素捕获，并依次向下传递。2．冒泡——事件首先通过捕获，从顶部元素传递到目标元素。当到达目标元素时，激活冒泡模式，从目标元素传回到顶部元素。 可以向addEventListener传递参数，很容易地选择希望的事件处理顺序。第3个参数如果传入true，将采用事件捕获；如果传入false，则采用事件冒泡。因此，某种意义上来说，W3C标准更倾向于优先选择事件冒泡，默认是事件冒泡。 首先从上到下进行捕获，如果遇到捕获模式的元素就执行事件。接着向下捕获直到底部元素，然后转为冒泡模式，从底部到顶部依次处理 this关键字指向的是事件处理器注册的元素，不一定是发生事件的元素。 通过事件代理，我们必须确保代理的元素是目标元素的祖先元素。这样，我们可以确定单击事件最终会冒泡到事件代理注册的元素上。 比如，我们要为一个被激活的表格添加样式，可以创建唯一的处理器，注册到比单元格更高层级的元素上，通过冒泡可以处理所有的单元格单击事件。我们知道单元格是表格的后代元素，通过event.target即可获得被单击的元素。this指向注册的祖先元素 通过内置的CustomEvent构造函数和dispatchEvent方法，创建和分发自定义事件，减少应用程序不同部分之间的耦合。 如加载动画时实现：","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://vergessenwang.github.io/tags/JS/"}]},{"title":"JS进阶：闭包和作用域","slug":"JS进阶：闭包和作用域","date":"2020-06-16T15:20:14.000Z","updated":"2020-06-16T15:22:45.144Z","comments":true,"path":"posts/frontend/2020-06-16-JS进阶：闭包和作用域.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-06-16-JS进阶：闭包和作用域.html","excerpt":"首先我们来看一个常见的问题 为什么用let声明的时候，显示的是1,2,3,4；而用var声明的时候就显示5,5,5,5呢？ 这其中涉及到两个问题：1.var和let的作用域 2. setTimeout的异步 今天先解决第一个问题。","text":"首先我们来看一个常见的问题 为什么用let声明的时候，显示的是1,2,3,4；而用var声明的时候就显示5,5,5,5呢？ 这其中涉及到两个问题：1.var和let的作用域 2. setTimeout的异步 今天先解决第一个问题。 学习自：JS忍者秘籍 原生JavaScript不支持私有变量。但是，通过使用闭包，我们可以实现很接近的、可接受的私有变量。闭包内部的变量可以通过闭包内的方法访问，构造器外部的代码则不能访问闭包内部的变量。 一句话理解闭包：内部的嵌套函数可以访问到外部函数的变量，即使这个外部函数已经执行完毕退出了。 当在外部函数中声明内部函数时，不仅定义了函数的声明，而且还创建了一个闭包。该闭包不仅包含了函数的声明，还包含了在函数声明时该作用域中的所有变量。当最终执行内部函数时，尽管声明时的作用域已经消失了，但是通过闭包，仍然能够访问到原始作用域。闭包不是在创建的那一时刻的状态的快照，而是一个真实的状态封装，只要闭包存在，就可以对变量进行修改。 谨记每一个通过闭包访问变量的函数都具有一个作用域链，作用域链包含闭包的全部信息使用闭包时，所有的信息都会存储在内存中，直到JavaScript引擎确保这些信息不再使用（可以安全地进行垃圾回收）或页面卸载时，才会清理这些信息。只要至少有一个通过闭包访问这些变量的函数存在，这个环境就会一直保持。 JavaScript引擎执行代码时，每一条语句都处于特定的执行上下文中。有两种执行上下文：全局执行上下文和函数执行上下文。二者最重要的差别是：全局执行上下文只有一个，当JavaScript程序开始执行时就已经创建了全局上下文；而函数执行上下文是在每次调用函数时，就会创建一个新的。 注意区分函数上下文（this）和执行上下文（调用栈） 一旦发生函数调用，当前的执行上下文必须停止执行，并创建新的函数执行上下文来执行函数。当函数执行完成后，将函数执行上下文销毁，并重新回到发生调用时的执行上下文中。 词法环境（lexical environment）是JavaScript引擎内部用来跟踪标识符与特定变量之间的映射关系。通常称为作用域(scopes)。 无论何时调用函数，都会创建一个新的执行环境，被推入执行上下文栈。此外，还会创建一个与之相关联的词法环境，词法环境通常用于保持跟踪函数中定义的变量。并存储在名为[[Environment]]的内部属性上（也就是说无法直接访问或操作）。JavaScript引擎将调用函数的内置[[Environment]]属性与创建函数时的环境进行关联。 在作用域范围内，每次执行代码时，代码结构都获得与之关联的词法环境。内部代码结构可以访问外部代码结构中定义的变量。如果在当前环境中无法找到某一标识符，就会对外部环境进行查找。 var、let与constconst静态变量在声明时需要写初始值，一旦声明完成之后，其值就无法更改。对于对象类型而言，我们不能将一个全新的对象赋值给const变量。但是，我们可以修改const变量已有的对象。如给已有对象添加属性，给数组push新值 当使用关键字var时，该变量是在距离最近的函数内部或是在全局词法环境中定义的。（注意：忽略块级作用域） 变量forMessage与i虽然是被包含在for循环中，但实际是在reportActivity环境中注册的 当使用let与const声明变量时，变量是在距离最近的环境中定义的。 注册标识符的过程 对于所找到的函数声明，将创建函数，并绑定到当前环境与函数名相同的标识符上。若该标识符已经存在，那么该标识符的值将被重写。 因此我们可以直接使用函数的引用，而不需要强制指定函数的定义顺序。 需要注意的是，这种情况仅针对函数声明有效。函数表达式与箭头函数都不在此过程中，而是在程序执行过程中执行定义的。 变量提升。例如，变量的声明提升至函数顶部，函数的声明提升至全局代码顶部。变量和函数的声明并没有实际发生移动。只是在代码执行之前，先在词法环境中进行注册。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://vergessenwang.github.io/tags/JS/"}]},{"title":"JS进阶：函数","slug":"JS进阶：函数","date":"2020-06-15T13:49:15.000Z","updated":"2020-06-15T13:54:46.937Z","comments":true,"path":"posts/frontend/2020-06-15-JS进阶：函数.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-06-15-JS进阶：函数.html","excerpt":"学习自：JS忍者秘籍 推荐Mozilla的HTML5指南，可通过https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5查看。 Mozilla也为DOM提供了一份报告，可以通过https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model进行查看。 Web应用的生命周期 页面构建每当解析到脚本元素时，浏览器就会停止从HTML构建DOM，并开始执行JavaScript代码。JavaScript代码由浏览器的JavaScript引擎执行，例如，Firefox的Spidermonkey引擎，Chrome和Opera和V8引擎和Edge的（IE的）Chakra引擎。 浏览器暴露给JavaScript引擎的主要全局对象是window对象，它代表了包含着一个页面的窗口。全局window对象会存在于整个页面的生存期之间，在它上面存储着所有的JavaScript变量。所以所有在某个JavaScript代码执行期间用户创建的全局变量都能正常地被其他脚本元素中的JavaScript代码所访问到。 下面两个步骤都会一直交替执行。1．将HTML构建为DOM。2．执行JavaScript代码。 最后，当浏览器处理完所有HTML元素后，页面构建阶段就结束了。随后浏览器就会进入应用生命周期的第二部分：事件处理。","text":"学习自：JS忍者秘籍 推荐Mozilla的HTML5指南，可通过https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5查看。 Mozilla也为DOM提供了一份报告，可以通过https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model进行查看。 Web应用的生命周期 页面构建每当解析到脚本元素时，浏览器就会停止从HTML构建DOM，并开始执行JavaScript代码。JavaScript代码由浏览器的JavaScript引擎执行，例如，Firefox的Spidermonkey引擎，Chrome和Opera和V8引擎和Edge的（IE的）Chakra引擎。 浏览器暴露给JavaScript引擎的主要全局对象是window对象，它代表了包含着一个页面的窗口。全局window对象会存在于整个页面的生存期之间，在它上面存储着所有的JavaScript变量。所以所有在某个JavaScript代码执行期间用户创建的全局变量都能正常地被其他脚本元素中的JavaScript代码所访问到。 下面两个步骤都会一直交替执行。1．将HTML构建为DOM。2．执行JavaScript代码。 最后，当浏览器处理完所有HTML元素后，页面构建阶段就结束了。随后浏览器就会进入应用生命周期的第二部分：事件处理。 事件处理浏览器执行环境的核心思想基于：同一时刻只能执行一个代码片段，即所谓的单线程执行模型。所以，浏览器需要一种方式来跟踪已经发生但尚未处理的事件。为实现这个目标，浏览器使用了事件队列 事件是异步的，如下类型的事件会在其他类型事件中发生。● 浏览器事件，例如当页面加载完成后或无法加载时；● 网络事件，例如来自服务器的响应（Ajax事件和服务器端事件）；● 用户事件，例如鼠标单击、鼠标移动和键盘事件；● 计时器事件，当timeout时间到期或又触发了一次时间间隔。 事件处理器是当某个特定事件发生后我们希望执行的函数。有两种方式注册事件。 ● 通过把函数赋给某个特殊属性；window.onload = function（ ）{};通过这种方式，事件处理器就会注册到load事件上（当DOM已经就绪并全部构建完成，就会触发这个事件）。这种做法会带来缺点：对于某个事件只能注册一个事件处理器。也就是说，一不小心就会将上一个事件处理器改写掉。 ● 通过使用内置addEventListener方法。让我们能够注册尽可能多的事件 函数JavaScript中最关键的概念是：函数是第一类对象（first-class objects），或者说它们被称作一等公民（first-class citizens）。JavaScript中函数拥有对象的所有能力，也因此函数可被作为任意其他类型对象来对待。 如具有动态创建和分配的属性。 回调函数第一类对象的特点之一是，它能够作为参数传入函数。对于函数而言，这项特性也表明：如果我们将某个函数作为参数传入另一个函数，传入函数会在应用程序执行的未来某个时间点才执行。大家所知道的更一般的概念是回调函数（callback function）。 更通俗的理解是被其他函数在稍后的某个合适时间点“再回来调用”。 123var values = [0, 3, 2, 5, 7, 4, 8, 1];values.sort(function(value1, value2) &#123; return value1- value2; &#125;); 匿名函数的好处：当一个函数不会在代码的多处位置被调用时，该特性可以避免用非必须的名字污染全局命名空间。 函数声明和函数表达式 最后4个表达式都是立即调用函数。首先创建了一个函数，然后立即调用这个新创建的函数。这种函数叫作立即调用函数表达式（IIFE） 函数声明和函数表达式除了在代码中的位置不同以外，还有一个更重要的不同点是：对于函数声明来说，函数名是强制性的，而对于函数表达式来说，函数名则完全是可选的。函数声明必须具有函数名是因为它们是独立语句。一个函数的基本要求是它应该能够被调用，所以它必须具有一种被引用方式，于是唯一的方式就是通过它的名字。 箭头函数箭头函数是JavaScript标准中的ES6新增项 形参和实参如果实参的数量大于形参，那么额外的实参不会赋值给任何形参。反之，如果形参的数量大于实参，那么那些没有对应实参的形参则会被设为undefined。 剩余参数和默认参数都已被加入ES6标准。 为函数的最后一个命名参数前加上省略号（…）前缀，这个参数就变成了一个叫作剩余参数的数组，数组内包含着传入的剩余的参数。 只有函数的最后一个参数才能是剩余参数。试图把省略号放在不是最后一个形参的任意形参之前都会报错，错误以SyntaxError: parameter after rest parameter的形式展现。 JavaScript不支持函数重载，对于参数不足的情况，可以用创建默认参数的方式为函数的形参赋值。 可以为默认参数赋任何值，它既可以是数字或者字符串这样的原始类型，也可以是对象、数组，甚至函数这样的复杂类型。每次函数调用时都会从左到右求得参数的值，并且当对后面的默认参数赋值时可以引用前面的默认参数，但是会降低可读性。 适当地使用默认参数——避免空值，或作为配置函数的简单标记能够带来简洁优雅的代码。 隐式函数参数this和arguments参数this表示被调用函数的上下文对象，而arguments参数表示函数调用过程中传递的所有参数。两者会被静默地传递给函数，并且可以像函数体内显式声明的参数一样被正常访问。 arguments对象有一个名为length的属性，表示实参的确切个数。通过数组索引的方式可以获取单个参数的值。但它并非JavaScript数组，如果你尝试在arguments对象上使用数组的方法，会发现最终会报错。arguments对象仅是一个类数组的结构。而剩余参数是真正的Array实例 arguments对象可作为函数参数的别名。如果为arguments[0]赋一个新值，那么，同时也会改变第一个参数的值。将arguments对象作为函数参数的别名使用时会影响代码的可读性，因此在JavaScript提供的严格模式（strict mode）中将无法再使用它。 this参数的指向不仅是由定义函数的方式和位置决定的，同时还严重受到函数调用方式的影响。 函数的调用方式影响this的取值。 如果作为函数调用，在非严格模式下，this指向全局window对象；在严格模式下，this指向undefined。 作为方法调用，this通常指向调用的对象。 作为构造函数调用，this指向新创建的对象。 通过call或apply调用，this指向call或apply的第一个参数。● 箭头函数没有单独的this值，this在箭头函数创建时确定。● 所有函数均可使用bind方法，创建新函数，并绑定到bind方法传入的参数上。被绑定的函数与原始函数具有一致的行为。 可以通过4种方式调用一个函数： ● 作为一个函数(function)直接被调用。当以这种方式调用时，函数上下文（this关键字的值）有两种可能性：在非严格模式下，它将是全局上下文（window对象），而在严格模式下，它将是undefined。 ● 作为一个方法(method)关联在一个对象上，实现面向对象编程。当函数作为某个对象的方法被调用时，该对象会成为函数的上下文，并且在函数内部可以通过参数访问到。这样你就可以通过this在任何方法中引用该方法的“宿主”对象 通过this返回的函数上下文取决于whatsMyContext的调用方式。 ● 作为一个构造函数(constructor)new实例化一个新的对象。 不要把函数的构造器和构造函数混为一谈。new Function(&#39;a&#39;, &#39;b&#39;, &#39;return a+b&#39;)函数的构造器将动态创建的字符串创建为函数。构造函数是我们用来创建和初始化对象实例的函数。 使用关键字new调用函数会触发以下几个动作。1．创建一个新的空对象。2．该对象作为this参数传递给构造函数，从而成为构造函数的函数上下文。3．新构造的对象作为new运算符的返回值。 当构造函数自身有返回值时会是什么结果？● 如果构造函数返回一个对象，则该对象将作为整个表达式的值返回，而传入构造函数的this将被丢弃。● 但是，如果构造函数返回的是非对象类型，则忽略返回值，返回新创建的对象。 解决函数上下问题● 通过函数的apply或者call方法 浏览器的事件处理系统将把调用的上下文定义为事件触发的目标元素，因此常会产生一些问题。 使用apply和call方法可以显式地指定任何对象作为函数的上下文。 使用apply方法调用函数，需要为其传递两个参数：作为函数上下文的对象和一个数组作为函数调用的参数。call方法的使用方式类似，不同点在于是直接以参数列表的形式，而不再是作为数组传递。apply和call之间唯一的不同之处在于如何传递参数如果有一组无关的值，则直接使用call方法。若已有参数是数组类型，apply方法是更佳选择。 在执行回调函数时可能会经常用到。 forEach遍历函数将每个元素传给回调函数，将当前元素作为回调函数的上下文。 使用call方法调用回调函数，将当前遍历到的元素作为第一个参数，循环索引作为第二个参数，使得当前元素作为函数上下文，循环索引作为回调函数的参数。 使用箭头函数绕过函数上下文。箭头函数没有单独的this值。箭头函数的this与声明所在的上下文的相同。 箭头函数在构造函数内部，this指向新创建的对象本身。在全局代码中定义对象字面量，在字面量中定义箭头函数，那么箭头函数内的this指向全局window对象 函数还可访问bind方法创建新函数。无论使用哪种方法调用，bind方法创建的新函数与原始函数的函数体相同，新函数被绑定到指定的对象上。 所有函数均可访问bind方法，可以创建并返回一个新函数，并绑定在传入的对象上","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://vergessenwang.github.io/tags/JS/"}]},{"title":"AJAX通信:XHR&JSONP","slug":"AJAX通信-XHR-JSONP","date":"2020-06-11T15:51:09.000Z","updated":"2020-06-11T15:54:49.171Z","comments":true,"path":"posts/frontend/2020-06-11-AJAX通信-XHR-JSONP.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-06-11-AJAX通信-XHR-JSONP.html","excerpt":"部分内容学习自：Javascript权威指南 XHRAjax的全称是Asynchronous JavaScript And XML，即异步JavaScript和XML。Ajax通过在浏览器和服务器之间添加Ajax中间层，允许浏览器异步发送请求，同时允许动态加载服务器响应。 用户在浏览页面的同时可以发送请求，浏览器无须频繁地重新加载新页面，服务器的响应不再是整个页面内容，而只是必须更新的部分数据。Ajax 可以减轻服务器和带宽的负担，提供更好的服务响应。 Ajax应用的主要特点是使用脚本操纵HTTP和Web服务器进行数据交换，不会导致页面重载。避免页面重载（这是Web初期的标准做法）的能力使Web应用感觉更像传统的桌面应用。Web应用可以使用Ajax技术把用户的交互数据记录到服务器中；也可以开始只显示简单页面，之后按需加载额外的数据和页面组件来提升应用的启动时间。 浏览器通过 JavaScript 代码向服务器发送请求，JavaScript 代码负责解析服务器的响应数据，并把样式表加到数据上，然后在现有网页中显示出来。 XML是Ajax的核心技术吗？以JSON作为数据交换格式不仅更加简单，而且网络传输的数据量更小，因此JSON逐渐取代了Ajax技术中XML的地位。 Ajax使用JavaScript来回传送数据，XMLHttpRequest是Ajax的核心。浏览器在XMLHttpRequest类上定义了它们的HTTP API。这个类的每个实例都表示一个独立的请求/响应对，并且这个对象的属性和方法允许指定请求细节和提取响应数据。 XMLHttpRequest不是协议级的HTTP API而是浏览器级的API。浏览器需要考虑cookie、重定向、缓存和代理，但代码只需要担心请求和响应。 JavaScript主要完成如下事情： 创建XMLHttpRequest对象。通过XMLHttpRequest向服务器发送请求。 创建回调函数，监视服务器响应状态，在服务器响应完成后，回调函数启动。 回调函数通过DOM动态更新HTML页面。 官方API","text":"部分内容学习自：Javascript权威指南 XHRAjax的全称是Asynchronous JavaScript And XML，即异步JavaScript和XML。Ajax通过在浏览器和服务器之间添加Ajax中间层，允许浏览器异步发送请求，同时允许动态加载服务器响应。 用户在浏览页面的同时可以发送请求，浏览器无须频繁地重新加载新页面，服务器的响应不再是整个页面内容，而只是必须更新的部分数据。Ajax 可以减轻服务器和带宽的负担，提供更好的服务响应。 Ajax应用的主要特点是使用脚本操纵HTTP和Web服务器进行数据交换，不会导致页面重载。避免页面重载（这是Web初期的标准做法）的能力使Web应用感觉更像传统的桌面应用。Web应用可以使用Ajax技术把用户的交互数据记录到服务器中；也可以开始只显示简单页面，之后按需加载额外的数据和页面组件来提升应用的启动时间。 浏览器通过 JavaScript 代码向服务器发送请求，JavaScript 代码负责解析服务器的响应数据，并把样式表加到数据上，然后在现有网页中显示出来。 XML是Ajax的核心技术吗？以JSON作为数据交换格式不仅更加简单，而且网络传输的数据量更小，因此JSON逐渐取代了Ajax技术中XML的地位。 Ajax使用JavaScript来回传送数据，XMLHttpRequest是Ajax的核心。浏览器在XMLHttpRequest类上定义了它们的HTTP API。这个类的每个实例都表示一个独立的请求/响应对，并且这个对象的属性和方法允许指定请求细节和提取响应数据。 XMLHttpRequest不是协议级的HTTP API而是浏览器级的API。浏览器需要考虑cookie、重定向、缓存和代理，但代码只需要担心请求和响应。 JavaScript主要完成如下事情： 创建XMLHttpRequest对象。通过XMLHttpRequest向服务器发送请求。 创建回调函数，监视服务器响应状态，在服务器响应完成后，回调函数启动。 回调函数通过DOM动态更新HTML页面。 官方API 请求设置12345678function reqListener () &#123; console.log(this.responseText);&#125;var oReq = new XMLHttpRequest();oReq.addEventListener(&quot;load&quot;, reqListener);oReq.open(&quot;GET&quot;, &quot;http://www.example.org/example.txt&quot;);oReq.send(); open（）open（）的第一个参数指定HTTP方法或动作。这个字符串不区分大小写，但通常大家用大写字母来匹配HTTP协议。“GET”和“POST”方法是得到广泛支持的。“GET”用于常规请求，它适用于当URL完全指定请求资源，当请求对服务器没有任何副作用以及当服务器的响应是可缓存时。“POST”方法常用于HTML表单。它在请求主体中包含额外数据（表单数据）且这些数据常存储到服务器上的数据库中（副作用）。相同URL的重复POST请求从服务器得到的响应可能不同，同时不应该缓存使用这个方法的请求。当提交表单的目标仅仅是一个只读查询，GET比POST更合适。 除了“GET”和“POST”之外，XMLHttpRequest规范也允许把“DELETE”、“HEAD”、“OPTIONS”和“PUT”作为o p e n（）的第1个参数。（“CONNECT”、“TRACE”和“TRACK”因为安全风险已被明确禁止。） open（）的第2个参数是URL，它是请求的主题。这是相对于文档的URL，这个文档包含调用open（）的脚本。如果指定绝对URL、协议、主机和端口通常必须匹配所在文档的对应内容：跨域的请求通常会报错。 通过 XMLHttpRequest 生成的请求可以有两种方式来获取数据，异步模式或同步模式。请求的类型是由这个 XMLHttpRequest 对象的 open() 方法的第三个参数async的值决定的。如果该参数的值为 false，则该 XMLHttpRequest请求以同步模式进行，否则该过程将以异步模式完成。 如果请求一个受密码保护的URL，把用户名和密码作为第4个和第5个参数传递给open（） setRequestHeader（）用post方法常需要设置头部信息，如 request.setRequestHeader（&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;）; 以下首部无法自定义，有些是浏览器自动处理的，有些是为了防止伪造。 如果对相同的头调用setRequestHeader（）多次，新值不会取代之前指定的值，相反，HTTP请求将包含这个头的多个副本或这个头将指定多个值。 send（）GET请求绝对没有主体，所以应该传递null或省略这个参数。POST请求通常拥有主体，同时它应该匹配使用setRequestHeader（）指定的“Content-Type”头。 对于混合格式，XHR2定义了新的FormData API，它容易实现多部分请求主体。首先，使用FormData（）构造函数创建FormData对象，然后按需多次调用这个对象的append（）方法把个体“部分”（可以是字符串、File或Blob对象）添加到请求中。最后，把FormData对象传递给send（）方法。send（）方法将对请求定义合适的边界字符串和设置“Content-Type”头。 响应获取为了在响应准备就绪时得到通知，必须监听XMLHttpRequest对象上的readystatechange事件。每次readyState属性改变都会触发readystatechange事件。readyState值： 为了监听readystatechange事件，请把事件处理函数设置为XMLHttpRequest对象的onreadystatechange属性。也能使用addEventListener（） 以下内容要会手写 XMLHttpRequest也支持同步响应。如果把false作为第3个参数传递给open（），那么send（）方法将阻塞直到请求完成。在这种情况下，不需要使用事件处理程序：一旦send（）返回，仅需要检查XMLHttpRequest对象的status和responseText属性。 使用getResponseHeader（）和getAllResponseHeaders（）能查询响应头。 status和statusText属性以数字和文本的形式返回HTTP状态码。 响应主体可以从responseText属性中得到文本形式的，从responseXML属性中得到Document形式的。对象或数组这样的结构化数据作为其响应，应该传输JSON编码，可以把responseText属性传递给JSON.parse（） JSON.parse()【从一个字符串中解析出json对象】JSON.stringify()【从一个对象中解析出字符串】 abort（）调用abort（）的主要原因是完成取消或超时请求消耗的时间太长或当响应变得无关时。假设使用XMLHttpRequest为文本输入域请求自动完成推荐。如果用户在服务器的建议达到之前输入了新字符，这时等待请求不再有趣，应该中止。 jsonp策略通过 XHR 实现 Ajax 通信的一个主要限制，来源于跨域安全策略。默认情况下，XHR 对象只能访 问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。 CORS（Cross-Origin Resource Sharing，跨源资源共享）是 W3C 的一个工作草案，定义了在必须访 问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部 让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 比如一个简单的使用 GET 或 POST 发送的请求，它没有自定义的头部，而主体内容是 text/plain。在 发送该请求时，需要给它附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端 口），以便服务器根据这个头部信息来决定是否给予响应。 下面是 Origin 头部的一个示例： Origin: http://www.nczonline.net 如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源 信息（如果是公共资源，可以回发”*”）。例如： Access-Control-Allow-Origin: http://www.nczonline.net 如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器 会处理请求。注意，请求和响应都不包含 cookie 信息。 因为同源策略，浏览器不允许原始脚本查找跨域文档的内容。使用XMLHttpRequest，文档内容都是通过responseText属性暴露，所以同源策略不允许XMLHttpRequest进行跨域请求。 有一些安全细节需要了解。首先，如果给XMLHttpRequest的open（）方法传入用户名和密码，那么它们绝对不会通过跨域请求发送（这使分布式密码破解攻击成为可能）。除外，跨域请求通常也不会包含其他任何的用户证书：cookie和HTTP身份验证令牌（token）通常不会作为请求的内容部分发送且任何作为跨域响应来接收的cookie都会丢弃。如果跨域请求需要这几种凭证才能成功，那么必须在用send（）发送请求前设置XMLHttpRequest的withCredentials属性为true。这样做不常见，但测试withCredentials的存在性是测试浏览器是否支持CORS的一种方法。 XMLHttpRequest只是AJAX的一种实现方法。 &lt;script&gt;元素并未真正受限于同源策略：它加载并执行任何来源的脚本。使得&lt;script&gt;元素成为取代XMLHttpRequest的主流Ajax传输协议。 只须设置&lt;script&gt;元素的src属性（假如它还没插入到document中，需要插入进去），插入操作触发HTTP请求以下载src属性所指向的URL。使用基于&lt;script&gt;的Ajax传输协议时，服务器的响应采用JSON编码的数据格式，当执行脚本时，JavaScript解析器能自动将其“解码”。由于它使用JSON数据格式，因此这种Ajax传输协议也叫做“JSONP”。 P代表“填充”或“前缀”，追加“?json”（或&amp;json） 保证返回一个JSONP响应 为了使用&lt;script&gt;元素进行Ajax传输，必须允许Web页面可以执行远程服务器发送过来的任何JavaScript代码。这意味着对于不可信的服务器，不应该采取该技术","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://vergessenwang.github.io/tags/AJAX/"},{"name":"CROS","slug":"CROS","permalink":"http://vergessenwang.github.io/tags/CROS/"}]},{"title":"CSS练习：渐变风格登录界面","slug":"CSS练习：渐变风格登录界面","date":"2020-06-10T15:33:49.000Z","updated":"2020-06-10T15:34:29.806Z","comments":true,"path":"posts/frontend/2020-06-10-CSS练习：渐变风格登录界面.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-06-10-CSS练习：渐变风格登录界面.html","excerpt":"","text":"学习自视频 效果： 主要学到的知识点： 配色的重要性 background-image: linear-gradient(to bottom right,rgb(114,135,254),rgb(130,88,186)); 线性渐变颜色对比 margin: 0 auto; login 主体内容自动居中 box-shadow: 0 10px 50px 0px rgb(59,45,159); 阴影方向与渐变的一致性 border-top-left-radius: 15px; 圆角 display: inline-block; 行内布局 border-bottom: 3px solid rgb(237,221,22); 重要内容加下边框突出 outline: 0; input 去除轮廓线 hover + transition 实现颜色变化 ::-webkit-input-placeholder {color: rgb(199,191,219);} 专门用于占位符的颜色设置 height: calc(100% - 120px); 计算出的高度 一个BUG： ​ 发送框不知道为什么会跑到上面去了… 回头再好好看一下position: relative;和position: absolute;","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://vergessenwang.github.io/tags/CSS/"}]},{"title":"HTTP:报文，缓存，Cookie与HTTPS","slug":"HTTP-报文，缓存，Cookie与HTTPS","date":"2020-06-10T15:20:05.000Z","updated":"2020-06-10T15:31:24.465Z","comments":true,"path":"posts/network/2020-06-10-HTTP-报文，缓存，Cookie与HTTPS.html","link":"","permalink":"http://vergessenwang.github.io/posts/network/2020-06-10-HTTP-报文，缓存，Cookie与HTTPS.html","excerpt":"笔记学习自：图解HTTP 当年HTTP协议的出现主要是为了解决文本传输的难题。1997年1月公布的HTTP/1.1是目前主流的HTTP协议版本。 HTTP方法GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。 POST方法用来传输实体的主体。 get和post区别:get是以实体的方式得到由请求 URI 所指定资源的信息。post方式: 用来向服务器发出请求，要求它接收被附在请求后的实体，并把它请求 URI 所指定资源的附加新子项，所以 post 请求可能会导致新的资源的建立和 / 或已有资源的修改。 PUT方法用来传输文件。在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。鉴于HTTP/1.1的PUT方法自身不带验证机制，一般的Web网站不使用该方法。 DELETE方法用来删除文件，是与PUT相反的方法。 HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。使用GET方法时，对应请求资源的实体会作为响应返回；而使用HEAD方法时，对应请求资源的实体主体不随报文首部作为响应返回 OPTIONS方法用来查询针对请求URI指定的资源支持的方法。如： TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200 OK的响应。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。 CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。","text":"笔记学习自：图解HTTP 当年HTTP协议的出现主要是为了解决文本传输的难题。1997年1月公布的HTTP/1.1是目前主流的HTTP协议版本。 HTTP方法GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。 POST方法用来传输实体的主体。 get和post区别:get是以实体的方式得到由请求 URI 所指定资源的信息。post方式: 用来向服务器发出请求，要求它接收被附在请求后的实体，并把它请求 URI 所指定资源的附加新子项，所以 post 请求可能会导致新的资源的建立和 / 或已有资源的修改。 PUT方法用来传输文件。在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。鉴于HTTP/1.1的PUT方法自身不带验证机制，一般的Web网站不使用该方法。 DELETE方法用来删除文件，是与PUT相反的方法。 HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。使用GET方法时，对应请求资源的实体会作为响应返回；而使用HEAD方法时，对应请求资源的实体主体不随报文首部作为响应返回 OPTIONS方法用来查询针对请求URI指定的资源支持的方法。如： TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码200 OK的响应。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。 CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 HTTP报文实体（entity）作为请求或响应的有效载荷数据（补充项）被传输。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。 常用的内容编码有以下几种。●gzip（GNU zip）●compress（UNIX系统的标准压缩）●deflate（zlib）●identity（不进行编码） 断点重传：从之前下载中断处恢复下载。要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。执行范围请求时，会用到首部字段Range来指定资源的byte范围。针对范围请求，响应会返回状态码为206 Partial Content的响应报文。如果服务器端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。 内容协商：指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。●Accept-Charset●Accept-Encoding●Accept-Language●Content-Language 通用首部字段 首部字段Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。使用首部字段Upgrade时，还需要额外指定Connection:Upgrade。对于附有首部字段Upgrade的请求，服务器可用101 Switching Protocols状态码作为响应返回。 如为了实现WebSocket通信，在HTTP连接建立之后，需要完成一次“握手”（Handshaking）的步骤 使用首部字段Via是为了追踪客户端与服务器之间的请求和响应报文的传输路径。报文经过代理或网关时，会先在首部字段Via中附加该服务器的信息，然后再进行转发。 请求首部字段 Accept: text/html,application/xhtml+xml,application/xml;q=0.9使用q=来额外表示权重值，当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。 首部字段Authorization是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的401状态码响应后，把首部字段Authorization加入请求中。 Host首部字段在HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段。 在GET或HEAD方法中使用首部字段If-None-Match可获取最新的资源。 通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。 首部字段User-Agent会将创建请求的浏览器和用户代理名称等信息传达给服务器。 响应首部字段 首部字段ETag能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的ETag值。另外，当资源更新时，ETag值也需要更新。 强ETag值，不论实体发生多么细微的变化都会改变其值。 弱ETag值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变ETag值。这时，会在字段值最开始处附加W/。 首部字段WWW-Authenticate用于HTTP访问认证。它会告知客户端适用于访问请求URI所指定资源的认证方案（Basic或是Digest）和带参数提示的质询（challenge）。状态码401 Unauthorized响应中，肯定带有首部字段WWW-Authenticate。 实体首部字段 首部字段Allow用于通知客户端能够支持Request-URI指定资源的所有HTTP方法。当服务器接收到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回。与此同时，还会把所有能支持的HTTP方法写入首部字段Allow后返回。 状态码如200 OK，以3位数字和原因短语组成。 https://tool.lu/httpcode/ 这个网站还蛮有意思的 204 No Content服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。 206 Partial Content客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。 301 Moved Permanently永久性重定向。如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。 302 Found临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。 303 See Other由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。 当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。 304 Not Modified304虽然被划分在3XX类别中，但是和重定向没有关系。该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）。304状态码返回时，不包含任何响应的主体部分。附带条件的请求是指采用GET方法的请求报文中包含If-Match,If-Modified-Since,If-None-Match,If-Range,If-Unmodified-Since中任一首部。 307 Temporary Redirect临时重定向。该状态码与302 Found有着相同的含义。307会遵照浏览器标准，不会从POST变成GET。 400 Bad Reques该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。 401 Unauthorized该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。 403 Forbidden该状态码表明对请求资源的访问被服务器拒绝了。 500 Internal Server Error该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。 503 Service Unavailable该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。 缓存缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。 当判定缓存过期后，会向源服务器确认资源的有效性。 通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。 缓存请求指令 缓存响应指令 使用no-cache指令的目的是为了防止从缓存中返回过期的资源。 从字面意思上很容易把no-cache误解成为不缓存，但事实上no-cache代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为do-not-serve-from-cache-without-revalidation更合适。no-store才是真正地不进行缓存 当使用no-store指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。 当客户端发送的请求中包含max-age指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定max-age值为0，那么缓存服务器通常需要将请求转发给源服务器。当服务器返回的响应中包含max-age指令时，缓存服务器将不对资源的有效性再作确认，而max-age数值代表资源保存为缓存的最长时间。 min-fresh指令要求缓存服务器返回至少还未过指定时间的缓存资源。 使用max-stale可指示缓存资源，即使过期也照常接收。 使用only-if-cached指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码504 Gateway Timeout。 使用must-revalidate指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条504（Gateway Timeout）状态码。 使用no-transform指令可防止缓存或代理压缩图片等类似操作。 CookieHTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。每当有新的请求发送时，就会有对应的新响应产生。这是为了更快地处理大量事务，确保协议的可伸缩性。为了实现期望的保持状态功能，于是引入了Cookie技术。 Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed, =&gt; 10-Oct-12 07:12:20 GMT＞服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。Cookie: sid=1342077140226724 Set-Cookie的字段值 一旦Cookie从服务器端发送至客户端，服务器端就不存在可以显式删除Cookie的方法。但可通过覆盖已过期的Cookie，实现对客户端Cookie的实质性删除操作。 HttpOnly属性是Cookie的扩展功能，它使JavaScript脚本无法获得Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting,XSS）对Cookie的信息窃取。 Session管理基于表单认证本身是通过服务器端的Web应用，会使用Cookie来管理Session 步骤1： 客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方法把请求发送给服务器。而这时，会使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送。步骤2： 服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器端。向客户端返回响应时，会在首部字段Set-Cookie内写入Session ID（如PHPSESSID=028a8c…）。为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie内加上httponly属性。步骤3： 客户端接收到从服务器端发来的Session ID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID也随之发送到服务器。服务器端可通过验证接收到的Session ID识别用户和其认证状态。 HTTPSHTTP+加密+认证+完整性保护=HTTPS HTTP主要有这些不足，例举如下。●通信使用明文（不加密），内容可能会被窃听●不验证通信方的身份，因此有可能遭遇伪装，DoS攻击（Denial of Service，拒绝服务攻击）●无法证明报文的完整性，所以有可能已遭篡改，中间人攻击（Man-in-the-Middle attack,MITM） HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全传输层协议）的组合使用，加密HTTP的通信内容。 SSL位于表示层。 SSL采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。公开密钥加密使用一对非对称的密钥。 HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。 SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。 HTTPS的通信步骤 步骤1： 客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。步骤2： 服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。步骤3： 之后服务器发送Certificate报文。报文中包含公开密钥证书。步骤4： 最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。步骤5: SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密。步骤6： 接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。步骤7： 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。步骤8： 服务器同样发送Change Cipher Spec报文。步骤9： 服务器同样发送Finished报文。步骤10： 服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。步骤11： 应用层协议通信，即发送HTTP响应。步骤12： 最后由客户端断开连接。断开连接时，发送close_notify报文。 在以上流程中，应用层发送数据时会附加一种叫做MAC（Message Authentication Code）的报文摘要。MAC能够查知报文是否遭到篡改，从而保护报文的完整性。 既然HTTPS那么安全可靠，那为何所有的Web网站不一直使用HTTPS？ 使用HTTP相比，网络负载可能会变慢2到100倍 加密通信会消耗更多的CPU及内存资源 想要节约购买证书的开销","categories":[{"name":"network","slug":"network","permalink":"http://vergessenwang.github.io/categories/network/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://vergessenwang.github.io/tags/HTTP/"}]},{"title":"JavaScript基础","slug":"JavaScript基础","date":"2020-06-08T16:04:38.000Z","updated":"2020-06-08T16:08:22.019Z","comments":true,"path":"posts/frontend/2020-06-09-JavaScript基础.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-06-09-JavaScript基础.html","excerpt":"学习笔记源自：绿叶 对于CSS来说，外部CSS文件只能在head中引入。对于JavaScript来说，外部JavaScript文件不仅可以在head中引入，还可以在body中引入。引入外部CSS文件使用的是“link标签”，而引入外部JavaScript文件使用的是“script标签”。 基本语法变量变量由字母、下划线、$或数字组成，并且第一个字母必须是字母、下划线或$。区分大小写 变量不能是系统关键字和保留字。","text":"学习笔记源自：绿叶 对于CSS来说，外部CSS文件只能在head中引入。对于JavaScript来说，外部JavaScript文件不仅可以在head中引入，还可以在body中引入。引入外部CSS文件使用的是“link标签”，而引入外部JavaScript文件使用的是“script标签”。 基本语法变量变量由字母、下划线、$或数字组成，并且第一个字母必须是字母、下划线或$。区分大小写 变量不能是系统关键字和保留字。 所有JavaScript变量都由var声明。 常量名全部采用大写形式 数据类型基本数据类型有5种：数字、字符串、布尔值、未定义值和空值。常见的引用数据类型只有一种：对象（数组也是属于对象的一种）。 null跟undefined的区别？1234console.log(null==undefined); //true 因为两者都默认转换成了falseconsole.log(typeof undefined); //\"undefined\" console.log(typeof null); //\"object\" console.log(null===undefined); //false \"===\"表示绝对相等，null和undefined类型是不一样的，所以输出“false” null和undefined转换成number数据类型null 默认转成 0undefined 默认转成 NaN null表示”没有对象”，即该处不应该有值。典型用法是：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有被赋值。典型用法是（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有return返回值时，默认返回undefined。 显式类型转换将字符串转换为数字，有两种方式。Number（ ）。只能将纯“数字型字符串”转换为数字parseInt（ ）和parseFloat（ ）。提取“首字母为数字的任意字符串”中的数字，可以接受第1个字符是加号或减号。提取类似”100px”这种字符串中的数字，这个时候我们就应该使用parseInt（ ）和parseFloat（ ）如果数字是小数，则parseInt（ ）和parseFloat（ ）两个方法返回的结果是不一样的，我们可以利用这个特点，来判断一个数是整数，还是小数。 将数字转换为字符串，也有两种方式。与空字符串相加。 使用更多toString（ ）。 这些转换在一些跟数位有关的算法题中很常用。 内置对象常用的内置对象有4种。 字符串对象：String。 length属性来获取字符串的长度。 toLowerCase（ ）方法将大写字符串转化为小写字符串，toUpperCase（ ）方法将小写字符串转化为大写字符串。 charAt（ ）方法来获取字符串中的某一个字符。var char=str.charAt（i）; substring（ ）方法来截取字符串的某一部分。substring（start,end）的截取范围为“[start,end）”当end省略时，截取的范围为“start到结尾”。 replace（ ）方法来用一个字符串替换另外一个字符串的某一部分。replace（ ）方法有两种使用形式：一种是直接使用字符串来替换，另外一种是使用正则表达式来替换。正则只会替换第一个匹配的 split（ ）方法把一个字符串分割成一个数组，分割符可以是一个字符、多个字符或一个正则表达式。split（ ）方法有两个参数：第1个参数表示分割符，第2个参数表示获取“分割之后的前n个元素”。split（””）可以用来分割字符串的每一个字符。数组join（ ）方法一般都是配合字符串的split（ ）方法来使用的。 indexOf（ ）方法可以找出“某个指定字符串”在字符串中“首次出现”的下标位置 lastIndexOf（ ）方法可以找出“某个指定字符串”在字符串中“最后出现”的下标位置。如果字符串中不包含“指定字符串”,indexOf（ ）或lastIndexOf（ ）会返回-1。 两个字符之间比较的是ASCII码的大小 isNaN（ ）函数来判断一个值是否为NaN值。NaN，意为Not a Numer（非数字）。 数组对象：Array。 12var 数组名=new Array（元素1,元素2,……,元素n）; //完整形式var 数组名=[元素1,元素2,……,元素n]; //简写形式 length属性来获取数组的长度。 slice（ ）方法获取数组的某一部分。slice（start,end）的截取范围为[start,end） unshift（ ）方法在数组开头添加新元素 shift（ ）方法删除数组中的第一个元素 push（ ）方法在数组结尾添加新元素，不需要知道数组有多少个元素 pop（ ）方法删除数组的最后一个元素 sort（ ）方法对数组中的所有元素进行大小比较，可以将排序函数作为参数 reverse（ ）方法实现数组中所有元素的反向排列 join（ ）方法将数组中的所有元素连接成一个字符串。默认情况下，一般会采用英文逗号（,）作为连接符。str1.split（&quot;*&quot;）.join（&quot;#&quot;） 即可实现符号替换 数组是可以存储“不同数据类型”的数据的，只不过在实际开发中极少这样做。 日期对象：Date。创建一个日期对象，必须使用new关键字。其中Date对象的方法有很多，主要分为两大类：getXxx（ ）和setXxx（ ）。注意getMonth（ ）方法的返回值是0（一月）到11（十二月）之间的整数此外还要注意，要获取当前的“日”，不是使用getDay（ ），而是使用getDate（ ），getDay（ ）是用来获取星期几的，返回数字，有时需要用预设汉字数组转为汉字set比get能设置更多的信息 数值对象：Math。Math对象不需要使用new关键字来创造，而可以直接使用它的属性和方法。Math对象的属性都是常量120*Math.PI/180 //120°Math对象中的方法（常用）atan2（x）能够精确判断角度对应哪一个角，而atan（x）不能。大多数用的是atan2（x）random（ ）方法的范围是[0, 1） 例子：随机生成验证码 函数根据作用域，变量可以分为全局变量和局部变量。全局变量一般在主程序中定义，其有效范围是从定义开始，一直到整个程序结束。也就是全局变量在任何地方都可以使用。局部变量一般在函数中定义，其有效范围只限于在函数中。也就是局部变量只能在函数中使用，函数之外是不能使用函数中定义的变量的。 JavaScript代码是从上到下执行的，JavaScript遇到函数定义部分会直接跳过（忽略掉），只有遇到函数调用时才会返回执行函数定义部分。也就是说，函数定义之后只有被调用才有意义。 JavaScript的函数调用方式有很多，常见的有以下4种。 直接调用。 在表达式中调用。 在超链接中调用，指的是在a元素的href属性中用“javascript：函数名”的形式来调用函数。当用户点击超链接时，就会调用该函数。 在事件中调用。如鼠标移动，点击等 嵌套函数可以在一个函数的内部定义另外一个函数。但是在内部定义的函数只能在内部调用，如果在外部调用，就会出错。 嵌套函数的功能非常强大，并且跟JavaScript最重要的一个概念“闭包”有重要的关系。 一句话理解闭包：内部的嵌套函数可以访问到外部函数的变量，即使这个外部函数已经执行完毕退出了。 DOMDOM，全称是“Document Object Model（文档对象模型）”，它是由W3C定义的一个标准。 DOM采用的是“树形结构”，用“树节点”的形式来表示页面中的每一个元素。每一个元素就是一个节点，而每一个节点就是一个对象。也就是说，我们在操作元素时，其实就是把这个元素看成一个对象，然后使用这个对象的属性和方法来进行相关操作 节点和元素是不一样的概念，节点是包括元素的。DOM节点共有12种类型，但是常见的只有下面3种。元素节点。属性节点。文本节点。属性节点和文本节点看起来像是元素节点的一部分，但实际上，它们是独立的节点，并不属于元素节点。只有元素节点才可以拥有子节点，属性节点和文本节点都无法拥有子节点。 可以使用nodeType属性来判断一个节点的类型。 节点操作（元素节点）获取元素节点获取的是一个DOM对象，我们在给变量命名的时候，习惯性地以英文“o”开头 getElementById（ ）类似于CSS中的id选择器 getElementsByTagName（ ）类似于CSS中的“元素选择器”。获取的是一个“类数组”（也叫伪数组），只能使用数组的length属性以及下标 getElementsByClassName（ ）类似于CSS中的class选择器。 querySelector（ ）和querySelectorAll（ ）使用CSS选择器的语法来获取所需要的元素。前者获取第一个。实际上调用了CSS选择器，性能不太好 getElementsByName（ ）只用于表单元素，一般只用于单选按钮和复选框。document.title和document.body 一个页面只有一个title元素和一个body元素 注意element的单复数，如果是数组必须加索引才能访问到元素 getElementById（ ）前面只可以接document，也就是document.getElementById（ ）。getElementsByTagName（ ）前面不仅可以接document，还可以接其他DOM对象。getElementById（ ）和getElementsByClassName（ ）不可以操作动态创建的DOM元素，而getElementsByTagName（ ）可以操作动态创建的DOM元素。 创建元素使用createElement（ ）来创建一个元素节点，也可以使用createTextNode（ ）来创建一个文本节点，然后可以将元素节点与文本节点“组装”成我们平常看到的“有文本内容的元素”。这种方式又被称为“动态DOM操作”。所谓的“动态DOM”，指的是使用JavaScript创建的元素。这个元素一开始在HTML中是不存在的。 在操作动态DOM时，设置元素class用的是className而不是class，因为JavaScript有很多关键字和保留字，其中class已经作为保留字了 插入元素插入元素有以下两种方法。appendChild（ ）把一个新元素插入到父元素的内部子元素的“末尾”。insertBefore（ ）将一个新元素插入到父元素中的某一个子元素“之前”。A.insertBefore（B,ref）则表示在ref之前插入B。 这两种插入元素的方法都需要先获取父元素才可以操作。 删除元素使用removeChild（ ）方法来删除父元素下的某个子元素。如oUl.removeChild（oUl.lastElementChild）; 复制元素obj.cloneNode（bool）参数obj表示被复制的元素，而参数bool是一个布尔值，取值如下。1或true：表示复制元素本身以及复制该元素下的所有子元素。0或false：表示仅仅复制元素本身，不复制该元素下的子元素。 替换元素A.replaceChild（new,old）; 综上可知，要实现节点的各种操作，必须先找到父元素才行。 HTML属性操作（属性节点）使用对象属性使用obj.attr这种方式，不仅可以获取静态HTML元素的属性值，还可以获取动态创建的DOM元素中的属性值 要获取一个元素的class，写成oBtn.class是错误的，正确的写法是oBtn.className。 在实际开发中，在更多的情况下，我们要获取的是表单元素的值。其中文本框、单选按钮、复选框、下拉列表中的值，都是通过value属性来获取的。 使用对象方法关于操作HTML元素的属性，JavaScript为我们提供了4种方法。 getAttribute（ ） 注意参数要加引号，不仅可以用来获取静态HTML元素的属性值，还可以用来获取动态DOM元素中的属性值 setAttribute（ ） removeAttribute（ ）在更多情况下是结合class属性来“整体”控制元素的样式属性的 hasAttribute（ ）直接使用removeAttribute（ ）删除元素的属性的做法是不太正确的，比较严谨的做法是先用hasAttribute（ ）判断这个属性是否存在，只有存在，才去删除。 使用obj.attr（也就是对象属性方式）是无法获取自定义属性值的，只能用getAttribute（”attr”）（也就是对象方法方式）来实现。同样地，对于自定义属性的值的设置，我们也只能用setAttribute（ ）方法来实现。想要删除元素的某个属性，我们只能使用removeAttribute（ ）这一个方法。 记住：只有“对象方法方式”才可以操作自定义属性。 CSS属性操作获取CSS属性值getComputedStyle（obj）.attr需要注意的是，这里的属性名使用的是“骆驼峰型”的CSS属性名。如font-size应该写成fontSize getComputedStyle（ ）方法其实有两种写法：getComputedStyle（obj）.attr和getComputed Style（obj）[“attr”]。实际上，凡是对象的属性都有这两种写法。后者常用于通过get获得的字符串用于设置。 设置一个CSS属性的值，有两种方式可以实现。 style对象。obj.style.attr=&quot;值&quot;; 这种方式设置的是“行内样式” cssText属性。同时设置多个CSS属性，这也是在元素的style属性中添加的。cssText的值是一个字符串。注意，这个字符串中的属性名不再使用骆驼峰型的写法，而是使用平常的CSS写法因为变量中是不允许出现中划线的oDiv.style.cssText=&quot;width:100px;height:100px;border:1px solid gray;&quot;; 在实际开发的时候，如果要为一个元素同时设置多个CSS属性，我们很少使用cssText来实现，而更倾向于使用操作HTML属性的方式给元素加上一个class属性值，从而整体地给元素添加上样式。 获取CSS属性值，不可以用obj.style.attr或obj.style.cssText吗？为什么一定要用getComputedStyle（ ）呢？obj.style.attr只可以获取元素style属性中设置的CSS属性，对于内部样式或者外部样式，它是没办法获取的。getComputedStyle（ ），从名字上就可以看出来，意思是get computed style（获取计算后的样式）。所谓“计算后的样式”，是指不管是内部样式，还是行内样式，最终获取的是根据CSS优先级计算后的结果。 DOM遍历使用parentNode属性来获得某个元素的父元素。 使用以下两组方式来获得父元素中的所有子元素或某个子元素。childNodes、firstChild、lastChild。children、firstElementChild、lastElementChild。更常用 使用childNodes、firstChild、lastChild这几个方法来操作元素节点非常麻烦，因为它们都把文本节点（一般是空白节点）算进来了 使用以下2组方式来获得兄弟元素。previousSibling、nextSibling。previousElementSibling、nextElementSibling。 跟查找子元素的两组方式一样，previousSibling和nextSibling查找出来的可能是文本节点（一般是空白节点），因此如果只操作元素节点，建议使用previousElementSibling和nextElementSibling。 innerHTML和innerText使用innerHTML属性很方便地获取和设置一个元素的“内部元素”，也可以使用innerText属性获取和设置一个元素的“内部文本”。 innerHTML后面的字符串要换行只要在每一行后面加上个反斜杠（\\）就可以了 使用appedChild（ ）方法需要依次设置属性值。innerHTML属性可以直接很多属性。 document.write（ ）和innerHTML之间有什么区别？ write是DOM方法,向文档写入HTML表达式或Java代码，可列出多个参数，参数被顺序添加到文档中。innerHTML是DOM属性,设置或返回调用元素开始结束标签之间的HTML元素。 document.write 会直接写入文档流中, 如果在文档渲染完毕后调用会迫使浏览器重新渲染,innerHtML 仅仅修改DOM 内部的内容.document.write会重绘整个页面，而innerHTML是可以重绘页面的某一部分. 通过document.write插入&lt;&gt;元素会自动执行其中的脚本；大多数浏览器中，通过innerHTML插入&lt;&gt;元素并不会执行其中的脚本。 innerHTML很多情况下都优于document.write，其原因在于其允许更精确的控制要刷新页面的那一个部分。 事件其实从本质上来说，事件调用方式用于操作元素的属性。只不过这个属性不是一般的属性，而是“事件属性”。 调用方法在JavaScript中，调用事件的方式有两种。 在script标签中调用。 更常用 123obj.事件名=function()&#123; ……&#125;; 如果多个元素都要调用，可以写成一个专门的函数。再将函数赋值给事件 在元素中调用。 事件类型JavaScript常见的事件共有以下5种。 页面事件onload表示文档加载完成后再执行的一个事件。一般地，只有在想要“获取页面中某一个元素”的时候才会用到。因为在默认情况下，浏览器是从上到下来解析一个页面的。如果没有加载完就会出现解析错误。但是如果script中只定义了函数，在元素中进行调用，则不会报错。 123window.onload=function()&#123; ……&#125; onbeforeunload表示离开页面之前触发的一个事件。 鼠标事件onmouseover和onmouseout分别用于控制鼠标“移入”和“移出”这两种状态，如在下拉菜单导航中，鼠标移入会显示二级导航，鼠标移出则会收起二级导航。 在实际开发中，onmousedown、onmouseup和onmousemove经常配合实现拖拽、抛掷等效果 键盘事件键盘按下：onkeydown。键盘松开：onkeyup。 表单事件onfocus表示获取焦点时触发的事件，而onblur表示失去焦点时触发的事件，两者是相反的操作。一般用于单行文本框和多行文本框。focus（ ）是一个方法，仅仅用于让元素获取焦点。而onfocus是一个属性，它是用于事件操作的。 当我们选中“单行文本框”或“多行文本框”中的内容时，就会触发onselect事件。select（ ）是一个方法，仅仅用于全选文本。而onselect是一个属性，它是用于事件操作的。 onchange事件常用于“具有多个选项的表单元素”的操作，选择某一项时触发。 选择下拉列表的某一项时，触发的是onchange事件，而不是onselect事件。onselect事件仅仅在选择文本框中的内容时才会触发 编辑事件使用oncopy事件来防止页面内容被复制。 使用onselectstart事件来防止页面内容被选取。 使用oncontextmenu事件来禁止使用鼠标右键。 事件监听与处理事件处理器通过操作HTML属性的方式来实现，如oBtn.onclick=function（ ）{……};事件处理器不能为一个元素添加多个相同事件。 事件监听器又称为“绑定事件”。可以为同一个元素添加多个相同的事件obj.addEventListener（type ,fn ,false）type是一个字符串，指的是事件类型。如单击事件用click，鼠标移入用mouseover等。一定要注意，这个事件类型是不需要加上“on”前缀的。fn是一个函数名，或是一个匿名函数。false表示事件冒泡阶段调用。 解绑obj.removeEventListener（type ,fn ,false）;如果你想使用removeEventListener（ ）方法来解除一个事件，那么在使用addEventListener（ ）添加事件的时候，就一定要用定义函数（不能是匿名函数）的形式。 removeEventListener（ ）只可以解除“事件监听器”添加的事件，不可以解除“事件处理器”添加的事件。如果要解除“事件处理器”添加的事件，我们可以使用“obj.事件名 = null;”来实现 event对象当一个事件发生的时候，这个事件有关的详细信息都会临时保存到一个指定的地方，这个地方就是event对象。 每次调用一个事件的时候，JavaScript都会默认给这个事件函数加上一个隐藏的参数，这个参数就是event对象。一般来说，event对象是作为事件函数的第1个参数传入的。其实e只是一个变量名，它存储的是一个event对象。也就是说，e可以换成其他名字，如ev、event、a等 使用event对象的type属性来获取事件的类型。 获取键盘中的键对应的键码，可以使用event对象的keyCode属性。e.keyCode返回的是一个数字，而e.shiftKey、e.ctrlKey、e.altKey返回的都是布尔值（true或false） 事件操作中的this哪个DOM对象（元素节点）调用了this所在的函数，那么this指向的就是哪个DOM对象。 主要用在定义的事件被不同的元素调用时，可以方便地设置对应元素的属性值。其实这就是典型的闭包问题。 在事件函数中，如果想要使用当前的元素节点，我们应该尽量使用this来代替oBtn、oLi[i]等写法。 window对象一个浏览器窗口就是一个window对象 window对象下面又分为很多对象。window对象及下面这些location、navigator等子对象，由于都是用于操作浏览器窗口的，所以我们又称之为“BOM”，也就是Browser Object Module（浏览器对象模型）。 window对象的常用方法对于window对象，无论是它的属性，还是方法，都可以省略window前缀。 window.open（url,target）url为空，则表示打开一个空白窗口。空白窗口很有用，我们可以使用document.write（ ）往空白窗口输出文本，甚至输出一个HTML页面。target表示打开方式，它的取值跟a标签中target属性的取值是一样的，常用取值有两个：_blank（默认值）和_self。实际上，window.open（ ）就像函数调用一样，会返回新窗口对应的window对象。如果你打开的是同一个域名下的页面或空白窗口，就可以像上面那样操作新窗口的元素或样式；但是如果你打开的是另外一个域名下的页面，是不允许操作新窗口的内容的，因为涉及跨域的问题。 alert（ ）对话框一般只用于提示文字。confirm（ ）对话框不仅提示文字，还提供确认。根据不同布尔值可以设置不同的操作。prompt（ ）对话框不仅会提示文字，还会返回一个字符串。 setTimeout（code,time）;参数code可以是一段代码，可以是一个函数，也可以是一个函数名。参数time是时间，单位为毫秒，表示要过多长时间才执行code中的代码。 定义一个变量timer，用于保存setTimeout（ ）这个定时器，以便使用clearTimeout（timer）来暂停。 setInterval（ ）跟setTimeout（ ）语法是一样的，唯一不同的是可以重复执行无数次。 为了避免重复点击开启多个定时器，最好在开始时清除一下。 document对象document是浏览器为每个窗口内的HTML页面创建的对象。 document对象常用的属性 document.URL和window.location.href都可以获取当前页面的URL，但是它们也有区别：document.URL只能获取不能设置，window.location.href既可以获取也可以设置。 document.referrer 可以通过它来统计“用户都是通过什么方式来到你的网站的”。 document对象常用的方法 location对象location对象的属性 地址“?”后面的这些内容，也叫作querystring（查询字符串），一般用于数据库查询。 井号（#）一般用于锚点链接 navigator对象window.navigator.userAgent 获取浏览器的类型。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://vergessenwang.github.io/tags/JS/"}]},{"title":"CSS3新特征","slug":"CSS3新特征","date":"2020-06-08T15:49:41.000Z","updated":"2020-06-08T16:02:25.657Z","comments":true,"path":"posts/frontend/2020-06-08-CSS3新特征.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-06-08-CSS3新特征.html","excerpt":"学习笔记源自：绿叶 新增速览新增选择器 新增属性","text":"学习笔记源自：绿叶 新增速览新增选择器 新增属性 兼容性查询浏览器兼容性 处理浏览器兼容：根据内核加上前缀对于低版本的IE6~IE8，可以借助behavior属性来引入ie-css3.htc这个扩展文件来实现 检测内核 如我的iPad的Safari 新增选择器属性选择器CSS3新增的3个属性选择器使得选择器具有通配符的功能，正则表达式如匹配doc文件 a[href$=&quot;doc&quot;] 子元素伪类选择器第一类注意是父元素！ 在实际开发中，子元素伪类选择器特别适合操作列表的不同样式，避免id和class泛滥，让结构与样式分离 第二类:first-of-type、:last-of-type、:nth-of-type(n)、:only-of-type按类型选择 :first-child在选择父元素下的子元素时，不仅要区分元素类型，还要求是第一个子元素。而:first-of-type在选择父元素下的子元素时，只需要区分元素类型，不要求是第一个子元素。 UI伪类选择器UI，全称“User Interface”，也就是用户界面。 元素的状态包括：可用、不可用、选中、未选中、获取焦点、失去焦点等。UI伪类选择器的共同特点是：对于指定的样式，在默认状态下不起作用，只有当元素处于某种状态时才起作用。此外，大多数UI伪类选择器都是针对表单元素的。 :focus具有该属性的元素： 表单元素（按钮、单选框、复选框、文本框、下拉列表） 超链接 ::selection定义页面中被选中文本的样式。 单冒号往往都是伪类，而双冒号往往都是伪元素。为整个页面的选中文本定义样式，我们只需要使用::selection{}就可以实现。其中，::selection前面是不需要加任何元素的。 :checked定义单选框或复选框被选中时的样式。 :enabled和:disabled定义表单元素如文本框、单选框、复选框等，“可用”和“不可用”这两种状态时的样式 :read-write和:read-only可以使用:read-write选择器来定义表单元素“可读写”时的样式，也可以使用:read-only选择器来定义表单元素“只读”时的样式。 其他伪类选择器使用:root选择器来选择HTML页面的根元素，也就是。可以用来定义整个页面的背景 使用:empty选择器来选择一个“不包含任何子元素和内容”的元素，也就是选择一个空元素。像HTML5的2048小游戏就可以用到:empty选择器 使用:target选择器来选取页面中的某一个target元素。所谓的target元素，指的是id被当成页面的锚点链接来使用的元素。 使用:not()选择器来选取某一个元素之外的所有元素。例如对于“ul li:not(.first)”这个选择器，表示选择ul元素下除了第一个li元素之外的所有li元素。这个选择器非常重要，在实际开发中用得非常多 文本样式 text-shadowtext-shadow:x-offset y-offset blur color; x-offset是“水平阴影”，值为正，则阴影向右偏移；如果值为负，则阴影向左偏移。 y-offset是“垂直阴影”，值为正，则阴影向下偏移；如果值为负，则阴影向上偏移。 blur是“模糊距离”，表示阴影的模糊程度。blur不能为负值。可以为文本定义多个阴影，阴影效果会按从左到右的顺序应用到文本上，因此可能会出现相互覆盖的效果。常用于定义四个方向不同的效果 text-stroketext-stroke是一个复合属性，它是由text-stroke-width和text-stroke-color两个子属性组成的。 使用text-stroke配合color:transparent;，可以实现镂空文字。 text-overflowtext-overflow属性取值 要想实现文本溢出时就显示省略号效果，我们还需要结合white-space和overflow这两个属性来实现，overflow:hidden;white-space:nowrap;text-overflow:ellipsis;这三个是固定搭配的 想要实现这种多行文字的省略号效果，单纯使用CSS是无法实现的，必须借助JavaScript或jQuery才行。这里推荐一个jQuery插件：jquery.dotdotdot.js word-wrap、word-break一般情况下，我们只会用到word-wrap:break-word;或word-break:break-all；这两个来实现强制换行 前者按单词换行，后者会把单词截断。这两个属性都是针对英文页面来说的 @font-face把服务器中的字体文件下载到本地电脑，然后让浏览器端可以显示用户电脑没有安装的字体。 1234@font-face&#123; font-family: 字体名称; src:url(文件路径);&#125; 然后使用font-family引用字体。 不建议使用@font-face来实现嵌入中文字体。这是因为中文字体文件大多数都是10MB以上。这么大的字体文件，会严重影响页面的加载速度，导致用户体验非常差。 实际上，@font-face方法不仅可以用于嵌入字体，还可以用于实现字体图标技术（即iconfont）。 颜色样式opacity透明度opacity属性取值是一个数值，取值范围为0.0~1.0。其中0.0表示完全透明，1.0表示完全不透明。 opacity属性不仅作用于元素的背景颜色，还会作用于内部所有子元素以及文本内容。 opacity属性在实际开发中用得也比较多，大多数时候都是配合:hover来定义鼠标指针移动到某个按钮或图片上时，改变透明度来呈现动态的效果。 RGBA颜色在RGB基础上增加了一个透明度通道Alpha。取值范围为0.0~1.0。 RGBA中的透明度只会针对当前设置的属性起作用。 渐变background:linear-gradient(方向, 开始颜色, 结束颜色)线性渐变的“方向”取值有两种:一种是使用角度（单位为deg），另一种是使用关键字线性渐变也可以接受一个“值列表”，用于同时定义多种颜色的线性渐变，颜色值之间用英文逗号隔开即可。线性渐变使用的是background属性，而不是background-color属性。 background:radial-gradient(position,shape size, start-color, stop-color)position用于定义圆心位置，取值跟background-position属性取值一样。shape size用于定义形状大小，由两部分组成，shape定义形状，size定义大小。position和shape size都是可选参数。如果省略，则表示采用默认值。start-color和stop-color都是必选参数，可以有多个颜色值。 默认情况下，径向渐变的颜色节点是均匀分布的，不过我们可以为每一种颜色添加百分比，从而使得各个颜色节点不均匀分布。 边框样式在前端开发中，我们都是秉着“尽量少用图片”的原则。能用CSS实现的效果，就尽量不要用图片。因为每一个图片都会引发一次HTTP请求，加上图片体积大，会极大影响页面的加载速度。 border-radius可以为四个角设置圆角半径，“左上角、右上角、右下角、左下角” 上半圆实现原理：把高度（height）设为宽度（width）的一半，并且左上角和右上角的圆角半径定义与元素的高度一致，而右下角和左下角的圆角半径定义为0。 圆的实现原理：元素的宽度和高度定义为相同值，4个角的圆角半径定义为宽度（或高度）的一半（或者50%）。 实现椭圆: border-radius:x/y;原理如下：元素的宽度和高度不相等，其中4个角的圆角水平半径定义为宽度的一半，垂直半径定义为高度的一半。 box-shadowbox-shadow:x-offset y-offset blur spread color style;spread：定义阴影的大小。style：定义是外阴影还是内阴影。style取值有两种：outset（默认值）和inset。当x-offset和y-offset都为0时，阴影都是向外发散或者向内发散。 多方向 box-shadow:左阴影, 上阴影, 下阴影, 右阴影; border-colors必须分别为4条边设定颜色。如果边框宽度（即border-width）为n个像素，则该边框可以使用n种颜色，即每像素显示一种颜色。 border-colors兼容性较差 border-image 4条边的切割宽度，依次为上边、右边、下边、左边（顺时针）。平铺方式：有3种取值，分别为repeat、round和stretch。 各种图案尝试实现一下。 背景样式 background-sizebackground-size属性取值有两种：一种是长度值，如px、em、百分比等；另一种是使用关键字第一种某一边多出来会被剪切；第二种有一条边可能填不满。 background-origin使用background-origin属性来定义背景图片是从什么地方开始平铺的 background-origin往往都是配合background-position来使用的 background-clip属性值同上，默认左上角的部分被剪切。 动画效果CSS3中，动画效果包括3个部分：变形（transform）、过渡（transition）、动画（animation）。 transformtransform属性的变形方法： 平移有3种情况： translateX()、translateY()、translate()。 缩放也有3种情况：scaleX()、scaleY()、scale()。当x或y取值为0~1时，元素进行缩小；当x或y取值大于1时，元素进行放大。 倾斜也有3种情况：skewX()、skewY()、skew()。倾斜度数，单位为deg（即degree的缩写）。如果度数为正，则表示元素沿x轴方向逆时针倾斜或沿y轴方向顺时针倾斜如transform:skewX(30deg)其实skewX()方法的变形原理是这样的：由于元素限定了高度为100px，而skewX()方法是沿着x轴方向倾斜的，因此只要倾斜角度不超过180°，元素都会保持100px的高度，同时为了保持倾斜，元素只能沿着x轴方向拉长本身。 transform: rotate(angle); 参数angle表示元素相对于中心原点旋转的度数，单位为deg。如果度数为正，则表示顺时针旋转；如果度数为负，则表示逆时针旋转。 默认情况下，CSS3的各种变形（平移、缩放、倾斜等）都是以元素的中心原点进行变形的。可以使用transform-origin属性来改变元素的中心原点。 transition使用transition属性将元素的某一个属性从“一个属性值”在指定的时间内平滑地过渡到“另一个属性值”。凡是涉及CSS3过渡，我们都是结合:hover伪类来实现过渡效果的 transition: 过渡属性 过渡时间 过渡方式 延迟时间; transition是一个复合属性，主要包括4个子属性： 在实际开发中，当有多个CSS属性需要实现过渡效果时，直接定义transition-property属性取值为all。即所有在hover中发生了改变的属性 transition-timing-function属性取不同值 transition属性分别写在“普通状态”和“悬浮状态”内的不同：移入时效果两者没有区别，但是如果把transition属性写在普通状态内，移出时会有过渡效果；如果把transition属性写在悬浮状态内，移出时没有过渡效果。 实践下遮罩层介绍，手风琴效果等。 animationtransition属性只能实现一次性的动画效果，而animation属性可以实现连续性的动画效果。 animation:动画名称 持续时间 动画方式 延迟时间 动画次数 动画方向; 定义动画 12345@keyframes 动画名&#123; 0%&#123;&#125; …… 100%&#123;&#125;&#125; 0%表示动画的开始，100%表示动画的结束，0%和100%是必须的。不过，一个@keyframes规则可以由多个百分比组成，每一个百分比都可以定义自身的CSS样式，从而形成一系列的动画效果。如果仅仅只有0%和100%这两个百分比，可以使用关键字from和to来代替 然后使用animation属性来“调用动画” animation-iteration-count属性取值有两种：一种是“正整数”，另一种是“infinite” animation-direction属性取值有3个 使用animation-play-state属性来定义动画的播放状态。属性只有两个取值，running和paused 实践：了解一些酷炫动画的具体实现。 多列布局浮动布局比较灵活，但不容易控制；定位布局可以精准定位，但是却不够灵活。 在CSS3中，多列布局常用的属性有 column-count属性取值有两种 column-width属性取值有两种body就会自动根据容器宽度、每列宽度、内容多少这三者来计算列数。 column-gap属性取值有两个 column-rule属性跟border属性是非常相似的 column-span属性取值只有两种 实践：瀑布流布局 滤镜效果在CSS3中，所有的滤镜效果都是使用filter属性来实现的。 brightness()方法的取值是一个百分比，其中0%~100%表示减弱图片的亮度，例如0%就是完全黑色；100%以上表示增强图片的亮度，例如200%就是将亮度提高2倍。 grayscale()方法的取值是一个百分比，其中0%表示不做任何修改，100%表示完全灰度（即黑白图片）。 复古滤镜，也叫褐色滤镜。 反色，指的是将红、绿、蓝3个通道的像素取各自的相反值。 hue-rotate()方法的取值是一个度数，单位为deg（即degree的缩写）。其中，0deg表示不旋转，360deg表示旋转360°，也就是相当于一个循环。 drop-shadow(x-offset y-offset blur color); 弹性盒子模型通过弹性盒子模型，我们可以轻松地创建自适应浏览器窗口的“流动布局”以及自适应字体大小的弹性布局，使得响应式布局的实现更加容易。 在使用弹性盒子模型之前，必须为父元素定义“display:flex;”或“display:inline-flex;” 重点掌握flex、flex-flow、order、justify-content、align-items flex-grow属性取值是一个数值，默认值为0。当取值为0时，表示不索取父元素的剩余空间；当取值大于0时，表示索取父元素的剩余空间（即子元素放大）。取值越大，索取得越多。在使用flex-grow时，一般是不需要对弹性盒子内部的子元素定义宽度或高度的，否则会影响flex容器的比例分配。——即直接将父元素所有空间按比例分配 flex-shrink属性用于定义弹性盒子内部子元素的缩小比例。也就是当所有子元素宽度之和大于父元素的宽度时，子元素如何缩小自己的宽度。 flex-grow和flex-shrink是互斥的，不可能同时生效。flex-grow的默认值为0，而flex-shrink的默认值为1。 flex-basis就是width的替代品，它们都用来定义子元素的宽度。只不过在弹性盒子中，flex-basis的语义会比width更好。如果某一个子元素同时设置flex-basis和width，那么flex-basis的值会覆盖width的值。flex-basis属性取值有两个：一个是“auto”，即该子元素的宽度是根据内容多少来定的；另一个是“长度值” flex-direction属性取值有4个，flex-direction属性是在弹性盒子（即父元素）上定义的。 flex-wrap属性常见取值有3个 使用order属性来定义弹性盒子内部“子元素”的排列顺序。order属性取值是一个正整数，即序号 justify-content属性取值 align-items属性取值 实现块元素在其父元素的水平居中和垂直居中很简单，只需要在其父元素中添加以下代码即可： 123display: flex;justify-content: center;align-items: center; 其他样式使用outline属性来定义表单中文本框的轮廓线样式，可以把轮廓线看成是一条特殊的边框来理解。如 12input[type=\"text\"]:focus &#123; outline:1px solid red; &#125; 使用initial属性直接将某个CSS属性重置为它的默认值，initial取值可以用于任何HTML元素上的任何CSS属性。 使用calc()函数通过“计算”的方式来定义某一个属性的取值。只能使用加（+）、减（-）、乘（*）和除（/）这4种运算。表达式中有加号（+）和减号（-）时，其前后必须有空格。在自适应布局中涉及不同单位之间的运算时用得非常多。 举例：三列平分布局 overflow-x和overflow-y这两个属性都有4种取值 使用pointer-events属性来定义元素是否禁用鼠标单击事件。pointer-events属性是一个与JavaScript有关的属性。比较常见的用法是获取验证码。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://vergessenwang.github.io/tags/CSS/"}]},{"title":"Vue中使用BootstrapVue","slug":"Vue中使用BootstrapVue","date":"2020-06-06T15:32:27.000Z","updated":"2020-06-06T15:33:36.317Z","comments":true,"path":"posts/frontend/2020-06-06-Vue中使用BootstrapVue.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-06-06-Vue中使用BootstrapVue.html","excerpt":"项目运行报错: System limit for number of file watchers reached 原来是linux系统中限制了用户可以watch文件变更的最大数，因此需要通过sysctl.conf进行更改数值 echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p 解决方案参考 重启服务，不再报错。 接下来集成 bootstrap-vue CSS框架。官方文档 简单使用教程 报错 GET https://registry.npmjs.com/boostrap-vue - Not found 怎么会找不到？？ 先装个nrm来管理镜像 npm install -g nrm nrm用法","text":"项目运行报错: System limit for number of file watchers reached 原来是linux系统中限制了用户可以watch文件变更的最大数，因此需要通过sysctl.conf进行更改数值 echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p 解决方案参考 重启服务，不再报错。 接下来集成 bootstrap-vue CSS框架。官方文档 简单使用教程 报错 GET https://registry.npmjs.com/boostrap-vue - Not found 怎么会找不到？？ 先装个nrm来管理镜像 npm install -g nrm nrm用法 诶，我明明用的是淘宝源啊？？ 测下速度，这么感人的吗？ 试了一下还是不行，然后我把 i 换成 install 分开安装，就可以了？？这是什么鬼bug啊… 所以最好用这个命令装 npm install bootstrap-vue bootstrap 在Vue项目的main.js中引入 12345import BootstrapVue from 'bootstrap-vue'import 'bootstrap/dist/css/bootstrap.css'import 'bootstrap-vue/dist/bootstrap-vue.css'Vue.Vue.use(BootstrapVue) 点击VS Code下面的spaces可以切换缩进格式 然后就可以愉快的引入样式啦 浏览器安装了对于的vue devtools后就可以更方便的查看组件了 父组件在export default 中定义获得数据的方法 12345678910111213141516data() &#123; return &#123; questions: [] &#125;&#125;,mounted: function() &#123; fetch(&quot;url for api...&quot;,&#123; method: &apos;get&apos; &#125;) .then((response) =&gt; &#123; return response.json() &#125;) .then((jsonData) =&gt; &#123; return this.questions = jsonData.results &#125;)&#125; 子组件在export default 中用props获得父组件的数据, 除了object还可以传递function等 1234567&lt;script&gt;export default &#123; props: &#123; currentQuestion: Object, &#125;&#125;&lt;/script&gt; Lodash是一个好用的Javascript原生库，可以学到各种算法的实现 官方文档 源码","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://vergessenwang.github.io/tags/vue/"}]},{"title":"Html5新特征","slug":"Html5新特征","date":"2020-06-04T06:33:49.000Z","updated":"2020-06-08T16:02:53.440Z","comments":true,"path":"posts/frontend/2020-06-04-Html5新特征.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-06-04-Html5新特征.html","excerpt":"学习笔记源自：绿叶 HTML指的是HTML4.01，XHTML是HTML的过渡版，HTML5是HTML的升级版。 W3C官方地址：https://www.w3.org/TR/html5/MDN官方地址：https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5 新增速览新增元素 新增属性","text":"学习笔记源自：绿叶 HTML指的是HTML4.01，XHTML是HTML的过渡版，HTML5是HTML的升级版。 W3C官方地址：https://www.w3.org/TR/html5/MDN官方地址：https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5 新增速览新增元素 新增属性 结构元素HTML5新增的主要结构元素有6个：header、nav、article、aside、section、footer。 header在HTML5中，header元素一般用于3个地方：页面头部、文章头部（article元素）和区块头部（section元素）。 当用于页面头部时，header元素一般用于包含网站名称、页面LOGO、顶部导航、介绍信息等 当用于文章头部时（即article元素头部），header元素一般用于包含“文章标题”和“meta信息”两部分。所谓的meta信息，一般指的是作者、点赞数、评论数等 当用于区块头部时（即section元素头部），header元素一般只包含区块的标题内容 nav在HTML5中，nav元素一般用于3个地方：顶部导航、侧栏导航和分页导航。 一般情况下，主导航主要是使用无序列表来实现。 1234567&lt;nav id=\"nav\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; articlearticle元素一般只会用于一个地方：文章内容部分。内部可以包含header元素、section元素和footer元素等。 asideaside元素一般用于表示跟周围区块相关的内容 如果aside元素放在article元素或section元素之中，则aside内容必须与article内容或section内容紧密相关。 如果aside元素放在article元素或section元素之外，则aside内容应该是与整个页面相关的，比如相关文章、相关链接、相关广告等。 sectionsection元素一般用于某一个需要标题内容的区块。如果页面某个区块不需要标题，直接使用div元素就可以了。 在实际开发中，对于页面某一个区块，优先考虑语义化更好的article元素和aside元素，如果这两个都不符合，再考虑使用section元素。 footerfooter元素一般用于两个地方：一个是“页面底部”，另一个是“文章底部”。当用于页面底部时，footer元素一般包含友情链接、版权声明、备案信息等。当用于文章底部时，也就是放在article元素内部时，footer元素一般包含“上一篇/下一篇导航”“文章分类”“发布信息”等。 表单元素新增input元素类型 email类型的文本框采用了浏览器内置的验证机制，而浏览器内置的验证机制必须使用submit按钮才会触发。 tel/url类型文本框并不具备完备的验证功能，如果想要达到验证效果，则需要结合pattern属性来实现。 当type属性取值为“range”时，我们可以通过拖动滑动条获取某一个范围内的数字。&lt;input type=&quot;range&quot; min=&quot;最小值&quot; max=&quot;最大值&quot; step=&quot;间隔数&quot;/&gt; 在实际开发中，range类型元素都是需要结合JavaScript来操作的 number类型跟range类型功能非常相似，都是获取某一个范围内的数字。不过两者的外观不一样，其中number类型使用的是“微调按钮”，而range类型使用的是“滑块”。 当type属性取值为“color”时，我们可以直接使用浏览器自带的取色工具来获取颜色值。&lt;input type=&quot;color&quot; value=&quot;&quot;/&gt; value属性用于设置颜色初始值，格式必须是十六进制颜色值如#F1F1F1，不能是关键字 当我们点击date类型元素时，浏览器会弹出自带的日历工具，以方便直接选取日期。value属性用于设置日期初始值，格式必须如“2018-05-20” time的value属性用于设置时间初始值，格式必须如“08:04”。 month的value属性用于设置初始值，格式必须如“2018-08” week的value属性用于设置初始值，格式必须如“2018-W04” 其他表单元素新增了3个表单元素：output、datalist、keygen。 使用output元素来定义表单元素的输出结果或计算结果。&lt;output&gt;&lt;/output&gt; output元素是一个行内元素，只不过它比span元素更具有语义化。output元素一般放在form元素内部，并且配合其他表单元素（如文本框等）来使用。 使用datalist元素来为文本框提供一个可选的列表。 如果想要把datalist绑定到某个文本框，需要设置该文本框的list属性值等于datalist的id值。 使用keygen元素来生成页面的密钥。如果表单内部有keygen元素，则提交表单时，keygen元素将生成一对密钥：一个保存在客户端，称为“私密钥（Private Key）”；另一个发送到服务器，称为“公密钥（Public Key）”。keygen元素主要是作为客户端安全保护的一种方法，不过它在各大浏览器中的兼容性很差 语义化元素使用更具有语义化的address元素来为“整个页面”或者“某一个article元素”添加地址信息（电子邮件或真实地址）。一般放在footer元素内部 &lt;time datetime=&quot;时间&quot;&gt;&lt;/time&gt;datetime属性中的时间是提供给搜索引擎看的，而time标签内的时间是提供给用户看的，两者内容可以一样也可以不一样。time元素与datetime属性的关系，有点类似于img元素与alt属性的关系。 使用progress元素以进度条的形式来显示某一个任务的完成度，如上传文件、下载文件等。 &lt;progress max=&quot;最大值&quot; value=&quot;当前值&quot;&gt;&lt;/progress&gt; &lt;meter min=&quot;最小值&quot; max=&quot;最大值&quot; value=&quot;当前值&quot;&gt;&lt;/meter&gt; meter元素跟progress元素非常相似，都是以进度条形式来显示数据比例。不过，两者在语义上有很大的区别： meter元素一般用于显示静态数据比例。所谓的静态数据，指的是很少改变的数据，例如男生人数占全班人数的比例。 progress元素一般用于显示动态数据比例。所谓“动态数据”，指的是会不断改变的数据，例如下载文件的进度。 figure和figcaption这两个元素实现“图片+图注”效果 1234&lt;figure&gt; &lt;img src=\"\" alt=\"\"/&gt; &lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt; 使用fieldset元素来给表单元素进行分组。其中，legend元素用于定义某一组表单的标题。 123&lt;fieldset&gt; &lt;legend&gt;表单组标题&lt;/legend&gt;&lt;/fieldset&gt; 使用fieldset和legend有两个作用：增强表单的语义；定义fieldset元素的disabled属性来禁用整个组中的表单元素。 改良元素常用的是a元素的download属性，&lt;a href=&quot;文件地址&quot; download=&quot;新文件名&quot;&gt;&lt;/a&gt; ol元素新增了一个reversed属性，用于设置列表顺序为降序显示。 使用更具有语义化的small元素来表示“小字印刷体”的文字。small元素一般用于网站底部的免责声明、版权声明等 HTML5为script元素新增了两个属性：defer和async。defer和async都是异步加载的，两者区别在于，异步加载外部JavaScript文件完成后何时执行。defer等到整个HTML文档加载完成才会执行，更符合大多数开发场景对脚本加载执行的要求。async加载完毕立即执行 html加载顺序 怎样使低版本的IE浏览器支持HTML5新元素？ 新增属性公共属性使用hidden属性来显示或隐藏某一个元素。 使用draggable属性来定义某一个元素是否可以被拖动。draggable=”true”只能定义元素可以被拖动这一个行为，拖动后并不会改变元素的位置。 使用contenteditable属性来定义某个元素的内容是否可以被编辑。 使用data-*属性来为元素实现自定义属性。使用DOM操作中的obj.dataset.xxx来获取data-属性的值。自定义属性在JavaScript动画以及实际开发中用得是非常多的 input元素的新增属性autocomplete属性一般都是结合datalist元素来实现自动提示功能。适用于所有文本框型的input元素，包括text、password、email、url、tel等。 使用autofocus属性来实现文本框自动获取焦点。 使用placeholder属性为文本框添加提示内容。 使用required属性来定义文本框输入内容不能为空。 使用pattern属性来为文本框添加验证功能。 &lt;input type=&quot;text&quot; pattern=&quot;正则表达式&quot; /&gt;email、url、tel这3个类型的input元素，本质上都内置了pattern属性，因此它们会自动进行相关匹配验证。 关于正则, 之前写过一篇关于java的正则 不过JS的正则还需要重新学习一下 form元素的新增属性使用novalidate属性来禁用form元素的所有文本框内置的验证功能。然后使用JavaScript来创建更为复杂且健全的验证 元素拖放仅给元素设置draggable=”true”，则该元素只具备可拖曳的特点，并不能改变元素的位置。如果想要拖动改变元素的位置，我们还需要结合元素拖放触发的事件来操作。 一般情况下我们需要操作3个事件：ondragstart、ondragover和ondrop。 dataTransfer对象主要用于在“源元素”与“目标元素”之间传递数据。有两个最重要的方法：setData()和getData()。在整个拖曳过程中，具体操作是这样的：开始拖放源元素时（ondragstart事件），调用setData()方法保存数据；然后在放入目标元素时（ondrop事件），调用getData()方法读取数据。 setData(format, data); getData(format); 注意要调用event.preventDefault()方法来屏蔽元素的默认行为。 文件操作文件上传是使用input元素来实现的，其中type属性取值为”file”。 文件上传input元素有两个重要属性：multiple和accept multiple属性表示“是否选择多个文件”。 accept属性用于设置文件的过滤类型（MIME类型） &lt;input type=&quot;file&quot; accept=&quot;image/jpeg, image/png&quot; multiple/&gt; 在文件上传元素中，将会产生一个FileList对象，它是一个类数组对象，表示所有文件的集合。其中，每一个文件就是一个File对象。有如下属性： 在HTML5中，专门提供了一个文件操作的API，即FileReader对象。我们通过FileReader对象可以很方便地读取文件中的数据。FileReader对象有5个方法： 在HTML5以前，我们一般都是先将本地图片上传到服务器，等上传成功后再由后台返回图片的地址在前端显示。到了HTML5时代，我们使用FileReader对象的readAsDataURL()方法，可以不经过后台而直接将本地图片显示在页面中，这样可以减少前后端的频繁交互，减少服务器端的压力。 FileReader对象提供了6个事件，用于检测文件的读取状态： 在HTML5中，还新增了一个Blob对象，用于代表原始二进制数据。实际上，前面介绍的File对象也继承于Blob对象。var blob = new Blob(dataArray, type); 常用于下载链接的创建 在实际开发中，FileReader对象的readAsText()、readAsArrayBuffer()等方法可以读取文件数据，然后结合Blob对象下载文件的功能，就可以实现将数据导出文件备份到本地。当要恢复数据时，通过input元素上传备份文件，使用readAsText()、readAsArrayBuffer()等方法读取文件，即可恢复数据。 本地存储Cookie的限制： 大小限制：大多数浏览器支持最大为4KB的Cookie。 数量限制：大多数浏览器只允许每个站点存储20个Cookie，如果想要存储更多Cookie，则旧的Cookie将会被丢弃。 有些浏览器还会对它们将接收的来自所有站点的Cookie总数做出绝对限制，通常为300个。 Cookie默认情况下都会随着HTTP请求发送到后台，但是实际上大多数请求都是不需要Cookie的。 HTML5新增了3种全新的数据存储方式：localStorage、sessionStorage和indexedDB。 localStorage用于永久保存客户端的少量数据，sessionStorage用于临时保存客户端的少量数据，而indexedDB用于永久保存客户端的大量数据。 localStorage对于localStorage来说，每一个域名可以保存5MB数据。不同浏览器的localStorage数据是不可以共用的 方法： 统计访问数的例子： sessionStoragesessionStorage对象跟localStorage对象非常相似，两者有着完全相同的方法。localStorage和sessionStorage都是window对象下的子对象。也就是说，localStorage.getItem()其实是window.localStorage.getItem()的简写。 sessionStorage对象保存的是“临时数据”，用户关闭浏览器后，数据就会丢失；而localStorage对象保存的是“永久数据”，用户关闭浏览器后，数据依然存在。 在实际开发中，localStorage用得比较多 indexedDB在本地数据库这个技术方向，最新的HTML5标准表示只支持indexedDB。该数据库是一种存储在客户端本地的NoSQL数据库 indexedDB对象是window对象下的一个子对象，我们可以使用indexedDB对象的open()方法来创建或打开一个数据库。open()方法有两个参数：第1个参数是数据库名；第2个参数是数据库版本号。 window.indexedDB.open()方法返回一个请求对象，我们将其赋值给变量request。该请求对象有两个事件：onerror事件和onsuccess事件。onerror事件表示请求失败时触发的事件，onsuccess事件表示请求成功时触发的事件 e.target.result获取的是一个IDBDatabase对象。通过IDBDatabase对象，我们可以获取数据库的各种信息如数据库名、版本号等。数据库的增删查改操作，都是基于这个对象的 在indexedDB中，一个对象仓库就是一张表。 使用IDBDatabase对象的createObjectStore()方法来创建一个新的对象仓库。创建对象仓库，都是在onupgradeneeded事件中执行的。因此，我们必须更新数据库版本号，以便触发onupgradeneeded事件。 createObjectStore()方法有两个参数：第1个参数是“对象仓库名”；第2个参数用于设置对象仓库的主键。如果你想要让主键是一个递增的数字，可以使用下面这一句代码：var store = db.createObjectStore(&quot;对象仓库名&quot;,{autoIncrement:true}); 凡是对象仓库的增删查改，都是在请求对象request的onsuccess事件中操作的。当想要使用对象仓库进行增删查改操作时，我们都需要开始一个事务。使用IDBDatabase对象的transaction()方法开启一个事务，返回的是一个事务对象，即transaction对象。transaction()方法有两个参数：第1个参数是“对象仓库名”，它是“字符串数组”；第2个参数是“事务模式”，有两个取值。 “read”：只读； “readwrite”：可读写。 使用ObjectStore对象的add()方法往对象仓库中添加数据调用objectStore对象的delete()方法来为对象仓库删除数据使用get()方法来查询对象仓库的数据使用put()方法来更新对象仓库的数据使用clear()方法来清空对象仓库的数据 音频视频audio和video这两个元素大多数的属性和方法都是相同的 video元素autoplay、controls和loop属性无须多说。而preload属性表示是否预加载，它有3个取值： 一定要使用width和height这两个属性来定义视频的宽度和高度。如果没有定义，则浏览器显示的是视频原来的大小。如果视频本身过于大，则会影响页面布局。 对于HTML5视频格式，主要有3种，分别是ogg、mp4和webm。 兼容： 12345&lt;video&gt; &lt;source type=\"vdieo/ogg\" src=\"文件路径\" /&gt; &lt;source type=\"video/mp4\" src=\"文件路径\" /&gt; &lt;source type=\"video/webm\" src=\"文件路径\" /&gt;&lt;/video&gt; 视频的默认样式一般比较难看，用户体验并不好。在自定义视频中，我们不仅需要使用CSS重新制作外观样式，还需要借助JavaScript来将播放、暂停、进度条显示、音量控制等功能实现才行。 audio元素的属性跟video元素的属性几乎是一样的 对于HTML5音频格式，主要有3种，分别是ogg、mp3和wav。 离线应用HTML5离线存储是基于一个新建的.appcache文件的缓存机制（不是存储技术），通过这个文件来解析清单中的离线存储资源，这些资源就会像Cookie一样被存储下来。之后当网络处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 所谓“离线存储”，指的是建立一个URL列表，该列表可以包含HTML文件、CSS文件、JavaScript文件和图片等。离线存储的容量上限为5MB，不适合用来大量存储图片文件，只适合用来保存静态图片，比如LOGO。 页面头部加入manifest属性：manifest属性的取值是cache.manifest文件的路径。网站根目录下新建一个cache.manifest文件，文件格式如下： 更新方式： 自动更新，指的是通过改变cache.manifest文件的内容来触发更新缓存。最有效的方法是修改cache.manifest文件内部的版本注释version xx.xx.xx 手动更新，指的是通过JavaScript事件来操作更新缓存。如使用applicationCache对象的update()方法来更新缓存 多线程JavaScript的执行环境是单线程的。 在HTML5中，我们可以使用Web Worker创建一个“后台线程”来执行某一段耗时较长的JavaScript程序，而不会影响页面响应。 Web Worker技术基本原理就是：在当前JavaScript的主线程中，使用Worker()构造函数新建一个worker实例，然后加载某一个JavaScript文件，发送给一个后台线程来处理（注意，这里是后台线程）。 使用Worker()构造函数新建一个worker实例，其中，参数url表示需要发送到后台线程处理的JavaScript文件的路径。worker.postMessage()表示发送数据给worker线程，其中参数yourdata可以是数字、字符串、对象等。worker.onmessage = function(e){};表示接收worker发过来的数据，然后进行处理。在处理函数内部，我们可以使用e.data来获取发过来的数据。 一个例子： Web Worker由于使用的是后台线程，发送给后台线程的那个JavaScript文件的使用有一定的限制，例如无法访问DOM、无法访问全局变量或全局函数等。 Web Worker依然可以使用定时器的4个函数：setTimeout()、clearTimeout()、setInterval()、clearInterval()。 Web Worker不支持跨域加载JavaScript。 地理位置window.navigator.geolocation 获取用户的地理位置信息。HTML5定位是针对手机端的 geolocation对象有3个方法： navigator.geolocation.getCurrentPosition(function(position){ ……}, error, option); getCurrentPosition()方法有3个参数：第1个参数是一个回调函数，表示在成功获取到当前地理位置后才会执行；第2个参数也是一个回调函数，表示在获取当前地理位置失败时才会去执行；第3个参数是一些可选属性的列表，它包含多个属性。大多数情况下，我们只会用到第1个参数。 如果想要获取当前位置的信息，都是在回调函数中利用position对象来获取。position对象有很多属性 watchPosition()跟getCurrentPosition()方法非常相似，两者有着共同的参数。它会定期地自动获取位置信息，不需要我们手动刷新页面。实际上，对于watchPosition()的效果，也可以使用getCurrentPosition()结合setInterval()来实现。 watchPosition()方法会返回一个数字，我们可以把它保存在变量watchID中。当想要停止监视用户位置时，把这个watchID作为参数传递给clearWatch()方法就可以实现。 百度地图API 借助百度地图API来实现驾车线路规划 桌面通知Notification API通知属于桌面性质的通知，它跟浏览器是脱离的，消息是置顶的。 var notice = new Notification(title, options); title是必选参数，表示通知框的标题内容；options是一个对象，用来设置一些可选参数。其中options对象中的参数有很多 Notification.permission表示调用Notification对象下的permission属性，这个属性用于获取用户的确认信息，也就是确认提示框返回的值。 CanvasHTML5有两个主要的2D图形技术：Canvas和SVG。 Canvas是使用JavaScript动态生成的，SVG是使用XML静态描述的。 Canvas是基于“位图”的，适用于像素处理和动态渲染，图形放大会影响质量；SVG是基于“矢量”的，图形放大不会影响质量。使用Canvas绘制出来的是一个“位图”，而使用SVG绘制出来的是一个“矢量图”。 每次发生修改，Canvas需要重绘，而SVG不需要重绘。 Canvas技术，指的就是使用Canvas元素结合JavaScript来绘制各种图形的技术。需要以下3步： ①获取Canvas对象。②获取上下文环境对象Context。③开始绘制图形。 即，使用document.getElementById()方法来获取Canvas对象（这是一个DOM对象），然后使用Canvas对象的getContext(“2d”)方法获取上下文环境对象Context，最后使用Context对象的属性和方法来绘制各种图形。 Canvas是一个行内块元素（即inline-block），我们一般需要指定其3个属性：id、width和height。默认情况下，Canvas的宽度为300px，高度为150px。对于Canvas的宽度和高度，我们一定要在HTML属性中定义，而不是在CSS样式中定义。 低版本兼容问题：可以在低版本IE浏览器引入excanvas.js来使用Canvas，但是在功能上也会有很多限制，例如无法使用fillText()方法等。 W3C坐标系的y轴正方向是向下的。 在Canvas中，使用moveTo()和lineTo()方法可以画各种多边形，包括三角形、矩形、多边形等。moveTo的含义是“将画笔移到该点的位置，然后开始绘图”。lineTo的含义是“从起点开始画直线，一直画到终点坐标”。再用笔连线，即stroke()。 哎，这块内容有点多，看不动了，以后再专门找时间看吧。。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://vergessenwang.github.io/tags/HTML/"}]},{"title":"CSS基础","slug":"CSS基础","date":"2020-06-01T15:05:50.000Z","updated":"2020-06-08T16:03:31.846Z","comments":true,"path":"posts/frontend/2020-06-01-CSS基础.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-06-01-CSS基础.html","excerpt":"学习笔记源自：绿叶 CSS，指的是“Cascading Style Sheet（层叠样式表）” 常用属性速览","text":"学习笔记源自：绿叶 CSS，指的是“Cascading Style Sheet（层叠样式表）” 常用属性速览 引入方式想要在一个页面引入CSS，共有以下3种方式：外部样式表，内部样式表，行内样式表。 当样式需要被应用到多个页面时，外部样式表是最理想的选择。使用外部样式表，就可以通过更改一个CSS文件来改变整个网站的外观。 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;文件路径&quot; /&gt; 内部样式表，指的是把HTML代码和CSS代码放到同一个HTML文件中。其中，CSS代码放在style标签内，style标签是放在head标签内部的。 123&lt;style type=\"text/css\"&gt; ……&lt;/style&gt; 行内样式表的CSS是在“标签的style属性”中定义的。 @import方式与外部样式表很相似。@import方式是先加载HTML后加载CSS，而link是先加载CSS后加载HTML。如果HTML在CSS之前加载，页面用户体验就会非常差。 选择器选择器的不同，在于它的选择方式不同，但是它们的最终目的是相同的，就是把你想要的元素选中，这样才可以定义该元素CSS样式。 12345选择器 &#123; 属性1 : 取值1; …… 属性n : 取值n;&#125; 最实用的5种选择器：元素选择器，id选择器，class选择器，后代选择器，群组选择器。 id选择器，id名前面必须要加上前缀“#”class名前面必须要加上前缀英文句号（.）可以为不同的元素设置相同的class来为他们定义相同的CSS样式 后代选择器，就是选择元素内部中某一种元素的所有元素：包括子元素和其他后代元素（如“孙元素”）。父元素和后代元素必须要用空格隔开，表示选中某个元素内部的后代元素 群组选择器，指的是同时对几个选择器进行相同的操作。对于群组选择器，两个选择器之间必须要用英文逗号（,）隔开 字体 除了字体颜色，其他字体属性都是以“font”前缀开头的。 对于font-family属性，如果字体类型只有一个英文单词，则不需要加上双引号；如果字体类型是多个英文单词或是中文的，则需要加上双引号。 font-size属性取值有多种：一种是“关键字”，如small、medium、large等；另外一种是“像素值”，如10px；还有em、百分比等严格来说，px属于相对单位，因为屏幕分辨率的不同，1px的大小也是不同的。 字体粗细（font-weight）与字体大小（font-size）是不一样的。粗细指的是字体的“肥瘦”，而大小指的是字体的“宽高”。font-weight属性取值有两种：一种是“100~900的数值”，另一种是“关键字”。 其中100相当于lighter，400相当于normal，700相当于bold，而900相当于bolder。 有些字体有斜体italic属性，但有些字体却没有italic属性。oblique是让没有italic属性的字体也能够有斜体效果。 color属性取值有两种，一种是“关键字”，另一种是“十六进制RGB值”。除了这两种，其实还有RGBA、HSL等 文本字体样式针对的是“文字本身”的形体效果，而文本样式针对的是“整个段落”的排版效果。 中文段落首行一般需要缩进两个字的空间。想要实现这个效果，那么textindent值应该是font-size值的2倍。 text-align属性不仅对文本有效，对图片（img元素）也有效。 在HTML学习中，我们使用s元素实现中划线，用u元素实现下划线。但是有了CSS之后，我们都是使用text-decoration属性来实现。使用“text-decoration:none;”去除a元素的下划线，这个技巧我们在实际开发中会大量用到。 使用line-height属性来控制一行文本的高度。 使用letter-spacing属性来控制字与字之间的距离。每一个中文汉字都被当作一个“字”，而每一个英文字母也被当作一个“字”。word-spacing只针对英文单词而言。 边框几乎所有的元素都可以定义边框。例如，div元素可以定义边框，img元素可以定义边框，table元素可以定义边框，span元素同样也可以定义边框 简写形式： border:1px solid red; 还有hidden、dotted、double等取值。 局部边框推荐使用上右下左的顺序 去除边框的三种写法：如“border-bottom:0px;”“border-bottom:0;”和“border-bottom:none; 列表在HTML中，对于有序列表和无序列表的列表项符号，都是使用type属性来定义的。在CSS中，不管是有序列表还是无序列表，我们都是使用list-style-type属性来定义列表项符号的。 list-style-type属性是针对ol或者ul元素的，而不是li元素。 由于列表项符号不太美观，因此在实际开发中，大多数情况下我们都需要使用“list-styletype:none;”将其去掉。 如果我们想自定义列表项符号，那该怎么实现呢？ 在CSS中，我们可以使用list-style-image属性来定义列表项图片，也就是使用图片来代替列表项符号。 list-style-image:url（图片路径）; 一般情况下我们都不会用liststyle-image属性来实现，而是使用更为高级的iconfont图标技术来实现 表格使用caption-side属性来定义表格标题的位置。 在表格加入边框后的页面效果中，单元格之间是有一定空隙的。可以使用border-collapse属性来去除单元格之间的空隙。 可以使用border-spacing属性来定义表格边框间距。 以上几种属性都是在table元素中定义的。 border-collapse只限用于表格，不能用于其他元素 如果要为表格添加边框，我们一般需要同时对table、th、td这几个元素进行设置 图片借助width和height来改变其大小。 border:1px solid red; 边框 text-align:取值; 水平对齐，很多人以为图片的水平对齐是在img元素中定义的，其实这是错的。图片是在父元素中进行水平对齐 vertical-align:取值; 垂直对齐 “vertical-align属性定义周围的行内元素或文本相对于该元素的垂直方式”。因此并不能实现img元素在div中的垂直居中 float:取值; 文字环绕 背景定义“背景颜色”使用的是background-color属性，而定义“背景图片”则比较复杂，往往涉及以下属性 color属性用于定义“文本颜色”，而background-color属性用于定义“背景颜色”，这两个要注意区分。 背景图片与图片是不一样的，背景图片是使用CSS来实现，而图片是使用HTML来实现。两者的使用场合也不一样，大多数情况下都是使用图片，不过在某些无法使用图片的场合中，我们就要考虑背景图片形式。 background-position属性常用取值有两种：一种是“像素值”，另外一种是“关键字” background-position:水平距离 垂直距离;` 两个值是相对该元素的左上角来说的关键字 在实际开发中，background-position一般用于实现CSS Spirit（精灵图片）。 使用background-attachment属性来定义背景图片是随元素一起滚动还是固定不动。 超链接定义4个伪类，必须按照“link、visited、hover、active”的顺序进行，不然浏览器可能无法正常显示这4种样式 在实际开发中，我们只会用到两种状态：未访问时状态和鼠标经过状态。 12a&#123;…&#125;a:hover&#123;…&#125; 事实上，“:hover”伪类可以定义任何一个元素在鼠标经过时的样式。 鼠标样式对于鼠标样式的定义，我们有两种方式：浏览器鼠标样式和自定义鼠标样式。 cursor:取值; 浏览器 一般只会用到3个：default、pointer和text。 cursor:url（图片地址）,属性值; 自定义 , 鼠标图片后缀名一般都是“.cur” 盒子模型在“CSS盒子模型”理论中，页面中的所有元素都可以看成一个盒子，并且占据着一定的页面空间。 内容区有3个属性：width、height和overflow。当内容过多，超出width和height时，可以使用overflow属性来指定溢出处理方式。行内元素如span不可以设置width和height。行内元素设置的width和height无法生效，它的宽度和高度只能由内容区撑起来。可以使用display属性来将行内元素转换为块元素 内边距，又常常被称为“补白”，指的是内容区和边框之间的空间，可以看成是内容区的背景区域。 外边距，指的是两个盒子之间的距离，它可能是子元素与父元素之间的距离，也可能是兄弟元素之间的距离。CSS允许给外边距属性指定负数值，当外边距为负值时，整个盒子将向指定负值的相反方向移动，以此产生盒子的重叠效果，这就是传说中的“负margin技术”。 浮动布局正常文档流，又称为“普通文档流”或“普通流”，也就是W3C标准所说的“normal flow”。正常文档流的简单定义：“正常文档流，将一个页面从上到下分为一行一行，其中块元素独占一行，相邻行内元素在每一行中按照从左到右排列直到该行排满。” 脱离文档流，指的是脱离正常文档流。如果我们想要改变正常文档流，可以使用两种方法：浮动和定位。 float属性让元素向左浮动或者向右浮动，以便让周围的元素或文本环绕着这个元素。 浮动最常用于实现水平方向上的并排布局，如两列布局、多列布局 我们一般都是在浮动元素后面再增加一个空元素，然后为这个空元素定义“clear:both”来清除兄弟元素浮动。还有“overflow:hidden”，以及其他更为常用的伪元素。 浮动涉及的理论知识极其复杂，其中包括块元素和行内元素、CSS盒子模型、脱离文档流、BFC、层叠上下文。 优先使用浮动布局，不行再配合定位布局。 定位 固定定位，指的是被固定的元素不会随着滚动条的拖动而改变位置。先使用“position:fixed”让元素成为固定定位元素，接着使用top、bottom、left和right这4个属性来设置元素相对浏览器的位置。固定定位最常用于实现“回顶部特效” 相对定位，指的是该元素的位置是相对于它的原始位置计算而来的。不会脱离文档流 绝对定位在几种定位方式中使用最为广泛，因为它能够很精确地把元素定位到任意你想要的位置。一个元素变成了绝对定位元素，这个元素就完全脱离文档流了，绝对定位元素的前面或后面的元素会认为这个元素并不存在，此时这个元素浮于其他元素上面，已经完全独立出来了。也是相对浏览器的位置。 在默认情况下，元素没有指定position属性时，这个元素就是静态定位的。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://vergessenwang.github.io/tags/CSS/"}]},{"title":"HTML基础","slug":"HTML基础","date":"2020-06-01T14:53:25.000Z","updated":"2020-06-08T16:03:19.702Z","comments":true,"path":"posts/frontend/2020-06-01-HTML基础.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-06-01-HTML基础.html","excerpt":"学习笔记源自：绿叶 常用标签速览","text":"学习笔记源自：绿叶 常用标签速览 head在HTML中，一般来说，只有6个标签能放在head标签内。 meta标签：定义页面的特殊信息，如页面关键字、页面描述等。这些信息不是提供给用户看的，而是提供给搜索引擎蜘蛛。两个重要的属性：name和http-equiv。http-equiv属性只有两个重要作用：定义网页所使用的编码，定义网页自动刷新跳转。 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; 在HTML5标准中，简写为&lt;meta charset=&quot;utf-8&quot;/&gt;必须放在title标签以及其他meta标签前面 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;6;url=...&quot;/&gt; 当前页面在6秒后会自动跳转，很多“小广告”网站就是用这种方式来实现页面定时跳转的。 title标签：定义网页的标题。 style标签：定义元素的CSS样式 script标签：定义页面的JavaScript代码 link标签：用于引入外部样式文件（CSS文件） base标签 body静态页面和动态页面的区别在于是否与服务器进行数据交互。 文本在HTML中，共有6个级别的标题标签：h1、h2、h3、h4、h5、h6。其中h是header的缩写。一个页面一般只能有一个h1标签，而h2到h6标签可以有多个。其中，h1表示的是这个页面的大标题。h1~h6标题标签看起来很简单，但是在搜索引擎优化中却扮演着非常重要的角色。 title标签用于显示地址栏的标题，而h1标签用于显示文章的标题 使用“p标签”来显示一段文字。段落标签会自动换行，并且段落与段落之间有一定的间距。 换行，有两种方法：一种是“使用两个p标签”，另外一种是“使用br标签”。其中&lt;br/&gt;是自闭合标签，br是break（换行）的缩写。使用p标签会导致段落与段落之间有一定的间隙，而使用br标签则不会。br标签是用来给文字换行的，而p标签是用来给文字分段的。如果你的内容是两段文字，则不需要使用br标签换行那么麻烦，而是直接用两个p标签就可以了。 常用的文本标签有以下8种 粗体标签：strong、b。在实际开发中，如果想要对文本实现加粗效果，尽量使用strong标签，而不要使用b标签。这是因为strong标签比b标签更具有语义性。 斜体标签：i、em、cite。尽量使用em标签emphasized 上标标签：sup。superscripted（上标）的缩写 下标标签：sub。subscripted（下标）的缩写 中划线标签：s。 下划线标签：u。 大字号标签：big。 小字号标签：small。 后面4种完全可以使用CSS来代替 使用“hr标签”来实现一条水平线的效果。hr，是horizon（水平线）的缩写。 使用“div标签”来划分HTML结构，从而配合CSS来整体控制某一块的样式。div，全称division（分区），内部可以放入绝大多数其他的标签，如p标签、strong标签和hr标签等。 自闭合标签：由于只有开始符号而没有结束符号，因此不可以在内部插入标签或文字。 在HTML中，块元素在浏览器显示状态下将占据整一行，并且排斥其他元素与其位于同一行。一般情况下，块元素内部可以容纳其他块元素和行内元素。行内元素可以与其他行内元素位于同一行。行内元素内部可以容纳其他行内元素，但不可以容纳块元素。 HTML中，空格是需要用代码来实现的。其中，空格的代码是 &amp;nbsp;3个相当于一个字 特殊符号对应的代码，都是以“&amp;”开头，并且以“;”（英文分号）结尾的。 列表在HTML中，列表共有3种：有序列表、无序列表和定义列表。 有序列表ol标签和li标签需要配合一起使用，不可以单独使用，而且标签的子标签也只能是li标签，不能是其他标签。但是子标签内部可以有其他标签 可以使用type属性来改变列表项符号。在默认情况下，有序列表使用数字作为列表项符号。CSS之后，我们可以不再使用type属性，而应使用liststyle-type属性。 无序列表ul与ol类似 在实际的前端开发中，无序列表比有序列表更为实用。 定义列表由两部分组成：名词和描述。 12345&lt;dl&gt; &lt;dt&gt;名词&lt;/dt&gt; &lt;dd&gt;描述&lt;/dd&gt; ……&lt;/dl&gt; dl即definition list（定义列表），dt即definition term（定义名词），而dd即definition description（定义描述）。 HTML的精髓就在于标签的语义。在HTML中，大部分标签都有它自身的语义。例如，p标签，表示的是paragraph，标记的是一个段落；h1标签，表示的是header1，标记的是一个最高级标题。但div和span是无语义的标签，我们应该优先使用其他有语义的标签。 表格12345678910111213141516171819202122232425262728&lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;!--表头--&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表头单元格1&lt;/th&gt; &lt;th&gt;表头单元格2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!--表身--&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表行单元格1&lt;/td&gt; &lt;td&gt;表行单元格2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表行单元格3&lt;/td&gt; &lt;td&gt;表行单元格4&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;!--表脚--&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;标准单元格5&lt;/td&gt; &lt;td&gt;标准单元格6&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 一个表格只能有一个标题，也就是只能有一个caption标签。在默认情况下，标题位于整个表格的第一行。 tr指的是table row（表格行），th指的是table header cell（表头单元格），td指的是table data cell（表格单元格）。显示上：浏览器会以“粗体”和“居中”来显示th标签中的内容，但是td标签不会。 表脚（tfoot）往往用于统计数据。对于thead、tbody和tfoot标签，不一定需要全部都用上，如tfoot就很少用。thead、tbody和tfoot除了可以使代码更具有语义，还有另外一个重要作用：方便分块来控制表格的CSS样式。 使用rowspan属性来合并行。所谓的合并行，指的是将“纵向的N个单元格”合并。使用colspan属性来合并列。 图片&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; /&gt; alt属性用于图片描述，这个描述文字是给搜索引擎看的。当图片无法显示时，页面会显示alt中的文字。title属性也用于图片描述，不过这个描述文字是给用户看的。当鼠标指针移到图片上时，会显示title中的文字。在实际开发中，对于img标签，src和alt这两个是必选属性。一般都使用相对路径，几乎不会使用绝对路径。 位图，又叫作“像素图”，它是由像素点组成的图片。对于位图来说，放大图片后，图片会失真；缩小图片后，图片同样也会失真。最常见的位图的图片格式有3种（可以从图片后缀名看出来）：jpg（或jpeg）、png、gif。 jpg格式可以很好地处理大面积色调的图片，适合存储颜色丰富的复杂图片，如照片、高清图片等。此外，jpg格式的图片体积较大，并且不支持保存透明背景。 png格式是一种无损格式，可以无损压缩以保证页面打开速度。此外，png格式的图片体积较小，并且支持保存透明背景，不过不适合存储颜色丰富的图片。 gif格式的图片效果最差，不过它适合制作动画。支持透明背景。实际上，小伙伴们经常在QQ或微信上发的动图都是gif格式的。这里来总结一下：如果想要展示色彩丰富的高品质图片，可以使用jpg格式；如果是一般图片，为了减少体积或者想要透明效果，可以使用png格式；如果是动画图片，可以使用gif格式。 矢量图，又叫作“向量图”，是以一种数学描述的方式来记录内容的图片格式。举个例子，我们可以使用y=kx来绘制一条直线，当k取不同值时可以绘制不同角度的直线，这就是矢量图的构图原理。矢量图最大的优点是图片无论放大、缩小或旋转等，都不会失真。最大的缺点是难以表现色彩丰富的图片矢量图的常见格式有“.ai”“.cdr”“.fh”“.swf”。其中“.swf”格式比较常见，它指的是Flash动画 网页中的图片绝大多数都是位图，而不是矢量图。 现在的切图，指的是前端工程师拿到UI设计师的图稿时，需要分析页面的布局，哪些用CSS实现，哪些用图片实现，哪些用CSS Spirit实现等。 超链接使用a标签来实现超链接。即anchor锚点 &lt;a href=&quot;链接地址&quot;&gt;文本或图片&lt;/a&gt; 默认情况下，超链接都是在当前浏览器窗口打开新页面的。在HTML中，我们可以使用target属性来定义超链接打开窗口的方式。 超链接有两种：一种是外部链接，另外一种是内部链接。外部链接指向的是“外部网站的页面”，而内部链接指向的是“自身网站的页面”。 锚点链接，简单地说，就是单击某一个超链接，它就会跳到当前页面的某一部分。需要定义以下2个参数： 目标元素的id a标签的href属性指向该#id 表单表单最重要的作用就是在浏览器端收集用户的信息，然后将数据提交给服务器来处理。表单，指的是文本框、按钮、单选框、复选框、下拉列表等的统称。 在HTML中，表单标签有5种：form、input、textarea、select和option。必须要把所有表单标签放在form标签内部。 form method属性取值有两个：一个是“get”，另外一个是“post”。get的安全性较差，而post的安全性较好。所以在实际开发中，大多数情况下我们都是使用post。 target属性与a标签的target属性是一样的 enctype属性用于指定表单数据提交的编码方式。一般情况下，我们不需要设置，除非你用到上传文件功能。 inputinput是自闭合标签，它是没有结束符号的。其中type属性取值如表： 加上value属性，是为了方便JavaScript或者服务器操作数据。 密码文本框中输入的字符不可见，是一种特殊的单行文本框。密码文本框只能使周围的人看不见你输入的内容是什么，实际上它并不能保证数据的安全。 单选框&lt;input type=&quot;radio&quot; name=&quot;组名&quot; value=&quot;取值&quot; /&gt;name属性表示单选按钮所在的组名，而value表示单选按钮的取值，这两个属性必须要设置。对于这一组单选按钮，只能选中其中一项，而不能同时选中两项。这就是所谓的“单选框”。可以使用checked属性来实现默认选中 复选框与单选框类似。 常见的按钮有3种：普通按钮（button），提交按钮（submit），重置按钮（reset）。普通按钮一般情况下都是配合JavaScript来进行各种操作的。提交按钮一般都是用来给服务器提交数据的。重置按钮一般用来清除用户在表单中输入的内容。 textarea&lt;textarea rows=&quot;行数&quot; cols=&quot;列数&quot; value=&quot;取值&quot;&gt;默认内容&lt;/textarea&gt; select和option下拉列表是由select和option这两个标签配合使用来表示的。 12345&lt;select&gt; &lt;option&gt;选项内容&lt;/option&gt; …… &lt;option&gt;选项内容&lt;/option&gt;&lt;/select&gt; 如果想要同时选取多项，首先要设置multiple属性，然后使用“Ctrl+鼠标左键”来选取。将size取值设置为1、2或3时，会发现Chrome浏览器无效。这是因为Chrome浏览器要求最低是4个选项 selected属性表示列表项是否被选中 框架使用iframe标签来实现一个内嵌框架。内嵌框架，是指在当前页面再嵌入另外一个网页。&lt;iframe src=&quot;链接地址&quot; width=&quot;数值&quot; depth=&quot;数值&quot;&gt;&lt;/iframe&gt;","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://vergessenwang.github.io/tags/HTML/"}]},{"title":"VS Code常用前端插件","slug":"VS-Code常用前端插件","date":"2020-05-30T13:28:37.000Z","updated":"2020-05-30T13:30:05.654Z","comments":true,"path":"posts/frontend/2020-05-30-VS-Code常用前端插件.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-05-30-VS-Code常用前端插件.html","excerpt":"Eslint：JavaScript代码检测, JavaScript代码风格检测, JavaScript代码自动格式化 vue vetur: vue代码高亮，智能提示 vue 2 snippets: 自动补全 HTML CSS Support: 代码提示 htmltagwrap：外面嵌套标签 IntelliSense for CSS class names in HTML: 类名补全 Auto Rename Tag: 同时更改头尾标签 Path Autocomplete：路径补全 Image preview： 图片预览 JavaScript (ES6) code snippets: js代码提示 Quokka.js ：观察js变量变化(这个太强了) EJS language support","text":"Eslint：JavaScript代码检测, JavaScript代码风格检测, JavaScript代码自动格式化 vue vetur: vue代码高亮，智能提示 vue 2 snippets: 自动补全 HTML CSS Support: 代码提示 htmltagwrap：外面嵌套标签 IntelliSense for CSS class names in HTML: 类名补全 Auto Rename Tag: 同时更改头尾标签 Path Autocomplete：路径补全 Image preview： 图片预览 JavaScript (ES6) code snippets: js代码提示 Quokka.js ：观察js变量变化(这个太强了) EJS language support Debugger for Firefox: 浏览器调试，可以打断点 GitLens: git日志插件 open in browser: 浏览器预览 Browser Preview：右侧分屏实时预览(单屏实用)，要预装Debugger for Chrome live server: 在本地开启一个端口显示网页 Community Material Theme: 更换主题 ctrl+p选择 Dracula Official: 我觉得这款主题更好看 vscode-icons: 文件图标 Bracket Pair Colorizer 2: 括号颜色 indent-rainbow: 缩进颜色 leetcode: 你懂我的意思吧 注意点击前面那个小球球切换到中国版，不然登陆不上去 哇，这样刷leetcode也太快乐了吧～～","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://vergessenwang.github.io/tags/IDE/"}]},{"title":"模板引擎","slug":"模板引擎","date":"2020-05-28T16:02:40.000Z","updated":"2020-05-28T17:23:48.574Z","comments":true,"path":"posts/frontend/2020-05-29-模板引擎.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-05-29-模板引擎.html","excerpt":"模板引擎不属于特定技术领域，是为了使用户界面与业务数据（内容）分离而产生的，是跨领域跨平台的概念。严格的模板引擎的定义是，输入模板字符串+数据，得到渲染过的字符串（页面）。 后端服务器的资源是有限的，并且对数据的处理是随着用户数量的增加而叠加的，用户的每一次操作，页面渲染都是在消耗服务器资源，少量的用户操作或许不会导致服务器卡顿，但是当出现成千上万甚至更多的用户时，可能仅是网络请求就会让服务器无响应甚至宕机（参照春运）。而如果将页面的渲染放在用户端（前端），用户只有一个，几十毫秒的渲染时间跟请求延迟比起来根本算不上瓶颈，所以既可以提高用户的体验，同时也减轻了服务器的压力。 通常我们将渲染方法设计为render()，参数就是模板路径和数据。render()我们可以将其看成是一个约定接口，接受相同参数，最后返回HTML片段。这样的方法我们都视作实现了这个接口。如： 形成模板技术的也就如下4个要素。❑ 模板语言。❑ 包含模板语言的模板文件。❑ 拥有动态数据的数据对象。❑ 模板引擎。 实现上，从正则替换的方式到拼写字符串直接输入，再到AST解析，存在各种输出页面内容的方式，但从定义上来说都是差不多的。 前端模板引擎分为两种，基于字符串的模板引擎和基于JavaScript的模板引擎。 模板引擎主要有以下几个步骤。❑ 语法分解。提取出普通字符串和表达式，这个过程通常用正则表达式匹配出来❑ 处理表达式。将标签表达式转换成普通的语言表达式。❑ 生成待执行的语句。❑ 与数据一起执行，生成最终字符串。","text":"模板引擎不属于特定技术领域，是为了使用户界面与业务数据（内容）分离而产生的，是跨领域跨平台的概念。严格的模板引擎的定义是，输入模板字符串+数据，得到渲染过的字符串（页面）。 后端服务器的资源是有限的，并且对数据的处理是随着用户数量的增加而叠加的，用户的每一次操作，页面渲染都是在消耗服务器资源，少量的用户操作或许不会导致服务器卡顿，但是当出现成千上万甚至更多的用户时，可能仅是网络请求就会让服务器无响应甚至宕机（参照春运）。而如果将页面的渲染放在用户端（前端），用户只有一个，几十毫秒的渲染时间跟请求延迟比起来根本算不上瓶颈，所以既可以提高用户的体验，同时也减轻了服务器的压力。 通常我们将渲染方法设计为render()，参数就是模板路径和数据。render()我们可以将其看成是一个约定接口，接受相同参数，最后返回HTML片段。这样的方法我们都视作实现了这个接口。如： 形成模板技术的也就如下4个要素。❑ 模板语言。❑ 包含模板语言的模板文件。❑ 拥有动态数据的数据对象。❑ 模板引擎。 实现上，从正则替换的方式到拼写字符串直接输入，再到AST解析，存在各种输出页面内容的方式，但从定义上来说都是差不多的。 前端模板引擎分为两种，基于字符串的模板引擎和基于JavaScript的模板引擎。 模板引擎主要有以下几个步骤。❑ 语法分解。提取出普通字符串和表达式，这个过程通常用正则表达式匹配出来❑ 处理表达式。将标签表达式转换成普通的语言表达式。❑ 生成待执行的语句。❑ 与数据一起执行，生成最终字符串。 基于字符串的模板引擎就是通过字符串替换的方式，来渲染出HTML，再将HTML插入DOM节点中，其代表性框架有Mustache和Handlebars.js。 从软件架构上来看，Mustache提供了多语言的版本，即官方提供了诸如Python、Java、Ruby等语言的模板引擎。因为前后台共用这些模板，它可以使得后台渲染变得相当容易。只需要读取对应的模板文件，就可以将Model填充到数据中。 其基本原理是，全局正则匹配模板关键字，再从传入的data中找到是否有对应的值，如data中存在对象，则使用该值进行替换，否则该值为空。 基于字符串的模板引擎在更新DOM的时候会更新所有DOM节点，这时浏览器需要重新渲染所有的节点。当我们拥有大量的HTML元素或DOM操作时，如果每次都刷新整个DOM节点，显然是不合适的。 基于JavaScript的模板引擎基于JavaScript的模板引擎的表现形式是，将模板转义为JavaScript，在执行的过程中，再动态更新所需要的DOM节点。相应的逻辑如下：（1）将模板编译为某种DSL（领域特别语言），比如HyperScript或者JavaScript对象（代码+数据），创建虚拟的树（AST树）。（2）在使用时，通过这个虚拟树来创建一个DOM节点。（3）（可选）当发生变更时，通过DOM Diff算法来替换对应的修改结点。 它和基于字符串的模板引擎的区别主要在于第三点，是否全局替换DOM节点。比如Virtual DOM，就是带一个Dom Diff的JavaScript模板引擎，在进行大量DOM操作的时候，由于只对变化的DOM进行替换，可以提高前端应用的性能。 Vue的render实现template 模板 通过 Compile 编译 得到 render函数。 compile 编译可以分成 parse、optimize 与 generate 三个阶段，最终需要得到 render function。 其实就是Vnode+data 123456789101112131415161718192021222324252627282930&lt;div id=”app“&gt; &lt;p&gt;&#123;&#123;price&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;/*** _c : 创建dom标签* _v : 创建文本节点* _s : toString*/var vm = new Vue(&#123; el: ’\\#app‘, data: &#123; price: 100 &#125;&#125;) // 这个模板最终生成的函数是下面这个 // 以下是手写的 render 函数function render() &#123; with(this) &#123; // this 就是 vm return _c( ’div‘, &#123; attrs: &#123;’id‘: ’app‘&#125; &#125;, [ _c(’p‘, [_v(_s(price))]) ] ) &#125; _c即$createElement 的实现（如何创建Vnode）： vue的整个实现流程简易说明第一步：解析模板成 render 函数第二步：响应式开始监听第三步：首次渲染，显示页面，且绑定依赖第四步：data 属性变化，触发 rerender 把模板解析为 render 函数 运用 with，模板中的所有信息都被 render 函数包含；模板中用到的 data 中的属性，都变成了 JS 变量；模板中的 v-model v-for v-on 都变成了 JS 逻辑；render 函数返回 vnode 响应式开始监听 Object.defineProperty 将data 的属性代理到 vm 上 首次渲染，显示页面且绑定依赖 初次渲染，执行 updateComponent, 执行vm._render()；执行 render 函数，会访问到 data 下的数据，被响应式的 get 方法监听到；执行 updateComponent，会走到 vdom 的 patch 方法；patch 将 vnode 渲染成 DOM，初次渲染完成 data 属性变化，触发 rerender 修改属性，被响应式的 set 监听到；set 中执行 updateComponent；updateComponent 重新执行 vm._render()；生成的 vnode 和 prevVnode ，通过 patch 进行对比；渲染到 html 中 一个简明的js实现123456789101112131415 var TemplateEngine = function(html, options) &#123; var re = /&lt;%([^%&gt;]+)?%&gt;/g, reExp = /(^( )?(if|for|else|switch|case|break|&#123;|&#125;))(.*)?/g, code = ’var r=[];\\n‘, cursor = 0; var add = function(line, js) &#123; js? (code += line.match(reExp) ? line + ’\\n‘ : ’r.push(‘ + line + ’);\\n‘) : (code += line != ’‘ ? ’r.push(”‘ + line.replace(/“/g, ’\\\\”‘) + ’“);\\n‘ : ’‘); return add; &#125; while(match = re.exec(html)) &#123; add(html.slice(cursor, match.index))(match[1], true); cursor = match.index + match[0].length; &#125; add(html.substr(cursor, html.length - cursor)); code += ’return r.join(”“);‘; return new Function(code.replace(/[\\r\\t\\n]/g, ’‘)).apply(options);&#125; 从编译角度理解v-if和v-show的区别v-if编译成了三元运算符同时还可以解释为什么连用时v-for比v-if优先级高。所以最好在外面嵌套一个template，把v-if放在外层。或者用计算属性先过滤 v-show编译成了指令","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://vergessenwang.github.io/tags/vue/"}]},{"title":"PytorchText语言翻译Tutorial使用","slug":"PytorchText语言翻译Tutorial使用","date":"2020-05-27T15:48:51.000Z","updated":"2020-05-27T15:49:50.178Z","comments":true,"path":"posts/NLP/2020-05-27-PytorchText语言翻译Tutorial使用.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2020-05-27-PytorchText语言翻译Tutorial使用.html","excerpt":"使用TORCHTEXT进行语言翻译 pip install scapy 之后发现语言包下不下来。官方语言库 手动下载 en_core_web_sm-2.2.5.tar.gz de_core_news_sm-2.2.5.tar.gz 但是github仍然下载受限 于是找到了网友分享的链接： en_core_web_sm-2.2.5：下载 x9vc 因为最终要做的是中英文翻译，直接找了一个中文库：Chinese_models_for_SpaCy 进入存放目录 pip install en_core_web_sm-2.2.5.tar.gz 进行安装 12&gt;&gt;&gt;import spacy&gt;&gt;&gt;nlp = spacy.load(\"en_core_web_sm\") 检测是否安装成功 为了方便使用本来想设置一下简写 spacy link en_core_web_sm en 但是spacy命令无法识别，可能要用管理员身份安装吧。但是因为用虚拟环境弄的，不想把路径弄坏了，就此作罢。 然而导入中文包时出错 ValueError: could not broadcast input array from shape (128) into shape (96)","text":"使用TORCHTEXT进行语言翻译 pip install scapy 之后发现语言包下不下来。官方语言库 手动下载 en_core_web_sm-2.2.5.tar.gz de_core_news_sm-2.2.5.tar.gz 但是github仍然下载受限 于是找到了网友分享的链接： en_core_web_sm-2.2.5：下载 x9vc 因为最终要做的是中英文翻译，直接找了一个中文库：Chinese_models_for_SpaCy 进入存放目录 pip install en_core_web_sm-2.2.5.tar.gz 进行安装 12&gt;&gt;&gt;import spacy&gt;&gt;&gt;nlp = spacy.load(\"en_core_web_sm\") 检测是否安装成功 为了方便使用本来想设置一下简写 spacy link en_core_web_sm en 但是spacy命令无法识别，可能要用管理员身份安装吧。但是因为用虚拟环境弄的，不想把路径弄坏了，就此作罢。 然而导入中文包时出错 ValueError: could not broadcast input array from shape (128) into shape (96) 回头看了一下，spacy是2.2.4版本，然后issue有人遇到了同样的问题，好像并没有很好的解决方法？ 算了，用NLTK吧… 吃惊，我居然装过了，我明明都还没下数据包呢 找了一下路径，想起来有一次在另一个虚拟环境的时候差点被这个路径问题弄疯…见此文) 看来不同的虚拟环境都可以扫描到。事实证明以前踩的坑还是有用的.. 过了一会德语包居然又能下了，于是还是用spacy, 先熟悉一下训练流程。 Jupyter使用conda install jupyter notebook 安装 jupyter notebook 启动8888端口，默认居然启动的是IE，复制CMD中的地址，注意要带上token, 就可以在其他浏览器打开了 这不就是我之前在ModelArts里面用过的界面吗…原来那个也是Jupyter啊 右上角新建一个notebook 安装 texlive-xetex 便于导出为PDF H：查看所有快捷键。 S：保存当前 Notebook 内容。 P：调出 Notebook 命令栏。 B：在当前单元格下方新建空白单元格。 M：将单元格格式转换为 Markdown。 Y：将单元格格式转换为 Code。 连续按 D+D：删除当前单元格。（慎用，推荐使用 X 剪切单元格代替，因为其可以起到删除效果，且删错了还可以粘贴回来） 连续按 I+I+I：强制中止内核（当某个单元格执行时间较长或卡住时，可以强行中止，中止后前序单元格状态依旧保留，非常好用。） Shift + Enter：运行当前单元格内容。（当 Markdown 单元格处于编辑状态时，运行即可复原） 训练过程按照tutorial给的步骤尝试训练 因为是手动下载的并且没有link tokenizer_language=&quot;de&quot; 要改成对应的下载包名 en_core_web_sm de_core_news_sm 开始训练了 2000 years later…. 小霸王这训练速度我裂开了….等我有钱了我也要买2080Ti 换到台式机上，先装了Anoconda再安依赖包 1pip install torch===1.5.0 torchvision===0.6.0 -f https://download.pytorch.org/whl/torch_stable.html https://download.pytorch.org/whl/torch_stable.html 半天下不下来，直接去网站下了，我服了 cu102/torch-1.5.0-cp37-cp37m-win_amd64.whl cu102/torchvision-0.6.0-cp37-cp37m-win_amd64.whl 然后 12conda install cudatoolkit=10.2pip install tensorflow tensorboard jieba torchtext spacy-2.2.0-cp37-cp37m-win_amd64.whl 看看2.0版本能不能用中文包, 结果发现还是有问题。 还是继续用2.2.4, 试了一下可以跑，但是速度10m一个epoch, 依然很慢 检查了一下 发现 torch.cuda.is_available() == false , 原来没有用上显卡…虽然我的是几年前拉跨的960了，还是要物尽其用啊。 尝试一下有没有什么解决方法： 看了一个显卡驱动版本是388，先用驱动精灵升级到442,升级出现问题nvidia驱动和window版本不兼容,先更新系统。 我的台式机，不愧是你，还是17年更新过一次。 https://www.geforce.cn/drivers 下载英伟达官方驱动更新程序，尝试更新到445成功。 再检查torch.cuda.is_available()变为true了 再次运行，好啦，1m一个epoch，不愧是GPU啊，可以开始愉快的写模型了~ 结合tensorboard中途装了一下tensorflow由于版本问题并不能运行。 于是看到一个叫tensorboardx的工具 https://github.com/lanpa/tensorboardX","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"Pytorch","slug":"Pytorch","permalink":"http://vergessenwang.github.io/tags/Pytorch/"}]},{"title":"Vue异步更新原理","slug":"Vue异步更新原理","date":"2020-05-22T07:13:52.000Z","updated":"2020-05-22T07:14:31.950Z","comments":true,"path":"posts/frontend/2020-05-22-Vue异步更新原理.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-05-22-Vue异步更新原理.html","excerpt":"Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 为了在数据更新操作之后操作DOM，我们可以在数据变化之后立即使用Vue.nextTick(callback)；这样回调函数会在DOM更新完成后被调用，就可以拿到最新的DOM元素了。","text":"Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 为了在数据更新操作之后操作DOM，我们可以在数据变化之后立即使用Vue.nextTick(callback)；这样回调函数会在DOM更新完成后被调用，就可以拿到最新的DOM元素了。 nextTick原理 把回调函数放入callbacks等待执行 将执行函数放到微任务或者宏任务中 事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调 我们每次调用$nextTick的过程其实就是在向callbacks新增回调函数的过程。 对当前环境进行不断的降级处理，尝试使用原生的Promise.then、MutationObserver和setImmediate，上述三个都不支持最后使用setTimeout；降级处理的目的都是将flushCallbacks函数放入微任务或者宏任务，等待下一次事件循环时来执行。MutationObserver是Html5的一个新特性，用来监听目标DOM结构是否改变，也就是代码中新建的textNode；如果改变了就执行MutationObserver构造函数中的回调函数，不过是它是在微任务中执行的。 flushCallbacks，把callbacks数组复制一份，然后把callbacks置为空，最后把复制出来的数组中的每个函数依次执行一遍；所以它的作用仅仅是用来执行callbacks中的回调函数。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://vergessenwang.github.io/tags/vue/"}]},{"title":"Vue生命周期","slug":"Vue生命周期","date":"2020-05-21T12:51:05.000Z","updated":"2020-05-21T12:53:44.701Z","comments":true,"path":"posts/frontend/2020-05-21-Vue生命周期.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-05-21-Vue生命周期.html","excerpt":"所谓“生命周期”，是指实例对象从构造函数开始执行（被创建）到被GC（Garbage Collection，垃圾回收）回收销毁的整个存在时期，在生命周期中被自动调用的函数叫作生命周期函数，也被形象地称为生命周期钩子函数。 可以利用不同时期的钩子函数去完成不同的操作。例如需要在某个时期去获取后台数据、在某个时期去更新数据等。利用生命周期钩子函数可以精准定位到某个时期去完成一些特定的事情。 beforeCreate：在实例开始初始化时同步调用，在组件实例刚被创建的时候增加一些loading事件。此时数据观测、事件等都尚未初始化。data不可见 created：在实例创建之后调用。此时已完成数据观测、属性和方法的运算，watch/event事件回调。但尚未开始DOM编译，即未挂载到document中。$el属性不可见 beforeMount：在mounted之前运行。相关render函数首次被调用 mounted：在编译结束时调用。此时所有指令已生效，数据变化已能触发DOM更新，但不保证$el已插入文档。 beforeUpdate：在实例挂载之后，再次更新实例（如更新data）时会调用该方法，此时尚未更新DOM结构。 updated：在实例挂载之后，再次更新实例并更新完DOM结构后调用。注意监听的是DOM而不是数据。该钩子在服务器端渲染时不会被调用 beforeDestroy：在开始销毁实例时调用，此刻实例仍然有效。该钩子在服务器端渲染时不会被调用 destroyed：在实例被销毁之后调用。此时所有绑定和实例指令都已经解绑，子实例也被销毁。该钩子在服务器端渲染时不会被调用 activated：需要配合动态组件keep-live属性使用。在动态组件初始化渲染的过程中调用该方法。 deactivated：需要配合动态组件keep-live属性使用。在动态组件初始化移出的过程中调用该方法。","text":"所谓“生命周期”，是指实例对象从构造函数开始执行（被创建）到被GC（Garbage Collection，垃圾回收）回收销毁的整个存在时期，在生命周期中被自动调用的函数叫作生命周期函数，也被形象地称为生命周期钩子函数。 可以利用不同时期的钩子函数去完成不同的操作。例如需要在某个时期去获取后台数据、在某个时期去更新数据等。利用生命周期钩子函数可以精准定位到某个时期去完成一些特定的事情。 beforeCreate：在实例开始初始化时同步调用，在组件实例刚被创建的时候增加一些loading事件。此时数据观测、事件等都尚未初始化。data不可见 created：在实例创建之后调用。此时已完成数据观测、属性和方法的运算，watch/event事件回调。但尚未开始DOM编译，即未挂载到document中。$el属性不可见 beforeMount：在mounted之前运行。相关render函数首次被调用 mounted：在编译结束时调用。此时所有指令已生效，数据变化已能触发DOM更新，但不保证$el已插入文档。 beforeUpdate：在实例挂载之后，再次更新实例（如更新data）时会调用该方法，此时尚未更新DOM结构。 updated：在实例挂载之后，再次更新实例并更新完DOM结构后调用。注意监听的是DOM而不是数据。该钩子在服务器端渲染时不会被调用 beforeDestroy：在开始销毁实例时调用，此刻实例仍然有效。该钩子在服务器端渲染时不会被调用 destroyed：在实例被销毁之后调用。此时所有绑定和实例指令都已经解绑，子实例也被销毁。该钩子在服务器端渲染时不会被调用 activated：需要配合动态组件keep-live属性使用。在动态组件初始化渲染的过程中调用该方法。 deactivated：需要配合动态组件keep-live属性使用。在动态组件初始化移出的过程中调用该方法。 后两张的运用例子可以用来进行缓存优化，避免重复加载。 另外还有两个钩子函数beforeRouteEnter和beforeRouteLeave可以配合路由切换使用。 有一点需要注意，在Vue 2.0中，mounted钩子触发时并不保证元素已经被添加到DOM上。如果想保证元素已经被添加，可以调用Vue.nextTick()方法（也可以通过this.$nextTick()调用）并传入一个回调函数，在回调函数中添加需要在元素被添加到DOM之后运行的代码。 通过以上分析总结Vue生命周期在真实场景下的业务应用如下 created：进行AJAX请求异步数据的获取、初始化数据。 123456created() &#123; fetch('url') .then(function(response) &#123; console.log(response) &#125;)&#125; mounted：挂载元素内DOM节点的获取。可以发起后端请求，取回数据，接收页面之间传递的参数、由子组件向父组件传递参数等。 nextTick：针对单一事件更新数据后立即操作DOM。 updated：数据更新的统一业务逻辑处理。 watch：监听具体数据变化，并做相应的处理。 最后一个应该是beforeDestroy","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://vergessenwang.github.io/tags/vue/"}]},{"title":"Vue渲染方法","slug":"Vue渲染方法","date":"2020-05-20T09:57:07.000Z","updated":"2020-05-21T12:52:56.347Z","comments":true,"path":"posts/frontend/2020-05-20-Vue渲染方法.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-05-20-Vue渲染方法.html","excerpt":"当获取到后端数据后，我们会把它按照一定的规则加载到写好的模板中，输出成在浏览器中显示的HTML，这个过程就称之为渲染。而Vue.js是在前端（即浏览器内）进行的模板渲染。 早期的Web项目一般是在服务器端进行渲染，服务器进程从数据库获取数据后，利用后端模板引擎，甚至于直接在HTML模板中嵌入后端语言（例如JSP），将数据加载进来生成HTML，然后通过网络传输到用户的浏览器中，然后被浏览器解析成可见的页面。而前端渲染则是在浏览器里利用JS把数据和HTML模板进行组合。两种方式各有自己的优缺点，需要更具自己的业务场景来选择技术方案。 前端渲染的优点在于：① 业务分离，后端只需要提供数据接口，前端在开发时也不需要部署对应的后端环境，通过一些代理服务器工具就能远程获取后端数据进行开发，能够提升开发效率。② 计算量转移，原本需要后端渲染的任务转移给了前端，减轻了服务器的压力。 而后端渲染的优点在于：① 对搜索引擎友好。② 首页加载时间短，后端渲染加载完成后就直接显示HTML，但前端渲染在加载完成后还需要有段js渲染的时间。 Vue.js 2.0开始支持服务端渲染，从而让开发者在使用上有了更多的选择。","text":"当获取到后端数据后，我们会把它按照一定的规则加载到写好的模板中，输出成在浏览器中显示的HTML，这个过程就称之为渲染。而Vue.js是在前端（即浏览器内）进行的模板渲染。 早期的Web项目一般是在服务器端进行渲染，服务器进程从数据库获取数据后，利用后端模板引擎，甚至于直接在HTML模板中嵌入后端语言（例如JSP），将数据加载进来生成HTML，然后通过网络传输到用户的浏览器中，然后被浏览器解析成可见的页面。而前端渲染则是在浏览器里利用JS把数据和HTML模板进行组合。两种方式各有自己的优缺点，需要更具自己的业务场景来选择技术方案。 前端渲染的优点在于：① 业务分离，后端只需要提供数据接口，前端在开发时也不需要部署对应的后端环境，通过一些代理服务器工具就能远程获取后端数据进行开发，能够提升开发效率。② 计算量转移，原本需要后端渲染的任务转移给了前端，减轻了服务器的压力。 而后端渲染的优点在于：① 对搜索引擎友好。② 首页加载时间短，后端渲染加载完成后就直接显示HTML，但前端渲染在加载完成后还需要有段js渲染的时间。 Vue.js 2.0开始支持服务端渲染，从而让开发者在使用上有了更多的选择。 条件渲染为元素挂上v-if指令即可，与之配套的还有v-else-if和v-else。v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回除了 false，0，&quot;&quot;，null，undefined 和 NaN 外的值的时候被渲染。 v-show也可以用于实现条件渲染，不过它只是简单地切换元素的CSS属性：display。 v-if和v-show的区别相对于v-if来说，v-show并不能算作真正的条件渲染，因为挂载它的多个元素之间并没有条件上下文关系。v-show判定为假的元素的display属性被赋值为none，不过仍保留在DOM中，而v-if判定为假的元素则根本没有在DOM中出现。v-if引起了dom操作级别的变化，而v-show仅发生了样式的变化，从切换的角度考虑，v-show消耗的性能要比v-if小。 除此之外，v-if切换时，Vue.js会有一个局部编译/卸载的过程，因为v-if中的模板也可能包括数据绑定或子组件。v-if会确保条件块在切换当中适当地销毁与中间内部的事件监听器和子组件。而且v-if是惰性的，如果在初始条件为假时，v-if本身什么都不会做，而v-show则仍会进行正常的操作，然后把css样式设置为display:none。 几个注意点●v-if会在切换中将组件上的事件监听器和子组件销毁和重建。当组件被销毁时，它将无法被任何方式获取，因为它已不存在于DOM中。●在创建父组件时，如果子组件的v-if被判定为假，Vue不会对子组件做任何事情，直到第一次判定为真时。这在使用Vue生命周期钩子函数时要尤为注意，如果生命周期已走过组件创建的阶段，却仍无法获取组件对象，想一想，是不是v-if在作怪。●一般来说，v-if 会牵涉到虚拟 DOM diff 算法，有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。●v-show不支持template元素 列表渲染v-for用于实现列表渲染，可以使用item in items或者item of items的语法 语法v-for = &#39; (item, index) in items&#39;➢ item表示每次遍历得到的元素➢ index表示item的索引，为可选参数➢ items表示数组或者对象 如上所示是一个双层循环。第一层遍历数组，第二层遍历数组中对象的键值对。在遍历对象时，是按Object.keys()的结果进行遍历，但是不能保证它的结果在不同的JavaScript引擎下是一致的。 除了数组和对象，v-for还可以接受单个整数，用作循环次数 Vue会把数组当作被观察者加入响应式系统中，当调用一些方法修改数组时，对应的视图将会同步更新。 上面这些数组操作方法，会直接改变原始数组称为变异方法，会促使视图自动更新。 非变异方法，例如：filter()、slice()、concat()，他们都是返回一个新数组，那么，在 Vue 中使用到这些方法，怎么样才能促使视图更新呢？我们就必须使用数组替换法，将非变异方法返回的新数组直接赋值给的旧数组 如：this.nav = this.nav.slice(1,4) 采用set方法去更新值因为Vue.js对data中数组的原生方法进行了封装，所以在改变数组时能触发视图更新，但以下两种情况是无法触发视图更新的：① 通过索引直接修改数组元素，例如vm.items[0] = { title : ‘title-changed’}; —使用下标／键名为数组／对象设置成员时② 无法直接修改“修改数组”的长度，例如：vm.items.length = 0 对于第一种情况，Vue.js提供了$set方法或者其他能引起原始数组改变的方法： 1234// Vue.setVue.set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 同样对于对象而言，由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除，直接进行修改操作是不会构成响应式，不会触发视图更新。必须使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性 key属性在列表渲染的时候，为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue1.0可以通过trace-by给数组设定唯一标识绑定，这样，Vue.js在渲染过程中会尽量复用原有对象的作用域及DOM元素。 在Vue.js 2.2.0以上的版本里，当在组件中使用v-for时，key是必须的，然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，需要使用props： 1&lt;my-component v-for=\"(item, index) in items\" v-bind:item=\"item\" v-bind:index=\"index\" v-bind:key=\"item.id\" &gt;&lt;/my-component&gt; 不能自动将item注入到组件里的原因是，会使组件与v-for的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。 具体来说，当使用v-for更新已渲染过的元素列表时，默认用“就地复用”策略。如果数据项的顺序被改变，Vue.js将不会移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时DOM状态（如表单输入值）的列表渲染输出。所以为了给Vue.js一个提示，以便能跟踪每个节点的身份，从而重用和重新排序现有元素，开发者需要为每项提供一个唯一的key属性。 显示过滤显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性或者直接用方法。 可以视为一种缓存？有点像数据库里的view 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;span v-for=\"number in oddNumber\"&gt;&#123;&#123;number&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; numberArray:[1,2,3,4,5,6,7,8] &#125;, computed: &#123; //计算 numberArray 中为奇数的 oddNumber 奇数数组 oddNumber:function()&#123; return this.numberArray.filter(function(number)&#123; return number%2===1 &#125;) &#125; &#125;, &#125;)&lt;/script&gt; 同时使用两种渲染方式可以配合起来使用 12345678910111213141516 &lt;div id=\"app\"&gt; &lt;div v-if=\"numbers.length\"&gt; &lt;div v-for=\"item in numbers\"&gt; &#123;&#123;item&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;div style=\"color:red\" v-else&gt;请添加数组元素&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:'#app', data:&#123; numbers:[1,2,3,4] &#125; &#125;)&lt;/script&gt; 对于这两种渲染方式，如何要同时处理多个DOM元素，可以放在template标签内。但template标签本身不会显示在DOM渲染结果中。注意v-show不支持template元素 当它们处于同一节点，v-for的优先级比v-if更高，这意味着v-if将分别重复运行于每个v-for循环中。 Vue.js 2.0新特性与渲染有关的主要是两个方面，Render函数和服务端渲染。Render函数给开发者提供了自由度更高的模板编程能力，而不仅仅局限于之前的v-if/v-else指令。服务端渲染则为SPA项目提供了有利于SEO和网络情况慢的解决方案，弥补了纯粹前端渲染的一些弊端。 Render函数除了给定的两种渲染方式以外，还可以用render自定义渲染函数，通过参数动态地加载组件选项 Render函数中主要提供了createElement方法 函数化组件是一个没有状态（data）和没有实例（this上下文）的一种组件类型，只通过render函数进行渲染，以及render函数中新增的context参数来传递上下文。由于不存在状态和上下文，组件的渲染开销就比较低，常用于不含具体模板，但根据所传参数可以生成具体类型组件的情况（有点类似于abstract class） 服务端渲染主要依赖于Vue-server-renderer，由它提供了方法将Vue.js实例转化成HTML字符串形式。 这部分以后再看吧","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://vergessenwang.github.io/tags/vue/"}]},{"title":"Vue响应式原理","slug":"Vue响应式原理","date":"2020-05-19T13:37:08.000Z","updated":"2020-05-21T12:52:47.443Z","comments":true,"path":"posts/frontend/2020-05-19-Vue响应式原理.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-05-19-Vue响应式原理.html","excerpt":"“响应式”，是指当数据改变后，Vue 会通知到使用该数据的代码。例如，视图渲染中使用了数据，数据改变后，视图也会自动更新。 Vue中最重要的概念就是响应式数据，一方面指衍生数据和元数据之间的响应，通过数据链来实现；另一方面则是指视图与数据之间的绑定。 数据链得益于数据链，在Vue中我们可以通过修改元数据的值来触发一系列数据的更新。当你修改数据起点时，所有存在在网上的节点值都将同步更新 衍生数据应该怎样实现从而保证其值只依赖于元数据而不允许被外界修改呢？ 通过函数式编程，衍生数据也得以实现。函数式编程的核心是根据元数据生成新的衍生数据，提供唯一确定的输入，函数将返回唯一确定的输出，它并不会修改原有变量的值。这在运用JS闭包概念进行开发时尤为重要，在函数作用域内调用域外或全局的变量时并不会修改它们的值。实际上，函数式编程就是建立了一条数据流通的链路，开发者只需要关注输入和输出两端的内容就可以，这是封装复用的一种最佳实践","text":"“响应式”，是指当数据改变后，Vue 会通知到使用该数据的代码。例如，视图渲染中使用了数据，数据改变后，视图也会自动更新。 Vue中最重要的概念就是响应式数据，一方面指衍生数据和元数据之间的响应，通过数据链来实现；另一方面则是指视图与数据之间的绑定。 数据链得益于数据链，在Vue中我们可以通过修改元数据的值来触发一系列数据的更新。当你修改数据起点时，所有存在在网上的节点值都将同步更新 衍生数据应该怎样实现从而保证其值只依赖于元数据而不允许被外界修改呢？ 通过函数式编程，衍生数据也得以实现。函数式编程的核心是根据元数据生成新的衍生数据，提供唯一确定的输入，函数将返回唯一确定的输出，它并不会修改原有变量的值。这在运用JS闭包概念进行开发时尤为重要，在函数作用域内调用域外或全局的变量时并不会修改它们的值。实际上，函数式编程就是建立了一条数据流通的链路，开发者只需要关注输入和输出两端的内容就可以，这是封装复用的一种最佳实践 Vue实例提供了computed计算属性选项，以供开发者生成衍生数据对象。虽然计算属性以函数形式声明，却并不接受参数，也只能以属性的方式调用。由于计算属性的this指向Vue实例，所以它可以获取实例上所有已挂载的可见属性。 一般在模板语法内使用表达式非常便利，模板也只用于简单的运算，当表达式过于复杂时，在模板中放入太多逻辑会让模板过重且难以维护。为此，Vue提供了计算属性computed。可以像绑定普通属性一样在模板中绑定计算属性。当你的计算属性的依赖数据发生改变时，你的相关计算属性也会重新计算。引用了计算属性computed后，就可将复杂的逻辑放入计算中进行处理，同时computed有缓存功能，可防止复杂计算逻辑多次调用引起的性能问题。即在 Vue 中计算属性是 惰性的，只有当依赖数据发生改变时，才会触发计算，否则，它的值是上一次触发计算的缓存值。注意是改变依赖的数据而不是改变数据的值！ 原模版语法引入计算属性computed使用methods来实现同样功能不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要book的属性还没有发生改变，多次访问totalPrice计算属性会立即返回之前的计算结果，而不必再次执行函数。相比之下，每当触发重新渲染时，调用方法将总是再次执行函数。如果你不需要缓存功能，就使用methods。 数据绑定视图模型（Model）层只是普通的JavaScript对象，修改它则视图（View）自动更新。当我们把普通的JavaScript对象传给Vue实例的data选项时，Vue将遍历对象属性，并使用Object.defineProperty将其全部转化为getter/setter，并在组件渲染时将属性记录为依赖。之后当依赖项的setter函数被调用时，会通知watcher重新计算并更新其关联的所有组件，把数据渲染进DOM。 通俗来说就是Vue修改了每个添加到data上的对象，当该对象发生变化时Vue会收到通知，从而实现响应式。对象的每个属性会被替换为getter和setter方法，因此可以像使用正常对象一样使用它，但当你修改这个属性时，Vue会知道它发生了变化。 由于Object.defineProperty是ES5中一个无法shim（自定义拓展）的特性，所以Vue，应用无法运行在不支持Object.defineProperty的IE8及其以下版本浏览器上 响应式声明渲染机制 以下面这个对象为例： 1const data = &#123; userId: 10 &#125;; 当userId发生变化时，你如何得知它发生变化了呢？可以存储这个对象的一个副本，然后比较二者，但这并不是最高效的方法。这种方法称为脏检查，也是Angular1所采用的方法。另外一种方法是，使用Object.defineProperty()覆写这个属性： 12345678910const storedData = &#123;&#125;;storedData.userId = data.userId;Object.defineProperty(data, ’userId‘, &#123; get() &#123;return storedData.userId;&#125;, set(value) &#123; console.log(’User ID changed! ‘); storedData.userId = value; &#125;, configurable: true, enumerable: true&#125;; Object API的defineProperty方法属性配置项（描述符） 因为getter/setter方法是在Vue实例初始化的时候添加的，只有已经存在的属性是响应式的；当为对象添加一个新的属性时，直接添加并不会使这个属性成为响应式的： 12345678const vm = new Vue(&#123; data: &#123; formData: &#123; username: ’someuser‘ &#125; &#125;&#125;);vm.formData.name = ’Some User‘; 尽管formData.username属性是响应式的，并且会对变化做出响应，但formData.name属性并非如此。有几种方法处理这种情况。最简单的办法是在初始化时在对象上定义这个属性，并把它的值设置为undefined。上例中的formData对象会变成下面这样： 123formData: &#123; username: ’someuser‘, name: undefined &#125; 或者，也可以使用Object.assign()来创建一个新的对象然后覆盖原有对象，当需要一次性更新多个属性时，这是最有效的办法： 12vm.formData = Object.assign(&#123;&#125;, vm.formData, &#123; name: ’Some User‘ &#125;); 最后，Vue还提供了Vue.set()方法，可以使用它将属性设置为响应式的：Vue.set(vm.formData, ’name‘, ’Some User‘);在组件内部也可以使用this.$set来调用这个方法。 双向绑定一个双向绑定的例子： 123456789101112131415&lt;body&gt; &lt;!-- 数据双向绑定 --&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"msg\"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el:'#app',//el: 挂载点 data:&#123; //data:数据选项 msg:'hello' &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 在我们对文本框输入值时，实例 data 中的 msg 值也随之变化。其中一个方向的绑定是双大括号中的 ，绑定至底层 Vue 实例的数据，在浏览器中就被渲染成实例 data 选项中 msg 的值；另一个方向的绑定是v-model, 将用户输入的值绑定到了Vue 实例的数据msg 绑定的方式有两种: Vue.js 借鉴了 Angular.js 的双花括号的方式，进行向页面输出数据和调用对象方法。可以由模板引擎根据数据实时进行修正，Vue负责驱动模板把数据渲染到DOM上； 属性名也是一种指令，如v-model就是双向绑定。使用v-model时一定要记住，如果设置了value、checked和selected属性，这些属性会被忽略。如果想设置输入元素的初始值，应该在data对象中设置。 底层原理核心机制是 观察者模式。 通过 Object.defineProperty() 替换配置对象属性的 set、get 方法，实现“拦截” watcher 在执行 getter 函数时触发数据的 get 方法，从而建立依赖关系 写入数据时触发 set 方法，从而借助 dep 发布通知，进而 watcher 进行更新 Vue 中 watcher 的观察对象，确切来说是一个求值表达式，或者函数。这个表达式或者函数，在一个 Vue 实例的上下文中求值或执行。这个过程中，使用到数据，也就是 watcher 所依赖的数据。用于记录依赖关系的属性是 deps，对应的是由 dep 对象组成的数组，对应所有依赖的数据。而表达式或函数，最终会作为求值函数记录到 getter 属性，每次求值得到的结果记录在 value 属性。另外，还有一个重要的属性 cb，记录回调函数，当 getter 返回的值与当前 value 不同时被调用 当数据是对象时 当数据是数组时，原型链重写 在数组的七个方法上进行拦截，重写时添加了一个on.dep.notify() 进行视图更新 计算属性在内部也是基于 watcher 实现的，每个计算属性对应一个 watcher，其 getter 也就是计算属性的声明函数。不过，计算属性对应的 watcher 与直接通过 vm.$watch() 创建的 watcher 略有不同，它其实没有 cb（空函数），只有 getter，并且它的值只在被使用时才计算并缓存。 计算属性对应的 watcher 初始创建的时候，并没有执行 getter，这个时候就会设置 dirty 为 true，这样当前获取计算属性的值的时候，会执行 getter 得到 value，然后标记 dirty 为 false。这样后续再获取计算属性的值，不需要再计算（执行 getter），直接就能返回缓存的 value。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://vergessenwang.github.io/tags/vue/"}]},{"title":"MVC&MVVM","slug":"MVC-MVVM","date":"2020-05-18T10:17:35.000Z","updated":"2020-05-21T13:05:08.523Z","comments":true,"path":"posts/frontend/2020-05-18-MVC-MVVM.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-05-18-MVC-MVVM.html","excerpt":"MVC不是框架，不是设计模式，也不是软件架构，而是一种架构模式。 ● 框架（Framework）：是一个系统的可重用设计，表现为一组抽象的可交互方法。它就像若干类的构成，涉及若干构件，以及构件之间的相互依赖关系、责任分配和流程控制等。比如，C++语言的QT、MFC、GTK, Java语言的SSH、SSI, PHP语言的Smarty（MVC模式）, Python语言的Django（MTV模式）等。● 设计模式（Design Pattern）：是一套被反复使用、多数人知晓的、经过分类的代码设计经验总结。其目的是为了代码的可重用性、让代码更容易被他人理解、保证代码的可靠性。比如，工厂模式、适配器模式和策略模式等。● 软件架构（Software architecture）：是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计。软件架构是一个系统的草图，软件体系结构是构建计算机软件实践的基础。● 架构模式（风格）：也可以说成框架模式，一个架构模式描述软件系统里基本的结构组织或纲要。架构模式提供一些事先定义好的子系统，指定它们的责任，并给出把它们组织在一起的法则和指南。一个架构模式常常可以分解成很多个设计模式的联合使用。MVC模式就属于架构模式，还有MTV、MVP、CBD和ORM等。","text":"MVC不是框架，不是设计模式，也不是软件架构，而是一种架构模式。 ● 框架（Framework）：是一个系统的可重用设计，表现为一组抽象的可交互方法。它就像若干类的构成，涉及若干构件，以及构件之间的相互依赖关系、责任分配和流程控制等。比如，C++语言的QT、MFC、GTK, Java语言的SSH、SSI, PHP语言的Smarty（MVC模式）, Python语言的Django（MTV模式）等。● 设计模式（Design Pattern）：是一套被反复使用、多数人知晓的、经过分类的代码设计经验总结。其目的是为了代码的可重用性、让代码更容易被他人理解、保证代码的可靠性。比如，工厂模式、适配器模式和策略模式等。● 软件架构（Software architecture）：是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计。软件架构是一个系统的草图，软件体系结构是构建计算机软件实践的基础。● 架构模式（风格）：也可以说成框架模式，一个架构模式描述软件系统里基本的结构组织或纲要。架构模式提供一些事先定义好的子系统，指定它们的责任，并给出把它们组织在一起的法则和指南。一个架构模式常常可以分解成很多个设计模式的联合使用。MVC模式就属于架构模式，还有MTV、MVP、CBD和ORM等。 MVCMVC模式是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 模型负责数据的持久化（也就是存储）；视图负责数据的输入和显示，直接和用户交互的一层，如大家看到的网站的页面内容、在表单上输入的数据；控制器负责具体的业务逻辑，根据用户的请求内容操作相应的模型和视图。 Controller本身不输出任何内容，也不做任何处理，它只是接收请求并决定调用哪个模型构件去处理请求，然后确定用哪个视图来显示返回的数据。 中介模式通过一个中介对象来封装一系列的对象交互，使多个对象之间不需要显式地相互引用，从而使其耦合松散。MVC模式可以理解成对中介模式的一种延伸 外观模式的核心思想是：用一个简单的接口来封装一个复杂的系统，使这个系统更容易使用，也就是对软件进行分层，不同的层实现不同的功能。而 MVC 模式将这一思想应用到了极致 MVPMVP是MVC的一个变种，在MVP中使用Presenter对视图和模型进行解耦。Presenter相当于MVC中的Controller，负责业务逻辑的处理；Model和View不能直接通信，只能通过Presenter间接地通信 Java的Spring MVC就是用的这种模式 MVTMTV 模式本质上与 MVC 模式没有什么差别，也是各组件之间保持松耦合关系，只是定义上有些许不同。 Model（模型）：负责业务对象与数据库的对象（ORM）。Template（模板）：负责如何把页面展示给用户。View（视图）：负责业务逻辑，并在适当的时候调用Model和Template。 Python的Django就是用这种模式实现的 MVVMMVVM（Model-View-ViewModel）最早由微软提出，ViewModel指“Model of View”，即“视图的模型”，它将View的状态和行为抽象化，让我们可以将UI和业务逻辑分开，将原来MVC中的C（Controller）用VM（ViewModel）来取代，相当于对MVC做了拓展。 在MVP中，Presenter负责协调和控制Model与View的工作，保证Model和View的数据实时同步和更新，但这个操作需要程序员写代码手动控制。而MVVM中ViewModel把View和Model的同步逻辑自动化了，以前Presenter负责的View和Model同步不再需要手动地进行操作，而是交给框架所提供的数据绑定功能来负责，只需要告诉它View显示的数据对应的是Model的哪一部分即可。 除了熟悉的这3部分之外，其实在MVVM的实现中还引入了一个隐式的Binder层，声明式数据和命令绑定在MVVM模式中就是通过它实现的。DataBinding是一个实现数据和View层绑定的框架，是构建MVVM模式的关键工具。 双向数据绑定可以简单地理解为一个模板引擎，当视图改变时更新模型，当模型改变时更新视图。不同的框架实现双向数据绑定的技术有所不同，一般有以下3种 数据劫持 发布-订阅模式 脏值检查 Vue采用数据劫持和发布-订阅模式的方式。 Observer：数据监听器 Compiler：指定解析器 Watcher：订阅者 Observer用于监听数据变化，如果数据发生改变，不论是在View层还是Model层，Oberver都会知道，然后告诉Watcher。Compiler的作用是对数据进行解析，之后绑定指定的事件，在这里主要用于更新视图。Vue.js数据绑定的流程：首先将需要绑定的数据用数据劫持方法找出来，之后用Observer监听这堆数据，如果数据发生变化，Observer就会告诉Watcher，然后Watcher会决定让哪个Compiler去做出相应的操作，这样就完成了数据的双向绑定。 虚拟DOM虚拟DOM只是MVVM框架的一种实现方案，二者没有好坏之分。在流行的前端框架中，除了React采用虚拟DOM之外，其他MVVM系框架，如Angular、Vue、Avalon，采用的都是数据绑定。 当有数据变化要进行对应的操作时，React检查是DOM结构层面的，而MVVM的检查则是数据层面的。MVVM的性能检测也根据检测层面的不同而有所不同：Angular的脏检查使得任何变动都会产生固定的更新的代价；而Vue/Avalon采用的依赖收集，使得在JS和DOM层面都会产生更新。 · 脏检查：scope digest +必要DOM更新· 依赖收集：重新收集依赖+必要DOM更新 可以看出，Angular效率低的地方在于任何小变动都会引起界面的重绘，但是，当所有数据都变化的时候，Angular并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，在数据流比较小的时候几乎可以忽略，但在数据量比较大的时候就会产生一定的消耗。相比之下，React的变动检查则是DOM结构层面的，即使是全新的数据，只要渲染结果没有变化，也不需要重新绘制。 Angular和Vue都提供了重绘的优化机制，即有效地复用实例和DOM元素。在优化的版本中，Angular和Vue采用了track by $index技术后比React的效率更高。 所以在框架选择和技术性能分析的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合，以及DOM、脏检查MVVM、数据收集MVVM在不同场合各自的表现和优缺点，具体表现和区别如下。· 初始渲染阶段：Virtual DOM &gt;脏检查≥依赖收集· 小量数据更新时：依赖收集&gt;Virtual DOM +优化&gt;脏检查（无法优化）&gt; Virtual DOM无优化· 大量数据更新时：脏检查+优化≥依赖收集+优化&gt;Virtual DOM（无优化）&gt; MVVM无优化 实际应用例如在浏览器端使用MVVM , 在服务器端可以使用MVC。而从宏观来看，前端又可视为view，后端又可视为model。","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"http://vergessenwang.github.io/tags/MVVM/"}]},{"title":"NLP多文本分类Baseline复现","slug":"NLP多文本分类Baseline复现","date":"2020-05-13T00:48:38.000Z","updated":"2020-05-13T00:52:11.090Z","comments":true,"path":"posts/NLP/2020-05-13-NLP多文本分类Baseline复现.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2020-05-13-NLP多文本分类Baseline复现.html","excerpt":"助教给的源码地址 首先创建一个新的虚拟环境 conda create -n NLP2020 python=3.7 激活环境，进入文件目录，安装依赖pip install -r requirement_dev.txt 报错： ERROR: Could not install packages due to an EnvironmentError: [WinError 5] 拒绝访问。: ‘C:\\Users\\18771\\AppData\\Local\\Temp\\pip-uninstall-5kehbgst\\pip.exe’Consider using the --user option or check the permissions. 按描述加上--user ，安装成功但有警告 WARNING: The script twine.exe is installed in ‘C:\\Users\\18771\\AppData\\Roaming\\Python\\Python37\\Scripts’ which is not on PATH.Consider adding this directory to PATH or, if you prefer to suppress this warning, use –no-warn-script-location. 于是还是用管理员方式运行Anaconda Prompt, 重新安装了一下，顺便升级了pip python -m pip install --upgrade pip 按README继续安装其他依赖 12345pytorch==1.4.0cudatoolkit==9.2tensorboard==2.2.1scikit-learn==0.22jieba==0.42.1 由于没有GPU，我就没有安装cudatoolkit","text":"助教给的源码地址 首先创建一个新的虚拟环境 conda create -n NLP2020 python=3.7 激活环境，进入文件目录，安装依赖pip install -r requirement_dev.txt 报错： ERROR: Could not install packages due to an EnvironmentError: [WinError 5] 拒绝访问。: ‘C:\\Users\\18771\\AppData\\Local\\Temp\\pip-uninstall-5kehbgst\\pip.exe’Consider using the --user option or check the permissions. 按描述加上--user ，安装成功但有警告 WARNING: The script twine.exe is installed in ‘C:\\Users\\18771\\AppData\\Roaming\\Python\\Python37\\Scripts’ which is not on PATH.Consider adding this directory to PATH or, if you prefer to suppress this warning, use –no-warn-script-location. 于是还是用管理员方式运行Anaconda Prompt, 重新安装了一下，顺便升级了pip python -m pip install --upgrade pip 按README继续安装其他依赖 12345pytorch==1.4.0cudatoolkit==9.2tensorboard==2.2.1scikit-learn==0.22jieba==0.42.1 由于没有GPU，我就没有安装cudatoolkit pip install pytorch tensorboard scikit-learn jieba 安装pytorch报错 Exception: You tried to install “pytorch”. The package named for PyTorch is “torch”ERROR: Failed building wheel for pytorch 去到pytorch官网 选择自己所需的版本 用生成的命令进行安装 pip install torch==1.5.0+cpu torchvision==0.6.0+cpu -f https://download.pytorch.org/whl/torch_stable.html 查看安装好的依赖包 然鹅奇怪的是requirement中的安装包并没有显示出来，难道没装好？ 回过头去看了一下安装信息，不知道路径会不会在后来产生一些问题 先用online_shopping_10_cats数据尝试运行 查看args.py中的参数配置，再修改 scripts/train_classification.sh 哦豁，完蛋是sh脚本 今天我尝试着用pycharm打开项目文件, 发现一个神奇的东西，这插件也不知道能不能行 安装完重启IDE后配置git路径(所以前提是已经安装好了git) 后续又遇到一点问题：当用git去执行的时候，不是在虚拟环境中去执行的，所以无法导入依赖。 算了，还是重写一个bat吧。主要修改:路径前用set ${ path}改为%path% 123set WORKSPACE=\"C:\\Users\\18771\\Desktop\\NLP_2020\\NLP2020\\NLP2020-classification\\nlp_2020\"set DATADIR=\"%WORKSPACE%\\data\"python ..\\nlp_2020\\classification\\train.py --data_dir %DATADIR%\\classification --model_name_or_path %DATADIR%\\model --output_dir %DATADIR%\\output --cache_dir %DATADIR%\\cache --embed_path %DATADIR%\\sgns.sogounews.bigram-char 打开代码一片红… 补充安装pip install torchtext torchtext预处理流程： 定义Field：声明如何处理数据 定义Dataset：得到数据集，此时数据集里每一个样本是一个 经过 Field声明的预处理 预处理后的 wordlist 建立vocab：在这一步建立词汇表，词向量(word embeddings) 构造迭代器：构造迭代器，用来分批次训练模型 修改路径中重复报错 FileNotFoundError: [WinError 3] 系统找不到指定的路径。: ‘${DATADIR}\\output’ 把train.py第171行的os.makedir(args.output_dir) 改为 os.makedirs(args.output_dir) 数据文件总是匹配不到 FileNotFoundError: [Errno 2] No such file or directory: ‘C:\\Users\\18771\\Desktop\\NLP_2020\\NLP2020\\NLP2020-classification\\nlp_2020\\data\\classification\\{mode}.csv’ 此时mode = ‘train’, 尝试了多次无果，没办法只能把文件名写死了os.path.join(args.data_dir, &#39;train.csv&#39;), 词向量加载完毕 报错 AttributeError: ‘Example’ object has no attribute ‘news’ 应该是训练数据title不一致，查看训练数据，果然title是cat label 和 review 换上数据 总算开始训练了 tensorboard --logdir=./runs 在本地6006端口查看实时训练情况","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"Pytorch","slug":"Pytorch","permalink":"http://vergessenwang.github.io/tags/Pytorch/"}]},{"title":"用Pytorch进行深度学习","slug":"用Pytorch进行深度学习","date":"2020-05-12T07:07:50.000Z","updated":"2020-05-12T07:08:38.987Z","comments":true,"path":"posts/NLP/2020-05-12-用Pytorch进行深度学习.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2020-05-12-用Pytorch进行深度学习.html","excerpt":"实验楼学习链接 Pytorch文档 Torchvision文档 torch.empty(x,y) 返回填充了未初始化数据的张量 torch.rand(x,y) 创建一个随机初始化的矩阵, 范围（0,1） torch.zeros(x, y, dtype=torch.type) 创建一个 0 填充的矩阵，指定数据类型 x = torch.tensor([[2,3],[3,4]]) 给定数据创建 Tensor，注意多维数组要封装成一个参数 x = x.new_ones(5, 3, dtype=torch.double) new_* 方法来创建对象，这里的意思是创建一个double类型，5×3的值为1.0的矩阵。根据现有张量创建新张量，如果没有设置dtype等属性，将重用输入张量的属性。 x = torch.randn_like(x, dtype=torch.float) 不改变size维度，只变化数值和dtype x.size() 获取张量大小，返回值是 tuple 类型，所以它支持 tuple 类型的所有操作。 torch.add(x,y,out=result) or x+y 张量加法, 前一种方法指定了输出参数 y.add_(x) y的值将被更新为x+y的结果，任何以下划线结尾的操作都会用结果替换原变量。例如：x.copy_(y), x.t_(), 都会改变 x。 z = x.view(-1, 8) torch.view 可以改变张量的维度和大小， size为-1时自动计算出行数？","text":"实验楼学习链接 Pytorch文档 Torchvision文档 torch.empty(x,y) 返回填充了未初始化数据的张量 torch.rand(x,y) 创建一个随机初始化的矩阵, 范围（0,1） torch.zeros(x, y, dtype=torch.type) 创建一个 0 填充的矩阵，指定数据类型 x = torch.tensor([[2,3],[3,4]]) 给定数据创建 Tensor，注意多维数组要封装成一个参数 x = x.new_ones(5, 3, dtype=torch.double) new_* 方法来创建对象，这里的意思是创建一个double类型，5×3的值为1.0的矩阵。根据现有张量创建新张量，如果没有设置dtype等属性，将重用输入张量的属性。 x = torch.randn_like(x, dtype=torch.float) 不改变size维度，只变化数值和dtype x.size() 获取张量大小，返回值是 tuple 类型，所以它支持 tuple 类型的所有操作。 torch.add(x,y,out=result) or x+y 张量加法, 前一种方法指定了输出参数 y.add_(x) y的值将被更新为x+y的结果，任何以下划线结尾的操作都会用结果替换原变量。例如：x.copy_(y), x.t_(), 都会改变 x。 z = x.view(-1, 8) torch.view 可以改变张量的维度和大小， size为-1时自动计算出行数？ 将 PyTorch 张量转换为 NumPy 数组（反之亦然）是一件轻而易举的事。PyTorch 张量和 NumPy 数组将共享其底层内存位置，改变一个也将改变另一个。 b = a.numpy() 1tensor([2., 2., 2., 2., 2.]), array([2., 2., 2., 2., 2.], dtype=float32) b = torch.from_numpy(a) 1array([2., 2., 2., 2., 2.]), tensor([2., 2., 2., 2., 2.], dtype=torch.float64) 所有的 Tensor 类型默认都是基于 CPU， CharTensor 类型不支持到 NumPy 的转换。 autograd为张量上的所有操作提供了自动求导。如果设置 .requires_grad 为 True，那么将会追踪所有对于该张量的操作。当完成计算后通过调用 .backward()会自动计算所有的梯度，这个张量的所有梯度将会自动积累到 .grad 属性。这也就完成了自动求导的过程。 如果 .requires_grad=True 但是你又不希望进行 Autograd 的计算，那么可以将变量包裹在 with torch.no_grad() 中 nn.Module 中包含了构建神经网络所需的各个层和 forward(input) 方法，该方法返回神经网络的输出。 神经网络的典型训练过程如下： 定义包含可学习参数（权重）的神经网络模型。 在数据集上迭代。 通过神经网络处理输入。 计算损失（输出结果和正确值的差值大小）。 将梯度反向传播回网络节点。 更新网络的参数，一般可使用梯度下降等最优化方法。 模型中必须要定义 forward 函数，backward 函数（用来计算梯度）会被 autograd 自动创建。可以在 forward 函数中使用任何针对 Tensor 的操作。 一个损失函数接受一对 (output, target) 作为输入，计算一个值来估计网络的输出和目标值相差多少。 调用 loss.backward() 获得反向传播的误差。但是在调用前需要清除已存在的梯度，否则梯度将被累加到已存在的梯度。 123456789net.zero_grad() # 清除梯度print('conv1.bias.grad before backward')print(net.conv1.bias.grad)loss.backward()print('conv1.bias.grad after backward')print(net.conv1.bias.grad) 以上代码只能被执行一次。 最简单的权重更新规则是随机梯度下降SGD: weight=weight-learning rate*gradient 当你想使用其他不同的优化方法，如 SGD、Nesterov-SGD、Adam、RMSPROP 等来更新神经网络参数时。可以借助于 PyTorch 中的 torch.optim 快速实现。 123456789101112import torch.optim as optim# 创建优化器optimizer = optim.SGD(net.parameters(), lr=0.01)# 执行一次训练迭代过程optimizer.zero_grad() # 梯度置零output = net(input)loss = criterion(output, target)loss.backward()optimizer.step() # 更新loss 训练一个图像分类器，基本流程如下： 使用 torchvision 加载和归一化训练集和测试集。— 文本可以使用原始 Python 和 Cython 来加载，或者使用 NLTK 或 SpaCy 处理。 123456789101112131415161718192021import torchvisionimport torchvision.transforms as transforms# 图像预处理步骤transform = transforms.Compose( [transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])# 训练数据加载器trainset = torchvision.datasets.CIFAR10( root='./data', train=True, download=True, transform=transform)trainloader = torch.utils.data.DataLoader( trainset, batch_size=4, shuffle=True, num_workers=2)# 测试数据加载器testset = torchvision.datasets.CIFAR10( root='./data', train=False, download=True, transform=transform)testloader = torch.utils.data.DataLoader( testset, batch_size=4, shuffle=False, num_workers=2)# 图像类别classes = ('plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck')trainloader, testloader 定义一个卷积神经网络。 1234567891011121314151617181920212223242526import torch.nn as nnimport torch.nn.functional as Fclass Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(3, 6, 5) self.pool = nn.MaxPool2d(2, 2) self.conv2 = nn.Conv2d(6, 16, 5) self.fc1 = nn.Linear(16 * 5 * 5, 120) self.fc2 = nn.Linear(120, 84) self.fc3 = nn.Linear(84, 10) def forward(self, x): x = self.pool(F.relu(self.conv1(x))) x = self.pool(F.relu(self.conv2(x))) x = x.view(-1, 16 * 5 * 5) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return xnet = Net()net 定义损失函数和优化器。 123criterion = nn.CrossEntropyLoss()optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)optimizer 这里使用交叉熵作为损失函数，使用带动量的随机梯度下降完成参数优化。 在训练集上训练网络。 12345678910111213141516171819for epoch in range(1): # 迭代一次 running_loss = 0.0 for i, data in enumerate(trainloader, 0): # 获取输入 inputs, labels = data # 梯度置 0 optimizer.zero_grad() # 正向传播，反向传播，优化 outputs = net(inputs) loss = criterion(outputs, labels) loss.backward() optimizer.step() # 打印状态信息 running_loss += loss.item() if i % 200 == 199: # 每 200 批次打印一次 print('[%d, %5d] loss: %.3f' % (epoch + 1, i + 1, running_loss / 200)) running_loss = 0.0print('Finished Training.') 在测试集上测试网络。 一般情况下，可以通过预测神经网络输出的类别标签与实际情况标签进行对比来进行检测。如果预测正确，我们把该样本添加到正确预测列表。 输出是各个标签的权重。一个类别的权重越大，神经网络越认为它是这个类别。 12345678910111213141516class_correct = list(0. for i in range(10))class_total = list(0. for i in range(10))with torch.no_grad(): for data in testloader: images, labels = data outputs = net(images) _, predicted = torch.max(outputs, 1) c = (predicted == labels).squeeze() for i in range(4): label = labels[i] class_correct[label] += c[i].item() class_total[label] += 1for i in range(10): print('Accuracy of %5s : %2d%%' % (classes[i], 100 * class_correct[i] / class_total[i])) 获取单个类别上的预测准确率","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"Pytorch","slug":"Pytorch","permalink":"http://vergessenwang.github.io/tags/Pytorch/"}]},{"title":"Linux内核分析","slug":"Linux内核分析","date":"2020-05-11T15:25:02.000Z","updated":"2020-05-11T15:26:23.442Z","comments":true,"path":"posts/OS/2020-05-11-Linux内核分析.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2020-05-11-Linux内核分析.html","excerpt":"实验楼学习链接 patch -p1 &lt; ../mykernel_for_linux3.9.4sc.patch patch命令用于为特定软件包打补丁，diff命令可以生成补丁文件 123456// 在当前路径下打当前路径的补丁（当前路径的补丁就是当时在制作补丁的时候在该路径下做的）$ patch-p0&lt; xxx.patch //在当前路径打上级路径的补丁（这里需要忽略上一级路径使用-p1）$ patch -p1 &lt; xx.patch//在当前路径打上上级路径的补丁（这里需要忽略上上一级路径使用-p2）$ patch -p2 &lt; x.patch","text":"实验楼学习链接 patch -p1 &lt; ../mykernel_for_linux3.9.4sc.patch patch命令用于为特定软件包打补丁，diff命令可以生成补丁文件 123456// 在当前路径下打当前路径的补丁（当前路径的补丁就是当时在制作补丁的时候在该路径下做的）$ patch-p0&lt; xxx.patch //在当前路径打上级路径的补丁（这里需要忽略上一级路径使用-p1）$ patch -p1 &lt; xx.patch//在当前路径打上上级路径的补丁（这里需要忽略上上一级路径使用-p2）$ patch -p2 &lt; x.patch 编译前 编译后 $ qemu -kernel arch/x86/boot/bzImage arch/x86/boot/下生成bzImage编译好的大内核镜像，运行内核代码，调试内核镜像，其实两个c文件中就是一个print函数，包含中断机制。 QUME模拟出了一个完整的个人电脑，它里面的CPU啊什么的都是模拟出来的，它甚至可以模拟不同架构的CPU，比如说在使用Intel X86的CPU的电脑中模拟出一个ARM的电脑或MIPS的电脑。如果想定制这个虚拟机的配置，比如用什么样的CPU啊、什么样的显卡啊、什么样的网络配置啊，指定相应的命令行参数就可以了。 qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -s -S 调试另一个内核 -initrd file参数表示使用“file”作为初始化的RAM磁盘 123456# 关于-s和-S选项的说明：# 1. -S# -S freeze CPU at startup (use ’c’ to start execution)# 2. -s# -s shorthand for -gdb tcp::1234 # 若不想使用1234端口，则可以使用-gdb tcp:xxxx来取代-s选项 结合gdb进行调试，在gdb界面中targe remote之前加载符号表，建立gdb和gdbserver之间的连接,设置断点 gdb中按c,进行断点调试","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://vergessenwang.github.io/tags/Linux/"}]},{"title":"阿里云ECS上部署Discuz论坛镜像","slug":"阿里云ECS上部署Discuz论坛镜像","date":"2020-04-13T16:12:32.000Z","updated":"2020-04-13T16:13:23.304Z","comments":true,"path":"posts/Test/2020-04-14-阿里云ECS上部署Discuz论坛镜像.html","link":"","permalink":"http://vergessenwang.github.io/posts/Test/2020-04-14-阿里云ECS上部署Discuz论坛镜像.html","excerpt":"为了做性能测试的实验，打算在ECS中部署一个Discuz论坛。 首先设置安全组策略，除添加端口80，外还加上20/20，21/21，3306/3306，30000/30050 将当前系统盘备份，创建一个快照。 然后，停止实例，更换系统盘，在镜像市场中选择一个Discuz镜像，填好“root”登录密码，确认更换","text":"为了做性能测试的实验，打算在ECS中部署一个Discuz论坛。 首先设置安全组策略，除添加端口80，外还加上20/20，21/21，3306/3306，30000/30050 将当前系统盘备份，创建一个快照。 然后，停止实例，更换系统盘，在镜像市场中选择一个Discuz镜像，填好“root”登录密码，确认更换 在浏览器输入公网IP，即可开始安装 根据文档描述 注意： 安装的时候可能会提示数据库无法连接上而失败，请把数据库地址改为127.0.0.1，并确保数据库密码正确。 三、默认预装了discuz程序，用公网IP访问进行论坛配置设置并开通。 1、mysql数据库权限及FTP权限都是随机生产，在服务器内部的default.pass文件里。您只需登录服务器后，通过命令cat /root/default.pass 即可查看到。 2、默认安装了phpmyadmin管理平台，管理数据库更方便。 ​ 数据库的管理地址为：http://公网 ip/phpmyadmin/ ​ phpmyadmin的账号和密码即为数据库的权限 远程连接到ECS，查看默认的密码 填入服务器上的数据库密码，一定不要使用默认的密码。。别问我为什么强调，问就是重装 安装完毕 发帖测试，么的问题，镜像建站这么简单的吗… 不过还有一个问题，登录的过程中要输入验证码，这在自动化测试的时候，可能遇到麻烦 进入管理员后台，在防灌水中将验证关掉 话说回来，这样的方法虽然简单，但是一个网站只能部署在一个服务器上，如果一个服务器要部署多个网站，还是自己手动安装环境，用不同的端口做映射好一点。","categories":[{"name":"Test","slug":"Test","permalink":"http://vergessenwang.github.io/categories/Test/"}],"tags":[]},{"title":"Junit5单元测试","slug":"Junit5单元测试","date":"2020-03-30T14:54:49.000Z","updated":"2020-03-30T14:56:26.205Z","comments":true,"path":"posts/Test/2020-03-30-Junit5单元测试.html","link":"","permalink":"http://vergessenwang.github.io/posts/Test/2020-03-30-Junit5单元测试.html","excerpt":"之前已经学习过，测试方法大致可分为黑盒测试和白盒测试。Junit是一种白盒测试的工具 步骤 定义一个测试类： 类名：被测试类名Test 包名：xxx.xxx.xxx.test 定义测试方法：可以独立运行 方法名：test测试方法名 返回值：void 参数列表：空参 结果判断：Assertions.assertEquals(expected, result) 给方法加@Test注解, 这是对简单程序而言。 如果是复杂项目如SpringBoot，就要用@SpringBootTest 。因为对象之间是有依赖的，直接new当前测试对象可能某些组成部分为null 。然后用@Autowired 将Bean注入；当没有真实数据时，可以用@MockBean 注解来模拟真实Bean, 此时需要相应的规则 , 如 when(obj.func()).thenReturn()；但是如果每次都要配置规则其实很麻烦，于是还可以用@SpyBean 注解，有规则按规则，无规则按默认 导入Junit依赖 import org.junit.jupiter.api.Test; 最好选择Junit5 还可以用JunitGenerator V2.0插件，在设置中进行配置，不过可选的只有Junit3和Junit4, 不建议使用","text":"之前已经学习过，测试方法大致可分为黑盒测试和白盒测试。Junit是一种白盒测试的工具 步骤 定义一个测试类： 类名：被测试类名Test 包名：xxx.xxx.xxx.test 定义测试方法：可以独立运行 方法名：test测试方法名 返回值：void 参数列表：空参 结果判断：Assertions.assertEquals(expected, result) 给方法加@Test注解, 这是对简单程序而言。 如果是复杂项目如SpringBoot，就要用@SpringBootTest 。因为对象之间是有依赖的，直接new当前测试对象可能某些组成部分为null 。然后用@Autowired 将Bean注入；当没有真实数据时，可以用@MockBean 注解来模拟真实Bean, 此时需要相应的规则 , 如 when(obj.func()).thenReturn()；但是如果每次都要配置规则其实很麻烦，于是还可以用@SpyBean 注解，有规则按规则，无规则按默认 导入Junit依赖 import org.junit.jupiter.api.Test; 最好选择Junit5 还可以用JunitGenerator V2.0插件，在设置中进行配置，不过可选的只有Junit3和Junit4, 不建议使用 更简单的方法是直接用IDEA中内置的Junit模块，方法名上右键GOTO-&gt;Test 按需选择内容 复用不同的模块之间，有些操作其实是一样的，因此就可以把一些复用的操作分离出来，如初始化资源申请等 @Before 注解init()初始化方法，用于资源申请，所有测试方法执行之前 @BeforeEach 每个测试都执行一次 @BeforeAll 所有测试只执行一次，所以必须是static @After 注解close()释放资源方法，在所有测试方法执行完后，都会自动执行该方法，即使结果出错了 两种用法同上。 异常测试测试时有时对可能发生的每种类型的异常进行测试 使用@Test注解使用@Test注解自带的 expected = Exception.class 属性来断言需要抛出一个异常，如下： 1234@Test(expected = IllegalArgumentException.class) public void testExpectedException2() &#123; new Person('Joe', -1); &#125; 在运行测试的时候，此方法必须抛出异常，这个测试才算通过。 这种方法不能指定断言的异常信息，而且有一个潜在的问题：当被标记的这个测试方法中的任何一个操作抛出了相应的异常时，这个测试就会通过。这就意味着有可能抛出异常的地方并不是我们期望的那个操作。 使用try-catch这种写法看上去和实现类的写法很相似，当没有异常被抛出的时候fail方法会被调用，输出测试失败的信息。 123456789@Test public void testExpectedException3() &#123; try &#123; new Person('Joe', -1); fail('Should have thrown an IllegalArgumentException because age is invalid!'); &#125; catch (IllegalArgumentException e) &#123; assertThat(e.getMessage(), containsString('Invalid age')); &#125; &#125; 使用ExpectedException这种方法除了可以指定期望抛出的异常类型之外还可以指定在抛出异常时希望同时给出的异常信息。它需要在测试之前使用Rule标记来指定一个ExpectedException，并在测试相应操作之前指定期望的Exception类型。 123456789@Rule public ExpectedException exception = ExpectedException.none(); @Test public void testExpectedException() &#123; exception.expect(IllegalArgumentException.class); exception.expectMessage(containsString('Invalid age')); new Person('Joe', -1); &#125; 参数化测试主要使用的是 Junit5提供的@ParameterizedTest 需要引入junit-jupiter-params，该包提供的注解类型有： 123456@ValueSource@EnumSource@MethodSource@CsvSource@CsvFileSource@ArgumentsSource value source是最简单的参数源，通过注解可以直接指定携带的运行参数。 String values: @ValueSource(strings = {“foo”, “bar”, “baz”}) Double values: @ValueSource(doubles = {1.5D, 2.2D, 3.0D}) Long values: @ValueSource(longs = {2L, 4L, 8L}) Integer values: @ValueSource(ints = {2, 4, 8}) 示例： 1234567891011121314151617181920212223242526272829import static org.junit.jupiter.api.Assertions.assertEquals; import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.ValueSource; public class ValueSourcesExampleTest &#123; @ParameterizedTest @ValueSource(ints = &#123;2, 4, 8&#125;) void testNumberShouldBeEven(int num) &#123; assertEquals(0, num % 2); &#125; @ParameterizedTest @ValueSource(strings = &#123;\"Radar\", \"Rotor\", \"Tenet\", \"Madam\", \"Racecar\"&#125;) void testStringShouldBePalindrome(String word) &#123; assertEquals(isPalindrome(word), true); &#125; @ParameterizedTest @ValueSource(doubles = &#123;2.D, 4.D, 8.D&#125;) void testDoubleNumberBeEven(double num) &#123; assertEquals(0, num % 2); &#125; boolean isPalindrome(String word) &#123; return word.toLowerCase().equals(new StringBuffer(word.toLowerCase()).reverse().toString()); &#125;&#125; 其实批量输入最好是用CsvSource，使用示例如下 12345678910111213141516class TwoSumTest &#123; @ParameterizedTest @CsvSource(&#123; \"'[1, 1]', 2, '[0, 1]'\", \"'[3, 2, 3]', 6, '[0, 2]'\", \"'[2, 7, 11, 15]', 9, '[0, 1]'\" &#125;) void twoSum( @ConvertWith(String2int.class) int[] nums, int target, @ConvertWith(String2int.class) int[] expect ) &#123; TwoSum solution = new TwoSum(); assertArrayEquals(expect, solution.twoSum(nums, target)); &#125;&#125; 通过@CsvSource传入的每一项，就相当于一个csv文件的一行，是一个String。 每一行中，可以有若干列，这里是三列，代表测试函数的三个输入参数的一组值。 为了让值中包含分隔符,，需要用单引号&#39;&#39;包含。 如果是基本数据类型，如int、String之类，JUnit5会尝试直接转换。 而如果是不常见的数据类型，则需要使用@ConvertWith。 上一段代码中的@ConvertWith(String2int.class) int[] nums,，就是在用一个自定义类String2int.class，把String类型转换为int[]。 CSVSource应用参考 JUnit 5 新特性 官方文档 单元测试理论单元测试是针对最小的功能单元编写测试代码，对java来说，就是针对单个方法的测试。 TDD三条规则： 除非为了使一个失败的单元测试通过，否则不允许编写任何产品代码 在一个单元测试中只允许编写刚好能导致失败的内容（编译错误也算） 只允许编写刚好能够使一个失败的单元测试通过的产品代码 对于一个软件，整体的测试过程是：单元测试 -&gt; 集成测试 -&gt; 系统测试 -&gt; 性能测试 单元测试方法分为代码级别测试和模块级别测试 代码级别测试：熟悉模块功能，内部逻辑与接口，编写测试用例 接口测试：确保接口实现符合文档规范 调用本模块的输入参数是否正确(参数数目，属性，类型次序) 是否修改了只读型参数 全局量的定义在各模块是否一致 在单元有多个入口的情况下，是否引用了与当前入口无关的参数 常数是否当作变量来传递 数据结构测试：确保数据结构可用，例如数据库，文件，自定义的数据结构 不正确或不一致的数据类型说明 使用尚未赋值或尚未初始化的变量 错误的初始值或错误的缺省值 变量名拼写错 上溢/下溢或地址异常 路径测试：尽可能对每一条独立执行路径进行测试，满足某种覆盖标准 不同数据类型之间的比较 错误的使用逻辑运算符或优先级 关系表达式中比较运算出错 循环终止条件或不可能出现 迭代发散时不能退出 错误的修改了循环变量 错误处理测试 边界测试：对于边界值进行测试 普通合法数据是否正确处理 普通非法数据是否正确处理 边界内最接近边界的合法数据是否正确处理 边界外最接近边界的非法数据是否正确处理 N次循环的第0,1,n次是否有错 运算或判断中取最大最小值时是否有错 数据流，控制流中刚好等于/大于/小于确定比较值时是否出错 模块级别测试：主要是功能测试，通过黑盒测试方法 其他测试项：性能，代码规范等","categories":[{"name":"Test","slug":"Test","permalink":"http://vergessenwang.github.io/categories/Test/"}],"tags":[]},{"title":"栈与队列(一)","slug":"栈与队列-一","date":"2020-03-27T15:29:51.000Z","updated":"2020-03-31T06:39:54.145Z","comments":true,"path":"posts/DataStructure/2020-03-27-栈与队列-一.html","link":"","permalink":"http://vergessenwang.github.io/posts/DataStructure/2020-03-27-栈与队列-一.html","excerpt":"Java中的栈类JAVA 中，使用 java.util.Stack 类的构造方法创建对象。 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; public Stack() &#123; &#125; public E push(E item) &#123; addElement(item); return item; &#125; public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; &#125; public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); &#125; public boolean empty() &#123; return size() == 0; &#125; public synchronized int search(Object o) &#123; int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; throw new EmptyStackException(); return -1; &#125; /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = 1224463164541339165L;&#125; 基于vector实现stack","text":"Java中的栈类JAVA 中，使用 java.util.Stack 类的构造方法创建对象。 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; public Stack() &#123; &#125; public E push(E item) &#123; addElement(item); return item; &#125; public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; &#125; public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); &#125; public boolean empty() &#123; return size() == 0; &#125; public synchronized int search(Object o) &#123; int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; throw new EmptyStackException(); return -1; &#125; /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = 1224463164541339165L;&#125; 基于vector实现stack 构造方法 ： public Stack() 创建一个空 Stack。 方法： public push （item ） 把项 压入栈顶。其作用与 addElement (item ) 相同。 public pop () 移除栈顶对象，并作为函数的值 返回该对象。返回：栈顶对象（Vector 对象的中的最后一项）抛出异常 ： EmptyStackException 如果堆栈空 public peek() 查看栈顶对象而不移除它返回：栈顶对象（Vector 对象的中的最后一项）抛出异常 ： EmptyStackException 如果堆栈式空的 public boolean empty （测试堆栈是否为空） 当且仅当堆栈中不含任何项时 返回 true，否则 返回 false. public int search (object o) 返回对象在堆栈中位置， 以 1 为基数， 如果对象 ｏ是栈中的一项，该方法返回距离 栈顶最近的出现位置到栈顶的距离； 栈中最上端项的距离。使用equals 方法比较 o 与 堆栈中的项 设计一个具有getMin功能的栈实现一个特殊的栈,在实现栈的基本功能的基础上,再实现返回栈中最小元素的操作。【要求】1.pop、push、getMin操作的时间复杂度都是O(1)。2.设计的栈类型可以使用现成的栈结构。 思路1 两栈同步用一个固定的位置保存最小值。但是还要考虑一个问题，如果有多个重复的最小值时，有pop和push时应该如何处理？是不是还有保存个数呢？这时隐约想起不知在哪看过的一个方法：同时用两个栈，最小值栈同步更新 代码实现 Minstack.java 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Stack;public class Minstack &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack; public Minstack()&#123; this.stack = new Stack&lt;&gt;(); this.minStack = new Stack&lt;&gt;(); &#125; public Integer push(Integer item)&#123; stack.push(item); if(!minStack.empty())&#123; Integer min = ((minStack.peek() - item) &gt; 0 )? item:minStack.peek(); minStack.push(min); &#125;else&#123; minStack.push(item); &#125; return item; &#125; public Integer pop()&#123; Integer moveout; moveout = stack.pop(); minStack.pop(); return moveout; &#125; public Integer getMin()&#123; if(!minStack.empty())&#123; return minStack.peek(); &#125;else &#123; return Integer.MIN_VALUE; &#125; &#125; public boolean empty() &#123; return stack.size() == 0; &#125;&#125; 测试类 12345678910111213141516public class Test &#123; public static void main(String[] args)&#123; Integer[] list = &#123;2,3,5,6,4,2,1,0,6,7&#125;; Minstack minstack = new Minstack(); for(int i = 0 ; i &lt; list.length; i++)&#123; minstack.push(list[i]); System.out.println(\"入栈数为\"+ list[i] + \" 栈中所有元素最小值为\"+ minstack.getMin()); &#125; while (!minstack.empty())&#123; System.out.print(\"出栈数为\"+ minstack.pop()); if (minstack.getMin() != Integer.MIN_VALUE)&#123; System.out.println(\" 栈中剩余元素最小值为\"+ minstack.getMin()); &#125;else System.out.println(\" 栈中已无更多元素\"); &#125; &#125;&#125; 测试结果 思路2 两栈不同步非同步压入，如果待入栈元素更小或相等，则压入minStack; 否则，不压入。 这样的话，在弹出的时侯还需要做一次比较，相比于思路1是用比较的开销来节省了minStack的空间。 由两个栈组成的队列用两个栈实现队列，支持队列的基本操作：add poll peek 思路 倒腾来倒腾去看过很多次的一个题目了，就是把第一个栈满了以后，把元素依次弹出到第二个栈中，这样就从第一个的逆序变成了第二个栈的正序，第二个栈就可以当队列使用了。 队列的peek：查看首个元素，不会移除首个元素 需要注意的问题是，什么时候去倒腾数据，避免产生顺序错乱问题, 暂时想到的方法是要进行poll或者peek操作时，先判断第二个栈是否为空。为空则倒腾一下，不为空，直接对现有数据进行操作。假定第一个栈没有空间限制，add操作就不用涉及到第二个栈了 代码实现 Stacklist.java 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Stack;public class Stacklist &#123; private Stack&lt;Integer&gt; firstStack; private Stack&lt;Integer&gt; secondStack; public Stacklist()&#123; this.firstStack = new Stack&lt;&gt;(); this.secondStack = new Stack&lt;&gt;(); &#125; public Integer add(Integer item)&#123; firstStack.push(item); return item; &#125; public Integer poll()&#123; if(!secondStack.empty())&#123; return secondStack.pop(); &#125;else &#123; while (!firstStack.empty())&#123; secondStack.push(firstStack.pop()); &#125; if(!secondStack.empty())&#123; return secondStack.pop(); &#125;else throw new RuntimeException(\"已无更多元素\"); &#125; &#125; public Integer peek()&#123; if(!secondStack.empty())&#123; return secondStack.peek(); &#125;else &#123; while (!firstStack.empty())&#123; secondStack.push(firstStack.pop()); &#125; if(!secondStack.empty())&#123; return secondStack.peek(); &#125;else throw new RuntimeException(\"已无更多元素\"); &#125; &#125;&#125; 测试 123456789101112public class Test &#123; public static void main(String[] args)&#123; Stacklist stacklist = new Stacklist(); System.out.println(\"元素 \"+stacklist.add(2)+\" 入队\"); System.out.println(\"元素 \"+stacklist.add(4)+\" 入队\"); System.out.println(\"队首元素为 \"+stacklist.peek()); System.out.println(\"元素 \"+stacklist.poll()+\" 出队\"); System.out.println(\"队首元素为 \"+stacklist.peek()); System.out.println(\"元素 \"+stacklist.poll()+\" 出队\"); System.out.println(\"队首元素为 \"+stacklist.peek()); &#125;&#125; 结果 123456元素 2 入队元素 4 入队队首元素为 2元素 2 出队队首元素为 4元素 4 出队 代码优化自己写的时候就感觉到了…poll和peek重复的地方比较多, 有些相同的操作可以适当的分离成一个新的方法 优化后： 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Stack;public class Stacklist &#123; private Stack&lt;Integer&gt; firstStack; private Stack&lt;Integer&gt; secondStack; public Stacklist()&#123; this.firstStack = new Stack&lt;&gt;(); this.secondStack = new Stack&lt;&gt;(); &#125; public Integer add(Integer item)&#123; firstStack.push(item); return item; &#125; public Integer poll()&#123; if(firstStack.empty() &amp;&amp; secondStack.empty())&#123; throw new RuntimeException(\"已无更多元素\"); &#125; firstToSecond(); return secondStack.pop(); &#125; public Integer peek()&#123; if(firstStack.empty() &amp;&amp; secondStack.empty())&#123; throw new RuntimeException(\"已无更多元素\"); &#125; firstToSecond(); return secondStack.peek(); &#125; private void firstToSecond()&#123; if(secondStack.empty())&#123; while (!firstStack.empty())&#123; secondStack.push(firstStack.pop()); &#125; &#125; &#125;&#125; 将两个栈均为空的判断放在最前面，判断起来会更加简洁，代码也更具有可读性。 递归函数和栈逆序一个栈依次压入1，2，3，4，5, 然后将栈转置。只能用递归函数实现，不能用其他数据结构。 错误思路要用递归去实现，首先考虑递归的出口，和每一步变化中递归返回值之间的关系。 问题的关键在于：不能用额外的数据结构来保存中间弹出的数据。所以只能考虑用栈的返回值来保存了 最初是这样写的，然后发现结果并没有变。。 123456public void reverse()&#123; Integer temp = stack.pop(); if(stack.size() &gt; 0) reverse(); stack.push(temp); return ;&#125; 问题在于，拿到的数据还是只能按照原来的路径重新压入。 正确思路需要设计两个递归函数 递归函数一：将栈stack的栈底元素返回并移除。取完值后重新压栈 递归函数二：逆序一个栈，每层栈用 i 保存栈底值 也就是说，一个函数用来取数，一个函数用来逆序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Stack;public class ReverseStack &#123; private Integer[] list; private Stack&lt;Integer&gt; stack; public ReverseStack(Integer[] List)&#123; this.list = List; this.stack = new Stack&lt;&gt;(); for(int i = 0; i &lt; list.length;i++)&#123; this.stack.push(list[i]); &#125; &#125; public Integer getLast()&#123; Integer result = stack.pop(); if(stack.size() &gt; 0)&#123; Integer last = getLast(); stack.push(result); return last; &#125; return result; &#125; public void reverse()&#123; if(stack.size() == 0) return ; Integer i = getLast(); reverse(); stack.push(i); &#125; public void result()&#123; while (stack.size() != 0)&#123; System.out.println(stack.pop()); &#125; &#125;&#125;//testpublic class Test &#123; public static void main(String[] args) &#123; Integer[] list = &#123;1,2,3,4,5,6&#125;; ReverseStack reverseStack = new ReverseStack(list); reverseStack.reverse(); System.out.println(\"------ after reverse ------\"); reverseStack.result(); &#125;&#125; 测试结果 猫狗队列 要求： ● 用户可以调用add方法将cat类或dog类的实例放入队列中； ● 用户可以调用pollAll方法，将队列中所有的实例按照进队列的先后顺序依次弹出； ● 用户可以调用pollDog方法，将队列中dog类的实例按照进队列的先后顺序依次弹出； ● 用户可以调用pollCat方法，将队列中cat类的实例按照进队列的先后顺序依次弹出； ● 用户可以调用isEmpty方法，检查队列中是否还有dog或cat的实例； ● 用户可以调用isDogEmpty方法，检查队列中是否有dog类的实例； ● 用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。 初步思路这题考察的是面向对象中的继承重写问题，尝试着写了一下，有点问题，一是队列到底应该放在哪一个层次；二是没有实现接口时如何实例化。遇到了空指针问题，不知道如何写下去了。说到底还是基础不行啊.. 参考思路给不同的实例添上时间戳。为了不改变原本的类，封装一个新类 123456789101112131415161718192021public class PetEnterQueue &#123; private Pet pet; private long count; public PetEnterQueue(Pet pet, long count) &#123; this.pet = pet; this.count = count; &#125; public Pet getPet() &#123; return pet; &#125; public long getCount() &#123; return count; &#125; public String getEnterPetType()&#123; return this.pet.getPetType(); &#125;&#125; 设置一个全局计数器，同时用两个队列分别放dog和cat —- 我一开始的思路很有问题，我是打算两种放一起的。。然而线性表只能放同一种数据类型 所以从逻辑上来说这是一个混合队列，但是实现的时候，却要分别处理。时间戳主要是为了比较两个队列之间的先后顺序，可以看作是联系两个队列的桥梁 — 更一般的来说，其实这个一个特殊的队列合并问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.LinkedList;import java.util.Queue;public class DogCatQueue &#123; private Queue&lt;PetEnterQueue&gt; dogQ; private Queue&lt;PetEnterQueue&gt; catQ; private long count; public DogCatQueue()&#123; this.dogQ = new LinkedList&lt;&gt;(); this.catQ = new LinkedList&lt;&gt;(); this.count = 0; &#125; public void add(Pet pet)&#123; if(pet.getPetType().equals(\"dog\")) this.dogQ.add(new PetEnterQueue(pet,this.count++)); else if(pet.getPetType().equals(\"cat\")) this.catQ.add(new PetEnterQueue(pet,this.count++)); else throw new RuntimeException(\"err,not dog or cat\"); &#125; // 按题意这里是弹出dog cat中先进去的一个，而不是所有元素 public Pet pollAll()&#123; if(!this.isDogQueueEmpty() &amp;&amp; !this.isCatQueueEmpty())&#123; if(this.dogQ.peek().getCount() &lt; this.catQ.peek().getCount())&#123; return this.dogQ.poll().getPet(); &#125;else &#123; return this.catQ.poll().getPet(); &#125; &#125;else if(!this.isDogQueueEmpty())&#123; return this.dogQ.poll().getPet(); &#125;else if(!this.isCatQueueEmpty()) &#123; return this.catQ.poll().getPet(); &#125;else throw new RuntimeException(\"err,queue is empty\"); &#125; public Pet pollDog()&#123; if(!this.isDogQueueEmpty()) return (Dog)this.dogQ.poll().getPet(); else throw new RuntimeException(\"err,dogqueue is empty\"); &#125; public Pet pollCat()&#123; if(!this.isCatQueueEmpty()) return (Cat)this.catQ.poll().getPet(); else throw new RuntimeException(\"err,catqueue is empty\"); &#125; public boolean isEmpty()&#123; return this.dogQ.isEmpty() &amp;&amp; this.catQ.isEmpty(); &#125; public boolean isDogQueueEmpty()&#123; return this.dogQ.isEmpty(); &#125; public boolean isCatQueueEmpty()&#123; return this.catQ.isEmpty(); &#125;&#125; 注意Queue是用链表实现的。","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://vergessenwang.github.io/categories/DataStructure/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://vergessenwang.github.io/tags/栈/"},{"name":"队列","slug":"队列","permalink":"http://vergessenwang.github.io/tags/队列/"}]},{"title":"西方的幻灭","slug":"西方的幻灭","date":"2020-03-26T14:33:54.000Z","updated":"2020-03-26T14:35:05.041Z","comments":true,"path":"posts/thinking/2020-03-26-西方的幻灭.html","link":"","permalink":"http://vergessenwang.github.io/posts/thinking/2020-03-26-西方的幻灭.html","excerpt":"不管是被定义为受害者，还是加害者，结局好像并无太大的不同。 我们总是过于自卑，又过于自傲。 我们不理解西方用生命换来的自由文化，也不理解日本拼命隐瞒的耻感意识。 … (中间写了一些，后来都删掉了，这个话题还是不写了) 我对zz其实并无太大兴趣，只想写点民族性的东西，那还是换个角度吧。 今天看了浙大郑强教授05年的讲座，因其超前的预见性，颇有点触动。 在灾难中跑得最快的一定是那些开奔驰宝马的人，抗在一线的一定是那些深山老林的边防战士。 他的这句话，放在今天，换了角色同样适用。 还有诸如从小学初中就被放到国外培养的孩子比长大后留学的孩子更加可怕，这些也有相应的新闻印证。当然这种“可怕”，是从我们自己民族和国家的角度去看的，他们自己会为摆脱了什么落后愚昧的东西而庆幸着，反过来要挥舞着自由民主的大旗，开始攻击自己的同胞，地位也似乎上了一级，变成俯视了。 难道真是欧美一场大雨，就洗清了自己的骨头？","text":"不管是被定义为受害者，还是加害者，结局好像并无太大的不同。 我们总是过于自卑，又过于自傲。 我们不理解西方用生命换来的自由文化，也不理解日本拼命隐瞒的耻感意识。 … (中间写了一些，后来都删掉了，这个话题还是不写了) 我对zz其实并无太大兴趣，只想写点民族性的东西，那还是换个角度吧。 今天看了浙大郑强教授05年的讲座，因其超前的预见性，颇有点触动。 在灾难中跑得最快的一定是那些开奔驰宝马的人，抗在一线的一定是那些深山老林的边防战士。 他的这句话，放在今天，换了角色同样适用。 还有诸如从小学初中就被放到国外培养的孩子比长大后留学的孩子更加可怕，这些也有相应的新闻印证。当然这种“可怕”，是从我们自己民族和国家的角度去看的，他们自己会为摆脱了什么落后愚昧的东西而庆幸着，反过来要挥舞着自由民主的大旗，开始攻击自己的同胞，地位也似乎上了一级，变成俯视了。 难道真是欧美一场大雨，就洗清了自己的骨头？ 很显然，这场危机让我们意识到，不是。根本没有完美的制度，只是一种童话代替了另一种童话罢了。在和平的年代，这是没有问题的；一旦到非常时刻，各种弊端就显露了出来。 如果真相与自己曾经的幻想相差太大，人就会开始怀疑一切。 我曾经非常想要在未来某一天去国外定居，在风景优美的小村庄里了却余生。 现在看来，是我错了。 他们远没有我们想象得那般好，正如留在国内远没有我想象的那么糟。 在外面，无论语言多么流利，事业多么光鲜，却永远融不进去。可以改变国籍，却无法改变肤色以及从小塑造的文化观念。既然艺术是不分国界的，而我骨子里还是更加认同中国的传统文化，那我为啥非得出去，要想避世，找个四川的美地，不香吗？ 而且避世这种东西，并不是现阶段要考虑的。我们的国家确实还有很多问题，这正是我们存在的意义。枉受多年教育，却只图个人安逸，着实太不应该了。也可能是因为我比较幸运，没吃过太大的苦头，也有点玩世不恭吧… 且看灯花破，数载无心禅。 怀无为之心，并不是毫无作为。 所以突然并不太想去S公司了，未来的规划也该重新考虑。 一时半会也想不出什么来，只有脑海里浮现的“唯我国风”几个字，可能还是想做点跟文化输出有关的东西吧。 … 还有点想说的，就胡乱写上吧。 我们的国家经济实力如此之强，为什么短短几个月的封闭就受不了了，企业倒闭，员工失业，每个人都是负债累累的样子，这就是我们经济的抗压能力？钱都到了房地产了？那为什么房企也是苦不堪言？这其实不太敢深想了，可能这就是强大的代价吧。毕竟积贫积弱这么多年，不拼命些追不上。 虽然我国网民键盘实力不容小觑，但总的来说，我们民族还是很温和的。就拿年轻人广泛聚集的B站来说，我 之前看到一个性别认知障碍的女孩分享自己的生活，她生理为男性但是自我认知为女性，喜欢男性。评论区全是姐姐好温柔好漂亮之类的话，不禁让人为B站用户的素质惊叹。这要是放在油管，呵呵，键盘出征，寸草不生。","categories":[{"name":"thinking","slug":"thinking","permalink":"http://vergessenwang.github.io/categories/thinking/"}],"tags":[]},{"title":"白盒测试用例设计","slug":"白盒测试用例设计","date":"2020-03-22T13:19:22.000Z","updated":"2020-03-22T13:22:23.217Z","comments":true,"path":"posts/Test/2020-03-22-白盒测试用例设计.html","link":"","permalink":"http://vergessenwang.github.io/posts/Test/2020-03-22-白盒测试用例设计.html","excerpt":"白盒测试又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。白盒测试是一种测试用例的设计方法，盒子对应的是被测试的测试，”白盒”法全面了解程序内部逻辑结构、对所有逻辑路径进行测试。”白盒”法是穷举路径测试。测试者必须检查程序的内部结构，从检查程序的逻辑着手，得出测试数据。 静态白盒测试静态测试：不实际运行被测系统本身，检查文档内容、界面、代码规范等 静态白盒测试：不实际运行被测系统本身，检查和审查代码的设计、结构，也称为结构化分析。尽早发现程序中的缺陷，可以发现30%-70%的缺陷，可以为黑盒测试人员提供测试思路 代码检查应在编译和动态测试之前进行，在检查前，应准备好需求描述文档、程序设计文档、程序的源代码请当、代码编译标准和代码缺陷检查表等。在实际使用中，代码检查能快速找到缺陷，发现30%～70%的逻辑设计和编码缺陷，而且代码检查看到的问题本身而非征兆。","text":"白盒测试又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。白盒测试是一种测试用例的设计方法，盒子对应的是被测试的测试，”白盒”法全面了解程序内部逻辑结构、对所有逻辑路径进行测试。”白盒”法是穷举路径测试。测试者必须检查程序的内部结构，从检查程序的逻辑着手，得出测试数据。 静态白盒测试静态测试：不实际运行被测系统本身，检查文档内容、界面、代码规范等 静态白盒测试：不实际运行被测系统本身，检查和审查代码的设计、结构，也称为结构化分析。尽早发现程序中的缺陷，可以发现30%-70%的缺陷，可以为黑盒测试人员提供测试思路 代码检查应在编译和动态测试之前进行，在检查前，应准备好需求描述文档、程序设计文档、程序的源代码请当、代码编译标准和代码缺陷检查表等。在实际使用中，代码检查能快速找到缺陷，发现30%～70%的逻辑设计和编码缺陷，而且代码检查看到的问题本身而非征兆。 1）桌面检查这是一种传统的检查方法，由程序员检查自己编写的程序。程序员在程序通过编译之后，对源程序代码进行分析、检验，并补充相关文档，目的是发现程序中的错误。由于程序员熟悉自己的程序及其程序设计风格，桌面检查由程序员自己进行可以节省很多的检查时间，但应避免主观片面性 2）代码审查由若干程序员和测试员组成一个审查小组，通过阅读、讨论和争议，对程序进行静态分析的过程。 代码审查分两步：第一步，小组负责人提前把设计规格说明书、控制流程图、程序文本及有关要求、规范等分发给小组成员，作为审查的依据。小组成员在充分阅读这些材料后，进入审查的第二步，召开程序审查会。在会上，首先由程序员逐句简介程序的逻辑。在此过程中，程序员或其他小组成员可以提出问题，展开讨论，审查错误是否存在。实践表明，程序员在讲解过程中能发现许多原来自己没有发现的错误，而讨论和争议则促进了问题的暴露。 在会前，应当给审查小组每个成员准备一份常见错误的清单，把以往所有可能发生的常见错误罗列出来，供与会者对照检查，以提高审查的失效。这个常见的错误清单也成为检查表，它把程序中可能发生的各种错误进行分类，对每一类错误列出尽可能多的典型错误，然后把它们制成表格，供再审查时使用 3）代码走查与代码审查基本相同，分为两步，第一步也是把材料分给走查小组的每个成员，让他们认真研究程序，然后再开会。开会的程序与代码审查不同，不是简单地读程序和对照错误检查表进行检查，而是让与会者“充当”计算机，即首先由测试组成员为所测试程序准备一批有代表性的测试用例，提交给走查小组。走查小组开会，集体扮演计算机角色，让测试用例沿程序的逻辑运行一遍，随时记录程序的踪迹，供分析和讨论用。 人们借助测试用例的媒介作用，对程序的逻辑和功能提出各种疑问，结合问题开展热烈的讨论和争议，能够发现更多的问题。 4）代码扫描工具代码检查非常耗费时间，而且代码检查需要知识和经验的积累。代码检查可以使用测试软件进行自动化测试，以利于提高测试效率，降低劳动强度 现在白盒测试中源代码扫描越来越成为一种流行的技术，使用源代码扫描产品对软件进行代码扫描，一方面可以找出潜在的风险，从内对软件进行检测，提高代码的安全性，另一方面也可以进一步提高代码的质量。 比较主流的工具有：Fortify公司的Fortify SCA，Security Innovation公司的Checkmarx Suite和Armorize公司的CodeSecure。 动态白盒测试主要关注的是动态设计方法。动态分析的主要特点是当软件系统在模拟的或真实的环境中执行之前、之中和之后，对软件系统行为的分析。动态分析包含了程序在受控的环境下使用特定的期望结果进行正式的运行。它显示了一个系统在检查状态下是正确还是不正确。 设计测试用例，根据测试用例执行被测程序(代码)，验证代码的逻辑结构是否满足需求 逻辑覆盖法逻辑覆盖法是通过对程序逻辑结构的遍历实现程序的覆盖。 根据覆盖目标的不同和覆盖源程序语句的详尽程度，逻辑覆盖又可分为： 1. 语句覆盖(SC)语句覆盖是最基本的结构覆盖要求，在六种逻辑覆盖标准中是最弱的。语句覆盖要求设计足够多的测试用例，使得程序中每条语句至少被执行一次，尽可能达到100%的覆盖率 优点：可以很直观地从源代码得到测试用例，无须细分每条判定表达式。 缺点：由于这种测试方法仅仅针对程序逻辑中显式存在的语句，但对于隐藏的条件和可能到达的隐式逻辑分支，是无法测试的。例如将上例中判断条件改成if(x&gt;0||y&gt;0) 也是可以通过测试的，所以单纯的语句覆盖不能准确的判断运算中的逻辑关系错误。 2. 判定覆盖(DC)又称分支覆盖，设计若干个测试用例，运行所测程序，使程序中每个判断的取真分支和取假分支至少执行一次。即：程序中的每个分支至少执行一次。每个判断的取真、取假至少执行一次。 只要满足判定覆盖标准就一定满足语句覆盖标准。 同样将上例中判断条件改成if(x&gt;0||y&gt;0) ，还是通过测试。所以判定覆盖会忽略条件中的or情况 优点：判定覆盖比语句覆盖要多几乎一倍的测试路径，当然也就具有比语句覆盖更强的测试能力。同样判定覆盖也具有和语句覆盖一样的简单性，无须细分每个判定就可以得到测试用例。 缺点：往往大部分的判定语句是由多个逻辑条件组合而成(如：判定语句中包含AND、 OR、CASE)。若仅仅判断其整个最终结果，而忽略每个条件的取值情况，必然会遗漏部分测试路径。 3. 条件覆盖(CC)条件覆盖设计足够多的测试用例，使得判定中的每个条件获得各种可能的结果，即每个条件至少有一次为真值，有一次为假值。 由上图可知，虽然满足了条件100%覆盖，但是P1并没有覆盖到为T的情况。 优点：显然条件覆盖比判定覆盖，增加了对符合判定情况的测试，增加了测试路径。 缺点：要达到条件覆盖，需要足够多的测试用例，但条件覆盖并不能保证判定覆盖。条件覆盖只能保证每个条件至少有一次为真，而不考虑所有的判定结果。 4. 判定条件覆盖(CC)设计足够多的测试用例，使得判定中每个条件的所有可能结果至少出现一次，每个判定本身所有可能结果也至少出现一次。 满足判定条件覆盖一定能够满足条件覆盖，判定覆盖和语句覆盖。 同样将上例中判断条件改成if(x&gt;0||y&gt;0) ，还是通过测试。所以判定条件覆盖还是会忽略条件中的or情况 优点：判定/条件覆盖满足判定覆盖准则和条件覆盖准则，弥补了二者的不足。 缺点：判定/条件覆盖准则的缺点是未考虑条件的组合情况。 5. 条件组合覆盖(MCC)要求设计足够多的测试用例，使得每个判定中条件结果的所有可能组合至少出现一次。— 判定之间无需组合，所以条件组合的总数是各判定中条件组合数相加，而不是相乘。 满足条件组合条件覆盖一定能够满足条件覆盖，判定覆盖，判定条件覆盖和语句覆盖。 上图的问题是没有覆盖到路径：a-b-d-f 优点：多重条件覆盖准则满足判定覆盖、条件覆盖和判定/条件覆盖准则。 缺点：线性地增加了测试用例的数量。无能保证所有路径被执行 6. 路径覆盖设计足够的测试用例，覆盖程序中所有可能的路径。 但是从上图可见，并未满足判定条件100%覆盖，自然也不能满足100%条件覆盖。 优点：这种测试方法可以对程序进行彻底的测试，比前面五种的覆盖面都广。 缺点：由于路径覆盖需要对所有可能的路径进行测试(包括循环，条件组合，分支选择等).那么需要设计大量、复杂的测试用例，使得工作量呈指数级增长。 基本路径测试法在实际工作中，程序往往会包含大量的循环，分支等，那么用路径覆盖是很难全部覆盖的。 基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的语句覆盖100%，条件覆盖100%。 第一步：画出控制流图 流程图用来描述程序控制结构。可将流程图映射到一个相应的流图(假设流程图的菱形决定框中不包含复合条件)。在流图中，每一个圆，称为流图的结点，代表一个或多个语句。一个处理方框序列和一个菱形决测框可被映射为一个结点，流图中的箭头，称为边或连接，代表控制流，类似于流程图中的箭头。一条边必须终止于一个结点，即使该结点并不代表任何语句(例如：if-else-then结构)。由边和结点限定的范围称为区域。计算区域时应包括图外部的范围。 流图只有二种图形符号： 图中的每一个圆称为流图的结点，代表一条或多条语句。 流图中的箭头称为边或连接，代表控制流 在将程序流程图简化成控制流图时，应注意： 1）在选择或多分支结构中，分支的汇聚处应有一个汇聚结点。 2）边和结点圈定的范围叫做区域，当对区域计数时，图形外的区域也应记为一个区域。 ​ 3）如果判断中的条件表达式是由一个或多个逻辑运算符 (OR, AND, NAND, NOR)连接的复合条件表达式，则需要改为一系列只有单条件的嵌套的判断。 第二步：计算圈复杂度 圈复杂度是一种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的独立路径数目，为确保所有语句至少执行一次的测试数量的上界。独立路径必须包含一条在定义之前不曾用到的边。 第三步：导出可执行路径 一条独立路径是指，和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。V(G)值正好等于该程序的独立路径的条数。 第四步：设计测试用例 为了确保基本路径集中的每一条路径的执行，根据判断结点给出的条件，选择适当的数据以保证某一条路径可以被测试到 总结白盒测试主要应用与单元测试阶段，一般先静态后动态。设计用例一般使用基本路径测试，重点模块使用多种覆盖率标准。 优点 a.迫使测试人员去仔细思考软件的实现 b.可以检测代码中的每条分支和路径 c.揭示隐藏在代码中的错误 d.对代码的测试比较彻底 e.最优化 缺点 a.代价昂贵 b.无法检测代码中遗漏的路径和数据敏感性错误 c.不验证规格的正确性","categories":[{"name":"Test","slug":"Test","permalink":"http://vergessenwang.github.io/categories/Test/"}],"tags":[{"name":"白盒测试","slug":"白盒测试","permalink":"http://vergessenwang.github.io/tags/白盒测试/"}]},{"title":"创建型模式之单例模式","slug":"创建型模式之单例模式","date":"2020-03-21T14:52:36.000Z","updated":"2020-03-21T14:58:31.750Z","comments":true,"path":"posts/Design-Pattern/2020-03-21-创建型模式之单例模式.html","link":"","permalink":"http://vergessenwang.github.io/posts/Design-Pattern/2020-03-21-创建型模式之单例模式.html","excerpt":"创建型模式（Creational Pattern）是对类的实例化过程的抽象化，能够提供对象的创建和管理职责。创建型模式共有5种：■ 单例模式；■ 工厂方法模式；■ 抽象工厂模式；■ 建造者模式；■ 原型模式。 含义单例模式的英文原话是：Ensure a class has only one instance,and provide a global point of access to it. 单例模式的主要作用是确保一个类只有一个实例存在。单例模式可以用在建立目录、数据库连接、线程池等需要单线程操作的场合，用于实现对系统资源的控制。 单例类中一个最重要的特点是类的构造函数是私有的，从而避免外界利用构造函数直接创建出任意多的实例。另外需要注意的是，由于构造函数是私有的，因此该类不能被继承。","text":"创建型模式（Creational Pattern）是对类的实例化过程的抽象化，能够提供对象的创建和管理职责。创建型模式共有5种：■ 单例模式；■ 工厂方法模式；■ 抽象工厂模式；■ 建造者模式；■ 原型模式。 含义单例模式的英文原话是：Ensure a class has only one instance,and provide a global point of access to it. 单例模式的主要作用是确保一个类只有一个实例存在。单例模式可以用在建立目录、数据库连接、线程池等需要单线程操作的场合，用于实现对系统资源的控制。 单例类中一个最重要的特点是类的构造函数是私有的，从而避免外界利用构造函数直接创建出任意多的实例。另外需要注意的是，由于构造函数是私有的，因此该类不能被继承。 实现方法懒汉式单例类第一次引用类时，才进行对象实例化。 延迟加载，只有在真正使用的时候，才开始实例化 12345678910111213141516171819202122232425262728293031public class LazySingleton &#123; private volatile static LazySingleton instance; private LazySingleton()&#123;&#125; public static LazySingleton getInstance()&#123; if (instance == null)&#123; synchronized (LazySingleton.class)&#123; if(instance == null)&#123; instance = new LazySingleton(); &#125; &#125; &#125; return instance; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; new Thread(()-&gt;&#123; LazySingleton instance = LazySingleton.getInstance(); System.out.println(instance); &#125;).start(); new Thread(()-&gt;&#123; LazySingleton instance = LazySingleton.getInstance(); System.out.println(instance); &#125;).start(); &#125;&#125; synchronized 保证多线程安全，如果直接加在方法上，不管有没有实例化都会加一次锁，会有性能的损耗，所以放在方法内部，用double check加锁优化，有点类似Peterson算法。 同时还要用volatile避免空指针问题。 为什么可能会发生空指针问题呢？先来看一下编译的原理，对于语句Demo demo = new Demo(); 对编译后的.class文件用命令javap -v Demo.class 进行反汇编 可以看到标准的过程是：分配空间 -&gt; 初始化 -&gt; 引用赋值。 然而，由于JVM有即时编译功能，CPU也有流水线并行，可能第一个线程在未初始化之前先进行赋值，导致第二线程返回空指针, 所以用volatile 禁用字节码重排序。 饿汉式单例类类加载时，就进行对象实例化 基于JVM类加载机制保证线程安全。 类加载的初始化阶段就完成了实例的初始化。 类加载的时机：当前类是启动类，直接进行new操作，访问静态属性/方法，用反射访问类，初始化一个类的子类等 类加载的过程： 加载二进制数据到内存中，生成对应的Class 连接：a.验证 b.准备(给类的静态成员变量赋默认值) c.解析 初始化：给类的静态变量赋初值 123456789public class HungrySingleton &#123; private static HungrySingleton instance = new HungrySingleton(); private HungrySingleton()&#123;&#125; public static HungrySingleton getInstance()&#123; return instance; &#125;&#125; 静态内部类基于JVM的懒加载机制，静态内部类被调用的时候才会被加载。如果是非静态内部类，在创建内部类实例之前，必须首先创建外围类的实例，所以用静态类比较合适 1234567891011public class InnerSingleton &#123; private static class InnerClassHolder&#123; private static InnerSingleton instance = new InnerSingleton(); &#125; private InnerSingleton()&#123;&#125; public static InnerSingleton getInstance()&#123; return InnerClassHolder.instance; &#125;&#125; 反射攻击问题以上三种方法存在的问题是，如果拿到了构造函数显示创建，仍然可创建出多个实例来，即反射攻击 以静态内部类为例： 1234567891011121314151617public class Test &#123; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; Constructor&lt;InnerSingleton&gt; declaredConstructor = InnerSingleton.class.getDeclaredConstructor(); declaredConstructor.setAccessible(true); InnerSingleton innerSingleton = declaredConstructor.newInstance(); System.out.println(innerSingleton); new Thread(()-&gt;&#123; InnerSingleton instance = InnerSingleton.getInstance(); System.out.println(instance); &#125;).start(); &#125;&#125;//测试结果InnerSingleton@42a57993InnerSingleton@b79138 对于饿汉模式和静态内部类，一种解决办法是在构造函数中添加判断条件。但是懒汉模式就不行了 123private InnerSingleton()&#123; if(InnerClassHolder.instance != null) throw new RuntimeException(\" 此为单例，不允许重复创建 \"); &#125; 通过查看newInstance() 源码，发现了一个判断条件，不能为枚举类型 , 说明反射在通过newInstance创建对象时，会检查该类是否ENUM修饰，如果是则抛出异常，反射失败。 枚举类型“单元素的枚举类型已经成为实现Singleton的最佳方法” 1234567public enum EnumSingleton &#123; INSTANCE; public void print()&#123; System.out.println(this.hashCode()); &#125;&#125; 序列化问题如果一个单例的类实现了Serializable或Cloneable接口，当反序列化或克隆时可能会创建出一个新的实例来，因为还原的时候并不会调用类的构造函数。 解决方法一是在序列化时加上一个版本号，同时实现readResolve()方法，该方法返回单例对象 另一种解决方法仍然是使用枚举类型，天然支持反序列。 用枚举类型解决反射攻击和序列化问题 应用场景■ 要求生成唯一序列号的环境。■ 在整个项目中需要一个共享访问点或共享数据，例如，一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的。■ 创建一个对象需要消耗的资源过多，如访问IO和数据库等资源。■ 需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（也可以采用直接声明为static的方式）。 如在Spring框架中，每个Bean 默认就是单例的；Java 基础类库中的 java.lang.Runtime 类也采用了单例模式，其getRuntime()方法返回了唯一的实例。 注意事项■ 单例模式与单一职责原则有冲突。■ 单例类仅局限于一个JVM，因此当多个JVM的分布式系统时，这个单例类就会在多个JVM中被实例化，造成多个单例对象的出现。如果是无状态的单例类，则没有问题，因为这些单例对象是没有区别的。如果是有状态的单例类，则会出现问题，例如，给系统提供一个唯一的序列号，此时序列号不唯一，可能出现多次。因此，在任何使用EJB、RMI和JINI技术的分布式系统中，应当避免使用有状态的单例类。■ 同一个JVM中会有多个类加载器，当两个类加载器同时加载同一个类时，会出现两个实例，此时也应尽量避免使用有状态的单例类。■ 使用单例模式时，需要注意序列化和克隆对实例唯一性的影响。如果一个单例的类实现了Serializable或Cloneable接口，则有可能被反序列化或克隆出一个新的实例来，从而破坏了“唯一实例”的要求，因此，通常单例类不需要实现Serializable和Cloneable接口。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://vergessenwang.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"六大设计原则","slug":"六大设计原则","date":"2020-03-15T07:01:30.000Z","updated":"2020-03-15T07:05:41.186Z","comments":true,"path":"posts/Design-Pattern/2020-03-15-六大设计原则.html","link":"","permalink":"http://vergessenwang.github.io/posts/Design-Pattern/2020-03-15-六大设计原则.html","excerpt":"设计模式（Design Pattern，DP）能指导你如何去设计一个优秀的架构、编写一段健壮的代码、解决一个复杂的需求。 为了便于理解，先回顾下类图、对象图和包图中的主要建模元素： 单一职责原则单一职责原则的英文名称是Single Responsibility Principle，简称是SRP。单一职责原则的定义是：应该有且仅有一个原因引起类的变更。用“职责”或“变化原因”来衡量接口或类设计得是否优良 单一职责适用于接口、类，同时也适用于方法 看一个例子：RBAC模型（Role-Based Access Control，基于角色的访问控制），通过分配和取消角色来完成用户权限的授予和取消，把用户的信息抽取成一个BO（Business Object，业务对象），把行为抽取成一个Biz（Business Logic，业务逻辑）","text":"设计模式（Design Pattern，DP）能指导你如何去设计一个优秀的架构、编写一段健壮的代码、解决一个复杂的需求。 为了便于理解，先回顾下类图、对象图和包图中的主要建模元素： 单一职责原则单一职责原则的英文名称是Single Responsibility Principle，简称是SRP。单一职责原则的定义是：应该有且仅有一个原因引起类的变更。用“职责”或“变化原因”来衡量接口或类设计得是否优良 单一职责适用于接口、类，同时也适用于方法 看一个例子：RBAC模型（Role-Based Access Control，基于角色的访问控制），通过分配和取消角色来完成用户权限的授予和取消，把用户的信息抽取成一个BO（Business Object，业务对象），把行为抽取成一个Biz（Business Logic，业务逻辑） IUserBO的职责就是收集和反馈用户的属性信息；IUserBiz负责用户的行为，完成用户信息的维护和变更。在实际的使用中，我们更倾向于使用两个不同的类或接口：一个是IUserBO，一个是IUserBiz 对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑了。生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。 纯理论地来讲，这个原则是非常优秀的，但是现实有现实的难处，你必须去考虑项目工期、成本、人员技术水平、硬件情况、网络情况甚至有时候还要考虑政府政策、垄断协议等因素。 里氏替换原则继承的缺点：▪ 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；▪ 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；▪ 增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。 里氏替换原则（Liskov Substitution Principle，LSP），所有引用基类的地方必须能透明地使用其子类的对象。只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。 采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑 里氏替换原则为良好的继承定义了规范： 1.子类必须完全实现父类的方法。在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。 2.子类可以有自己的方法和属性。有子类出现的地方父类未必就可以出现，向下转型（downcast）是不安全的 3.覆盖或实现父类的方法时输入参数可以被放大。子类要重载父类方法，参数范围必须大于父类（符合里氏替换原则），否则就是重写父类方法,使用override标识，直接调用子类方法。此时由于方法的输入参数不同，是重载（Overload）而不是覆写（Override） 重载是为了增强适应性，以前的参数还可以运行，而覆写是将之前的彻底改写。如果一个子类对象传入的参数对应的方法只在父类实现，而未再子类重写，就会调用父类的方法，根据里氏替换原则，现在这个子类被当作父类来用了。 我们再反过来想一下，如果Father类的输入参数类型宽于子类的输入参数类型，会出现什么问题呢？会出现父类存在的地方，子类就未必可以存在，因为一旦把子类作为参数传入，调用者就很可能进入子类的方法范畴。子类在没有覆写父类的方法的前提下，子类方法被执行了，这会引起业务逻辑混乱子类的输入参数宽于或等于父类的输入参数，就是为了避免调用子类方法，优先调用子类方法 关于重载参数匹配，重载时（Overload）时的参数匹配规则如下： 符合基本类型的赋值规则，即低精度的值可以赋值给高精度或同精度的变量，而高精度的不可以赋值给低精度； 赋值规则匹配出多条时，选精度最小的。 4.覆写或实现父类的方法时输出结果可以被缩小。父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T 依赖倒置原则依赖倒置原则（Dependence Inversion Principle,DIP）在Java语言中的表现就是：▪ 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；▪ 接口或抽象类不依赖于实现类；▪ 实现类依赖接口或抽象类。 更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设计），被依赖者的变更竟然让依赖者来承担修改的成本，这是不合理的。采用依赖倒置原则可以减少类间的耦合性，降低并行开发引起的风险在IDriver中，通过传入ICar接口实现了抽象之间的依赖关系，Driver实现类也传入了ICar接口，至于到底是哪个型号的Car，需要在高层模块中声明。 TDD（Test-Driven Development，测试驱动开发）开发模式就是依赖倒置原则的最高级应用。先写好单元测试类，然后再写实现类， 可以引入一个JMock工具，其最基本的功能是根据抽象虚拟一个对象进行测试 1234567891011121314public class DriverTest extends TestCase&#123; Mockery context = new JUnit4Mockery(); @Test public void testDriver() &#123; //根据接口虚拟一个对象 final ICar car = context.mock(ICar.class); IDriver driver = new Driver(); //内部类 context.checking(new Expectations()&#123;&#123; oneOf (car).run(); &#125;&#125;); driver.drive(car); &#125;&#125; 对象的依赖关系有三种方式来传递： 1.构造函数传递依赖对象。在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注入 2.Setter方法传递依赖对象。在抽象中设置Setter方法声明依赖关系，依照依赖注入的说法，这是Setter依赖注入 3.接口声明依赖对象，该方法也叫做接口注入。 我们怎么在项目中使用这个规则呢？●每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备●变量的表面类型尽量是接口或者是抽象类●尽量不要覆写基类的方法●结合里氏替换原则使用，接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。 依赖倒置原则是6个设计原则中最难以实现的原则，它是实现开闭原则的重要途径，依赖倒置原则没有实现，就别想实现对扩展开放，对修改关闭。在项目中，只要记住是“面向接口编程”就基本上抓住了依赖倒置原则的核心。 接口隔离原则 接口尽量细化，同时接口中的方法尽量少。但同时根据接口隔离原则拆分接口时，首先必须满足单一职责原则。即最小的业务单位不能再继续分下去了 接口要高内聚，在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本 定制服务，只提供访问者需要的方法 决定接口的粒度大小只能根据经验和常识 迪米特法则迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP），一个类应该对自己需要耦合或调用的类知道得最少。 迪米特法则还有一个英文解释是：Only talk to your immediate friends（只与直接的朋友通信。）类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK API提供的类除外。朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类 一个类应该对自己需要耦合或调用的类知道得最少。朋友关系太亲密了，耦合关系会变得异常牢固，从而把修改变更的风险扩散开了。在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前不加访问权限，则默认为包类型）、protected等访问权限，是否可以加上final关键字等。 迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。 开闭原则依照Java语言的称谓，开闭原则是抽象类，其他五大原则是具体的实现类，也就是说前五个原则就是指导设计的工具和方法，而开闭原则才是其精神领袖。 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。开闭原则是Java世界里最基础的设计原则 123456789101112131415161718public class OffNovelBook extends NovelBook &#123; public OffNovelBook(String _name,int _price,String _author)&#123; super(_name,_price,_author); &#125; //覆写销售价格 @Override public int getPrice()&#123; //原价 int selfPrice = super.getPrice(); int offPrice=0; if(selfPrice&gt;4000)&#123; //原价大于40元，则打9折 offPrice = selfPrice * 90 /100; &#125;else&#123; offPrice = selfPrice * 80 /100; &#125; return offPrice; &#125;&#125; 开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。 开闭原则的运用： 1.抽象约束 通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法； 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类； 抽象层尽量保持稳定，一旦确定即不允许修改。 1234public interface IComputerBook extends IBook&#123; //计算机书籍是有一个范围 public String getScope();&#125; 2.元数据（metadata）控制模块行为什么是元数据？用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。举个非常简单的例子，login方法中提供了这样的逻辑：先检查IP地址是否在允许访问的列表中，然后再决定是否需要到数据库中验证密码（如果采用SSH架构，则可以通过Struts的拦截器来实现），该行为就是一个典型的元数据控制模块行为的例子，其中达到极致的就是控制反转（Inversion of Control），使用最多的就是Spring容器","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://vergessenwang.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"GC机制","slug":"GC机制","date":"2020-03-13T07:33:45.000Z","updated":"2020-03-13T08:09:38.420Z","comments":true,"path":"posts/Java/2020-03-13-GC机制.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-03-13-GC机制.html","excerpt":"对象分配、布局和访问创建当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程 对象所需内存的大小在类加载完成后便可完全确定，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，堆中内存是绝对规整的，分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录 线程安全问题有两种可选方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。 在eden中内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。 接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的()方法还没有执行，所有的字段都为默认的零值，new指令之后会接着执行()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。 将对象引用入栈，继续执行下一条指令 布局在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。","text":"对象分配、布局和访问创建当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程 对象所需内存的大小在类加载完成后便可完全确定，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，堆中内存是绝对规整的，分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录 线程安全问题有两种可选方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。 在eden中内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。 接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的()方法还没有执行，所有的字段都为默认的零值，new指令之后会接着执行()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。 将对象引用入栈，继续执行下一条指令 布局在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。 Mark Word对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。 以32 位 JVM为例 存储内容(30bit) 锁状态(2bit) identify_hashcode:25 age:4 biased_lock:1 (01)无锁 threadId:23 age:4 epoch:2 biased_lock:1 (01)偏向锁 ptr_to_lock_record:30 (00)轻量级锁 ptr_to_heavyweight_monitor:30 (10)重量级锁 gc_info:30 (11)GC标记 Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。不同状态的存储内容基本上是互斥的。 identify_hashcode 既然有方法可以生成为什么要放在对象头里？当一个对象的hashCode()未被重写时，调用这个方法会返回一个由随机数算法生成的值。因为一个对象的hashCode不可变，所以需要存到对象头中。当再次调用该方法时，会直接返回对象头中的hashcode。identify_hashcode 采用延迟加载的方式生成。只有调用hashcode()时，才会写入对象头。若一个类的hashCode()方法被重写，对象头中将不存储hashcode信息，因为一般我们自己实现的hashcode()并未将生成的值写入对象头。 当对象的状态不是默认状态时，对象的hashcode去哪儿了？当是轻量级锁/重量级锁时，jvm会将对象的 mark word 复制一份到栈帧的Lock Record中。 等线程释放该对象时，再重新复制给对象。如果一个对象头中存在hashcode,则无法使用偏向锁。 类型指针对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。 此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。 实例数据对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。 这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。 对象的第三部分是对齐填充，由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍 访问定位通过栈上的reference数据来操作堆上的具体对象。主流的访问方式主要有使用句柄和直接指针两种 句柄访问堆中可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息 使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。 直接指针访问reference中存储的直接是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销 使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，虚拟机HotSpot主要使用第二种方式进行对象访问 溢出异常堆内存溢出首先通过内存映像分析工具对Dump出来的堆转储快照进行分析。第一步首先应确认内存中导致OOM的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄漏的代码的具体位置。 如果不是内存泄漏，那就应当检查Java虚拟机的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。 栈溢出1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。 HotSpot虚拟机不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。 使用-Xss参数控制栈内存容量 如果测试时不限于单线程，通过不断建立线程的方式，在HotSpot上也是可以产生内存溢出异常的。如果是建立过多线程导致的内存溢出，在不能减少线程数量的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。 为什么我们要去了解垃圾收集和内存分配？当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。 程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，当方法结束或者线程结束时，内存自然就跟随着回收了。 堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理 堆对象回收判断4种引用 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。 软引用是用来描述一些还有用但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。 这4种引用强度依次逐渐减弱。 引用计数算法在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。 在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因必须要配合大量额外处理才能保证正确地工作，譬如很难解决对象之间循环引用的问题。 可达性分析算法 GC Roots根对象作为起始节点集，根据引用关系向下搜索，所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。 GC Roots Java技术体系里面，固定可作为GC Roots的对象包括以下几种： 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 在方法区中**常量引用的对象，譬如字符串常量池（String Table）里的引用。 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。 Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。 所有被同步锁（synchronized关键字）持有的对象。 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。 执行finalize()方法 要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。 如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。 finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。 这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次 finalized 调度优先级很低，而且还不保证正常跑完，而且还影响gc效率（因为所有回收对象的都要调一次)。它并不能等同于C和C++语言中的析构函数。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时 方法区常量和类型回收判断方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。 回收废弃常量与回收Java堆中的对象非常类似。已经没有任何字符串对象引用常量池中的常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。 判断不再使用的类型： 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。 垃圾收集算法从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。学习的是后者的算法 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。目前只有G1收集器会有这种行为。 分代收集理论建立在三个假说之上：1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。——存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的 收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法 在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。 标记-清除算法首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。 主要缺点有两个：第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 标记-整理算法 标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。移动则内存回收时会更复杂，不移动则内存分配时会更复杂。 如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，这样的停顿被最初的虚拟机设计者形象地描述为“Stop The World” HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的 标记-复制算法算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。 这种复制回收算法的代价是将可用内存缩小为了原来的一半 分代回收算法更优化的半区复制分代策略，现在称为“Appel式回收”。HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。 如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代，这对虚拟机来说就是安全的。 空间分配担保：在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX：HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。 年轻代使用复制算法；老年代使用清除或整理算法 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 进入老年代的四种情况： 未回收对象全部无法放入Survivor空间，所以只好通过分配担保机制提前转移到老年代去 对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到-XX：MaxTenuringThreshold（默认为15），就会被晋升到老年代中。 大对象直接进入老年代，避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX：MaxTenuringThreshold中要求的年龄。 GC机制 GC可视化工具：JDK自带的 jvisualvm JVM调优的两个方面：减少FullGC的次数；减少STW的时间 垃圾收集器个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。 Serial收集器Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择。它是一个单线程工作的收集器，在它进行垃圾收集时，必须“Stop The World”暂停其他所有工作线程，直到它收集结束。 迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率 关于安全点：可达性分析的主要位置或内容是在安全点处，如果执行线程没有在安全点处暂停，那么线程所使用的对象在安全点没有记录，可能被误删掉。例如方法调用、循环跳转、异常跳转等功能的指令会产生安全点 ParNew收集器ParNew收集器实质上是Serial收集器的多线程并行版本，默认开启的收集线程数与处理器核心数量相同，是不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：除了Serial收集器外，只有它能与CMS收集器配合工作。CMS收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次实现了让垃圾收集线程与用户线程（基本上）同时工作。 Parallel Scavenge收集器Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。也经常被称作“吞吐量优先收集器”，自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。 停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。 Serial Old收集器Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。 Parallel Old收集器Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。 在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。 CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于标记-清除算法实现的 整个过程分为四个步骤，包括：1）初始标记（CMS initial mark）: 标记一下GC Roots能直接关联到的对象，速度很快；需要“Stop The World”2）并发标记（CMS concurrent mark）: 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行3）重新标记（CMS remark）: 修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录, 需要“Stop The World”4）并发清除（CMS concurrent sweep）:清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。 有以下三个明显的缺点： 对处理器资源非常敏感, CMS默认启动的回收线程数是（处理器核心数量+3）/4, 当处理器核心数量不足四个时，分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。 无法处理“浮动垃圾”（Floating Garbage），由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用。有可能预留的内存无法满足程序分配新对象的需要，出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生，即临时启用Serial Old收集器来重新进行老年代的垃圾收。 大量空间碎片产生，无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC。 Garbage First（G1）收集器JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。 基于Region的内存布局在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待 跨Region引用对象如何解决：使用记忆集避免全堆作为GC Roots扫描。它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。 三色标计算法其实就是BFS 在并发标记阶段如何保证收集线程与用户线程互不干扰地运行：CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照（SATB）算法来实现的。与CMS中的“Concurrent Mode Failure”失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。 回收过程 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。关于TAMS指针：G1收集器则是通过原始快照（SATB）算法来实现收集线程与用户线程互不干扰地运行。G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配。 从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。 最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。 筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。 从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它并非纯粹地追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量 对比CMS相比CMS，G1的优点有很多，暂且不论可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集这些创新性设计带来的红利，单从最传统的算法理论上看，G1也更有发展潜力。与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。 G1的弱项也可以列举出不少，如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。 目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间 常用参数及工具","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://vergessenwang.github.io/tags/JVM/"}]},{"title":"LC-字符串专题(一)","slug":"LC-字符串专题-一","date":"2020-03-11T15:30:28.000Z","updated":"2020-03-31T06:39:02.705Z","comments":true,"path":"posts/DataStructure/2020-03-11-LC-字符串专题-一.html","link":"","permalink":"http://vergessenwang.github.io/posts/DataStructure/2020-03-11-LC-字符串专题-一.html","excerpt":"3 无重复字符的最长子串【中】思路：感觉有点难的亚子..因为重复出现的位置无法预料，那么下一次寻找的开始位置如何确定，难道用暴力解法依次遍历？首次，如何判断和记录重复，每次用一个哈希表？ 123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int end = 0, start = 0; end &lt; n; end++) &#123; char alpha = s.charAt(end); if (map.containsKey(alpha)) &#123; start = Math.max(map.get(alpha), start); &#125; ans = Math.max(ans, end - start + 1); map.put(s.charAt(end), end + 1); &#125; return ans; &#125;&#125; 用滑动窗口替代复杂度为$O(n^2)$的暴力解法，核心是要记录下重复位置用于窗口滑动 定义一个 map 数据结构存储 (k, v)，Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重 复, 同时存位置的方法可以从始至终只用一个哈希表即可 start = Math.max(map.get(alpha), start);start取更大的值，一方面start保证不会后退；另一方面value 值为重复字符上一次的位置 +1，下一次的最长必不包含本次重复的这一段，故直接跳到本次重复第一个字符的下一位置+无论是否更新 start，都会更新其 map 数据结构和结果 ans ans = Math.max(ans, end - start + 1); 字符串方法:string.length() string.charAt(pos) hashmap方法:hashmap.containsKey(key) hashmap.put(key,value) Math.max(value1,…) 哈希表还可以直接用int[26] 来代替","text":"3 无重复字符的最长子串【中】思路：感觉有点难的亚子..因为重复出现的位置无法预料，那么下一次寻找的开始位置如何确定，难道用暴力解法依次遍历？首次，如何判断和记录重复，每次用一个哈希表？ 123456789101112131415class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int end = 0, start = 0; end &lt; n; end++) &#123; char alpha = s.charAt(end); if (map.containsKey(alpha)) &#123; start = Math.max(map.get(alpha), start); &#125; ans = Math.max(ans, end - start + 1); map.put(s.charAt(end), end + 1); &#125; return ans; &#125;&#125; 用滑动窗口替代复杂度为$O(n^2)$的暴力解法，核心是要记录下重复位置用于窗口滑动 定义一个 map 数据结构存储 (k, v)，Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重 复, 同时存位置的方法可以从始至终只用一个哈希表即可 start = Math.max(map.get(alpha), start);start取更大的值，一方面start保证不会后退；另一方面value 值为重复字符上一次的位置 +1，下一次的最长必不包含本次重复的这一段，故直接跳到本次重复第一个字符的下一位置+无论是否更新 start，都会更新其 map 数据结构和结果 ans ans = Math.max(ans, end - start + 1); 字符串方法:string.length() string.charAt(pos) hashmap方法:hashmap.containsKey(key) hashmap.put(key,value) Math.max(value1,…) 哈希表还可以直接用int[26] 来代替 时间复杂度：$O(n)$空间复杂度：$O(min(n,m))$ m为字符集大小 5 最长回文子串【中】 思路:一般来说回文可以用栈判断，但这是一个动态问题。如果用栈的话，什么时候弹出其实感觉比较难判断。不如用双指针? 暴力解法12345678910111213141516171819202122232425public boolean isPalindromic(String s) &#123; int len = s.length(); for (int i = 0; i &lt; len / 2; i++) &#123; if (s.charAt(i) != s.charAt(len - i - 1)) &#123; return false; &#125; &#125; return true; &#125;public String longestPalindrome(String s) &#123; String ans = \"\"; int max = 0; int len = s.length(); for (int i = 0; i &lt; len; i++) for (int j = i + 1; j &lt;= len; j++) &#123; String test = s.substring(i, j); if (test.length() &gt; max &amp;&amp; isPalindromic(test)) &#123; max = test.length(); ans = test; &#125; &#125; return ans;&#125; 用双指针判断回文 时间复杂度：$O(n^3)$空间复杂度：$O(1)$ 暴力破解优化11234567891011121314151617public String longestPalindrome(String s) &#123; int length = s.length(); boolean[][] P = new boolean[length][length]; int maxLen = 0; String maxPal = \"\"; for (int len = 1; len &lt;= length; len++) //遍历所有的长度 for (int start = 0; start &lt; length; start++) &#123; int end = start + len - 1; if (end &gt;= length) //下标已经越界，结束本次循环 break; P[start][end] = (len == 1 || len == 2 || P[start + 1][end - 1]) &amp;&amp; s.charAt(start) == s.charAt(end); //长度为 1 和 2 的单独判断下 if (P[start][end] &amp;&amp; len &gt; maxLen) &#123; maxPal = s.substring(start, end + 1); &#125; &#125; return maxPal;&#125; boolean[][] P = new boolean[length][length] 存储判断结果矩阵 最外层按长度来遍历 长度为 1 和 2 的单独判断，然后基于其向两边拓展 时间复杂度：$O(n^2)$ 空间换时间空间复杂度：$O(n^2)$ — 可以优化 暴力破解优化21234567891011121314public String longestPalindrome7(String s) &#123; int n = s.length(); String res = \"\"; boolean[] P = new boolean[n]; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = n - 1; j &gt;= i; j--) &#123; P[j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; 3 || P[j - 1]); if (P[j] &amp;&amp; j - i + 1 &gt; res.length()) &#123; res = s.substring(i, j + 1); &#125; &#125; &#125; return res; &#125; 下一对角线的遍历只用到了相邻的更长对角线的结果，那么用长度为n的数组，结果不断覆盖 根据递推公式，采用倒序遍历 j-i+1为字符串长度len，len为1或者2,所以len&lt;3即j-i&lt;2,而用一维数组存储结果时len=1都为ture，所以长度为3只需要判断两端字符是否相等 时间复杂度：$O(n^2)$ 空间换时间空间复杂度：$O(n)$ 动态规化再用一个逆序字符串，转化为最长公共子串问题，但是效率并不太高 中心扩展法1234567891011121314151617181920212223public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) return \"\"; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1);&#125;private int expandAroundCenter(String s, int left, int right) &#123; int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123; L--; R++; &#125; return R - L - 1;&#125; 从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 n+n-1 个中心 start = i - (len - 1) / 2;end = i + len / 2; 确定回文字符串的起止位置 时间复杂度：$O(n^2)$空间复杂度：$O(1)$ — 充分利用了回文对称的特点 Manacher’s 算法一个讲解的不错的视频 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public String preProcess(String s) &#123; int n = s.length(); if (n == 0) &#123; return \"^$\"; &#125; String ret = \"^\"; for (int i = 0; i &lt; n; i++) ret += \"#\" + s.charAt(i); ret += \"#$\"; return ret;&#125;// 马拉车算法public String longestPalindrome2(String s) &#123; String T = preProcess(s); int n = T.length(); int[] P = new int[n]; int C = 0, R = 0; for (int i = 1; i &lt; n - 1; i++) &#123; int i_mirror = 2 * C - i; if (R &gt; i) &#123; P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R &#125; else &#123; P[i] = 0;// 等于 R 的情况 &#125; // 碰到之前讲的三种情况时候，需要利用中心扩展法 while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) &#123; P[i]++; &#125; // 判断是否需要更新 R if (i + P[i] &gt; R) &#123; C = i; R = i + P[i]; &#125; &#125; // 找出 P 的最大值 int maxLen = 0; int centerIndex = 0; for (int i = 1; i &lt; n - 1; i++) &#123; if (P[i] &gt; maxLen) &#123; maxLen = P[i]; centerIndex = i; &#125; &#125; int start = (centerIndex - maxLen) / 2; //最开始讲的求原字符串下标 return s.substring(start, start + maxLen);&#125; 加特殊字符 “#” 使字符串统一为奇数长度 用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 “#” 的原字符串的总长度;用 P 的下标 i 减去 P [ i ]，再除以 2，就是原字符串的开头下标了 相比于中心拓展法，利用了前半部分的对称信息; 对称时分三种情况来讨论 时间复杂度：$O(n)$空间复杂度：$O(n)$ 6 Z字形变换【中】思路：竖向和斜向的字符数相等，如何建立输出顺序与排列方式的联系?每 n+n-2 个数视为一组，这组元素以除最高和最低点外，每行有两个数。可以建立规律,后面的情况+模即2n-2 找规律12345678910111213141516171819class Solution &#123; public String convert(String s, int numRows) &#123; if (numRows == 1) return s; StringBuilder ret = new StringBuilder(); int n = s.length(); int cycleLen = 2 * numRows - 2; for (int i = 0; i &lt; numRows; i++) &#123; for (int j = 0; j + i &lt; n; j += cycleLen) &#123; ret.append(s.charAt(j + i)); if (i != 0 &amp;&amp; i != numRows - 1 &amp;&amp; j + cycleLen - i &lt; n) ret.append(s.charAt(j + cycleLen - i)); &#125; &#125; return ret.toString(); &#125;&#125; StringBuilder 是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象，支持链式操作。有.append(s) .insert(pos,s) .toString() 方法 时间复杂度：$O(n)$空间复杂度：$O(n)$ 按行排序12345678910111213141516171819202122232425class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows == 1) return s; int len = Math.min(s.length(), numRows); String []rows = new String[len]; for(int i = 0; i&lt; len; i++) rows[i] = \"\"; int loc = 0; boolean down = false; for(int i=0;i&lt;s.length();i++) &#123; rows[loc] += s.substring(i,i+1); if(loc == 0 || loc == numRows - 1) down = !down; loc += down ? 1 : -1; &#125; String ans = \"\"; for(String row : rows) &#123; ans += row; &#125; return ans; &#125;&#125; 用字符串数组来存储，+号直接拼接在后面 用向下或向右来控制row是增还是减 loc == 0 || loc == numRows - 1 每到顶点时变换方向 时间复杂度：$O(n)$空间复杂度：$O(n)$ 8 字符串转换整数(atoi)【 中】思路：寻找第一个非空格字符，没找到不转换。找到后若不是正负号也不是数字，不转换。若是正负号，记录符号，接着计算数值，计算数值：可以用栈？ 连续数值之后的字符可以忽略。计算出整数值之后还要判断是否在有效区间内，溢出返回最大或最小值。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public int myAtoi(String str) &#123; int i = 0, j = 0, len = str.length(); boolean negative = false; for (i = 0; i &lt; len; i++) &#123; if ('0' &lt;= str.charAt(i) &amp;&amp; str.charAt(i) &lt;= '9') &#123; break; &#125; else if (str.charAt(i) == '-' || str.charAt(i) == '+') &#123; negative = str.charAt(i) == '-'; i++; break; &#125; else if (str.charAt(i) != ' ') &#123; return 0; &#125; &#125; for (j = i; j &lt; len; j++) &#123; if (str.charAt(j) &lt; '0' || '9' &lt; str.charAt(j)) &#123; break; &#125; &#125; int ret = 0; String num = str.substring(i, j); for (int x = 0; x &lt; num.length(); x++) &#123; int cur = num.charAt(x) - '0'; if (negative) &#123; if (ret &lt; Integer.MIN_VALUE / 10|| ret == Integer.MIN_VALUE / 10 &amp;&amp; cur &gt; 8) &#123; return Integer.MIN_VALUE; &#125; ret = ret * 10 - cur; &#125; else &#123; if (ret &gt; Integer.MAX_VALUE / 10 || ret == Integer.MAX_VALUE / 10 &amp;&amp; cur &gt; 7) &#123; return Integer.MAX_VALUE; &#125; ret = ret * 10 + cur; &#125; &#125; return ret; &#125;&#125; 注意判断条件，哪些是可以并列的，以及先后顺序 直接用ret迭代，不用栈 32 位有符号整数范围 -2147483648 ～ +2147483647 如果没有+号这个溢出判断是不是有什么问题?范围缩小位? 时间复杂度：$O(n)$空间复杂度：$O(1)$ 10 正则表达式匹配【难】思路：首先这是一个匹配问题，由于正则的存在使得模式串有极多的可能性，如何确定一某合理的比较顺序?若是字母，判断对应位是否相等？不等为false。为．继续匹配下一位。为*时，若前面无字符，继续；有字符，先移动继续移动目标串直至不为该字符，特别的若该字符为．，若已处于模式串末尾返回true；否则返回false 12345678910111213141516171819202122232425class Solution &#123; public boolean isMatch(String s, String p) &#123; if(s==null || p==null) return false; int sIndex=0,pIndex=0; return matchCore(s,sIndex,p,pIndex); &#125; public boolean matchCore(String s,int sIndex,String p,int pIndex)&#123; if(sIndex==s.length() &amp;&amp; pIndex==p.length()) return true; if(sIndex &lt;s.length() &amp;&amp; pIndex==p.length()) return false; if(pIndex+1&lt;p.length() &amp;&amp; p.charAt(pIndex+1)=='*')&#123; //① sIndex+1：继续用*匹配下一个 ②pIndex+2：当*前面的字符没有出现过 if((sIndex &lt; s.length() &amp;&amp; p.charAt(pIndex)==s.charAt(sIndex))||(sIndex &lt;s.length() &amp;&amp; p.charAt(pIndex)=='.'))&#123; return matchCore(s,sIndex+1,p,pIndex) || matchCore(s,sIndex,p,pIndex+2); &#125;else&#123;//第一个匹配不上，认为其没出现过，判断下面的 return matchCore(s,sIndex,p,pIndex+2); &#125; &#125;else&#123;//模式的第二个不是*，匹配上就下一个，匹配不上就结束 if((sIndex &lt; s.length() &amp;&amp; p.charAt(pIndex)==s.charAt(sIndex))||(sIndex &lt; s.length() &amp;&amp; p.charAt(pIndex)=='.'))&#123; return matchCore(s,sIndex+1,p,pIndex+1); &#125;else&#123; return false; &#125; &#125; &#125;&#125; +return matchCore(s,sIndex+1,p,pIndex) || matchCore(s,sIndex,p,pIndex+2);精髓 一个较好的视频讲解","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://vergessenwang.github.io/categories/DataStructure/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://vergessenwang.github.io/tags/字符串/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://vergessenwang.github.io/tags/LeetCode/"}]},{"title":"Linux命令之文件与权限管理","slug":"Linux命令之文件与权限管理","date":"2020-03-09T14:12:44.000Z","updated":"2020-03-10T02:49:17.407Z","comments":true,"path":"posts/OS/2020-03-09-Linux命令之文件与权限管理.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2020-03-09-Linux命令之文件与权限管理.html","excerpt":"ext4Linux目前使用的是ext4文件系统ext4文件系统会把分区主要分为两大部分（暂时不提超级块）：一小部分用于保存文件的inode（i节点）信息；剩余的大部分用于保存block信息。inode的默认大小为128 Byte，用来记录文件的权限（r、w、x）、文件的所有者和属组、文件的大小、文件的状态改变时间（ctime）、文件的最近一次读取时间（atime）、文件的最近一次修改时间（mtime）、文件的数据真正保存的block编号。每个文件需要占用一个inode。 inode中是不记录文件名的，那是因为文件名记录在文件所在目录的block中。","text":"ext4Linux目前使用的是ext4文件系统ext4文件系统会把分区主要分为两大部分（暂时不提超级块）：一小部分用于保存文件的inode（i节点）信息；剩余的大部分用于保存block信息。inode的默认大小为128 Byte，用来记录文件的权限（r、w、x）、文件的所有者和属组、文件的大小、文件的状态改变时间（ctime）、文件的最近一次读取时间（atime）、文件的最近一次修改时间（mtime）、文件的数据真正保存的block编号。每个文件需要占用一个inode。 inode中是不记录文件名的，那是因为文件名记录在文件所在目录的block中。 也就是说，目录的block中记录的是这个目录下所有一级子文件和子目录的文件名及inode的对应；而文件的block中记录的才是文件实际的数据。 当我们查找一个文件，比如/root/test时，要经过以下步骤：●首先找到根目录的inode（根目录的inode是系统已知的，inode号是2），然后判断用户是否有权限访问根目录的block。●如果有权限，则可以在根目录的block中访问到/root/的文件名及对应的inode号。●通过/root/目录的inode号，可以查找到/root/目录的inode信息，接着判断用户是否有权限访问/root/目录的block。●如果有权限，则可以从/root/目录的block中读取到test文件的文件名及对应的inode号。●通过test文件的inode号，就可以找到test文件的inode信息，接着判断用户是否有权限访问test文件的block。●如果有权限，则可以读取block中的数据，这样就完成了/root/test文件的读取与访问。 命令提示符[root@localhost ~]# root：显示的是当前的登录用户 localhost：当前系统的简写主机名 ~：代表用户当前所在的目录 #：命令提示符，Linux用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是#；如果是普通用户，提示符就是$ 超级用户的家目录：/root/。普通用户的家目录：/home/用户名/。 [root@localhost ~]# 命令 [选项] [参数]命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。 目录操作命令ls选项： -a: 显示所有文件 –color=when: 支持颜色输出，when的值默认是always（总显示颜色），也可以是never（从不显示颜色）和auto（自动） -d: 显示目录信息，而不是目录下的文件 -h: 人性化显示，按照我们习惯的单位显示文件大小 -i: 显示文件的i节点号 -l: 长格式显示 -a选项中的a是all的意思，也就是显示隐藏文件，以“.”开头的文件是隐藏文件，隐藏文件不是为了把文件藏起来不让其他用户找到，而是为了告诉用户这些文件都是重要的系统文件，如非必要，不要乱动 “-l”选项用于显示文件的详细信息，“ll”等同于“ls -l”：●第一列：权限。●第二列：引用计数。文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录有多少个一级子目录。●第三列：所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户●第四列：所属组。默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。●第五列：大小。默认单位是字节。●第六列：文件修改时间。文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。●第七列：文件名。 “ls -l”显示的文件大小是字节，但是我们更加习惯的是千字节用KB显示，兆字节用MB显示，而“-h”选项就是按照人们习惯的单位显示文件大小的 每个文件都有一个被称作inode（i节点）的隐藏属性，可以看成系统搜索这个文件的ID，而“-i”选项就是用来查看文件的inode号的 cd-P （大写）是指如果切换的目录是软链接目录，则进入其原始的物理目录，而不是进入软链接目录；-L（大写）是指如果切换的目录是软链接目录，则直接进入软链接目录。“cd ~”命令可以快速回到用户的家目录，cd命令直接按回车键也是快速切换到家目录。 pwd是查看当前所在目录的命令 如果路径是从根目录开始，一级一级指定的，那使用的就是绝对路径。所谓相对路径，就是只从当前所在目录开始，切换目录。 mkdir如果需要建立一系列的新目录，则需要加入“-p”选项，递归建立才可以 rmdir既然可以递归建立目录，当然也可以加入“-p”选项递归删除目录。 但rmdir命令的作用十分有限，因为只能删除空目录，所以一旦目录中有内容，就会报错。删除文件或目录更多的使用rm命令 tree以树形结构显示目录下的文件apt install tree 安装 文件操作命令touch修改文件的时间戳。如果文件不存在，则会建立空文件；如果文件已经存在，则会修改文件的时间戳（访问时间、数据修改时间、状态修改时间都会改变）。千万不要把touch命令当成新建文件的命令 选项： -a: 只修改文件的访问时间（Access Time） -c: 如果文件不存在，则不建立新文件 -d: 把文件的时间改为指定的时间 -m: 只修改文件的数据修改时间（Modify Time） Linux中的每个文件都有三个时间，分别是访问时间（Access Time）、数据修改时间（Modify Time）和状态修改时间（Change Time）。这三个时间可以通过stat命令来进行查看。不过touch命令只能手工指定是只修改访问时间，还是只修改数据修改时间，而不能指定只修改状态修改时间。因为不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，所以状态修改时间会随之改变。注意：在Linux中，文件没有创建时间。 statstat是查看文件详细信息的命令选项： -f： 查看文件所在的文件系统信息，而不是查看文件的信息 注意观察各项命令会使哪些时间发生变化 修改文件内容，使用“echo 9527&gt;&gt; test”（这条命令会向test文件末尾追加一行“9527”数据） catconcatenate（连接、连续）的简写，合并文件并打印输出到标准输出。不论文件内容有多少，都会一次性显示。选项： -A： 相当于-vET选项的整合，用于列出所有隐藏符号 -E： 列出每行结尾的回车符$ -n： 显示行号 -T： 把Tab键用^I显示出来 -v： 列出特殊字 tac从最后一行开始显示内容，并把所有内容输出 more分屏显示文件内容。如果文件过大，则cat命令会有心无力，这时more命令的作用更加明显。 常用的交互命令如下●空格键：向下翻页。●b：向上翻页。●回车键：向下滚动一行。●/字符串：搜索指定的字符串。●q：退出。 less分行显示文件内容。可以使用上、下箭头 head显示文件开头的内容。默认显示文件的开头10行内容。选项： -n 行数： 从文件头开始，显示指定行数 -v: 显示文件名 tail显示文件结尾的内容。选项： -n 行数： 从文件结尾开始，显示指定行数 -f: 监听文件的新增内容, 光标不会退出命令，而会一直监听在文件的结尾处，等待显示新增内容。 ln在文件之间建立链接。[root@localhost ~]# ln [选项] 源文件 目标文件选项： -s： 建立软链接文件。如果不加“-s”选项，则建立硬链接文件 -f： 强制。如果目标文件已经存在，则删除目标文件后再建立链接文件 软链接文件的源文件必须写成绝对路径，而不能写成相对路径（硬链接没有这样的要求）；否则软链接文件会报错。 硬链接源文件和硬链接文件的inode号是一样的 硬链接的特点如下：●不论是修改源文件，还是修改硬链接文件，另一个文件中的数据都会发生改变。●不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件都可以被访问。●硬链接不会建立新的inode信息，也不会更改inode的总数。●硬链接不能跨文件系统（分区）建立，因为在不同的文件系统中，inode号是重新计算的。●硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的Linux来讲过于复杂。 软链接软链接和源文件的inode号是不一致的 软链接的标志非常明显，首先，权限位中“l”表示这是一个软链接文件；其次，在文件的后面通过“-&gt;”显示出源文件的完整名字。 软链接的特点（软链接的特点和Windows中的快捷方式完全一致）。●不论是修改源文件（check），还是修改软链接文件（check-soft），另一个文件中的数据都会发生改变。●删除软链接文件，源文件不受影响。而删除源文件，软链接文件将找不到实际的数据，从而显示文件不存在。●软链接会新建自己的inode信息和block，只是在block中不存储实际文件数据，而存储的是源文件的文件名及inode号。●软链接可以链接目录。●软链接可以跨分区。 目录和文件都能操作的命令rm删除文件或目录。选项： -f: 强制删除（force） -i: 交互删除，在删除之前会询问用户 -r: 递归删除，可以删除目录（recursive）数据强制删除之后无法恢复，除非依赖第三方的数据恢复工具，如extundelete等。但要注意，数据恢复很难恢复完整的数据，一般能恢复70%～80%就很难得了。 cp复制文件和目录。 [root@localhost ~]# cp [选项] 源文件 目标文件选项： -a: 相当于-dpr选项的集合 -d: 如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接, 不加“-d”选项，实际复制的是软链接的源文件 -i: 询问，如果目标文件已经存在，则会询问是否覆盖, 默认执行 -l: 把目标文件建立为源文件的硬链接文件，而不是复制源文件 -s: 把目标文件建立为源文件的软链接文件，而不是复制源文件 -p: 复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）当我们在执行数据备份、日志备份的时候，这些文件的时间可能是一个重要的参数，这就需要执行“-p”选项了。 -r: 递归复制，用于复制目录 mv移动文件或改名。[root@localhost ~]# mv [选项] 源文件 目标文件选项： -f: 强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖 -i: 交互移动，如果目标文件已经存在，则询问用户是否覆盖（默认选项） -n: 如果目标文件已经存在，则不会覆盖移动，而且不询问用户 -v: 显示详细信息 权限管理命令文件类型-“-”：普通文件。-“b”：块设备文件。这是一种特殊设备文件，存储设备都是这种文件，如分区文件/dev/sda1就是这种文件。-“c”：字符设备文件。这也是特殊设备文件，输入设备一般都是这种文件，如鼠标、键盘等。-“d”：目录文件。Linux中一切皆文件，所以目录也是文件的一种。-“l”：软链接文件。-“p”：管道符文件。这是一种非常少见的特殊设备文件。-“s”：套接字文件。这也是一种特殊设备文件，一些服务支持Socket访问，就会产生这样的文件。 所有者的权限 r：代表read，是读取权限。 w：代表write，是写权限。 x：代表execute，是执行权限。如果有字母，则代表拥有对应的权限；如果是“-”，则代表没有对应的权限。 如果在文件的权限位中含有“.”，则表示这个文件受SELinux的安全规则管理。 chmod修改文件的权限模式。[root@localhost ~]# chmod [选项] 权限模式 文件名选项： -R: 递归设置权限，也就是给子目录中的所有文件设定权限权限模式的格式是[ugoa][[+-=][perms]]，也就是[用户身份][[赋予方式][权限]] 用户身份 u：代表所有者（user）。 g：代表所属组（group）。 o：代表其他人（other）。 a：代表全部身份（all）。 赋予方式 +：加入权限。 -：减去权限。 =：设置权限。 权限 r：读取权限（read）4 可以对文件执行cat、more、less、head、tail等文件查看命令。可以在目录下执行ls命令 w：写权限（write）2 可以对文件执行vim、echo等修改文件数据的命令。注意：因为文件名保留在上级目录的block中，所以对文件拥有写权限，是不能删除文件本身的，而只能删除文件中的数据（也就是文件block中的内容）。要想删除文件名，需要对文件所在目录拥有写权限。 可以在目录下执行touch、rm、cp、mv命令。对目录来说，写（w）权限是最高权限。 x：执行权限（execute）1 对文件来说，执行（x）权限是最高权限。可以对目录执行cd命令 数字权限的赋予方式更加简单●644：这是文件的基本权限，代表所有者拥有读、写权限，而所属组和其他人拥有只读权限。●755：这是文件的执行权限和目录的基本权限，代表所有者拥有读、写和执行权限，而所属组和其他人拥有读和执行权限。●777：这是最大权限。在实际的生产服务器中，要尽力避免给文件或目录赋予这样的权限，这会造成一定的安全隐患。 创建普通用户user的简单步骤：第一步，添加用户执行命令“useradd user”；第二步，设置用户密码“passwd user”，输入两次密码确认。执行命令“su – user”切换用户 chown修改文件和目录的所有者和所属组。[root@localhost ~]# chown [选项] 所有者：所属组 文件或目录选项： -R： 递归设置权限，也就是给子目录中的所有文件设置权限 文件的所有者，才可以修改文件的权限。在Linux中，每个用户建立之后，都会建立和用户名同名的用户组，作为这个用户的初始组，user用户组是自动建立的。 chgrp修改文件和目录的所属组 umask在Linux中，通过umask默认权限来给所有新建立的文件和目录赋予初始权限，这一点和Windows不太一样，Windows是通过继承上级目录的权限来给文件和目录赋予初始权限的。 使用“-S”选项，会直接用字母来表示文件和目录的初始权限。 ●对文件来讲，新建文件的默认最大权限是666，没有执行（x）权限。这是因为执行权限对文件来讲比较危险，不能在新建文件的时候默认赋予，而必须通过用户手工赋予。换算成字母就是“-rw-rw-rw-”；而umask的值是022，也换算成字母就是“—–w–w-”。把两个字母权限相减，得到的就是新建文件的默认权限：（-rw-rw-rw-）-（—–w–w-）=（-rw-r–r–）。●对目录来讲，新建目录的默认最大权限是777。这是因为对目录而言，执行（x）权限仅仅代表进入目录，所以即使建立新文件时直接默认赋予，也没有什么危险。换算成字母就是“drwxrwxrwx”；而umask的值是022，也换算成字母就是“d—-w–w-”。也把两个字母权限相减，得到的就是新建目录的默认权限：（drwxrwxrwx）-（d—-w–w-）=（drwx-r-xr-x）。 umask默认权限可以直接通过命令来进行修改, 如umask 033，不过，通过命令进行的修改只能临时生效，一旦重启或重新登录就会失效。如果想让修改永久生效，则需要修改对应的环境变量配置文件/etc/profile。 帮助命令man显示联机帮助手册。man [选项] 命令选项：-f： 查看命令拥有哪个级别的帮助-k： 查看和命令相关的所有帮助 man命令的快捷键 man命令的帮助级别 ●whatis：这个命令的作用和man -f是一致的。●apropos：这个命令的作用和man -k是一致的。 Linux的命令很有意思，想知道这个命令是干什么的，可以执行whatis命令；想知道命令在哪里，可以执行whereis命令；想知道当前登录用户是谁，可以执行whoami命令。 infoinfo命令的帮助信息是一套完整的资料, 每个命令的帮助信息都会和书籍一样，拥有章节编号。 help能获取Shell内置命令的帮助，但在Linux中绝大多数命令是外部命令，所以help命令的作用非常有限。 –help绝大多数命令都可以使用“–help”选项来查看帮助，输出的帮助信息基本上是man命令的信息简要版。 搜索命令whereis查找二进制命令、源文件和帮助文档的命令。whereis命令不能搜索普通文件，而只能搜索系统命令。 选项：-b: 只查找二进制命令-m: 只查找帮助文档 which列出命令的所在路径。和whereis命令的区别在于，whereis命令可以在查找到二进制命令的同时，查找到帮助文档的位置；而which命令在查找到二进制命令的同时，如果这个命令有别名，则还可以找到别名命令。 locate按照文件名搜索文件。系统命令其实也是文件，也可以按照文件名来搜索系统命令。不能执行更复杂的搜索，比如按照权限、大小、修改时间等搜索文件。选项：-i: 忽略大小写 搜索速度非常快，而且耗费系统资源非常小。这是因为locate命令不会直接搜索硬盘空间，而会先建立locate数据库，然后在数据库中按照文件名进行搜索，是快速的搜索命令。缺点是数据库不是实时更新的，而要等用户退出登录或重启系统时，locate数据库才会更新，所以我们无法查找到新建立的文件。可以通过updatedb命令来手工更新这个数据。 同时，在locate执行搜索时，系统认为某些文件系统、某些文件类型和某些目录是没有搜索必要的，比如光盘、网盘、临时目录等，所以如/tmp/目录下的文件会被忽略 findfind是Linux中强大的搜索命令，不仅可以按照文件名搜索文件，还可以按照权限、大小、时间、inode号等来搜索文件。但是find命令是直接在硬盘中进行搜索的，如果指定的搜索范围过大，find命令就会消耗较大的系统资源，导致服务器压力过大。所以，在使用find命令搜索时，不要指定过大的搜索范围。 find 搜索路径 [选项] 搜索内容选项：-name: 按照文件名搜索，搜索的文件名必须和搜索内容一致才能找到。即find命令是完全匹配的-iname: 按照文件名搜索，不区分文件名大小写-inum: 按照inode号搜索-size [+-]大小： 按照指定大小搜索文件。千字节必须是小写的“k”，而兆字节必须是大写的“M”。按照字节搜索，则需要加搜索单位“c”。-atime [+-]时间： 按照文件访问时间搜索。如“-5”指的是5天内修改的文件，“5”指的是前5～6天那一天修改的文件，“+5”指的是6天前修改的文件。-mtime [+-]时间： 按照文件数据修改时间搜索-ctime [+-]时间： 按照文件状态修改时间搜索-perm 权限模式： 查找文件权限刚好等于“权限模式”的文件-perm -权限模式：查找文件权限全部包含“权限模式”的文件-perm +权限模式：查找文件权限包含“权限模式”的任意一个权限的文件-uid 用户ID: 按照用户ID查找所有者是指定ID的文件-gid 组ID: 按照用户组ID查找所属组是指定ID的文件-user 用户名： 按照用户名查找所有者是指定用户的文件-group 组名： 按照组名查找所属组是指定用户组的文件-nouser: 查找没有所有者的文件，主要用于查找垃圾文件。比如手工源码包安装的文件-type d: 查找目录-type f: 查找普通文件-type l: 查找软链接文件-a: and逻辑与 如find . -size +2k -a -type f-o: or逻辑或-not: not逻辑非 -exec选项find 搜索路径 [选项] 搜索内容 -exec 命令2 {} \\;“{}”和“\\; ”是标准格式，只要执行“-exec”选项，这两个符号必须完整输入。其次，这个选项的作用其实是把find命令的结果交给由“-exec”调用的命令2来处理。“{}”就代表find命令的查找结果。find . -perm 444 -exec ls -l {} \\;使用“-exec”选项，把find命令的结果直接交给“ls -l”命令处理 -ok”选项和“-exec”选项的作用基本一致，区别在于：“-exec”的命令2会直接处理，而不询问；“-ok”的命令2在处理前会先询问用户是否这样处理，在得到确认命令后，才会执行。","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://vergessenwang.github.io/tags/Linux/"}]},{"title":"线程池与生产者/消费者模型","slug":"线程池与生产者-消费者模型","date":"2020-03-08T15:25:23.000Z","updated":"2020-03-31T06:41:24.762Z","comments":true,"path":"posts/Java/2020-03-08-线程池与生产者-消费者模型.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-03-08-线程池与生产者-消费者模型.html","excerpt":"ULT&amp;KLTJVM在采用的是KLT模式，虽然并发程度高，但是可能会造成资源的浪费。","text":"ULT&amp;KLTJVM在采用的是KLT模式，虽然并发程度高，但是可能会造成资源的浪费。 线程池重用资源系统启动一个新线程的成本是比较高的，因为它涉及与操作系统交互。在这种情形下，使用线程池可以很好地提高性能，尤其是当程序中需要创建大量生存期很短暂的线程时，更应该考虑使用线程池 线程池的目的就是执行提交给线程池的任务，执行完一个任务后不会退出，而是继续等待或执行新任务。线程池主要由两个概念组成：一个是任务队列；另一个是工作者线程。工作者线程主体就是一个循环，循环从队列中接受任务并执行，任务队列保存待执行的任务。 线程池的优点：第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。 线程池的处理流程如下：1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。 2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。 3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 与数据库连接池类似的是，线程池在系统启动时即创建大量空闲的线程，程序将一个Runnable对象或Callable对象传给线程池，线程池就会启动一个线程来执行它们的run()或call()方法，当run()或call()方法执行结束后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个Runnable对象的run()或call()方法。 Executors实现 从Java 5开始，Java内建支持线程池。Java 5新增了一个Executors工厂类来产生线程池，该工厂类包含如下几个静态工厂方法来创建线程池。 newCachedThreadPool()：创建一个具有缓存功能的线程池，系统根据需要创建线程，这些线程将会被缓存在线程池中。 newFixedThreadPool(int nThreads)：创建一个可重用的、具有固定线程数的线程池。 newSingleThreadExecutor()：创建一个只有单线程的线程池，它相当于调用newFixedThread Pool()方法时传入参数为1 newScheduledThreadPool(int corePoolSize)：创建具有指定线程数的线程池，它可以在指定延迟后执行线程任务。corePoolSize指池中所保存的线程数，即使线程是空闲的也被保存在线程池内。 newSingleThreadScheduledExecutor()：创建只有一个线程的线程池，它可以在指定延迟后执行线程任务。 上面5个方法中的前3个方法返回一个ExecutorService对象，该对象代表一个线程池，它可以执行Runnable对象或Callable对象所代表的线程；而后2个方法返回一个ScheduledExecutorService线程池，它是ExecutorService的子类，它可以在指定延迟后执行线程任务。 当用完一个线程池后，应该调用该线程池的shutdown()方法，该方法将启动线程池的关闭序列，调用shutdown()方法后的线程池不再接收新任务，但会将以前所有已提交任务执行完成。当线程池中的所有任务都执行完成后，池中的所有线程都会死亡；另外也可以调用线程池的shutdownNow()方法来关闭线程池，该方法试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。 使用线程池来执行线程任务的步骤如下。（1）调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池。（2）创建Runnable实现类或Callable实现类的实例，作为线程执行任务。（3）调用ExecutorService对象的submit()方法来提交Runnable实例或Callable实例。（4）当不想提交任何任务时，调用ExecutorService对象的shutdown()方法来关闭线程池。 测试代码 123456789101112131415161718class MyTread implements Runnable&#123; public void run()&#123; for(int i = 0; i &lt; 100; i++)&#123; System.out.println(Thread.currentThread().getName() + \"i的值为：\" + i); &#125; &#125;&#125;public class TreadPoolTest&#123; public static void main(String[] args)&#123; throws Exception&#123; ExecutorService pool = Executor.newFixedThreadPool(6); pool.submit(new MyTread()); pool.submit(new MyTread()); pool.shutdown(); &#125; &#125;&#125; ThreadPoolExecutor❑ Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。❑ ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。❑ ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。❑ Future接口和实现Future接口的FutureTask类，代表异步计算的结果。❑ Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled-ThreadPoolExecutor执行。 IDEA TIPS：选中类或接口，右键查看类图，然后选中要看的类或接口右键选中要看的方法，即可出现一个继承图 ThreadPoolExecutor执行execute方法分下面4种情况。1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。 ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。 创建new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler); 创建一个线程池时需要输入几个参数，如下。 1）corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。 2）maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。 —— 任务队列满了且总线程池池未满时创建临时线程，超过活跃时间后停止 3）keepAliveTime（线程活动保持时间）：当线程池中的线程个数大于corePoolSize时额外空闲线程的存活时间。也就是说，一个非核心线程，在空闲等待新任务时，会有一个最长等待时间，即keepAliveTime，如果到了时间还是没有新任务，就会被终止。如果该值为0，则表示所有线程都不会超时终止。TimeUnit（线程活动保持时间的单位） 4）runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列：❑ ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。❑ LinkedBlockingQueue：基于链表的阻塞队列，可以指定最大长度，但默认是无界的。此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。❑ SynchronousQueue：没有实际存储空间的同步阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。❑ PriorityBlockingQueue：基于堆的无界阻塞优先级队列。 5）RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。❑ AbortPolicy：直接抛出异常。❑ CallerRunsPolicy：在任务提交者线程中执行任务，而不是交给线程池中的线程执行。❑ DiscardOldestPolicy：将等待时间最长的任务扔掉，然后自己排队。❑ DiscardPolicy：静默处理，忽略新任务，不抛出异常，也不执行。 拒绝策略只有在队列有界，且maximumPoolSize有限的情况下才会触发。如果队列无界，服务不了的任务总是会排队，但这不一定是期望的结果，因为请求处理队列可能会消耗非常大的内存，甚至引发内存不够的异常。如果队列有界但maxi-mumPoolSize无限，可能会创建过多的线程，占满CPU和内存，使得任何任务都难以完成。 6）线程池还可以接受一个参数：ThreadFactory。它是一个接口，这个接口根据Runnable创建一个Thread, ThreadPoolExecutor的默认实现是Executors类中的静态内部类DefaultThreadFactory，主要就是创建一个线程，给线程设置一个名称，设置daemon属性为false，设置线程优先级为标准默认优先级，线程名称的格式为：pool-&lt;线程池编号&gt;-thread-&lt;线程编号&gt;。如果需要自定义一些线程的属性，比如名称，可以实现自定义的ThreadFactory。 查看状态12345678//返回当前线程个数public int getPoolSize()//返回线程池曾经达到过的最大线程个数public int getLargestPoolSize()//返回线程池自创建以来所有已完成的任务数public long getCompletedTaskCount()//返回所有任务数，包括所有已完成的加上所有排队待执行的public long getTaskCount() 用一个int记录线程池的状态 线程池与生产消费者模式ThreadPoolExecutor实现了生产者/消费者模式，工作者线程就是消费者，任务提交者就是生产者，线程池自己维护任务队列。当我们碰到类似生产者/消费者问题时，应该优先考虑直接使用线程池，而非“重新发明轮子”，应自己管理和维护消费者线程及任务队列 生产者 123456789101112131415161718public class ProductThread extends Thread &#123; private int taskNum; private ArrayBlockingQueue queue; public ProductThread(int taskNum,ArrayBlockingQueue queue) &#123; this.taskNum = taskNum; this.queue = queue; &#125; public void run() &#123; try &#123; //模拟生产 Thread.currentThread().sleep(5000); System.out.println(\"开始生产\"); queue.add(taskNum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 消费者 1234567891011121314151617public class ConsumerThread extends Thread &#123; private ArrayBlockingQueue queue; public ConsumerThread(ArrayBlockingQueue queue) &#123; this.queue = queue; &#125; public void run() &#123; System.out.println(\"准备消费\"); int taskNum; try &#123; taskNum = (int) queue.take(); System.out.println(\"消费了\"+taskNum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 测试主方法 1234567891011121314151617181920public class ProductAndConsumer &#123; public static void main(String[] args) &#123; ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(20); //为多生产者和多消费者分别开创的线程池 ThreadPoolExecutor productPool = new ThreadPoolExecutor(10,20,60,TimeUnit.MILLISECONDS,new ArrayBlockingQueue(5),new ThreadPoolExecutor.CallerRunsPolicy()); ThreadPoolExecutor consumerPool = new ThreadPoolExecutor(10,20,60,TimeUnit.MILLISECONDS,new ArrayBlockingQueue(5),new ThreadPoolExecutor.CallerRunsPolicy()); System.out.println(\"start\"); for(int i = 0;i&lt;100;i++) &#123; productPool.execute(new ProductThread(i,queue)); consumerPool.execute(new ConsumerThread(queue)); &#125; productPool.shutdown(); consumerPool.shutdown(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://vergessenwang.github.io/tags/线程/"}]},{"title":"数据库影响因素之硬件、存储引擎和事务","slug":"数据库影响因素之硬件、存储引擎和事务","date":"2020-03-07T15:07:03.000Z","updated":"2020-03-07T15:09:52.241Z","comments":true,"path":"posts/database/2020-03-07-数据库影响因素之硬件、存储引擎和事务.html","link":"","permalink":"http://vergessenwang.github.io/posts/database/2020-03-07-数据库影响因素之硬件、存储引擎和事务.html","excerpt":"影响数据库的因素 Sql查询速度 服务器硬件 存储引擎 大表 大事务 服务器硬件CPUMYSQL不支持多核并发，会带来两方面的风险： 大量的并发使数据库连接数被占满。max_connection 默认为100 CPU耗尽导致宕机QPS：每秒钟处理的查询量 更多核数还是更高频率视具体情况而定：高并发选更多核；CPU密集和复杂SQL选更高频率 磁盘IO硬件升级调整计划任务，避开高峰期，做好磁盘维护 RAIDRAID（Redundant Array of Independent Disks，独立磁盘冗余数组）的基本思想就是把多个相对便宜的硬盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。 RAID 0：将多个磁盘合并成一个大的磁盘，不会有冗余，并行I/O，速度最快。在所有的级别中，RAID 0的速度是最快的。理论上，多磁盘的效能就等于（单一磁盘效能）×（磁盘数），但实际上受限于总线I/O瓶颈及其他因素的影响，RAID效能会随边际递减。也就是说，假设一个磁盘的效能是50MB/s，两个磁盘的RAID 0效能约96MB/s，三个磁盘的RAID 0也许是130MB/s而不是150MB/s。 RAID 1：两组以上的N个磁盘相互作为镜像，在一些多线程操作系统中能有很好的读取速度，但写入速度略有降低。RAID 1的数据安全性在所有的RAID级别上来说是最好的。但是所有RAID中磁盘利用率最低的一个级别。 RAID 5：是一种存储性能、数据安全和存储成本兼顾的存储解决方案。它使用的是Disk Striping（硬盘分区）技术。RAID 5至少需要三个硬盘，RAID 5不对存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成RAID 5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID 5的一个磁盘数据发生损坏后，利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。写入数据的速度相当慢，若使用Write Back可以让性能改善不少。","text":"影响数据库的因素 Sql查询速度 服务器硬件 存储引擎 大表 大事务 服务器硬件CPUMYSQL不支持多核并发，会带来两方面的风险： 大量的并发使数据库连接数被占满。max_connection 默认为100 CPU耗尽导致宕机QPS：每秒钟处理的查询量 更多核数还是更高频率视具体情况而定：高并发选更多核；CPU密集和复杂SQL选更高频率 磁盘IO硬件升级调整计划任务，避开高峰期，做好磁盘维护 RAIDRAID（Redundant Array of Independent Disks，独立磁盘冗余数组）的基本思想就是把多个相对便宜的硬盘组合起来，成为一个磁盘数组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。 RAID 0：将多个磁盘合并成一个大的磁盘，不会有冗余，并行I/O，速度最快。在所有的级别中，RAID 0的速度是最快的。理论上，多磁盘的效能就等于（单一磁盘效能）×（磁盘数），但实际上受限于总线I/O瓶颈及其他因素的影响，RAID效能会随边际递减。也就是说，假设一个磁盘的效能是50MB/s，两个磁盘的RAID 0效能约96MB/s，三个磁盘的RAID 0也许是130MB/s而不是150MB/s。 RAID 1：两组以上的N个磁盘相互作为镜像，在一些多线程操作系统中能有很好的读取速度，但写入速度略有降低。RAID 1的数据安全性在所有的RAID级别上来说是最好的。但是所有RAID中磁盘利用率最低的一个级别。 RAID 5：是一种存储性能、数据安全和存储成本兼顾的存储解决方案。它使用的是Disk Striping（硬盘分区）技术。RAID 5至少需要三个硬盘，RAID 5不对存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成RAID 5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID 5的一个磁盘数据发生损坏后，利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。写入数据的速度相当慢，若使用Write Back可以让性能改善不少。 RAID 10和RAID 01：RAID 10是先镜像再分区数据，将所有硬盘分为两组，视为RAID 0的最低组合，然后将这两组各自视为RAID 1运作。RAID 10有着不错的读取速度，而且拥有比RAID 0更高的数据保护性。RAID 01则与RAID 10的程序相反，先分区再将数据镜射到两组硬盘。RAID 10巧妙地利用了RAID 0的速度及RAID 1的安全（保护）两种特性，它的缺点是需要较多的硬盘，因为至少必须拥有四个以上的偶数硬盘才能使用。对比：对于数据库应用来说，RAID 10是最好的选择，它同时兼顾了RAID 1和RAID 0的特性。但是，当一个磁盘失效时，性能可能会受到很大的影响，因为条带（strip）会成为瓶颈。 固态硬盘SATA接口的SSD 也支持RAIDPCI-E卡，如Fusion IO。不支持SATA，RAID成本太高，且会占一定内存，优点是速度快。固态硬盘适用于存在大量随机I/O的场景，也可用于解决单线程负载的I/O瓶颈——用于单线程的从服务器更好 网卡流量采用高性能和高带宽的网络接口和交换机对多个网卡绑定，增强可用性和带宽减少从服务器数量进行缓存升级避免使用select * 查询分离业务网络和服务器网络 操作系统相关 文件系统相关 插件式存储引擎MySQL数据库的核心在于存储引擎。存储引擎的好处是，每个存储引擎都有各自的特点，能够根据具体的应用建立不同存储引擎表。 MySQL由以下几部分组成：□ 连接池组件□ 管理服务和工具组件□ SQL接口组件□ 查询分析器组件□ 优化器组件□ 缓冲（Cache）组件□ 插件式存储引擎□ 物理文件 设置引擎create table name () engine=myisam InnoDBInnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。其特点是行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认读取操作不会产生锁。从MySQL数据库5.5.8版本开始，InnoDB存储引擎是默认的存储引擎。 独立表空间可以用optimize table命令压缩，而系统表空间处理起来则较为复杂，空间很难回收；独立表空间可以提高IO性能 支持事务ACID特性，有redo log和undo log 行级锁，支持更多的并发 适合面向在线事务处理（OLTP）的应用 后来也开始支持全文索引和空间函数 查看状态show engine innodb status InnoDB通过使用多版本并发控制（MVCC）来获得高并发性，并且实现了SQL标准的4种隔离级别，默认为REPEATABLE级别。同时，使用一种被称为next-key locking的策略来避免幻读（phantom）现象的产生。除此之外，InnoDB储存引擎还提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash index）、预读（read ahead）等高性能和高可用的功能。 对于表中数据的存储，InnoDB存储引擎采用了聚集（clustered）的方式，因此每张表的存储都是按主键的顺序进行存放。如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。 MyISAMMySQL 5.5.8版本之前MyISAM存储引擎是默认的存储引擎不支持事务、表锁设计，缓冲池只缓存（cache）索引文件，而不缓冲数据文件支持全文索引，主要面向一些OLAP数据库应用。 MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。 表锁的设计使得读写操作是互斥的，读写混合的并发性不好 没有事务日志，表修复check/repair table 支持全文索引和前缀索引 只读文件支持数据压缩，myisampack工具使用赫夫曼（Huffman）编码静态算法来压缩数据，因此使用myisampack工具压缩后的表是只读的 在MySQL 5.0版本之前，MyISAM默认支持的表大小为4GB，如果需要支持大于4GB的MyISAM表时，则需要制定MAX_ROWS和AVG_ROW_LENGTH属性。从MySQL 5.0版本开始，MyISAM默认支持256TB的单表数据 适用场景 非事务型应用，如非财务管理应用 只读应用，共享锁并发 空间类应用，支持空间函数，如GPS应用 MemoryMemory存储引擎（之前称HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。但是表结构还存在，因为放在磁盘上 Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树索引。所以默认情况下等值查询快，不能进行范围索引。要根据业务需求选择索引 只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段（varchar）时是按照定常字段（char）的方式进行的，因此会浪费内存 MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集（intermediate result）。如果中间结果集大于Memory存储引擎表的容量设置，又或者中间结果含有TEXT或BLOB列类型字段，则MySQL数据库会把其转换到MyISAM存储引擎表而存放到磁盘中。 ArchiveArchive存储引擎只支持INSERT和SELECT操作，从MySQL 5.1开始支持索引。Archive存储引擎使用zlib算法将数据行（row）进行压缩后存储，压缩比一般可达1∶10。正如其名字所示，Archive存储引擎非常适合存储归档数据，如日志信息。Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身并不是事务安全的存储引擎，其设计目标主要是提供高速的插入和压缩功能。 总结对比考虑因素：事务，备份，错误恢复，存储引擎特征 大表分库分表：主键的选择，分表后跨分区数据的查询和统计历史数据归档，减少对前后端业务的影响：归档时间点的选择 大事务事务：ACID 并发事务带来的问题 脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 不可重复度和幻读区别：不可重复读的重点是修改，幻读的重点在于新增或者删除。 事务隔离级别SQL 标准定义了四个隔离级别： READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 READ-COMMITTED(读取已提交): 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 REPEATABLE-READ（可重读）: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化): 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别。InnoDB 存储引擎在 分布式事务 的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。 大事务解决问题：锁定太多的数据，造成阻塞和锁超时；回滚时间长；执行时间长 分批处理 移出不必要的select 操作","categories":[{"name":"database","slug":"database","permalink":"http://vergessenwang.github.io/categories/database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://vergessenwang.github.io/tags/MySQL/"}]},{"title":"VUE+ElementUI+SpringBoot实现前后端分离","slug":"VUE-ElementUI-SpringBoot实现前后端分离","date":"2020-03-06T12:40:14.000Z","updated":"2020-05-21T13:03:41.525Z","comments":true,"path":"posts/frontend/2020-03-06-VUE-ElementUI-SpringBoot实现前后端分离.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-03-06-VUE-ElementUI-SpringBoot实现前后端分离.html","excerpt":"环境配置安装node与npmsudo apt-get install -y nodejs 配置运行路径 sudo ln -s /usr/bin/nodejs /usr/bin/node 但是npm用同样的方法处理，报错： bash: /usr/bin/npm: 符号连接的层数过多升级node到指定版本，后面接版本号 先寻找路径：whereis npm 然后查看该目录下路径，删掉有误的 然而再安装npm时却没有对应的包(我还以为跟windows一样npm会跟node一起安装呢..) sudo apt remove nodejs 先删除了看看有没有别的包可用 看了下BBS，好像是官方apt源有点问题一直安装不了npm 尝试安装nodejs-bin, 查询npm时仍然 bash: /usr/bin/npm: 权限不够 寻找npm sudo find / -name npm 看到可以用nvm来解决这个问题","text":"环境配置安装node与npmsudo apt-get install -y nodejs 配置运行路径 sudo ln -s /usr/bin/nodejs /usr/bin/node 但是npm用同样的方法处理，报错： bash: /usr/bin/npm: 符号连接的层数过多升级node到指定版本，后面接版本号 先寻找路径：whereis npm 然后查看该目录下路径，删掉有误的 然而再安装npm时却没有对应的包(我还以为跟windows一样npm会跟node一起安装呢..) sudo apt remove nodejs 先删除了看看有没有别的包可用 看了下BBS，好像是官方apt源有点问题一直安装不了npm 尝试安装nodejs-bin, 查询npm时仍然 bash: /usr/bin/npm: 权限不够 寻找npm sudo find / -name npm 看到可以用nvm来解决这个问题 nvm官方文档 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash nvm install node 果真方便 nvm的详细使用（Linux） 稳妥起见还是安装了一个LTS版本 安装vue-cli开始下载不动，配置一下国内源 npm config set registry https://registry.npm.taobao.org npm install vue npm install -g @vue/cli 速度果然很快了 vue -V 4.2.3版本 使用 VUE UI创建项目vue ui 启动8000端口，界面如下： 该GUI界面只支持3.0以上版本，深色控改成了夜间模式… 手动完成相关配置，项目创建完成后自动打开一个仪表盘 运行服务器, 打开8080端口，出现前端页面，VUE牛皮！ 在IDEA中开发前端VUE在IDEA中导入刚才创建的项目，并安装vue.js插件 在IDE的终端 npm run serve 也可以直接启动8080端口 用假数据测试新建Book.vue文件，写好页面内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;书名&lt;/td&gt; &lt;td&gt;作者&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=&quot;item in books&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.author&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Book&quot;, data()&#123; return&#123; books:[ &#123; id:1, name: &apos;java_learn&apos;, author: &apos;wallen&apos; &#125;, &#123; id:2, name: &apos;java_learn30day&apos;, author: &apos;wallen&apos; &#125;, &#123; id:3, name:&apos;java&apos;, author: &apos;wallen&apos; &#125;, ] &#125; &#125; &#125;&lt;/script&gt; 在router的index.js中引入该组件 前端页面/book热更新 后端Spring Boot创建一个后端项目，选择所需依赖 配置application.perporties连接到Mysql 123456789101112spring.datasource.url = jdbc:mysql://localhost:3306/bookstorespring.datasource.username = ...spring.datasource.password = ...spring.datasource.driverClassName = com.mysql.jdbc.Driver# Specify the DBMSspring.jpa.database = MYSQL# Show or not log for each sql queryspring.jpa.show-sql = truespring.jpa.properties.hibernate.format_sql = trueserver.port=8181 JPA绑定数据创建实体类BookList 12345678@Entity@Datapublic class BookList &#123; @Id private Integer id; private String name; private String author;&#125; 创建BookListRepository 接口 12public interface BookListRepository extends JpaRepository&lt;BookList,Integer&gt; &#123;&#125; 对该接口进行单元测试 接口右键go to test 添加测试代码 1234567891011@SpringBootTestclass BookListRepositoryTest &#123; @Autowired private BookListRepository bookListRepository; @Test void findAll()&#123; System.out.println(bookListRepository.findAll()); &#125;&#125; 运行findAll()方法，报错 Failed to resolve org.junit.platform:junit-platform-launcher:1.5.2 在maven的setting.xml文件中添加阿里云镜像后依赖导入成功，运行报错 Caused by: java.sql.SQLSyntaxErrorException: Table ‘bookstore.book_list’ doesn’t exist 难道不能用驼峰？把之前的类和接口中的List都改成小写，再次运行，成功。可能的原因是JPA与数据库表名对应时只有首字母的大小写可以忽略 因为配置了show-sql 和 hibernate.format_sql 才显示上面的部分 根据提示：Loading class com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class iscom.mysql.cj.jdbc.Driver`. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 更改application中的配置类为com.mysql.cj.jdbc.Driver 对外接口创建BooklistHandler作为controller 1234567891011@RestController@RequestMapping(\"/book\")public class BooklistHandler &#123; @Autowired private BooklistRepository booklistRepository; @GetMapping(\"/findAll\") public List&lt;Booklist&gt; findAll()&#123; return booklistRepository.findAll(); &#125;&#125; 运行项目application的main方法, 访问 http://localhost:8181/book/findAll ，成功读出数据 前后端Axios对接在前端页面发送请求后端8181端口 vue add axios 在IDEA终端中安装插件axios，安装完毕在src中自动添加了一个plugins文件夹 Vue2.0之后，尤雨溪推荐大家用axios替换JQuery ajax，axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 支持 Promise API 客户端支持防止CSRF 提供了一些并发请求的接口（重要，方便了很多的操作） 从 node.js 创建 http 请求 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。简单来说： ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。 Axios中文说明 在Book.vue中添加初始化方法create() 12345created() &#123; axios.get(&apos;http://localhost:8181/book/findAll&apos;).then(function(resp)&#123; console.log(resp) &#125;) &#125; 请求类型为get , then 是回调函数，传入reponse结果 CROS跨域问题可以在前端或者后端进行解决，这里选择后端。 创建CrosConfig配置类 123456789101112131415161718@Configurationpublic class CrosConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; //设置允许跨域的路径 registry.addMapping(\"/**\") //设置允许跨域请求的域名 .allowedOrigins(\"*\") //是否允许证书 不再默认开启 .allowCredentials(true) //设置允许的方法 .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\",\"HEAD\",\"OPTIONS\") //跨域允许时间 .maxAge(3600) .allowedHeaders(\"*\"); &#125;&#125; 然后刷新8080,就可以在控制台获取到后台的data了 后台数据展示到页面123456created() &#123; const _this = this axios.get('http://localhost:8181/book/findAll').then(function(resp)&#123; _this.books = resp.data &#125;) &#125; 这里需要注意的是function原本的this 不能访问到外面的变量，所以要用_this把当前页面传进去 数据成功加载出来了 集成ElementUInpm install --save element-ui 项目命令行安装或者vue ui 查找element插件安装 重启项目，打开8080端口，主页会多出一个Button Element官方文档 CV布局容器中代码到App.vue , 注意html部分的el-container要放到div中 主页已经与官方示例一致，接下来分析el-xxx 了解其构成 el-menu :default-openeds 默认展开的子菜单，通过子菜单的index 值来关联 :default-active 默认选中的子菜单 el-submenu 可展开的菜单 index 必须是加引号的文本类型 template 菜单名 i 通过class 设置菜单图标 el-icon-message el-icon-menu el-icon-setting 更多样式参考icon组件 el-menu-item 菜单不可展开的子节点 index 必须是加引号的文本类型 el-main 一般用来存放页面跳转时的刷新内容 router-view 放在这里实现路由 导航动态加载App.vue中设置左侧菜单 12345678&lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt; &lt;el-menu&gt; &lt;el-submenu v-for=&quot;(item,index) in $router.options.routes&quot; :index=&quot;index+&apos;&apos;&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;&#123;&#123;item.name&#125;&#125;&lt;/template&gt; &lt;el-menu-item v-for=&quot;(item2,index2) in item.children&quot; :index=&quot;index+&apos;-&apos;+index2&quot;&gt;&#123;&#123;item2.name&#125;&#125;&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt;&lt;/el-aside&gt; v-for循环可以遍历index.js中配置的routes，加载相应个数的el-menu 这样的好处是方便以后新增菜单页面 读取出页面名称，:index = “index+’-‘“ 将遍历的下标转为文本类型的菜单index, 方便控制index.js路由内容123456789101112131415161718192021222324252627282930313233343536const routes = [ &#123; path: '/', name: 'nav1', component: App, children:[ &#123; path: '/pageone', name:\"pageone\", component: PageOne &#125;, &#123; path: '/pagetwo', name:\"pagetwo\", component: PageTwo &#125;, ] &#125;, &#123; path:\"/navigation\", name:\"nav2\", component:App, children:[ &#123; path: '/pagethree', name:\"pagthree\", component: PageThree &#125;, &#123; path: '/pagefour', name:\"pagefour\", component: PageFour &#125;, ] &#125;] 导航效果 左边的导航可以点击展开，下面的页面也可以点击切换了 确定驻留区和更新区可以看到上面的页面存在着页面嵌套的问题，接下来要对切换区域进行划分 App.vue只加载路由 12345&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 菜单栏放在Index.vue中 1234567891011121314151617&lt;template&gt; &lt;el-container style=&quot;height: 500px; border: 1px solid #eee&quot;&gt; &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt; &lt;el-menu&gt; &lt;el-submenu v-for=&quot;(item,index) in $router.options.routes&quot; :index=&quot;index+&apos;&apos;&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;&#123;&#123;item.name&#125;&#125;&lt;/template&gt; &lt;el-menu-item v-for=&quot;(item2,index2) in item.children&quot; :index=&quot;index+&apos;-&apos;+index2&quot;&gt;&#123;&#123;item2.name&#125;&#125;&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/el-container&gt;&lt;/template&gt; 然后把index.js中的app组件改为index，即可去掉嵌套 菜单切换与页面绑定 el-menu 标签添加router属性 Index.vue中el-menu 标签添加 router 在页面添加router-view 标签，这个容器可以动态渲染router el-menu-item 标签index 值就是要跳转的router el-menu-item 标签index 值改为`:index=”item2.path” 默认初始页面 redirect:跳转路径 路由数组中添加 redirect:&quot;/pageone&quot; 当前显示的页面被选中(特殊颜色) :class=&quot;$route.path==item2.path?&#39;is-active&#39;:&#39;&#39;&quot; 即地址栏路径与菜单栏item的index路径一致时，将该item标记特殊颜色 默认展开菜单 el-menu 添加 :default-openeds=&quot;[&#39;0&#39;,&#39;1&#39;]&quot; 表示默认展开菜单1和菜单2 1234567891011121314151617&lt;template&gt; &lt;el-container style=&quot;height: 500px; border: 1px solid #eee&quot;&gt; &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt; &lt;el-menu router :default-openeds=&quot;[&apos;0&apos;,&apos;1&apos;]&quot;&gt; &lt;el-submenu v-for=&quot;(item,index) in $router.options.routes&quot; :index=&quot;index+&apos;&apos;&quot;&gt; &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;&#123;&#123;item.name&#125;&#125;&lt;/template&gt; &lt;el-menu-item v-for=&quot;(item2,index2) in item.children&quot; :index=&quot;item2.path&quot; :class=&quot;$route.path==item2.path?&apos;is-active&apos;:&apos;&apos;&quot;&gt;&#123;&#123;item2.name&#125;&#125;&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/el-container&gt;&lt;/template&gt; 基于具体页面的数据对接选择一个所需的表样式和分页样式，注意要放在一个容器中，故可以新建一个div 绑定本页面script 中的数据el-table-column 标签的label 表示表头的名称，prop 用于跟script 中的tabelData中对应键名称进行绑定，实现数据导入 el-pagination分页标签 设置每页展示的记录条数:page-size=&quot;5&quot; 点击切换页面记录 @current-change=&quot;page&quot; 绑定page切换方法，方法要在script中实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;template&gt; &lt;div&gt; &lt;el-table :data=&quot;tableData&quot; border style=&quot;width: 100%&quot;&gt; &lt;el-table-column prop=&quot;id&quot; label=&quot;编号&quot; width=&quot;150&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;书名&quot; width=&quot;150&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;author&quot; label=&quot;标签&quot; width=&quot;150&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;操作&quot; width=&quot;150&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button @click=&quot;handleClick(scope.row)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;查看&lt;/el-button&gt; &lt;el-button type=&quot;text&quot; size=&quot;small&quot;&gt;编辑&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-pagination background layout=&quot;prev, pager, next&quot; :page-size=&quot;5&quot; :total=&quot;50&quot; @current-change=&quot;page&quot;&gt; &lt;/el-pagination&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; handleClick(row) &#123; console.log(row); &#125;, page(currentPage)&#123; switch(currentPage)&#123; case 1: this.tableData = [&#123; id: 1, name: &apos;前端&apos;, author: &apos;f&apos;, &#125;, ] break; case 2: this.tableData = [&#123; id: 2, name: &apos;后端&apos;, author: &apos;b&apos;, &#125;,] break; &#125; &#125; &#125;, data() &#123; return &#123; tableData: [&#123; id: 1, name: &apos;前端&apos;, author: &apos;f&apos;, &#125;, &#123; id: 2, name: &apos;后端&apos;, author: &apos;b&apos;, &#125;,] &#125; &#125; &#125;&lt;/script&gt; 页面效果 绑定后端数据首先在后端也要实现数据分页，JPA已经实现了这个功能, 进行测试，注意由于有多个重载，要选对参数类型。 1234567891011121314@SpringBootTestclass VueBackendtestApplicationTests &#123; @Autowired private BooklistRepository repository; @Test void contextLoads() &#123; PageRequest pageRequest = PageRequest.of(0,2); Page&lt;Booklist&gt; page = repository.findAll(pageRequest); int i = 0; &#125;&#125; 取第0页的两条记录，bug测试结果 BooklistHandler 中进行分页展示 123456789101112@RestController@RequestMapping(\"/book\")public class BooklistHandler &#123; @Autowired private BooklistRepository booklistRepository; @GetMapping(\"/findAll/&#123;page&#125;/&#123;size&#125;\") public Page&lt;Booklist&gt; findAll(@PathVariable(\"page\") Integer page, @PathVariable(\"size\") Integer size)&#123; PageRequest request = PageRequest.of(page,size); return booklistRepository.findAll(request); &#125;&#125; 打开http://localhost:8181/book/findAll/0/2 查看分页内容 对接要做的就是用实际的数据去替换tableData, 注意resp获取的数据格式, 数据在resp.data.content中 script 初始化 1234567created() &#123; const _this = this axios.get('http://localhost:8181/book/findAll/0/2').then(function(resp)&#123; //console.log(resp) _this.tableData = resp.data.content &#125;) &#125; 前端内容已更新为数据库内容 还要动态获取page和size, 在data中定义pageSize和total 变量，从created()中获取值 然后绑定给el-pagination的对应属性 :page-size=&quot;pageSize&quot; :total=&quot;total&quot; 同时更改跳转函数 page(), 只需在created()基础上传入当前页面参数即可 完整script代码(每页显示两条记录) 123456789101112131415161718192021222324252627282930313233&lt;script&gt; export default &#123; methods: &#123; handleClick(row) &#123; console.log(row); &#125;, page(currentPage)&#123; const _this = this axios.get(&apos;http://localhost:8181/book/findAll/&apos;+(currentPage-1)+&apos;/2&apos;).then(function(resp)&#123; _this.tableData = resp.data.content _this.pageSize = resp.data.size _this.total = resp.data.totalElements &#125;) &#125; &#125;, data() &#123; return &#123; pageSize:&apos;&apos;, total:&apos;&apos;, tableData: [] &#125; &#125;, created() &#123; const _this = this axios.get(&apos;http://localhost:8181/book/findAll/0/2&apos;).then(function(resp)&#123; _this.tableData = resp.data.content _this.pageSize = resp.data.size _this.total = resp.data.totalElements &#125;) &#125; &#125;&lt;/script&gt;","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://vergessenwang.github.io/tags/vue/"}]},{"title":"黑盒测试用例设计","slug":"黑盒测试用例设计","date":"2020-03-04T16:58:05.000Z","updated":"2020-03-04T16:59:23.971Z","comments":true,"path":"posts/Test/2020-03-05-黑盒测试用例设计.html","link":"","permalink":"http://vergessenwang.github.io/posts/Test/2020-03-05-黑盒测试用例设计.html","excerpt":"测试用例的构成要素 用例编号：唯一标识 如QQmail_login_001 用例标题：简要描述测试目的 何种情况下做何事有何结果 测试项目：所属项目 用例级别：重要程度，优先级 P1&gt;P2&gt;P3 预设条件：执行前提，如环境/数据 — 非必须 测试输入 执行步骤 预期结果：与执行的实际结果对比 在实际中根据项目要求对用例设计要素进行调整 黑盒测试用例设计方法从理论上讲，黑盒测试只能通过穷举输入测试。但是实际工作中这种方法是不可行的。所以衍生出多种黑盒测试用例设计方法，包括等价类划分法、边界值分析法、错误推测法、因果图发、判定表驱动法、正交试验设计法、功能图法、场景法等。 等价类分类代替穷举，根据功能需求分类 等价类：在所有测试的数据中，具有某种共同特征的子集 等价划分：是把程序的输入域划分成若干部分（子集），然后从每个部分中选取少数代表性数据作为测试用例。每一类的代表性数据在测试中的作用等价于这一类中的其他值。 有效等价类：是指对于程序的规格说明来说是合理的，有意义的输入数据构成的集合.利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。 无效等价类：与有效等价类的定义恰巧相反。无效等价类中是无效输入，系统预期返回一个错误值。测试无效输入能确保软件具有更高的可靠性。 设计测试用例时，要同时考虑这两种等价类.因为，软件不仅要能接收合理的数据，也要能经受意外的考验.这样的测试才能确保软件具有更高的可靠性。","text":"测试用例的构成要素 用例编号：唯一标识 如QQmail_login_001 用例标题：简要描述测试目的 何种情况下做何事有何结果 测试项目：所属项目 用例级别：重要程度，优先级 P1&gt;P2&gt;P3 预设条件：执行前提，如环境/数据 — 非必须 测试输入 执行步骤 预期结果：与执行的实际结果对比 在实际中根据项目要求对用例设计要素进行调整 黑盒测试用例设计方法从理论上讲，黑盒测试只能通过穷举输入测试。但是实际工作中这种方法是不可行的。所以衍生出多种黑盒测试用例设计方法，包括等价类划分法、边界值分析法、错误推测法、因果图发、判定表驱动法、正交试验设计法、功能图法、场景法等。 等价类分类代替穷举，根据功能需求分类 等价类：在所有测试的数据中，具有某种共同特征的子集 等价划分：是把程序的输入域划分成若干部分（子集），然后从每个部分中选取少数代表性数据作为测试用例。每一类的代表性数据在测试中的作用等价于这一类中的其他值。 有效等价类：是指对于程序的规格说明来说是合理的，有意义的输入数据构成的集合.利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。 无效等价类：与有效等价类的定义恰巧相反。无效等价类中是无效输入，系统预期返回一个错误值。测试无效输入能确保软件具有更高的可靠性。 设计测试用例时，要同时考虑这两种等价类.因为，软件不仅要能接收合理的数据，也要能经受意外的考验.这样的测试才能确保软件具有更高的可靠性。 划分准则等价类划分准则 在输入条件规定了取值范围或值的个数的情况下，则可以确立有一个有效等价类和两个无效等价类。—-如手机号由11位构成，无效则大/多于或者小/少于 在输入条件规定了输入值的集合或者规定了“必须如何”的条件情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则） —- 如要求电话都是数字，无效的情况可能是字母/汉字/特殊字符等多种情况 在输入条件是一个布尔量的情况下，可以确定一个有效等价类和一个无效等价类。 在规定了输入数据的一组值（假定n个），并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。 测试用例规则 为每一个等价类规定一个唯一的编号。 设计一个新的测试用例，使其尽可能多的覆盖尚未被覆盖的有效类。重复这一步，直到所有的有效等价类都被覆盖为止。 设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类被覆盖为止。 边界值大量的错误是发生在输入或输出范围的边界上，而不是在输入范围的内部。经验证明，考虑了边界调节的测试用例与其他没有考虑边界条件的测试用例相比，具有更高的测试回报率。 相比与等价类法，多了一个步骤：确定上点，离点，内点 上点 离点 内点 如果是闭区间，例如[1，10]。那么上点就是1,10。内点就是区间内任意一个数字，例如5。离点则是0,11 如果是开区间，例如（1,10）。那么上点就是1,10。内点就是区间内任意一个数字，例如5。离点则是（2,9） 这两个最大的区别就是在于离点的不同，概括起来一句话就是闭两边，开中间。也就是说闭区间的离点是区间外边相邻的两个数字（0,11），开区间的离点就是区间里边相邻的两个数字（2,9）。如两位整数加法器数的范围为-99—99，则应测试-99，-100和99，100 继续以电话号码的地区嘛为例，现在需要关注的是边界，如无效等价类6要测小于四位数的情况，现在的边界值就是3位 判定表使用等价类方法时对于输入域及输出域存在关联时无法覆盖，可以理解为判定表通过组合覆盖更多的情况 优点：能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。因此，利用判定表能够设计出完整的测试用例集合。在一些数据处理问题当中，某些操作的实施依赖于多个逻辑条件的组合，即：针对不同逻辑条件的组合值，分别执行不同的操作。判定表适合于处理这类问题。 判定表要素1)条件桩（Condition Stub）：列出了问题得所有条件。通常认为列出的条件的次序无关紧要。—- 输入 2)动作桩（Action Stub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。—- 输入的结果 3)条件项（Condition Entry）：列出针对它左列条件的取值。在所有可能情况下的真假值。—条件集合 4)动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作。 —- 动作集合 规则及规则合并1)规则：任何一个条件组合的特定取值及其相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。显然,判定表中列出多少组条件取值,也就有多少条规则,既条件项和动作项有多少列。 2)化简：就是规则合并有两条或多条规则具有相同的动作，并且其条件项之间存在着极为相似的关系。 如果动作结果一样，对于某些因素取“1”或“0”没有影响，即以“—”表示，并合并。 步骤：定义条件桩与动作桩 –&gt; 设计优化判定表 –&gt; 填写动作项 –&gt; 简化判定表 –&gt; 抽取用例(每个规则一条用例) 假定：优先警告缺纸，然后警告没有墨粉，最后警告驱动程序不对。 判定表的优/缺点优点：把复杂的问题按各种可能的情况一一列举，简明而易于理解，也避免遗漏。 缺点：不能表达重复执行的动作，如循环结构。判定表不能很好的伸缩。如有n个条件的判定表有2^n个规则。 因果图判定表的指数增长不适合复杂的条件，是先组合再分析关系；而因果图是先考虑所有输入/输出条件的相关制约关系及组合，输入与输出的关系，再根据分析的关系转化为判定表的规则 输入和输出的关系 输入条件之间的关系 输出条件之间的关系 设计步骤： 分析程序规格说明的描述中，哪些是原因，哪些是结果。 分析程序规格的描述中语义的内容，并将其表示成连接各个原因与各个结果的“因果图”。由于语法或环境的限制，有些原因与原因之间、原因与结果之间的组合情况不可能出现。为表明这些特殊情况，在因果图上用一些记号表明约束或限制条件。 把因果图转换为决策表。用0和1标识，中间状态也放在开始里面 根据决策表中的每一列设计测试用例。即：找出原因、结果 – 找出关系，画因果图 – 找出约束和限制，加上标记 – 转化为决策表 – 为每一个规则设计测试用例 场景法软件几乎都是用事件触发来控制流程的，时间触发时的情景形成场景，同一事件不同的触发顺序和处理结果形成事件流 事件流和备选流基本流：仅有一个基本流；经过用例的最简单的路径，指每个步骤都“正常”运作时所发生的事 —-正常 备选流 ：可以有多个；可选的或备选的情况 ，异常事件流程。—- 异常 场景是事件流的一个实例，由基本流或（基本流+备选流）的步骤组成，表明了用户执行系统操作系列。从开始到结束才算一个场景，其实画出来有点像UML中的流程图 备选流越多，场景越多，执行路径越多，将导致场景爆炸。 选取典型场景进行测试，其基本如下：1、最少场景数等于基本流与备选流的总数。2、有且唯一有一个场景仅包含基本流。3、对应某个备选流，至少应该有一个场景覆盖备选流，且在该场景中应尽量避免覆盖其他备选流。 上图的用例场景如下： 正交法根据正交性从全面试验中挑选出部分有代表性的点进行试验，这些有代表性的点具备了“均匀分散，齐整可比”的特点，正交试验设计是一种基于正交表的、高效率、快速、经济的试验。 正交实验设计方法：从大量的测试案例中挑选适量的、有代表性的例子，从而合理地安排测试的一种科学实验设计方法。通常用于配置测试 因素与水平因素数：条件因子的个数 水平数：条件因子取值的个数，取所有条件因子中取得值数目最大的那个。 正交表根据因素数、水平数、最小实验次数n，选择合适的正交表。 n = ∑(每列因素的水平数-1) + 1，也就是说正交表的行数要取大于n的最小值。 把变量的值映射到表中，每一行即一个测试用例。 使用正交表设计用例，（1）确定因素的取值范围或集合，（2）采用等价类划分、边界值分析等方法确定测试数据，（3）将确定的测试数据作为对应因素的水平值，（4）根据合适的正交表设计用例。 并不是我们想要什么正交表就有什么正交表，我们选取正交表时只能从现有的正交表中进行选择，而且选择的正交表要满足上述中的因素数、水平数、和最小实验次数n，在这个前提下选择实验次数最少的一个。 步骤：分析需求获取因子及水平 –&gt; 根据因子及水平数选择正交表 –&gt; 替换因子水平，获取实验次数 –&gt; 细化输出测试用例 错误推测法经验和直觉，没有具体的步骤，基于以往的项目经历对常出问题的点针对性设计测试用例 一般不单独使用，要在其他测试方法之上进行针对性测试 总结 可以关注该作者的文章","categories":[{"name":"Test","slug":"Test","permalink":"http://vergessenwang.github.io/categories/Test/"}],"tags":[{"name":"黑盒测试","slug":"黑盒测试","permalink":"http://vergessenwang.github.io/tags/黑盒测试/"}]},{"title":"IDEA内置Database插件连接Deepin上的MySql","slug":"IDEA内置Database插件连接Deepin上的MySql","date":"2020-03-04T06:49:09.000Z","updated":"2020-03-06T12:41:46.056Z","comments":true,"path":"posts/database/2020-03-04-IDEA内置Database插件连接Deepin上的MySql.html","link":"","permalink":"http://vergessenwang.github.io/posts/database/2020-03-04-IDEA内置Database插件连接Deepin上的MySql.html","excerpt":"配置serversudo apt-get install -y mysql-server mysql-client 安装 sudo mysql -uroot -p 初始密码直接空格 进入Mysql命令行 use mysql; update user set authentication_string=&#39;新密码&#39; where user=&#39;root&#39;; 注意修改密码要加单引号","text":"配置serversudo apt-get install -y mysql-server mysql-client 安装 sudo mysql -uroot -p 初始密码直接空格 进入Mysql命令行 use mysql; update user set authentication_string=&#39;新密码&#39; where user=&#39;root&#39;; 注意修改密码要加单引号 进行一些基本的sql操作 么的问题 IDEA驱动设置在IDEA中使用时 mysql-connector-java-8.0.15.jar 下载超时 国内下载链接.. 在项目中导入该jar依赖包 在database插件中配置驱动器 找到IDEA默认的存放驱动器的路径，将jar放在该目录下 /home/wliana/.IntelliJIdea2019.3/config/jdbc-drivers 还得下一个5.1.47版本，放在Mysql for 5.1 重新测试连接 Access denied for user ‘root‘@’localhost’ 连接问题排查可能访问权限没有开放，回到mysql 进行授权 grant all privileges on *.* to &#39;root&#39; @&#39;%&#39; identified by &#39;root&#39;; flush privileges; 然而并不是这个原因，经过好长时间多角度试探，我发觉了一个盲点…应该是密码编码转换的问题 select user, plugin from mysql.user; root的plugin被修改成了unix_socket，用密码登陆的plugin应该是mysql_native_password update mysql.user set plugin=&quot;mysql_native_password&quot; where user=&quot;root&quot;; 但是这样一来我用原来的密码登不上了….应该同步更新一下密码的 /etc/init.d/mysql stop 停止服务 企图跳过授权表…：mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp; ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’ (2 “No such file or directory”) 尝试重启：会重新生产mysqld.sock文件 成功登进去并重置了密码，但还是有同样的问题….算了，该睡觉了 感觉问题出在Linux上，因为之前的plugin是unix_socket 在Debian中软件包mysql已经替换成了mariadb了。在安装后/etc/mysql/mariadb.cnf预设了root用户使用socket的连接方式，所以不输入密码也可在命令行直接使用mysql命令登录。 难道说IDEA用@其实是一种远程连接的形式？ 修改/etc/mysql/mariadb.conf.d/50-server.cnf中的bind-address为允许的网络地址，若为整个网络则填入0.0.0.0或注释掉 啊，我好像发现问题了 authentication_string = password(&#39;密码&#39;) 应该是这样才对，我之前是直接跟的一个字符串… 回到IDEA测试 连接成功！ 可以直接在IDEA中进行mysql操作啦","categories":[{"name":"database","slug":"database","permalink":"http://vergessenwang.github.io/categories/database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://vergessenwang.github.io/tags/MySQL/"}]},{"title":"Git关联Github和码云并利用IDEA内置工具","slug":"Git关联Github和码云并利用IDEA内置工具","date":"2020-03-02T09:07:38.000Z","updated":"2020-03-02T09:40:15.199Z","comments":true,"path":"posts/Project/2020-03-02-Git关联Github和码云并利用IDEA内置工具.html","link":"","permalink":"http://vergessenwang.github.io/posts/Project/2020-03-02-Git关联Github和码云并利用IDEA内置工具.html","excerpt":"Git教程 Git与Svn对比Svn是集中式版本控制系统，必须联网才能工作。在一定成程度上可以看到其他开发人员在干什么，管理员也可以很轻松的掌握每个人的开发权限。 缺点：服务器单点故障；容错性差 Git是分布式版本控制系统，每人的电脑上有一个完整的本地仓库，多人协作时只需要把各自的修改推送给对方 初次使用配置安装git sudo apt-get install git 配置用户名和邮箱 git config --global user.name &quot;用户名&quot; git config --global user.email &quot;邮箱&quot; 生成ssh公匙、私匙 ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;三次回车 将id_rsa.pub的内容追加到authorized_keys 中 cat /home/wliana/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 其中id_rsa 为私钥，id_rsa.pub 为公钥 在github，进入Account Settings，左边选择SSH Keys，Add SSH Key, 粘贴cat /home/deepin/.ssh/id_rsa.pub获取的key 测试下是否配置成功 ssh -T git@github.com 按提示输入 yes 连接成功","text":"Git教程 Git与Svn对比Svn是集中式版本控制系统，必须联网才能工作。在一定成程度上可以看到其他开发人员在干什么，管理员也可以很轻松的掌握每个人的开发权限。 缺点：服务器单点故障；容错性差 Git是分布式版本控制系统，每人的电脑上有一个完整的本地仓库，多人协作时只需要把各自的修改推送给对方 初次使用配置安装git sudo apt-get install git 配置用户名和邮箱 git config --global user.name &quot;用户名&quot; git config --global user.email &quot;邮箱&quot; 生成ssh公匙、私匙 ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;三次回车 将id_rsa.pub的内容追加到authorized_keys 中 cat /home/wliana/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 其中id_rsa 为私钥，id_rsa.pub 为公钥 在github，进入Account Settings，左边选择SSH Keys，Add SSH Key, 粘贴cat /home/deepin/.ssh/id_rsa.pub获取的key 测试下是否配置成功 ssh -T git@github.com 按提示输入 yes 连接成功 Github和本地Git关联远程仓库在Github上新建一个远程仓库，最好不要勾选README.md 由于已经配置了RSA，可以直接使用SSH协议 本地仓库可参照上图命令 进入文件夹，使用git init变成可Git管理的库（或者在文件夹中新建一个.git文件夹） 将项目粘贴到仓库中（粘贴后可以通过git status来查看你当前的状态） git add . 把该目录下的所有文件添加到仓库（注意点是用空格隔开的） git commit -m提交注释把项目提交到仓库 关联及推送$ git remote add origin git@&lt;用户名&gt;/&lt;目标仓库&gt;.git 关联好之后我们就可以把本地库的所有内容推送到远程仓库 首次推送使用：$ git push -u origin master 新建的远程仓库是空的，所以要加上-u 远程仓库里面有了内容之后使用：$ git push origin master 准备回到github上看看，结果又连不上了，看来远程仓库还是的选国内的啊…哦豁，连博客都挂了… 同时关联到码云基于上面github不太稳定的原因，打算同时关联到码云。 注册并添加公钥，创建仓库 多么熟悉的味道.. 下面参照官方文档 如何保持码云Gitee和Github 同步更新 查看目前关联的远程仓库，发现有一个orgin , 这是之前关联到github上的，为了便于管理，删掉并重命名 先删除已关联的名为origin的远程库 git remote rm origin 通过 git remote add &lt;name&gt; &lt;url-of-remote&gt;指令来添加远程仓库 用git remote -v查看远程库信息,可以看到两个远程库 返回码云仓库，已更新, 大功告成 流程及命令 工作区域Git分为三个工作区域：工作区 Working Directory、暂存区 Staging Area、GIT仓库 repository 工作区（Working Directory）就是源码所在目录 隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 文件状态 Untracked 未追踪，即新建一个文件，还没有被git追踪，不会到版本库内。 Unmodified 未修改，该文件在git版本库内，但是还没有被修改。 modified 已修改，该文件在git版本库，已经修改，但还没有暂存。 Staged 已暂存，有修改的文件已经通过git add添加到暂存区。 仓库内文件的状态可以通过git status查看。 分支管理查看分支：git branch 创建分支：git branch 分支名 切换分支：git checkout 分支名 或者git switch 分支名 创建+切换分支：git checkout -b 分支名或者git switch -c 分支名 合并某分支到当前分支：git merge 分支名 删除分支：git branch -d 分支名 假设分支为dev, 合并Fast-forward是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 常用命令命令思维导图，来自文章 git常用操作命令总结(思维导图) 忽略特殊文件在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 在IDEA中使用Git在工具栏找到VCS ，新建Git目录 或者直接打开一个已经初始化了的工作区目录 这时IDEA右上角多了一些git操作 分别是pull 拉取更新；commit 提交；历史版本；回滚 在commit时就可以勾选需要同步的文件 history会在下面出现一个管理界面 同时VSC内容也发生了变化 这样就可以直接使用IDEA内置的工具来进行操作了 讲道理，为什么图这么糊？！强迫症选手根本无法忍受…明明我本地的图片很高清，上去后台看了一下，是原图..所以PicGo和OSS都没有压缩，那问题难道出在Typora的分辨率上？ 打开以前Blog看了一下，好像还真是..","categories":[{"name":"Project","slug":"Project","permalink":"http://vergessenwang.github.io/categories/Project/"}],"tags":[{"name":"版本管理","slug":"版本管理","permalink":"http://vergessenwang.github.io/tags/版本管理/"}]},{"title":"Java正则表达式","slug":"Java正则表达式","date":"2020-02-26T09:56:45.000Z","updated":"2020-02-26T10:02:52.729Z","comments":true,"path":"posts/Java/2020-02-26-Java正则表达式.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-02-26-Java正则表达式.html","excerpt":"正则表达式是一套标准，可用于任何语言 JDK内置正则表达式引擎：Java.uilt.regex 方法String类里也提供了如下几个特殊的方法。 boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。 String replaceAll(String regex, String replacement)：将该字符串中所有匹配regex的子串替换成replacement String replaceFirst(String regex, String replacement)：将该字符串中第一个匹配regex的子串替换成replacement String[] split(String regex)：以regex作为分隔符，把该字符串分割成多个子串。 上面这些特殊的方法都依赖于Java提供的正则表达式支持，除此之外，Java还提供了Pattern和Matcher两个类专门用于提供正则表达式支持。 精确匹配 需匹配 正则表达式 Java中正则 a&amp;c a\\&amp;c a\\&amp;c a和c a\\u548cc a\\u548cc 正则中特殊符号最好转义一下，而Java中\\也需转义 非ASCII字符用了\\u####表示，也要转义，不过这里Markdown没有显示岀来","text":"正则表达式是一套标准，可用于任何语言 JDK内置正则表达式引擎：Java.uilt.regex 方法String类里也提供了如下几个特殊的方法。 boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。 String replaceAll(String regex, String replacement)：将该字符串中所有匹配regex的子串替换成replacement String replaceFirst(String regex, String replacement)：将该字符串中第一个匹配regex的子串替换成replacement String[] split(String regex)：以regex作为分隔符，把该字符串分割成多个子串。 上面这些特殊的方法都依赖于Java提供的正则表达式支持，除此之外，Java还提供了Pattern和Matcher两个类专门用于提供正则表达式支持。 精确匹配 需匹配 正则表达式 Java中正则 a&amp;c a\\&amp;c a\\&amp;c a和c a\\u548cc a\\u548cc 正则中特殊符号最好转义一下，而Java中\\也需转义 非ASCII字符用了\\u####表示，也要转义，不过这里Markdown没有显示岀来 符号合法字符 特殊字符特殊字符在正则表达式中有其特殊的用途，如果需要匹配这些特殊字符，就必须首先将这些字符转义，也就是在前面添加一个反斜线（\\） 将上面多个字符拼起来，就可以创建一个正则表达式。 预定义字符“通配符”是可以匹配多个字符的特殊字符。正则表达式中的“通配符”远远超出了普通通配符的功能，它被称为预定义字符 12String input = “1990”;boolean is19xx = input.matches(“19\\\\d\\\\d”); 范围匹配方括号表达式 注意只能匹配[]其中一个字符 \\^写在[]取非；写在开始从行的开头开始匹配 正则表示还支持圆括号表达式，用于将多个表达式组成一个子表达式，圆括号中可以使用或运算符（|）。例如，正则表达式”(public|protected|private)”用于匹配Java的三个访问控制符其中之一。\\\\w{3,20}@\\\\w+\\\\.(com|org|cn|net|gov) 圆括号还可用于提取所需字符串，去掉多余内容 边界匹配符 数量标识符正则表达式支持的数量标识符有如下几种模式 Greedy（贪婪模式）：数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为——你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。 Reluctant（勉强模式）：用问号后缀（?）表示，它只会匹配最少的字符。也称为最小匹配模式。 Possessive（占有模式）：用加号后缀（+）表示，目前只有Java支持占有模式，通常比较少 使用Pattern和Matcher类Pattern对象是正则表达式编译后在内存中的表示形式，因此，正则表达式字符串必须先被编译为Pattern对象，然后再利用该Pattern对象创建对应的Matcher对象。执行匹配所涉及的状态保留在Matcher对象中，多个Matcher对象可共享同一个Pattern对象。Pattern是不可变类，可供多个并发线程安全使用。只编译一次然后多次使用可以提高匹配效率 123//将一个字符串编译成Pattern对象Pattern p=Pattern.compile(\"a*b\");//使用Pattern对象创建Matcher对象Matcher m=p.matcher(\"aaaaab\");boolean b=m.matches(); //返回true 如果某个正则表达式仅需一次使用，则可直接使用Pattern类的静态matches方法，此方法自动把指定字符串编译成匿名的Pattern对象 boolean b=Pattern.matches(&quot;a*b&quot;, &quot;aaaaab&quot;); //返回true 但采用这种语句每次都需要重新编译新的Pattern对象，不能重复利用已编译的Pattern对象，所以效率不高。 Matcher类提供了如下几个常用方法。 find()：返回目标字符串中是否包含与Pattern匹配的子串。 find()方法还可以传入一个int类型的参数，带int参数的find()方法从该int索引处向下搜索。group()：返回上一次与Pattern匹配的子串。 start()：返回上一次与Pattern匹配的子串在目标字符串中的开始位置。 end()：返回上一次与Pattern匹配的子串在目标字符串中的结束位置加1。 lookingAt()：返回目标字符串前面部分与Pattern是否匹配。 matches()：返回整个目标字符串与Pattern是否匹配。 reset()，将现有的Matcher对象应用于一个新的字符序列。replaceAll()把字符串中所有与正则表达式匹配的子串替换replaceFirst()，该方法只替换第一个匹配的子串 在Pattern、Matcher类的介绍中经常会看到一个CharSequence接口，该接口代表一个字符序列，其中CharBuffer、String、StringBuffer、StringBuilder都是它的实现类。","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://vergessenwang.github.io/tags/正则表达式/"}]},{"title":"JVM数据分区","slug":"JVM数据分区","date":"2020-02-19T15:57:27.000Z","updated":"2020-02-19T15:58:26.485Z","comments":true,"path":"posts/Java/2020-02-19-JVM数据分区.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-02-19-JVM数据分区.html","excerpt":"HotSpot虚拟机HotSpot虚拟机是Oracle/OpenJDK中JVM的一种默认实现，其他实现还有BEA System公司的JRockit与IBM公司的IBM J9。 HotSpot虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准即时编译和栈上替换编译（On-Stack Replacement，OSR）行为 HotSpot虚拟机中含有两个即时编译器，分别是编译耗时短但输出代码优化程度较低的客户端编译器（简称为C1）以及编译耗时长但输出代码优化质量也更高的服务端编译器（简称为C2）通常它们会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统 自JDK 10起，HotSpot中又加入了一个全新的即时编译器：Graal编译器。Graal编译器是以C2编译器替代者的身份登场的。Graal能够做比C2更加复杂的优化，如“部分逃逸分析”（Partial Escape Analysis），也拥有比C2更容易使用激进预测性优化（Aggressive Speculative Optimization）的策略，支持自定义的预测性假设等。 然而需要预热才能达到最高性能等特点有悖于目前微服务架构的趋势。一种解决方案是提前编译，Substrate VM是在Graal VM 0.20版本里新出现的一个极小型的运行时环境，包括了独立的异常处理、同步调度、线程管理、内存管理（垃圾收集）和JNI访问等组件，目标是代替HotSpot用来支持提前编译后的程序执行。但要求目标程序是完全封闭的，即不能动态加载其他编译器不可知的代码和类库。","text":"HotSpot虚拟机HotSpot虚拟机是Oracle/OpenJDK中JVM的一种默认实现，其他实现还有BEA System公司的JRockit与IBM公司的IBM J9。 HotSpot虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准即时编译和栈上替换编译（On-Stack Replacement，OSR）行为 HotSpot虚拟机中含有两个即时编译器，分别是编译耗时短但输出代码优化程度较低的客户端编译器（简称为C1）以及编译耗时长但输出代码优化质量也更高的服务端编译器（简称为C2）通常它们会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统 自JDK 10起，HotSpot中又加入了一个全新的即时编译器：Graal编译器。Graal编译器是以C2编译器替代者的身份登场的。Graal能够做比C2更加复杂的优化，如“部分逃逸分析”（Partial Escape Analysis），也拥有比C2更容易使用激进预测性优化（Aggressive Speculative Optimization）的策略，支持自定义的预测性假设等。 然而需要预热才能达到最高性能等特点有悖于目前微服务架构的趋势。一种解决方案是提前编译，Substrate VM是在Graal VM 0.20版本里新出现的一个极小型的运行时环境，包括了独立的异常处理、同步调度、线程管理、内存管理（垃圾收集）和JNI访问等组件，目标是代替HotSpot用来支持提前编译后的程序执行。但要求目标程序是完全封闭的，即不能动态加载其他编译器不可知的代码和类库。 在JDK 9时期，HotSpot虚拟机开放了Java语言级别的编译器接口（Java Virtual Machine Compiler Interface，JVMCI），使得在Java虚拟机外部增加、替换即时编译器成为可能，Graal编译器就是通过这个接口植入到HotSpot之中。 到了JDK 10，HotSpot又重构了Java虚拟机的垃圾收集器接口（Java Virtual Machine Compiler Interface），统一了其内部各款垃圾收集器的公共行为。 Java技术体系OpenJdk Java程序设计语言、Java虚拟机、Java类库这三部分统称为JDK（Java Development Kit） Java类库API中的Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment） JVM从软件层面屏蔽不同操作系统在底层硬件与指令上的区别 JVM数据分区 线程共享：方法区(元空间) 堆 线程私有：虚拟机栈(线程栈) 本地方法栈 程序计数器 虚拟机栈每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用和returnAddress类型 方法不能太长，一般不超过120行，过长会占用很多栈空间。拆分成模块，调用后马上弹出。不过也要考虑切换开销，这是时间换空间 这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。 在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。 程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。 每条线程都需要有一个独立的程序计数器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。 此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。 本地方法栈本地方法以Native关键字修饰，没有具体实现，通过执行引擎让操作系统调用相应的dll文件，早期用于Java和C语言的交互，调用C语言实现的底层代码。 与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。 方法区(元空间)存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，这种特性被开发人员利用得比较多的便是String类的intern()方法。 在JDK 8以前，HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。这种设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小） 《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。 堆Java堆在虚拟机启动时创建。在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配”，Java堆是垃圾收集器管理的内存区域 现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。 Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的 从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词，不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。 如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。 直接内存 在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 理解代码底层运行状态反汇编 javap -c xx.class &gt; xx.txt根据JVM命令手册查询每行汇编代码的含义","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://vergessenwang.github.io/tags/JVM/"}]},{"title":"Docker中运行Neo4j","slug":"Docker中运行Neo4j","date":"2020-02-17T12:29:15.000Z","updated":"2020-02-17T12:32:38.061Z","comments":true,"path":"posts/database/2020-02-17-Docker中运行Neo4j.html","link":"","permalink":"http://vergessenwang.github.io/posts/database/2020-02-17-Docker中运行Neo4j.html","excerpt":"查看最新的Neo4j镜像版本 此时最新为4.0 docker pull neo4j:4.0 拉取镜像4.0 报错Error response from daemon: Get https://registry-1.docker.io/v2/: dial tcp: lookup registry-1.docker.io on 10.0.2.3:53: read udp 10.0.2.15:51774-&gt;10.0.2.3:53: i/o timeout 可能DNS解析有点问题，看了一下全都是美国弗吉尼亚的Amazon数据中心，应该是访问不到 去找阿里云镜像，然后被满页的广告蒙蔽了双眼，一个多小时之后，我买了一台云服务器 ：D 我是谁？我在哪？我刚才不是在学Docker吗？后来，我就开始搭服务器了。。。","text":"查看最新的Neo4j镜像版本 此时最新为4.0 docker pull neo4j:4.0 拉取镜像4.0 报错Error response from daemon: Get https://registry-1.docker.io/v2/: dial tcp: lookup registry-1.docker.io on 10.0.2.3:53: read udp 10.0.2.15:51774-&gt;10.0.2.3:53: i/o timeout 可能DNS解析有点问题，看了一下全都是美国弗吉尼亚的Amazon数据中心，应该是访问不到 去找阿里云镜像，然后被满页的广告蒙蔽了双眼，一个多小时之后，我买了一台云服务器 ：D 我是谁？我在哪？我刚才不是在学Docker吗？后来，我就开始搭服务器了。。。 一天之后，我回来了。继续学这个 云服务器在云服务器中 docker pull neo4j 默认拉取 lasted 版本，这时速度依然很慢 添加阿里云地址 速度起飞…. docker run -it -d -p 7474:7474 -p 7687:7687 neo4j:4.0 7474端口用于管理界面，7687端口用于登录连接neo4j服务端 。采用后台运行方式启动，返回一个containerid 然而在云服务器还要进行安全组端口配置 这里试了几次都有点问题，不太明白是哪里出了问题，难度是没装java？或者是防火墙没关？ 先装sdkman来管理java，先装个java8 不得不说挺方便的，不用自己去改环境变量了 java -version 查看的版本为1.8 折腾了一会放弃了，还是在电脑上运行把。 Windows同样添加一下toolbox镜像加速 1234docker-machine ssh defaultsudo sed -i &quot;s|EXTRA_ARGS=&apos;|EXTRA_ARGS=&apos;--registry-mirror=阿里云镜像加速地址 |g&quot; /var/lib/boot2docker/profileexitdocker-machine restart default 这里使用的是我自己阿里云控制台里的镜像加速地址 重启之后提示 docker info 无法查看信息，提示 You may need to re-run the docker-machine env command. docker-machine env default 根据查询结果 输入 eval $(&quot;C:\\Program Files\\Docker Toolbox\\docker-machine.exe&quot; env default) 再次 docker info 查看信息成功，重新拉取neo4j, 很快的样子 二十分钟过后….好吧，并不快…. 运行docker run -d -p 7474:7474 -p 7687:7687 neo4j 在浏览器依然没有显示？？ 怎么回事，之前用neo4j的bin文件运行是没有问题的，难道是docker的原因？ 这时我想到了，docker实际上是一个虚拟机，那么在浏览器用localhost的访问当然是不行的，所以找到docker的IP 为 192.168.99.100 再访问 http://192.168.99.100:7474/browser/ 就有界面了 云服务器这时我又回到云服务器，试图找出存在的问题 用docker ps -a 命令 我发现在本机运行时 12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2d9721591b68 neo4j \"/sbin/tini -g -- /d…\" 53 minutes ago Up 48 minutes 0.0.0.0:7474-&gt;7474/tcp, 7473/tcp, 0.0.0.0:7687-&gt;7687/tcp jolly_goldberg 状态为UP ， 端口也映射成功 但是云服务器上的却是 Exited (1) 12345CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES28ba3f7d0527 neo4j \"/sbin/tini -g -- /d…\" 10 seconds ago Exited (1) 9 seconds ago fervent_ptolemy0ba0cba50e7d neo4j \"/sbin/tini -g -- /d…\" 11 minutes ago Exited (1) 11 minutes ago sad_pascal03f239d99289 neo4j:4.0 \"/sbin/tini -g -- /d…\" 3 hours ago Exited (1) 3 hours ago tender_shannon78df828be80b hello-world \"/hello\" 23 hours ago Exited (0) 23 hours ago suspicious_mestorf 也就是说，neo4j并没有正常的运行起来 去掉后台运行参数-d 后重新运行，报错 /var/lib/neo4j/bin/neo4j: line 238: /var/lib/neo4j/conf/neo4j.conf: Permission denied 出现了访问限制。 然而我并没有找到这个/var/lib/neo4j 这个目录，应该是要修改镜像文件吧。然而docker一般都是部署的已经写好的代码，所以用在云服务器上用docker运行neo4j的话，其实还要对源码进行相应的修改，构建自己的镜像，这个以后真正要部署的时候再说吧，也就是上传源码的事 话说回来，我一定非要在docker中运行neo4j吗… linux又开始折腾了，这次是在linux系统上装了Docker 和Neo4J sudo docker run --publish=7474:7474 --publish=7687:7687 neo4j 成功运行起来了, 使用默认账户密码neo4j/neo4j 登陆","categories":[{"name":"database","slug":"database","permalink":"http://vergessenwang.github.io/categories/database/"}],"tags":[{"name":"Neo4j","slug":"Neo4j","permalink":"http://vergessenwang.github.io/tags/Neo4j/"},{"name":"Docker","slug":"Docker","permalink":"http://vergessenwang.github.io/tags/Docker/"}]},{"title":"LC-链表专题(一)","slug":"LC-链表专题-一","date":"2020-02-16T13:19:09.000Z","updated":"2020-03-31T06:38:55.771Z","comments":true,"path":"posts/DataStructure/2020-02-16-LC-链表专题-一.html","link":"","permalink":"http://vergessenwang.github.io/posts/DataStructure/2020-02-16-LC-链表专题-一.html","excerpt":"2 两数相加【中】 思路：先获取两个链表的长度，以较长的的作为遍历次数。新建一个链表存储结果，每次循环将对应的位的数相加，同时设置一个标志位记录本次加法是否进位。若有进位则下一次的加法要+1","text":"2 两数相加【中】 思路：先获取两个链表的长度，以较长的的作为遍历次数。新建一个链表存储结果，每次循环将对应的位的数相加，同时设置一个标志位记录本次加法是否进位。若有进位则下一次的加法要+1 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 改进： 无需遍历获得长度，当两结点均为null时终止循环即可 注意不要遗漏最后的一次进位 使用dummyHead结点保存结果链表的起始位置，用于返回最终结果 dummyHead.next Java中新建值为x的链表结点new ListNode(x) 下一结点Cur.next —不用指针真方便啊 时间和空间复杂度：$O(max(m,n))$ 19 删除链表的倒数第N个节点【中】 思路:双指针差距为n，同时向后移动，当后面那个指针指向null时，前一个指针所指的即为要删除的结点。要返回链表的头结点，还要设一个指针存储头结点位置。—快慢指针 1234567891011121314151617class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode pre = new ListNode(0); pre.next = head; ListNode start = pre, end = pre; while(n != 0) &#123; start = start.next; n--; &#125; while(start.next != null) &#123; start = start.next; end = end.next; &#125; end.next = end.next.next; return pre.next; &#125;&#125; 改进： 为了方便处理head被删除的特殊情况，添加一个pre/dummyHead结点，使pre.next = head 因为删除时要知道前一结点，故判断条件为start.next=null时终止，此时end正好位于倒数n+1的位置 Java的删除end.next = end.next.next; 因为有垃圾回收机制，无需手动free 时间复杂度：$O(n)$ 21 合并两个有序链表【易】 思路：取下两个链表中较小的头结点挂到新链表的末尾，当其中一个链表为空时将另一个链表的剩余部分整体挂上。注意新链表是直接利用原链表中的结点，没有新建。 12345678910111213141516171819class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode prehead = new ListNode(-1); ListNode prev = prehead; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; prev.next = l1 == null ? l2 : l1; return prehead.next;## &#125;&#125; 改进： prev.next = l1 == null ? l2 : l1;此句简单精妙 最好时间复杂度：$O(min(m,n))$最坏时间复杂度：$O(m+n)$ 递归法:两个链表头部较小的一个与剩下元素的 merge 操作结果合并。如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。如果两个链表都是空的，那么过程终止—递归就是简洁 12345678910111213141516171819class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; 时间和空间复杂度：$O(m+n)$ 23 合并K个有序链表【难】思路: k路归并的具体实现，不太清楚，难道是堆排序?建一个K个结点的小根堆 12345678910111213141516171819202122public ListNode mergeKLists(ListNode[] lists) &#123; int len = 0; if((len=lists.length)==0 || lists == null) return null; ListNode preHead = new ListNode(-1); ListNode preNode = preHead; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(len, new Comparator&lt;ListNode&gt;() &#123; @Override public int compare(ListNode o1, ListNode o2) &#123; return o1.val - o2.val; &#125; &#125;); for (ListNode node : lists) &#123; if(node!=null) queue.add(node); &#125; while(!queue.isEmpty())&#123; ListNode small = queue.poll(); preNode.next = small; if(small.next!=null) queue.add(small.next); //将最小值节点后面的节点添加到队里中 preNode = preNode.next; &#125; return preHead.next; &#125; 改进： 用优先队列来代替小根堆，要重写比较器 每次要加入的新结点取自 small.next ListNode node : lists 遍历每个链表的头结点? 时间复杂度：$O(n*(log(k))$空间复杂度：$O(k)$ 分治法：两两归并，关键在于用二分法确定分组。归并法用上一题的递归 1234567891011121314151617181920212223242526class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) return null; return merge(lists, 0, lists.length - 1); &#125; private ListNode merge(ListNode[] lists, int left, int right) &#123; if (left == right) return lists[left]; int mid = left + (right - left) / 2; ListNode l1 = merge(lists, left, mid); ListNode l2 = merge(lists, mid + 1, right); return mergeTwoLists(l1, l2); &#125; private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1,l2.next); return l2; &#125; &#125;&#125; 时间复杂度：$O(n*(log(k))$空间复杂度：$O(n)$ 24 两两交换链表中的节点【中】 思路：第一反应是换值，结果被重点强调了..应该是以某种方式去改变指针指向，注意防止断链。可以想到的做法是： 新建一个额外的结点便于操作头结点。 12345678910111213141516class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode pre = new ListNode(0); pre.next = head; ListNode temp = pre; while(temp.next != null &amp;&amp; temp.next.next != null) &#123; ListNode start = temp.next; ListNode end = temp.next.next; temp.next = end; start.next = end.next; end.next = start; temp = start; &#125; return pre.next; &#125;&#125; 改进: 三个指针，更好理解 递归法返回值：交换完成的子链表调用单元：设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head，完成交换终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换 1234567891011class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; return next; &#125;&#125; 25 K个一组翻转链表【难】 思路：其实跟上题还是同样的原理，只是指针指向要根据k值作相应的调整。最后一组若第一次指针操作发现将指向null，则将此组保持原样。 123456789101112131415161718192021222324252627282930313233public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; ListNode end = dummy; while (end.next != null) &#123; for (int i = 0; i &lt; k &amp;&amp; end != null; i++) end = end.next; if (end == null) break; ListNode start = pre.next; ListNode next = end.next; end.next = null; pre.next = reverse(start); start.next = next; pre = start; end = pre; &#125; return dummy.next;&#125;private ListNode reverse(ListNode head) &#123; ListNode pre = null; ListNode curr = head; while (curr != null) &#123; ListNode next = curr.next; curr.next = pre; pre = curr; curr = next; &#125; return pre;&#125; 改进: 分段进行，模块化重复；将中间逆序后再将首尾相接 end.next = null;先把尾部置空。 pre.next = reverse(start);然后对首部调用逆序函数 逆序函数的实现，需要三个指针 61 旋转链表【中】 思路：先遍历找到尾结点，然后将前k%list.length个结点依次插入到尾部—然后发现我理解错了题意…能不能连成一个环，然后从中间剪断.. 12345678910111213141516171819202122232425class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; // base cases if (head == null) return null; if (head.next == null) return head; // close the linked list into the ring ListNode old_tail = head; for(int n = 1; old_tail.next != null; n++) old_tail = old_tail.next; old_tail.next = head; // find new tail : (n - k % n - 1)th node // and new head : (n - k % n)th node ListNode new_tail = head; for (int i = 0; i &lt; n - k % n - 1; i++) new_tail = new_tail.next; ListNode new_head = new_tail.next; // break the ring new_tail.next = null; return new_head; &#125;&#125; 改进： 新的表头在 n-k%n 处，表尾在表头的前一位置 时间复杂度：$O(n)$空间复杂度：$O(1)$ 83 删除排序链表中的重复元素【易】思路: 由于是排序的所以排序遍历，设定一个比较位，后面的值与该数相等时，删除，不过由于可能有多个连续的相同数，故没有必要一个个删，可以找到一个更大的数后一起删除，同时更新比较位 12345678910111213class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode cur = head; while(cur != null &amp;&amp; cur.next != null) &#123; if(cur.val == cur.next.val) &#123; cur.next = cur.next.next; &#125; else &#123; cur = cur.next; &#125; &#125; return head; &#125;&#125; 此算法依然是挨个删除的，数据较少时区别不大。 时间复杂度：$O(n)$空间复杂度：$O(1)$ 82 删除排序链表中的重复元素 ll【中】思路：相比于上一题的区别在于把重复的数本身也删除了。看来要在前面加多一个指针? 12345678910111213141516171819class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode cur = dummy; while (cur.next != null &amp;&amp; cur.next.next != null) &#123; if (cur.next.val == cur.next.next.val) &#123; ListNode temp = cur.next; while (temp != null &amp;&amp; temp.next != null &amp;&amp; temp.val == temp.next.val ) &#123; temp = temp.next; &#125; cur.next = temp.next; &#125; else cur = cur.next; &#125; return dummy.next; &#125;&#125; 改进: 因为head结点可能要被删除，故应新增一个结点，而不仅仅是增加一个指针。 在迭代过程中，如果cur.next.val == cur.next.next.val说明此时有重复元素，此时创建一个临时指针temp，指向cur的下一个节点，即temp指向的第一个重复元素所在的位置。通过while循环去重，去重后，temp指向的是重复元素中的最后一个位置。最后cur.next = temp.next就实现了消除重复元素。 相比于上一题，把cur = cur.next;放在else中后判断，即可实现有多个相同值时一起删除，妙啊！ 注意退出条件 cur.next != null &amp;&amp; cur.next.next != null 时间复杂度：$O(n)$空间复杂度：$O(1)$ 递归法 12345678910111213141516public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) &#123; return head; &#125; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head != null &amp;&amp; head.next != null &amp;&amp; head.val == head.next.val) &#123; head = head.next; &#125; //去掉所有重复的数字，然后进行递归 return deleteDuplicates(head.next); &#125; else &#123; head.next = deleteDuplicates(head.next); &#125; return head; &#125; 无需dummy结点 对于前面的部分，直接把重复的部分掐掉，剩下的部分递归","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://vergessenwang.github.io/categories/DataStructure/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://vergessenwang.github.io/tags/LeetCode/"},{"name":"链表","slug":"链表","permalink":"http://vergessenwang.github.io/tags/链表/"}]},{"title":"Spring MVC","slug":"Spring-MVC","date":"2020-02-14T16:01:39.000Z","updated":"2020-02-14T16:16:42.160Z","comments":true,"path":"posts/Java/2020-02-15-Spring-MVC.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-02-15-Spring-MVC.html","excerpt":"Spring MVC是Spring提供的一个轻量级Web框架，它实现了Web MVC设计模式。提供了一个前端控制器DispatcherServlet，使开发人员无须额外开发控制器对象。 在老版本的Spring中，配置文件内必须要配置处理器映射器、处理器适配器和视图解析器。但在Spring 4.0以后，如果不配置处理器映射器BeanNameUrlHandlerMapping、处理器适配器SimpleControllerHandlerAdapter和视图解析器InternalResourceViewResolver，就会使用Spring内部默认的配置来完成相应的工作 在web.xml中配置Spring MVC的前端控制器等信息在src目录下创建Spring MVC的核心配置文件springmvc-config.xml，在该文件中配置组件扫描器和视图解析器 执行流程（1）用户通过浏览器向服务器发送请求，请求会被Spring MVC的前端控制器DispatcherServlet所拦截。（2）DispatcherServlet拦截到请求后，会调用HandlerMapping处理器映射器。（3）处理器映射器根据请求URL找到具体的处理器，生成处理器对象及处理器拦截器（如果有就生成）一并返回给DispatcherServlet。（4）DispatcherServlet会通过返回信息选择合适的HandlerAdapter（处理器适配器）。（5）HandlerAdapter会调用并执行Handler（处理器），这里的处理器就是程序中编写的Controller类，也被称为后端控制器。（6）Controller执行完成后，会返回一个ModelAndView对象，该对象中包含视图名或包含模型与视图名。（7）HandlerAdapter将ModelAndView对象返回给DispatcherServlet。（8）DispatcherServlet会根据ModelAndView对象选择一个合适的ViewResolver（视图解析器）。（9）ViewResolver解析后，会向DispatcherServlet中返回具体的View（视图）。（10）DispatcherServlet对View进行渲染（即将模型数据填充至视图中）。（11）视图渲染结果会返回给客户端浏览器显示。","text":"Spring MVC是Spring提供的一个轻量级Web框架，它实现了Web MVC设计模式。提供了一个前端控制器DispatcherServlet，使开发人员无须额外开发控制器对象。 在老版本的Spring中，配置文件内必须要配置处理器映射器、处理器适配器和视图解析器。但在Spring 4.0以后，如果不配置处理器映射器BeanNameUrlHandlerMapping、处理器适配器SimpleControllerHandlerAdapter和视图解析器InternalResourceViewResolver，就会使用Spring内部默认的配置来完成相应的工作 在web.xml中配置Spring MVC的前端控制器等信息在src目录下创建Spring MVC的核心配置文件springmvc-config.xml，在该文件中配置组件扫描器和视图解析器 执行流程（1）用户通过浏览器向服务器发送请求，请求会被Spring MVC的前端控制器DispatcherServlet所拦截。（2）DispatcherServlet拦截到请求后，会调用HandlerMapping处理器映射器。（3）处理器映射器根据请求URL找到具体的处理器，生成处理器对象及处理器拦截器（如果有就生成）一并返回给DispatcherServlet。（4）DispatcherServlet会通过返回信息选择合适的HandlerAdapter（处理器适配器）。（5）HandlerAdapter会调用并执行Handler（处理器），这里的处理器就是程序中编写的Controller类，也被称为后端控制器。（6）Controller执行完成后，会返回一个ModelAndView对象，该对象中包含视图名或包含模型与视图名。（7）HandlerAdapter将ModelAndView对象返回给DispatcherServlet。（8）DispatcherServlet会根据ModelAndView对象选择一个合适的ViewResolver（视图解析器）。（9）ViewResolver解析后，会向DispatcherServlet中返回具体的View（视图）。（10）DispatcherServlet对View进行渲染（即将模型数据填充至视图中）。（11）视图渲染结果会返回给客户端浏览器显示。 注解用法Spring通过@Controller注解找到相应的控制器类后，还需要知道控制器内部对每一个请求是如何处理的，这就需要使用org.springframework.web.bind.annotation.RequestMapping注解类型。RequestMapping用于映射一个请求或一个方法，其注解形式为@RequestMapping，可以使用该注解标注在一个方法或一个类上。 Spring 4.3版本中引入了组合注解来帮助简化常用的HTTP方法的映射，并更好地表达被注解方法的语义。其组合注解如下所示。• @GetMapping：匹配GET方式的请求。• @PostMapping：匹配POST方式的请求。• @PutMapping：匹配PUT方式的请求。• @DeleteMapping：匹配DELETE方式的请求。• @PatchMapping：匹配PATCH方式的请求。以@GetMapping为例，该组合注解是@RequestMapping(method= RequestMethod.GET)的缩写 请求方法参数较多，不一一列举。绝大部分为Servlet API类型。但是，org.springframework.ui.Model类型不是一个Servlet API类型，而是一个包含Map对象的Spring MVC类型。如果方法中添加了Model参数，那么每次调用该请求处理方法时，Spring MVC都会创建Model对象，并将其作为参数传递给方法。 请求方法的返回值，常见的返回类型有ModelAndView、String和void。其中，ModelAndView类型中可以添加Model数据，并指定视图；String类型的返回值可以跳转视图，但不能携带数据；而void类型主要在异步请求时使用，它只返回数据，而不会跳转视图。 数据绑定Spring MVC框架会通过数据绑定组件（DataBinder）将请求参数串的内容进行类型转换，然后将转换后的值赋给控制器类中方法的形参，这样后台方法就可以正确绑定并获取客户端请求携带的参数。 步骤01 Spring MVC将ServletRequest对象传递给DataBinder。步骤02 将处理方法的入参对象传递给DataBinder。步骤03 DataBinder调用ConversionService组件进行数据类型转换、数据格式化等工作，并将ServletRequest对象中的消息填充到参数对象中。步骤04 调用Validator组件对已经绑定了请求消息数据的参数对象进行数据合法性校验。步骤05 校验完成后会生成数据绑定结果BindingResult对象，Spring MVC会将BindingResult对象中的内容赋给处理方法的相应参数。 比较常用的是POJO数据绑定。所有关联的请求参数封装在一个POJO中，然后为每一个参数设定set get 方法使用POJO类型数据绑定时，前端请求的参数名必须与要绑定的POJO类中的属性名一样，这样才会自动将请求数据绑定到POJO对象中，否则后台接收的参数值为null。对象比较复杂时，还可以在其中一个POJO中封装另一个POJO。 为了防止前端传入的中文数据出现乱码问题，可以使用Spring提供的编码过滤器来统一编码。要使用编码过滤器，只需要在web.xml中添加编码过滤器，这样所有的请求信息都会以UTF-8的编码格式进行解析。 有些特殊类型的参数无法在后台进行直接转换，例如日期数据需要开发者自定义转换器（Converter）或格式化（Formatter）进行数据绑定。对于复杂类型的数据，比如数组或者集合可以定义包含数组或者对象类的集合，进行绑定。 JSON数据交互JSON（JavaScript Object Notation，JS对象标记）是一种轻量级的数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据。 对象结构： 123&#123; keyl: valuel, key2: value2, ……&#125; 关键字（key）必须为String类型，值（value）可以是String、Number、Object、Array等数据类型。 为了实现浏览器与控制器类（Controller）之间的数据交互，Spring提供了一个HttpMessageConverter接口来完成此项工作。该接口主要用于将请求信息中的数据转换为一个类型为T的对象，并将类型为T的对象绑定到请求方法的参数中，或者将对象转换为响应信息传递给浏览器显示。MappingJacksona2HttpMessageConverter是Spring MVC默认处理JSON格式请求响应的实现类。 mvc:annotation-driven/配置会自动注册 RequestMappingHandlerMapping和RequestMappingHandlerAdapter两个Bean，并提供对读写XML和读写JSON等功能的支持。 RESTfulRESTful也称为REST（Representational State Transfer），可以将它理解为一种软件架构风格或设计风格。就是把请求参数变成请求路径 http://.../queryitems?id=1http://.../queryitems?id=1变为http://.../items/1 RESTful风格在HTTP请求中使用put、delete、post和get方式分别对应添加、删除、修改和查询的操作。","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://vergessenwang.github.io/tags/Spring/"}]},{"title":"阿里云OSS+PicGo搭建博客图床","slug":"阿里云OSS-PicGo搭建博客图床","date":"2020-02-13T11:54:21.000Z","updated":"2020-02-13T12:02:57.006Z","comments":true,"path":"posts/Blog/2020-02-13-阿里云OSS-PicGo搭建博客图床.html","link":"","permalink":"http://vergessenwang.github.io/posts/Blog/2020-02-13-阿里云OSS-PicGo搭建博客图床.html","excerpt":"博客自创建以来的就没有插入过图片，为了以后浏览的时候能更快明白之前写的东西，还是决定搭个图床。 之前看过在github以及七牛云上搭的，空间限制或需要域名备案而放弃，准备搭在阿里云OSS上。 在OSS中创建Bucket买了一个40G一年的OSS存储包，因为说不定以后还要存别的东西，就没有选择按量付费了。流量就直接按量了，反正应该就我自己会看… 创建Bucket注意权限改为公共读，我选择的标准按量收费。 在PicGO中连接OSSpicgo 项目地址 在图床设置中填写OSS中相应信息 KeyId和KeySecret可以从阿里的控制台获取， 储存空间名就是Bucket的名称，存储区域在访问域名可以找到 我的是 oss-cn-hangzhou。 存储路径比如2020/02/12/的话，上传的图片会默认放在OSS的2020/02/12文件夹下。注意存储路径一定要以/结尾 将图片拖拽或复制后上传剪贴板，会自动重命名并返回一个链接地址，默认为markdown格式","text":"博客自创建以来的就没有插入过图片，为了以后浏览的时候能更快明白之前写的东西，还是决定搭个图床。 之前看过在github以及七牛云上搭的，空间限制或需要域名备案而放弃，准备搭在阿里云OSS上。 在OSS中创建Bucket买了一个40G一年的OSS存储包，因为说不定以后还要存别的东西，就没有选择按量付费了。流量就直接按量了，反正应该就我自己会看… 创建Bucket注意权限改为公共读，我选择的标准按量收费。 在PicGO中连接OSSpicgo 项目地址 在图床设置中填写OSS中相应信息 KeyId和KeySecret可以从阿里的控制台获取， 储存空间名就是Bucket的名称，存储区域在访问域名可以找到 我的是 oss-cn-hangzhou。 存储路径比如2020/02/12/的话，上传的图片会默认放在OSS的2020/02/12文件夹下。注意存储路径一定要以/结尾 将图片拖拽或复制后上传剪贴板，会自动重命名并返回一个链接地址，默认为markdown格式 也可以设置快捷键，截图或复制后直接 shift + ctrl +P 真是 太好用了.. 展示效果如下： URL默认格式 https://blog-picture-wallen.oss-cn-hangzhou.aliyuncs.com/2020/02/12/...jpg 另外找到了一个支持图传的IOS的MWEB , 这下在ipad上也可以写markdown了 Linux下要用AppImage格式安装 出现奇怪报错： 12./PicGo-2.2.2.AppImage:行1: 未预期的符号 `newline' 附近有语法错误./PicGo-2.2.2.AppImage:行1: `&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;' 莫非是最新的2.2.2版本源码有错？定睛一看文件大小376B….重新下载 chmod a+x PicGo-2.2.2.AppImage 添加执行权限后执行 出现一个缩小的图标右键变为详细模式填写相应设置, 注意路径后一定要加/ 运行时会提示未安装xclip sudo apt install xclip 但每次这样运行比较麻烦，另外创建一个desktop文件 sudo vim /usr/share/applications/picgo.desktop 12345678910[Desktop Entry] Encoding=UTF-8 Name=PicGoComment=picture uploader Exec=/media/wliana/_dde_data2/software/PicGo-2.2.2.AppImageIcon=/media/wliana/_dde_data2/software/Icon/22xiaodongwu_18.pngTerminal=false StartupNotify=true Type=Application Categories=Application; 截图时按ctrl + alt + a 即可调用深度截图, ctrl + c 复制，shift + ctrl + p 上传， ctrl + v 直接贴到typora 真的很方便呀！ 自己弄了个小狮子的icon, 很可爱的亚子～ 这一套Icon也不错","categories":[{"name":"Blog","slug":"Blog","permalink":"http://vergessenwang.github.io/categories/Blog/"}],"tags":[{"name":"OSS","slug":"OSS","permalink":"http://vergessenwang.github.io/tags/OSS/"}]},{"title":"Spring基础之IoC与AOP","slug":"Spring基础之IoC与AOP","date":"2020-02-12T09:33:39.000Z","updated":"2020-02-12T09:34:59.510Z","comments":true,"path":"posts/Java/2020-02-12-Spring基础之IoC与AOP.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-02-12-Spring基础之IoC与AOP.html","excerpt":"Spring是一个以IoC（Inversion of Control，控制反转）和AOP（Aspect Oriented Programming）为内核的框架。 IoC和DIIoC是Spring的基础。IoC实现的是一种控制，简单地说，就是以前调用new构造方法来创建对象，现在变成了使用Spring来创建对象。DI（Dependency Inject，依赖注入）与IoC的含义相同，从两个角度描述同一个概念。简单地说，DI就是对象的属性，已经被注入好相关值，直接使用即可。 IoC是Inversion of Control的缩写，译为“控制反转”，还有的译为“控制反向”或者“控制倒置”。 在面向对象传统编程方式中，获取对象的方式通常是用new关键字主动创建一个对象。Spring中的IoC方式对象的生命周期由Spring框架提供的IoC容器来管理，直接从IoC容器中获取一个对象，控制权从应用程序交给了IoC容器。 IoC理论上是借助于“第三方”实现具有依赖关系对象之间的解耦，即把各个对象类封装之后，通过IoC容器来关联这些对象类。这样对象与对象之间就通过IoC容器进行联系，而对象与对象之间没有什么直接联系。 当对象A实例化和运行时，如果需要对象B，IoC容器就会主动创建一个对象B注入（依赖注入）到对象A所需要的地方。由此，对象A获得依赖对象B的过程，由主动行为变成被动行为，即把创建对象交给了IoC容器处理，控制权颠倒过来了，这就是所谓的控制反转","text":"Spring是一个以IoC（Inversion of Control，控制反转）和AOP（Aspect Oriented Programming）为内核的框架。 IoC和DIIoC是Spring的基础。IoC实现的是一种控制，简单地说，就是以前调用new构造方法来创建对象，现在变成了使用Spring来创建对象。DI（Dependency Inject，依赖注入）与IoC的含义相同，从两个角度描述同一个概念。简单地说，DI就是对象的属性，已经被注入好相关值，直接使用即可。 IoC是Inversion of Control的缩写，译为“控制反转”，还有的译为“控制反向”或者“控制倒置”。 在面向对象传统编程方式中，获取对象的方式通常是用new关键字主动创建一个对象。Spring中的IoC方式对象的生命周期由Spring框架提供的IoC容器来管理，直接从IoC容器中获取一个对象，控制权从应用程序交给了IoC容器。 IoC理论上是借助于“第三方”实现具有依赖关系对象之间的解耦，即把各个对象类封装之后，通过IoC容器来关联这些对象类。这样对象与对象之间就通过IoC容器进行联系，而对象与对象之间没有什么直接联系。 当对象A实例化和运行时，如果需要对象B，IoC容器就会主动创建一个对象B注入（依赖注入）到对象A所需要的地方。由此，对象A获得依赖对象B的过程，由主动行为变成被动行为，即把创建对象交给了IoC容器处理，控制权颠倒过来了，这就是所谓的控制反转 DI是Dependency Inject的缩写，译为“依赖注入”。所谓依赖注入，就是由IoC容器在运行期间动态地将某种依赖关系注入对象之中。例如，将对象B注入（赋值）给对象A的成员变量。 事实上，依赖注入（DI）和控制反转（IoC）是对同一件事情的不同描述，依赖注入是从应用程序的角度描述，即应用程序依赖容器创建并注入它所需要的外部资源；而控制反转是从容器的角度描述，即容器控制应用程序，由容器反向地向应用程序注入应用程序所需要的外部资源。这里所说的外部资源可以是外部实例对象，也可以是外部文件对象等 注入方法IoC/DI通常有setter（设置）注入和构造方法注入两种实现方式 • 属性setter()方法注入：IoC容器使用setter()方法注入被依赖的实例。通过调用无参构造器或无参静态工厂方法实例化Bean后，调用该Bean的setter()方法，即可实现基于setter()方法的依赖注入。该方式简单、直观，而且容易理解，所以Spring的设置注入被大量使用。• 构造方法注入：IoC容器使用构造方法注入被依赖的实例。基于构造方法的依赖注入通过调用带参数的构造方法来实现，每个参数代表着一个依赖。 核心容器Spring框架提供的两种核心容器分别是BeanFactory和ApplicationContext。 Spring框架的两个最基本和最重要的包是org.springframework.beans.factory（该包中的主要接口是BeanFactory）和org.springframework.context（该包中的主要接口是ApplicationFactory）。 Spring IoC框架的主要组件有Beans、配置文件applicationContext.xml、BeanFactory接口及其相关类、ApplicationContext接口及其相关类。 （1）Beans是指项目中提供业务功能的Bean，即容器要管理的Bean。Beans就是一个常见的JavaBean、Java类。 （2）在Spring中对Bean的管理是在配置文件中进行的。在Spring容器内编辑配置文件管理Bean又称为Bean的装配，实际上装配就是告诉容器需要哪些Bean，以及容器是如何使用IoC将它们配合起来的。Bean的配置文件是一个XML文件，可以命名为applicationContext.xml或其他，一般习惯使用applicationContext.xml。 配置文件包含Bean的id、类、属性及其值，包含一个元素和数个子元素。Spring IoC框架可根据Bean的id从Bean配置文件中取得该Bean的类，并生成该类的一个实例对象，继而从配置文件中获得该对象的属性和值。例如是元素的子元素，其name属性表示Bean实例中的相应属性名，ref属性用于指定其属性值是元素的子元素，用于调用Bean实例中的setUserDao()方法完成属性赋值，从而实现依赖注入。其name属性表示Bean实例中的相应属性名，ref属性用于指定其属性值 （3）BeanFactory采用了工厂设计模式，即Bean容器模式，负责读取Bean的配置文件，管理对象的生成、加载，维护Bean对象与Bean对象之间的依赖关系，负责Bean的生命周期。对于简单的应用程序来说，使用BeanFactory就已经足够管理Bean了，在对象的管理上可以获得许多便利性。 org.springframework.beans.factory.BeanFactory是一个顶级接口，包含管理Bean的各种方法 org.springframework.beans.factory.xml.XmlBeanFactory是BeanFactory常用的实现类，根据配置文件中的定义装载Bean。要创建XmlBeanFactory，需要传递一个FileInputStream对象，该对象把XML文件提供给工厂。代码可以写成： 1BeanFactory factory=new XmlBeanFactory( new FileInputStream(&quot;applicationContext.xml &quot;)); BeanFactory的常用方法如下：• getBean(String name)：可根据Bean的id生成该Bean的对象。• getBean(String name,Class requiredType)：可根据Bean的id和相应类生成该Bean的对象。 （4）ApplicationContext接口提供高级功能的容器，基本功能与BeanFactory很相似，但它还有以下功能：• 提供访问资源文件更方便的方法。• 支持国际化消息。• 提供文字消息解析的方法。• 可以发布事件，对事件感兴趣的Bean可以接收到这些事件。 ApplicationContext接口的常用实现类有以下3个。• FileSystemXmlApplicationContext：从文件系统中的XML文件加载上下文中定义的信息。• ClassPathXmlApplicationContext：从类路径中的XML文件加载上下文中定义的信息，把上下文定义的文件当成类路径资源。• XmlWebApplicationContext：从Web系统中的XML文件加载上下文中定义的信息。 其中，FileSystemXmlApplicationContext和ClassPathXmlApplicationContext的代码编写如下： 12ApplicationContext context=new FileSystemXmlApplicationContext(&quot;d:/applicationContext.xml￼&quot;);￼ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml &quot;); Beans作用域在Spring配置文件中，Bean的作用域是通过元素的scope属性来指定的，该属性值可以设置为singleton、prototype、request、session、globalSession、application、websocket七个值 singleton是Spring容器默认的作用域，当Bean的作用域为singleton时，Spring容器就只会存在一个共享的Bean实例，并且所有对Bean的请求，只要id与该Bean的id属性相匹配，就会返回同一个Bean的实例。singleton作用域对于无会话状态的Bean（如Dao组件、Service组件）来说是最理想的选择 对需要保持会话状态的Bean应用使用prototype作用域。在使用prototype作用域时，Spring容器会为每个对该Bean的请求都创建一个新的实例 装配方式Spring容器支持多种形式的Bean装配方式，如基于XML的装配、基于Annotation（注解）的装配和自动装配等 基于xml的装配Spring提供了两种基于XML的装配方式：设值注入（Setter Injection）和构造注入（Constructor Injection） 在Spring实例化Bean的过程中，Spring首先会调用Bean的默认构造方法来实例化Bean对象，然后通过反射的方式调用setter()方法来注入属性值。因此，设值注入要求一个Bean必须满足以下两点要求：• Bean类必须提供一个默认的无参构造方法。• Bean类必须为需要注入的属性提供对应的setter()方法。 使用设值注入时，在Spring配置文件中需要使用元素的子元素来为每个属性注入值；而使用构造注入时，在配置文件中需要使用元素的子元素来定义构造方法的参数，可以使用其value属性（或子元素）来设置该参数的值。 基于注解的装配注解将类标识为Spring中的Bean，Spring注解提供了一种高效的注解配置方式（对包路径下的所有Bean文件进行扫描)@Repository、@Service和@Controller的功能与@Component注解的功能相同，但为了使标注类本身用途更加清晰，建议在实际开发中使用@Repository、@Service和@Controller分别对实现类进行标注 自动装配Spring的元素中包含一个autowire属性，我们可以通过设置autowire的属性值来自动装配Bean。所谓自动装配，就是将一个Bean自动注入其他Bean的Property中 AOPAOP的全称是Aspect-Oriented Programming，即面向切面编程（也称面向方面编程），是面向对象编程（OOP）的一种补充，目前已成为一种比较成熟的编程方式。 在AOP思想中，通过Aspect（切面）可以分别在不同类的方法中加入事务、日志、权限和异常等功能。 Aspect（切面）在实际应用中，切面通常是指封装的用于横向插入系统功能（如事务、日志等）的类，该类要被Spring容器识别为切面，需要在配置文件中通过元素指定。 在Spring的配置文件中，配置切面使用的是aop:aspect元素，该元素会将一个已定义好的Spring Bean转换成切面Bean，所以要在配置文件中先定义一个普通的Spring Bean（如上述代码中定义的myAspect）。定义完成后，通过aop:aspect元素的ref属性即可引用该Bean。 Joinpoint（连接点）在程序执行过程中的某个阶段点，它实际上是对象的一个操作，例如方法的调用或异常的抛出。在Spring AOP中，连接点就是指方法的调用。 Pointcut（切入点）指切面与程序流程的交叉点，即那些需要处理的连接点。通常在程序中，切入点指的是类或者方法名，如某个通知要应用到所有以add开头的方法中，那么所有满足这一规则的方法都是切入点。 当aop:pointcut元素作为aop:config元素的子元素定义时，表示该切入点是全局切入点，可以被多个切面所共享；当aop:pointcut元素作为aop:aspect元素的子元素时，表示该切入点只对当前切面有效。在定义aop:pointcut元素时，通常会指定id和expression两个属性 express格式 ： execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-￼pattern) throws-pattern? 带有问号（?）的部分表示可选配置项，其他部分属于必须配置项。 其他• Advice（通知增强处理）：AOP框架在特定的切入点执行增强处理，即在定义好的切入点处所要执行的程序代码。可以将其理解为切面类中的方法，它是切面的具体实现。• Target Object（目标对象）：是指所有被通知的对象，也称为被增强对象。如果AOP框架采用的是动态的AOP实现，那么该对象就是一个被代理对象。• Proxy（代理）：将通知应用到目标对象之后，被动态创建的对象。• Weaving（织入）：将切面代码插入目标对象上，从而生成代理对象的过程。 基于XML的声明式AspectJ通过XML文件来定义切面、切入点及通知，Spring配置文件中的元素下可以包含多个aop:config元素，一个aop:config元素中又可以包含属性和子元素，其子元素包括aop:pointcut、aop:advisor和aop:aspect。在配置时，这3个子元素必须按照此顺序来定义。 基于注解的声明式AspectJ使用@Aspect注解定义了切面类，由于该类在Spring中是作为组件使用的，因此还需要添加@Component注解才能生效。然后使用@Pointcut注解来配置切入表达式，并通过定义方法来表示切入点名称。接下来在每个通知相应的方法上添加了相应的注解，并将切入点名称作为参数传递给需要执行增强的通知方法。如果需要其他参数（如异常通知的异常参数），可以根据代码提示传递相应的属性值。","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://vergessenwang.github.io/tags/Spring/"}]},{"title":"Deepin真好玩之我怎么又黑屏了？？","slug":"Deepin真好玩之我怎么又黑屏了？？","date":"2020-02-10T13:38:39.000Z","updated":"2020-02-10T13:44:10.819Z","comments":true,"path":"posts/OS/2020-02-10-Deepin真好玩之我怎么又黑屏了？？.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2020-02-10-Deepin真好玩之我怎么又黑屏了？？.html","excerpt":"开始使用华为的linux发行版了，2K屏真香！极简风格相当喜欢，UI也设计的不错，就是触摸板不太好滑。 尝试正确的姿势上网(暂时放弃)先去客户中心按指南下载Qt5，并扫描好配置的二维码。然而还要进行系统配置之后才能使用 开始用全局配置，但是考虑到访问国内速度可能较慢，于是打算用动态配置。 法一 配置PAC ：deepin系统安装shadowsocks-qt5并使用PAC全局代理) 配置之后反而国内的网站都访问不了，取消了也不能访问 据说还有个deepin系统的专门插件 https://github.com/lolimay/shadowsocks-deepin 但我懒得编译了 法二尝试使用Chrome插件 https://github.com/FelisCatus/SwitchyOmega/releases/ 注意下载后要将后缀改成.tar 后解压，把里面的”_metadata”文件夹改名为”metadata” 然后拖入Chrome的扩展程序界面即可手动安装 等我装好插件，配置完成之后，连百度都打不开了… 没办法，遇事不决重启试试。然后更刺激的来了，我输入密码进入桌面，两秒之后，黑屏了！！！ 先后经历之前的安装丢失，合屏待机之后无法唤醒等令人摸不着头脑的问题。 接下来，在各种recovery之间反复横跳…","text":"开始使用华为的linux发行版了，2K屏真香！极简风格相当喜欢，UI也设计的不错，就是触摸板不太好滑。 尝试正确的姿势上网(暂时放弃)先去客户中心按指南下载Qt5，并扫描好配置的二维码。然而还要进行系统配置之后才能使用 开始用全局配置，但是考虑到访问国内速度可能较慢，于是打算用动态配置。 法一 配置PAC ：deepin系统安装shadowsocks-qt5并使用PAC全局代理) 配置之后反而国内的网站都访问不了，取消了也不能访问 据说还有个deepin系统的专门插件 https://github.com/lolimay/shadowsocks-deepin 但我懒得编译了 法二尝试使用Chrome插件 https://github.com/FelisCatus/SwitchyOmega/releases/ 注意下载后要将后缀改成.tar 后解压，把里面的”_metadata”文件夹改名为”metadata” 然后拖入Chrome的扩展程序界面即可手动安装 等我装好插件，配置完成之后，连百度都打不开了… 没办法，遇事不决重启试试。然后更刺激的来了，我输入密码进入桌面，两秒之后，黑屏了！！！ 先后经历之前的安装丢失，合屏待机之后无法唤醒等令人摸不着头脑的问题。 接下来，在各种recovery之间反复横跳… 最后也不知道是哪步使她修复好了…看来应该好好学习如何备份，然后就可以瞎折腾了… 尝试更新源(已放弃)先将原先文件备份 sudo cp /etc/apt/source.list /etc/apt/source.list.original vim /etc/apt/source.list 添加镜像源： https://www.deepin.org/mirrors/packages/ 在该网站查找镜像源地址 选择所需的进行替换 lion 是稳定版， panda 是测试版 p 粘贴 例如华为源： deb [trusted=yes] https://mirrors.huaweicloud.com/deepin stable main contrib non-free deb-src deb https://mirrors.huaweicloud.com/deepin stable main 教程 https://blog.csdn.net/baidu_41751590/article/details/89064220 但是！！操作到一半发现自带的Deepin是camel版本的，是官方授权的，如果更换了的话，会导致变为非授权版本，无法正常更新。 作为一个强迫症，最终还是放弃了更新源。不得不说，华为的Linux的发行版还是存在很多问题，诸如居然没有自带应用商店。 我感觉已经要被这个系统整残了。。。 话说回来，Deepin配上华为的2K屏体验真的是不错，一个普通的记事本都能写出Typora的感觉 安装Typora官方指南 或者 sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add - add Typora&#39;s repository sudo add-apt-repository &#39;deb https://typora.io/linux ./&#39; 这一步报错：无法使用add-apt-repository命令 解决： apt-get install software-properties-common sudo apt-get update sudo apt-get install typora 报错：W: GPG 错误：http://dl.google.com/linux/chrome/deb stable Release: 下列签名无效： KEYEXPIRED 1555048520 KEYEXPIRED 1555048520 KEYEXPIRED 1555048520 KEYEXPIRED 1555048520W: 仓库 “http://dl.google.com/linux/chrome/deb stable Release” 没有数字签名。N: 无法认证来自该源的数据，所以使用它会带来潜在风险。N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。 解决： 把 /etc/apt/sources.list.d/ google-chrome.list 删除 这应该是在安装chrome的时候产生的，于是干脆把chrome卸载了，反正火狐也不错 最后发现camel源里面好像没有typora…装个软件这么难吗？？？ 没办法我只能手动下载压缩文件了。解压 创建一个到桌面的软链接方便启动 —后来发现并不方便 还是创建开始启动图标吧，在 /usr/share/applications 目录下创建 typora.desktop 文件 sudo vim /usr/share/applications/typora.desktop 直接参考Deepin 创建快捷方式 12345678910[Desktop Entry] Encoding=UTF-8 Name=TyporaComment=Markdown Editor Exec=/media/wliana/_dde_data2/software/Typora-linux-x64/TyporaIcon=/media/wliana/_dde_data2/software/Typora-linux-x64/resources/app/asserts/icon/icon_32x32@2x.pngTerminal=false StartupNotify=true Type=Application Categories=Application; 到官网下载好看的主题，没错就是要花里胡哨..放到主题文件夹里，重启typora即可。 最后发现还是自带的github主题好看。 接下来还有很多环境要配置，慢慢来吧","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"Deepin","slug":"Deepin","permalink":"http://vergessenwang.github.io/tags/Deepin/"}]},{"title":"云服务器ECS中配置Nginx和Docker","slug":"云服务器ECS中配置Nginx和Docker","date":"2020-02-06T17:40:30.000Z","updated":"2020-02-06T17:43:18.742Z","comments":true,"path":"posts/Project/2020-02-07-云服务器ECS中配置Nginx和Docker.html","link":"","permalink":"http://vergessenwang.github.io/posts/Project/2020-02-07-云服务器ECS中配置Nginx和Docker.html","excerpt":"今天心血来潮买了一个阿里云ECS云服务器，然后想起来以前还买过一个域名一直没用上，就拿来玩玩。 绑定域名在域名的控制台进行DNS解析，绑定好云服务器的公网IP 记录类型：默认A 主机记录：www ，就是给域名加一个前缀 解析路线：默认 记录值：云服务器的公网ip地址 TTL：默认 配置好后，ping 域名 检测一下，可以访问 接下来就可以部署一些自己的应用了 远程连接到服务器 ssh root@IP 输入密码，即可连接 首先对服务器进行升级 sudo apt-get update","text":"今天心血来潮买了一个阿里云ECS云服务器，然后想起来以前还买过一个域名一直没用上，就拿来玩玩。 绑定域名在域名的控制台进行DNS解析，绑定好云服务器的公网IP 记录类型：默认A 主机记录：www ，就是给域名加一个前缀 解析路线：默认 记录值：云服务器的公网ip地址 TTL：默认 配置好后，ping 域名 检测一下，可以访问 接下来就可以部署一些自己的应用了 远程连接到服务器 ssh root@IP 输入密码，即可连接 首先对服务器进行升级 sudo apt-get update Node 参考 wget https://nodejs.org/dist/v10.15.1/node-v10.15.1-linux-x64.tar.xz 下载源码 xz -d node-v10.15.1-linux-x64.tar.xz tar -xvf node-v10.15.1-linux-x64.tar 解压 rm node-v10.15.1-linux-x64.tar 删除多余文件夹 12ln -s /root/node-v10.15.1-linux-x64/bin/node /usr/local/bin/nodeln -s /root/node-v10.15.1-linux-x64/bin/npm /usr/local/bin/npm 创建软链接便于全局访问 为了更清晰的管理文件夹 123456mkdir -p /tool/node/mv /root/node-v10.15.1-linux-x64/* /tool/node/rm -f /usr/local/bin/noderm -f /usr/local/bin/npmln -s /tool/node/bin/node /usr/local/bin/nodeln -s /tool/node/bin/npm /usr/local/bin/npm 查看版本发现已经安装成功 Pm2npm install pm2 -g pm2可以用它来管理node进程 pm2命令 同样要配置软链接，类似于windows中的环境变量 ln -s /tool/node/bin/pm2 /usr/local/bin/ NginxNginx是一个高性能的 HTTP 和反向代理服务器，也是一个IMAP/POP3/SMTP 代理服, 是一个asynchronousservers异步服务器, 一般用来处理高并发 新建一个目录专门存放安装包（不然以后看起来很混乱）mkdir ~/software 下载并解压安装包至指定目录 wget -P ~/software/ http://nginx.org/download/nginx-1.12.2.tar.gz tar -zxvf nginx-1.12.2.tar.gz -C ~/tool 进入所在目前执行默认配置 ./configure 此步骤会报错因为还有很多依赖包没有安装 123apt-get install libpcre3 libpcre3-devapt-get install zlib1g-devapt-get install openssl libssl-dev 安装完毕后编译make 成功后多出一个Makefile文件 然后make install 会安装在 /usr/local/nginx 不知道为什么我在root目录想看不到usr文件夹？ 直接 cd /usr/local/nginx 进到nginx目录直接运行./sbin/nginx 结果说我没有安装?? 算了不编译了，apt一把梭 apt-get install nginx 运行时提示端口被占用 nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use) netstat -ntlp 查看端口情况 杀死进程 kill id 重新运行 ps aux|grep nginx 可以查看Nginx进程情况 但此时还不能通过浏览器直接访问，要在阿里云控制台进行安全组配置 分别设置入方向和出方向规则 刷新网站即可看到80端口可以访问了 非常有帮助的参考 Docker查看位数getconf LONG_BIT 64位 查看系统lsb_release -a 查看内核版本uname -r 4.4.0-170-generic 查看可安装的docker版本apt-cache madison docker-ce 居然没有。。看了要换镜像 apt-get -y install apt-transport-https ca-certificates curl software-properties-common 允许用于通过HTTPS来获取仓库 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 添加 Docker 的官方 GPG 密钥 sudo apt-key fingerprint 0EBFCD88 确认密钥 sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; 添加阿里云镜像仓库 更新 sudo apt-get update 再次apt-cache madison docker-ce 就可以看到极多版本的docker了 安装sudo apt-get install docker-ce docker-ce-cli containerd.io 查看docker是否启动 systemctl status docker 未启动则启动 systemctl start docker 尝试允许hello-world 的image，没有问题，安装成功 参考 其他安装了git方便以后管理代码 本来还想弄个gitbook部署上去，但是域名访问还要备案，内容也还没开始写，同步起来也比较麻烦，还是以后再弄吧 大致步骤是先在本地写好md文件及目录结构，build生成对应的静态文件，其中gitbook的源码还要结合nginx或express，用server.js设置好端口 然后将除modules以外的文件同步到github。服务器clone仓库，进入目录执行npm install安装依赖。 pm2执行server.js即可访问","categories":[{"name":"Project","slug":"Project","permalink":"http://vergessenwang.github.io/categories/Project/"}],"tags":[{"name":"云服务器","slug":"云服务器","permalink":"http://vergessenwang.github.io/tags/云服务器/"}]},{"title":"冲鸭，向着S公司","slug":"冲鸭，向着S公司","date":"2020-02-05T15:52:11.000Z","updated":"2020-02-05T16:19:25.408Z","comments":true,"path":"posts/Intern/2020-02-05-冲鸭，向着S公司.html","link":"","permalink":"http://vergessenwang.github.io/posts/Intern/2020-02-05-冲鸭，向着S公司.html","excerpt":"大概知识点Java基础良好 —- 容器，GC， 多线程 熟悉Spring等主流Web框架 —- java web, cloud 掌握WEB后端开发技术: 协议、架构、存储、缓存、安全等 对ERP有一定的概念，javascript &amp; abap 大数据—HANA相关，内存数据库 细节知识点 设计模式—单例的各种实现，模式的JDK动态，及为什么要动态 类加载器 新生代和老年代 —-GC 标记算法 数据库 —– 触发器和存储过程 基于oracle的一种数据库 —- 该公司会用的 索引、优化、如何处理非常多的数据 优化sql，让模糊查询走索引：%匹配符不能在字符前面 redis","text":"大概知识点Java基础良好 —- 容器，GC， 多线程 熟悉Spring等主流Web框架 —- java web, cloud 掌握WEB后端开发技术: 协议、架构、存储、缓存、安全等 对ERP有一定的概念，javascript &amp; abap 大数据—HANA相关，内存数据库 细节知识点 设计模式—单例的各种实现，模式的JDK动态，及为什么要动态 类加载器 新生代和老年代 —-GC 标记算法 数据库 —– 触发器和存储过程 基于oracle的一种数据库 —- 该公司会用的 索引、优化、如何处理非常多的数据 优化sql，让模糊查询走索引：%匹配符不能在字符前面 redis 线程安全，锁 —- 并发控制 启动线程的方式：Thread.start，线程池自动启动,callable 消息队列 快排：说了各种复杂度、稳定性和思想 红黑树：不会 加密算法底层 —-安全 TCP建立连接为什么需要三次 应用层协议有哪些 邮件的正则 xml转json JUC包 项目主要是做什么，数据库是怎样的 例题 m*n 个格子，从左边的最底层走到最右边的最上层，每一步只能往上或者往前走一步，问有多少种走法？ 内连接，左连接，全连接输出。 设计一个基类，和两个子类，子类分别实现递归与非递归斐波列切数列。 图的深度与广度遍历输出交通灯 observer 模式 JVM 中能实现一种实例的三种方法 WCF 中的 ABC 分别代表什么 三盏灯与三个开关，怎么样能够一个人进入连接开关和灯。 运用Design Pattern改进CopyFactory类，实现必须具有产品标准。 先有鸡还是先有蛋，阐述理由？ 线程在什么情况下会进入等待队列？列出3种情况。 数据库中某表只有1列，具有相同record，在没有index，key的情况下取出第5和第7行的结果。写出一种解决方案。 Implement the simplest singleton pattern(initialize if if necessary). Name three sort algorithms you are familiar with. Write out the correct or der by the average time complexity. Write code to sort a duplex direction linklist. The node T has overridden the comparision operators 形式一个小时，四道算法题，四道Sql题 —- 大概10分钟一道算法题？？？ 实习全年招聘，有上海、西安、成都、南京四个地点。暑期有VT项目 BTW: thoughtworks 也可以关注下，毕竟 全球最佳女性科技人员雇主…","categories":[{"name":"Intern","slug":"Intern","permalink":"http://vergessenwang.github.io/categories/Intern/"}],"tags":[]},{"title":"神奇Docker","slug":"神奇Docker","date":"2020-02-03T15:30:19.000Z","updated":"2020-02-05T16:07:43.096Z","comments":true,"path":"posts/Java/2020-02-03-神奇Docker.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-02-03-神奇Docker.html","excerpt":"Docker是Go语言开发的应用容器引擎，核心概念是：镜像、容器、仓库 关键字是：分布式应用，微服务，容器，虚拟化 传统的虚拟机技术是在硬件层面实现的，需要额外的虚拟机管理软件跟虚拟机操作系统。而Docker是在操作系统层面实现的，直接使用本地操作系统 Docker的主要目标是通过对应用组件的封装。分发、部署、运行等生命周期的管理，做到“一次封装，到处运行” Docker体系原理一个完整的Docker有以下几部分： DockerClient 客户端 Docker Deamon 守护进程 Docker Image 镜像 Docker Container 容器 Docker使用了C/S体系架构，Docker客户端与Docker守护进程通信，Docker守护进程负责构建，运行和分发Docker容器。","text":"Docker是Go语言开发的应用容器引擎，核心概念是：镜像、容器、仓库 关键字是：分布式应用，微服务，容器，虚拟化 传统的虚拟机技术是在硬件层面实现的，需要额外的虚拟机管理软件跟虚拟机操作系统。而Docker是在操作系统层面实现的，直接使用本地操作系统 Docker的主要目标是通过对应用组件的封装。分发、部署、运行等生命周期的管理，做到“一次封装，到处运行” Docker体系原理一个完整的Docker有以下几部分： DockerClient 客户端 Docker Deamon 守护进程 Docker Image 镜像 Docker Container 容器 Docker使用了C/S体系架构，Docker客户端与Docker守护进程通信，Docker守护进程负责构建，运行和分发Docker容器。 Docker Damon DockerD用来监听Docker API的请求和管理Docker对象，比如镜像、容器、网络和Volume Docker Client docker client是我们和Docker进行交互的最主要的方式方法，比如可以通过docker run来运行一个容器，然后我们的这个client会把命令发送给上面的Docker Docker Registry 用来存储Docker镜像的仓库，Docker Hub是Docker官方提供的一个公共仓库，而且Docker默认也是从Docker Hub上查找镜像的，当然你也可以很方便的运行一个私有仓库，当我们使用docker pull或者docker run命令时，就会从我们配置的Docker镜像仓库中去拉取镜像，使用docker push命令时，会将我们构建的镜像推送到对应的镜像仓库中 Images 镜像，镜像是一个制度模板，带有Docker容器的说明，一般来说的，镜像会基于另外的一些基础镜像上面安装一个Nginx服务器，这样就可以构建一个属于我们自己的镜像了 Containers 容器，容器是一个镜像的可运行的实例，可以使用Docker REST API或者CLI来操作容器，容器的实质是进程，但与直接在宿主执行的实例进程不同，容器进程属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间、甚至自己的用户ID。容器内的经常是运行在一个隔离的环境里，使用起来，就好像在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全 Docker详解 安装官网 然而该安装包并不支持WIN10 家庭版….只能用toolbox了 安装指南 然而在找镜像的过程中，感受到了对Windows系统深深的敌意….我生气了，我真的要换Linux本了… 确保虚拟化已启动 启动Docker 终端遇到问题： &quot;This computer doesn&#39;t have VT-X/AMD-v enabled. Enabling it in the BIOS is mandatory&quot; 首先检查一下电脑是否支持VT-X/AMD-v ，检测软件 我的结果是VT-X/AMD-v enabled ，那为什么还有这个问题呢？ 在SO上看到一个回答，关闭虚拟化检查。 cmd运行： 1docker-machine create -d virtualbox --virtualbox-memory=1024 创建了一个内存1G的虚拟机，然后 1docker-machine create -d virtualbox --virtualbox-no-vtx-check default 还是不行？？？ 另一种解决方法 直接修改sh文件设置 Open C:\\Program Files\\Docker Toolbox\\start.sh with an Editor Replace line 69 from &quot;${DOCKER_MACHINE}&quot; create -d virtualbox $PROXY_ENV &quot;${VM} to &quot;${DOCKER_MACHINE}&quot; create -d virtualbox --virtualbox-no-vtx-check $PROXY_ENV &quot;${VM}&quot; 可能是因为之前命令行的权限不够？ 再次启动终端, 上述问题消失，但又有别的问题 Downloading C:\\Users\\18771\\.docker\\machine\\cache\\boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v19.03.5/boot2docker.iso... 这一步下不下来，可能是众所周知的原因。 手动下载该文件 https://github.com/boot2docker/boot2docker/releases/download/v19.03.5/boot2docker.iso 放在 /Users/{user}/.docker/machine/cache/ 目录下 运行成功，会自动创建虚拟机，调用virtualBox的接口，创建虚拟网卡等一系列配置，最后出现了一只小鲸鱼！~~~ 12345678910 ## . ## ## ## == ## ## ## ## ## === /\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\\___/ === ~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~~ ~ / === \\______ o __/ \\ \\ __/ \\____\\_______/docker is configured to use the default machine with IP 192.168.99.100 此时进入了git命令行，即Linux环境 Docker命令命令在Toolbox 运行的 git 终端中运行，而非cmd 基本命令docker version 可以看到客户端OS是 Windows 而 服务端OS是 Linux docker info 查看相关信息 docker pull ... 从官方仓库pull docker run ... 如果本地没有该镜像，会从官方仓库pull下来，然后运行一个container docker image ls 查看本地镜像 docker container ls 查看本地容器—-容器就是动态的镜像(类似进程与程序的关系) 同一个镜像可以运行在不同的端口，每个端口运行着的都是一个容器，也就是镜像的实例 docker container stop contain_id 终止某容器 docker-machine ls 查看虚拟机 docker-machine rm ... 移除某虚拟机 image相关docker tag repoitory_name : old_tag repoitory_name : new_tag 添加tag, 但是ID不变，常常给某一个image加上latest标签, 在开发的过程里可以灵活地让其指向不同的image，管理更加灵活 例如从官方仓库pull时，就会默认下载latest版本 docker image history repoitory_name/id 查看更新历史 docker image inspect repoitory_name/id 查看详细信息，如开发环境，配置信息等 docker image remove repoitory_name/id 移除 container相关docker run -p port:port -d repoitory_name/id:tag -p 指定端口 -d 表示后台运行,返回一个container_id 加上--restart==always 每次重启docker自动创建，默认为no 适用于数据库等重启后就要马上启动的服务 加上-m -512m 分配内存—与实际的占用会有差异 加上--cpu-quato 5000 分配CPU的5% docker container pause container_id 暂停 docker container unpause container_id 继续 docker container stop container_id 停止 docker container kill container_id 立即停止 docker logs -f container_id 查看日志 docker container inspect container_id 查看详细信息，如状态，网络等 docker container prune 移除所有停止的container docker events container事件动态 docker top container_id container中运行的进程信息—–可以理解为container是对进程的封装？ docker stats container占用CPU和内存的情况 docker system df 查看对比信息 其他github下载速度过慢这是经常遇到，但一直没有解决的问题，在github上经常遇到的，下文件很慢很慢，绝大部分是因为来自于亚马逊的国外服务器 尝试1： 更改C:\\Windows\\System32\\drivers\\etc\\hosts文件，在文件中追加219.76.4.4 github-cloud.s3.amazonaws.com, 将域名指向该IP，即香港的服务器 在cmd命令行输入：ipconfig/flushdns（刷新DNS）—– 哇，果然快到飞起 方法2： 码云 —- 改天试试","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://vergessenwang.github.io/tags/Docker/"}]},{"title":"肆意蒸发的2019","slug":"肆意蒸发的2019","date":"2020-02-01T10:38:31.000Z","updated":"2020-02-01T10:39:57.508Z","comments":true,"path":"posts/life/2020-02-01-肆意蒸发的2019.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2020-02-01-肆意蒸发的2019.html","excerpt":"2020真是一个炸裂开局。 上一个频道还是晚会里的张灯结彩，下一个频道就成了医院里的白布裹尸。 谣言与真相，封锁与逃离，疯抢与暴利，牺牲与渎职。 多么荒诞的现实啊。一切仿佛《鼠疫》的情节重演。一切那么遥远，一切那么真实。 大概率是坎坷的一年了。还未到来的事情就不多想了，该总结一下2019了。 一年将尽，又是残冬的急景了，我南北奔跑，一年之内毫无半点成绩，只赢得许多悲愤，啊，想起来，做人真是没趣。 ——《郁达夫日记》 也许人生就是在海水中游泳，没有上岸的一天。","text":"2020真是一个炸裂开局。 上一个频道还是晚会里的张灯结彩，下一个频道就成了医院里的白布裹尸。 谣言与真相，封锁与逃离，疯抢与暴利，牺牲与渎职。 多么荒诞的现实啊。一切仿佛《鼠疫》的情节重演。一切那么遥远，一切那么真实。 大概率是坎坷的一年了。还未到来的事情就不多想了，该总结一下2019了。 一年将尽，又是残冬的急景了，我南北奔跑，一年之内毫无半点成绩，只赢得许多悲愤，啊，想起来，做人真是没趣。 ——《郁达夫日记》 也许人生就是在海水中游泳，没有上岸的一天。 难做的事和应该做的事…往往是同一件事。凡是有意义的事情都不会容易。我以前常常觉得很多事情没有意义，大概只是因为我选择的都是一些容易做的事情吧。同样的，当不知该选哪条路的时候，选比较难的那条路，选可能走不下去的那条路。 也许，学习的很盲目，觉得每日都忙，却不知最后学到了什么，还是因为没有意识到：掌握技术的唯一目的是拿它实现你想实现的想法或产品。 在学校的最后两个月里，其实一直处于一种很沉郁状态，可能总觉得要高网要挂(最后结果还可行，可是我明明卷子做得稀碎….这也让我意识到上课其实并不怎样重要) 可能太多情绪盘亘心头，可能在避世和热情里消耗太多。不过终究是过去了，现在目标逐渐清晰起来，状态也好了很多。 还有，以前我一直试图能让很多事情有个两全的结局，现在并不这样想了。 这一年 身体素质还是老样子 给人拍照依然毫无美感。。 开始喜欢 风景水彩 云彩，雪山，天空和夕阳 —- 从水彩里我感悟到色彩的神奇，而大自然的色彩又是如此浑然天成，令人除了惊叹，无从言语。老年的梦想是在某个欧洲风景优美的小镇画画放牛… 陶陶居的糯米鸡 — 啊，饿了 香蕉牛奶 —啊，好喝 南京东方宫的拉面 — 啊，真香 天海佑希 J2EE — 以后多学学SSM 依然喜欢 那几只居 坚持一件事直至有所收获的感觉 — 要拨一点时间，做有长期价值的事情 中秋的月亮 —- 可惜了，城市的灯太亮，没有月色 古风插画 沙雕表情包。。。 明白了我不喜欢 PM岗，我讨厌做PPT 算法岗，我讨厌数学公式 修福报 — 某日写代码到三点，有点升天的感觉。。相比于健康和快乐，努力获得的东西根本不值一提 太压抑的关系 明白了我做不到 过于精致的绘画技法 从过度的游戏里获得快乐 — 然而这并不影响我想买一个xbox… 想看而未看的 《搏击俱乐部》 《悲剧的诞生》 《卡拉马佐夫兄弟》 《我们赖以生存的隐喻》 …","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[{"name":"又是一年","slug":"又是一年","permalink":"http://vergessenwang.github.io/tags/又是一年/"}]},{"title":"刷LeetCode的正确姿势","slug":"刷LeetCode的正确姿势","date":"2020-01-31T15:23:46.000Z","updated":"2020-01-31T15:26:57.672Z","comments":true,"path":"posts/Intern/2020-01-31-刷LeetCode的正确姿势.html","link":"","permalink":"http://vergessenwang.github.io/posts/Intern/2020-01-31-刷LeetCode的正确姿势.html","excerpt":"今天，小伙伴问我，LeetCode刷了几道了？？？ 晴天霹雳。 确实要开始准备笔试了。但是也不想太盲目，所以先了解一下科学的刷题方法。 第一遍：从易到难—主要是easy和medium，广度，看别人的解法 第二遍：按类别—-深度，要有一个方面比较特殊 需要刷的数量 200~300 ，各个难度刷一半；每个类别的核心思想的理解，达到何种程度的优化。 反刷题：一开始就给出最优解？ 然而能不能做出题目其实是次要，重要的是解决问题的思路 其实刷题并不是要去实现一个量化的目标，诸如我刷了多少？刷了几遍？ 而是要去总结和理解题目背后的涵义。 找实习的话，其实学校的项目经验帮助不大，除非是参加过Github上大型的开源项目。","text":"今天，小伙伴问我，LeetCode刷了几道了？？？ 晴天霹雳。 确实要开始准备笔试了。但是也不想太盲目，所以先了解一下科学的刷题方法。 第一遍：从易到难—主要是easy和medium，广度，看别人的解法 第二遍：按类别—-深度，要有一个方面比较特殊 需要刷的数量 200~300 ，各个难度刷一半；每个类别的核心思想的理解，达到何种程度的优化。 反刷题：一开始就给出最优解？ 然而能不能做出题目其实是次要，重要的是解决问题的思路 其实刷题并不是要去实现一个量化的目标，诸如我刷了多少？刷了几遍？ 而是要去总结和理解题目背后的涵义。 找实习的话，其实学校的项目经验帮助不大，除非是参加过Github上大型的开源项目。 以下总结来自花花酱 刷多少题 每个类型10~20 DP越多越好 总共200~300 如何刷 按类型总结 第一遍：5分钟想不出来就看答案 第二遍：尝试不看答案完整实现( 不超过60min) 第三遍：快速实现( 不超过20min) 看不同版本的代码—-速度中间偏前的 看3~5种不同的实现，分析优缺点，速度快慢的原因 学习新的语言/ API 培养能力 至少能看出该使用什么样的算法 根据数据规模推算时间复杂度 代码风格： 命名、缩进、括号 不多说了，今天就开始吧","categories":[{"name":"Intern","slug":"Intern","permalink":"http://vergessenwang.github.io/categories/Intern/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://vergessenwang.github.io/tags/LeetCode/"}]},{"title":"Spring Boot实现简单REST-API","slug":"Spring-Boot实现简单REST-API","date":"2020-01-27T10:17:29.000Z","updated":"2020-01-27T10:20:24.678Z","comments":true,"path":"posts/Java/2020-01-27-Spring-Boot实现简单REST-API.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-01-27-Spring-Boot实现简单REST-API.html","excerpt":"设计模式之 依赖注入 「依赖注入」就是为了完成这样的 目标：将 依赖组件 的配置和使用分离开，以降低使用者与依赖之间的耦合度。 通过@component将类作为spring bean注入到spring container中，然后用 context.getBean 代替 new 来创建所需的对象 。值得注意的是，即使不显式创建，这些类也会被用单例模式自动创建好一个对象，等待被使用。如果要显式创建，必须用@Scope(value = “prototype”) 原型模式注解 对于有依赖的关系的对象，通过@Autowired 在spring container中自动寻找相应的类来建立依赖 预安装： JDK: Java10.0.2 IDE: IDEA 管理工具: Maven 3.6.1 Git SDKMAN然而在看很多教程的时候发现，java8用的比较多，我又不想卸载我的java10，于是找到了一个SDK管理工具用于管理java版本 安装指引 使用指引 另外该软件还可以管理Ant、Gradle、Maven、Springboot-cli、Groovy、Kotlin、Scala。可以说是java开发必备了","text":"设计模式之 依赖注入 「依赖注入」就是为了完成这样的 目标：将 依赖组件 的配置和使用分离开，以降低使用者与依赖之间的耦合度。 通过@component将类作为spring bean注入到spring container中，然后用 context.getBean 代替 new 来创建所需的对象 。值得注意的是，即使不显式创建，这些类也会被用单例模式自动创建好一个对象，等待被使用。如果要显式创建，必须用@Scope(value = “prototype”) 原型模式注解 对于有依赖的关系的对象，通过@Autowired 在spring container中自动寻找相应的类来建立依赖 预安装： JDK: Java10.0.2 IDE: IDEA 管理工具: Maven 3.6.1 Git SDKMAN然而在看很多教程的时候发现，java8用的比较多，我又不想卸载我的java10，于是找到了一个SDK管理工具用于管理java版本 安装指引 使用指引 另外该软件还可以管理Ant、Gradle、Maven、Springboot-cli、Groovy、Kotlin、Scala。可以说是java开发必备了 POSTMAN在项目还没有开发出前端页面时，用于模拟发送HTTP请求 安装及使用 界面挺不错的 例： POST –&gt; localhost:8080/api/v1/person Body – &gt; raw ,JSON –&gt; {内容} UUID Generator可在线生成UUID IDEA相关配置Maven配置本地仓库在maven安装目录中的conf -&gt; setting 中找到默认的本地仓库地址 为path/to/local/repo 新建一个本地仓库文件夹，并将地址替换 C:/Tools/maven/LocalWarehouse —–注意是另外写一行localrepository ,不是修改注释里面的 其实IDEA自带了maven，但是在这里设置为已经安装的相应配置。在IDEA的setting -&gt; Build tools 中设置maven的所在目录为C:\\Tools\\maven\\apache-maven-3.6.1 ，setting文件 C:\\Tools\\maven\\apache-maven-3.6.1\\conf\\settings.xml和本地仓库C:\\Tools\\maven\\LocalWarehouse Git在setting - &gt; version control 中 Git已经自动检测到，Github输入账号密码即可 实践学习视频 使用spring initializr 新建项目，在dependency的web中选择spring web 一个项目从数据层，服务层和用户接口层逐步去实现。 数据层数据模型 12345678910111213141516171819public class Person &#123; private final UUID id; @NotBlank private final String name; public Person(@JsonProperty(\"id\") UUID id, @JsonProperty(\"name\") String name) &#123; this.id = id; this.name = name; &#125; public UUID getId() &#123; return id; &#125; public String getName() &#123; return name; &#125;&#125; 输入的名字限制为非空 格式为JSON 数据操作接口 12345678910111213141516public interface PersonDao &#123; int insertPerson(UUID id, Person person); default int insertPerson(Person person)&#123; UUID id = UUID.randomUUID(); return insertPerson(id,person); &#125; List&lt;Person&gt; selectAllPeople(); Optional&lt;Person&gt; selectPersonById(UUID id); int deletePersonById(UUID id); int updatePersonById(UUID id,Person person);&#125; 如果只输入了姓名，则生成一个随机ID 接口实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Repository(\"fakeDao\")public class FakePersonDataAccessService implements PersonDao &#123; private static List&lt;Person&gt; DB = new ArrayList&lt;&gt;(); @Override public int insertPerson(UUID id, Person person) &#123; DB.add(new Person(id,person.getName())); return 1; &#125; @Override public List&lt;Person&gt; selectAllPeople() &#123; return DB; &#125; @Override public Optional&lt;Person&gt; selectPersonById(UUID id) &#123; return DB.stream() .filter(person -&gt; person.getId().equals(id)) .findFirst(); &#125; @Override public int deletePersonById(UUID id) &#123; Optional&lt;Person&gt; personMaybe = selectPersonById(id); if(!personMaybe.isPresent())&#123; return 0; &#125; DB.remove(personMaybe.get()); return 1; &#125; @Override public int updatePersonById(UUID id, Person update) &#123; return selectPersonById(id) .map(person -&gt;&#123; int indexOfPersonToUpdate = DB.indexOf(person); if(indexOfPersonToUpdate &gt;= 0)&#123; DB.set(indexOfPersonToUpdate, new Person(id, update.getName())); return 1; &#125; return 0; &#125;) .orElse(0); &#125;&#125; 给数据仓库命名，可以方便后续service处转为其他类型的repository 注意List的add/stream/set/remove等用法 服务层123456789101112131415161718192021222324252627282930@Servicepublic class PersonService &#123; public final PersonDao personDao; @Autowired public PersonService(@Qualifier(\"fakeDao\") PersonDao personDao) &#123; this.personDao = personDao; &#125; public int addPerson(Person person)&#123; return personDao.insertPerson(person); &#125; public List&lt;Person&gt; getAllPeople()&#123; return personDao.selectAllPeople(); &#125; public Optional&lt;Person&gt; getPersonById(UUID id)&#123; return personDao.selectPersonById(id); &#125; public int deletePerson(UUID id)&#123; return personDao.deletePersonById(id); &#125; public int updatePerson(UUID id, Person newPerson)&#123; return personDao.updatePersonById(id, newPerson); &#125;&#125; 注解为@service，明确作用 @Autowired 依赖注入 在spring container中自动寻找相应的类来建立依赖 @Qualifier(“fakeDao”) 按名查找 服务层其实是在调用数据层的操作 用户接口层123456789101112131415161718192021222324252627282930313233343536@RequestMapping(\"api/v1/person\")@RestControllerpublic class PersonController &#123; private final PersonService personService; @Autowired public PersonController(PersonService personService) &#123; this.personService = personService; &#125; @PostMapping public void addPerson( @Valid @NonNull @RequestBody Person person)&#123; personService.addPerson(person); &#125; @GetMapping public List&lt;Person&gt; getAllPeople()&#123; return personService.getAllPeople(); &#125; @GetMapping(path = \"&#123;id&#125;\") public Person getPersonById(@PathVariable(\"id\") UUID id)&#123; return personService.getPersonById(id) .orElse(null); &#125; @DeleteMapping(path = \"&#123;id&#125;\") public void deletePersonById(@PathVariable(\"id\") UUID id)&#123; personService.deletePerson(id); &#125; @PutMapping(path = \"&#123;id&#125;\") public void updatePerson(@PathVariable(\"id\") UUID id, @Valid @NonNull @RequestBody Person personToUpdate)&#123; personService.updatePerson(id, personToUpdate); &#125;&#125; @RequestMapping 指定HTTP路径 @RestController 明确控制器功能 @PostMapping @GetMapping @DeleteMapping @PutMapping 将HTTP类型与方法绑定 @PathVariable(“id”) 指定变量 @RequestBody 指定寻找部位 TIPS IDEA换上了新出的Mono字体真是赏心悦目啊 实现接口时，可以用快捷键 Ctrl + i 最后通过mave打包出来的jar是可以直接运行的","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://vergessenwang.github.io/tags/Spring-Boot/"}]},{"title":"React初体验--谁说前端很简单的？？","slug":"React初体验-谁说前端很简单的？？","date":"2020-01-21T17:14:03.000Z","updated":"2020-01-21T17:16:00.646Z","comments":true,"path":"posts/frontend/2020-01-22-React初体验-谁说前端很简单的？？.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2020-01-22-React初体验-谁说前端很简单的？？.html","excerpt":"预备知识 Node.js: 基于Chrome V8引擎的JavaScript 运行环境，使用了事件驱动、非阻塞I/O的模式 npm: node包管理工具 webpack：前端资源加载、打包工具，根据模块的依赖生成静态资源 ES6: js语言标准 React核心思想：声明式编程(注重结果而非实现)，组件化(自定义label)，虚拟DOM(减少渲染次数，diff算法) 环境搭建利用脚手架create-react-app来安装react 12345npm install -g create-react-app //安装脚手架C:\\Users\\18771\\AppData\\Roaming\\npm\\create-react-app -&gt; C:\\Users\\18771\\AppData\\Roaming\\npm\\node_modules\\create-react-app\\index.js+ create-react-app@3.3.0added 91 packages in 96.802s 1create-react-app my-app //会自动创建好Server Webpack 和 Babel 此时报错：bash: create-react-app: command not found","text":"预备知识 Node.js: 基于Chrome V8引擎的JavaScript 运行环境，使用了事件驱动、非阻塞I/O的模式 npm: node包管理工具 webpack：前端资源加载、打包工具，根据模块的依赖生成静态资源 ES6: js语言标准 React核心思想：声明式编程(注重结果而非实现)，组件化(自定义label)，虚拟DOM(减少渲染次数，diff算法) 环境搭建利用脚手架create-react-app来安装react 12345npm install -g create-react-app //安装脚手架C:\\Users\\18771\\AppData\\Roaming\\npm\\create-react-app -&gt; C:\\Users\\18771\\AppData\\Roaming\\npm\\node_modules\\create-react-app\\index.js+ create-react-app@3.3.0added 91 packages in 96.802s 1create-react-app my-app //会自动创建好Server Webpack 和 Babel 此时报错：bash: create-react-app: command not found 应该是路径问题 改用命令npx create-react-app my-app , 还是不行 用npm root命令寻找npm 的根目录发现是 C:\\Users\\18771\\node_modules 解决方法参考 12npm config set prefix /usr/localnpm i -g react-create-app 又报错 Unexpected end of JSON input while parsing near &#39;...5mVz30VuXnFvjkEbnA5Oc&#39; 进入 C:\\Users\\18771\\AppData\\Roaming\\npm-cache 目录 执行 npm cache clean --force 解决方法参考 重新安装 切换到要创建项目的目录，执行 npx create-react-app my-app 报错 ： 12npm ERR! code EINTEGRITYnpm ERR! sha512-k1g3gRQ4fwfJoIfgUpz78AovicSWKFANmvTfkAHP24MgJHjWfZI6ya7tsQZt1sLczvP4G9BE5G5MgADHdmJB/w== integrity checksum failed when using sha512: wanted sha512-k1g3gRQ4fwfJoIfgUpz78AovicSWKFANmvTfkAHP24MgJHjWfZI6ya7tsQZt1sLczvP4G9BE5G5MgADHdmJB/w== but got sha512-WkbI2UIeavrFcTouh/pYNWeOYEQFVDIs8JjFZLRlZPSyyYVpmqLA0jN+BTmrDVMN23qY0wBFktjQhVBJ1PO8Yw==. (698 bytes) 似乎是package-json 文件的问题 执行 npm cache verify 再次尝试成功创建 1234567891011121314151617181920212223242526272829303132333435363738npx create-react-app my-appnpm WARN react-scripts@3.3.0 requires a peer of typescript@^3.2.1 but none is installed. You must install peer dependencies yourself.npm WARN sass-loader@8.0.0 requires a peer of node-sass@^4.0.0 but none is installed. You must install peer dependencies yourself.npm WARN sass-loader@8.0.0 requires a peer of sass@^1.3.0 but none is installed. You must install peer dependencies yourself.npm WARN sass-loader@8.0.0 requires a peer of fibers@&gt;= 3.1.0 but none is installed. You must install peer dependencies yourself.npm WARN tsutils@3.17.1 requires a peer of typescript@&gt;=2.8.0 || &gt;= 3.2.0-dev || &gt;= 3.3.0-dev || &gt;= 3.4.0-dev || &gt;= 3.5.0-dev || &gt;= 3.6.0-dev || &gt;= 3.6.0-beta || &gt;= 3.7.0-dev || &gt;= 3.7.0-beta but none is installed. You must install peer dependencies yourself.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 (node_modules\\jest-haste-map\\node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.11: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 (node_modules\\chokidar\\node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.11: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.2 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.2: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)removed 1 package in 29.248sInitialized a git repository.Success! Created my-app at C:\\Users\\18771\\Desktop\\my_app\\my-appInside that directory, you can run several commands: npm start Starts the development server. npm run build Bundles the app into static files for production. npm test Starts the test runner. npm run eject Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can’t go back!We suggest that you begin by typing: cd my-app npm start 执行start 会自动在本地3000端口打开一个页面 在VS Code中安装 Simple React Snippets 和 Prettier插件 同时在setting.json中添加一行&quot;editor.formatOnSave&quot;: true, 自动格式化后保存 在Chrome中添加插件 React Developer Tools 实践Babel 可以将 JSX 翻译为 react boostraps为了设计CSS ，安装bootstrap ，直接在VS Code 的集成终端输入 npm i bootstrap@4.1.1 在index.js 中导入 import &quot;bootstrap/dist/css/bootstrap.css&quot;; components基本用法新建counter.jsx文件写入组件代码 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from \"react\"; //imrcclass Counter extends Component &#123; //cc state = &#123; count: 1, //imageUrl: \"https://picsum.photos/200\", tags: [\"tag1\", \"tag2\", \"tag3\"] &#125;; styles = &#123; fontWeight: \"bold\", fontSize: 20 &#125;; render() &#123; return ( &lt;React.Fragment&gt; &lt;span style=&#123;this.styles&#125; className=&#123;this.getBadgeClasses()&#125;&gt; &#123;this.formatCount()&#125; &lt;/span&gt; &lt;button className=\"btn btn-secondary btn-sm\"&gt;Increment&lt;/button&gt; &lt;ul&gt; &#123;this.state.tags.map(tag =&gt; ( &lt;li key=&#123;tag&#125;&gt;&#123;tag&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;img src=&#123;this.state.imageUrl&#125; alt=\"\" /&gt; &lt;/React.Fragment&gt; ); &#125; getBadgeClasses() &#123; let classes = \"badge m-2 badge-\"; classes += this.state.count === 0 ? \"warning\" : \"primary\"; return classes; &#125; formatCount() &#123; const &#123; count &#125; = this.state; return count === 0 ? \"Zero\" : count; &#125;&#125;export default Counter; 由于装了插件，可以直接用简写；因为render()只能默认产生一个元素，所以多个标签要用&lt;React.Fragment&gt;包起来； {}可以引用类中的成员或方法； className=”btn btn-secondary btn-sm”是bootstrap中的样式； style={this.styles} 自定义样式； classes += this.state.count === 0 ? “warning” : “primary”; 可按数值变化样式 {this.state.tags.map(tag =&gt; {tag})} map是一种遍历方法，为每个值设置一个key是为了react能区分出元素 除了用class，还可以用stateless funciton 来写组件(sfc) 这也是一种比较常用的写法，只是不能用this关键字 然后在index.js中引用 123import Counter from \"./components/counter\";ReactDOM.render(&lt;Counter /&gt;, document.getElementById(\"root\")); 按不同条件进行渲染1234567891011121314151617181920212223242526272829import React, &#123; Component &#125; from \"react\"; class Counter extends Component &#123; state = &#123; count: 1, tags: [\"tag1\", \"tag2\", \"tag3\"] &#125;; renderTags() &#123; if (this.state.tags.length === 0) return &lt;p&gt;There are no tags!&lt;/p&gt;; return ( &lt;ul&gt; &#123;this.state.tags.map(tag =&gt; ( &lt;li key=&#123;tag&#125;&gt;&#123;tag&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; ); &#125; render() &#123; return ( &lt;React.Fragment&gt; &#123;this.state.tags.length === 0 &amp;&amp; \"Please create a new tags!\"&#125; &#123;this.renderTags()&#125; &lt;/React.Fragment&gt; ); &#125;&#125;export default Counter; this.state.tags.length === 0 &amp;&amp; “Please create a new tags!” 在js中 &amp;&amp;结果为真时，返回最后一个表达式 新增一个方法用于条件判断 交互12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from \"react\"; //imrcclass Counter extends Component &#123; //cc state = &#123; count: 1 &#125;; constructor() &#123; super(); this.handleIncrement = this.handleIncrement.bind(this); &#125; handleIncrement() &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125; render() &#123; return ( &lt;React.Fragment&gt; &lt;span className=&#123;this.getBadgeClasses()&#125;&gt;&#123;this.formatCount()&#125;&lt;/span&gt; &lt;button onClick=&#123;this.handleIncrement&#125; className=\"btn btn-secondary btn-sm\" &gt; Increment &lt;/button&gt; &lt;/React.Fragment&gt; ); &#125; getBadgeClasses() &#123; let classes = \"badge m-2 badge-\"; classes += this.state.count === 0 ? \"warning\" : \"primary\"; return classes; &#125; formatCount() &#123; const &#123; count &#125; = this.state; return count === 0 ? \"Zero\" : count; &#125;&#125;export default Counter; button 中添加 *onClick= {this.handleIncrement} —注意没有跟() 并写好handleIncrement() 方法 this.handleIncrement = this.handleIncrement.bind(this); 主要是为了将this与当前的Counter 对象绑定—-还可以用箭头函数 this.setState({ count: this.state.count + 1 }); 需要用setstate显式更改状态才能显示在页面上 复合组件props可以作为一个参数传入，将任意类型的数据传给组件，但是不能修改，定义时也要声明为static state是在组件内部使用并可以修改的 父组件和子组件通信可以通过props进行信息传递，当子组件要更新父组件时，可以让父组件传一个回调函数给子组件，子组件通过调用实现父组件更新——很常用的一种做法 同级之间如果要相互通信，可以将一个的函数上升为共同的父组件的回调函数；或者采用react的上下文方式，子组件可以直接访问祖先组件的属性和方法 为避免写太多this.props ,可以定义 const {func1, func2...} = this.props 选出要用的方法，之后就可以不加this.props前缀了 分清是模块控制还是全局控制 lifecycle&amp;hooks 挂载期：constructor()—先调用super() ; render() —所有父子组件渲染完后才会挂载; componentDidMount() —常用于Ajax与Server交互 更新期：componentDidUpdate() 卸载期: componentWillUnmount() —从DOM树中删除组件之前调用，用于做一些数据清零工作避免内存泄露 每个阶段都有对应的钩子函数，按序执行 只能用于class组件不能用于stateless funciton组件 tips 同时修改前后标签，选中标签，Ctrl+d 为了更好的封装，选中要转为方法的语句，右键，vscode提供了一个refactor功能，可以自动抽取出一个方法 true &amp;&amp; ‘hi’ —&gt; ‘hi’ 在js中 &amp;&amp;结果为真时，返回最后一个表达式 bootstrap一些设计案例，甚至可以直接搜索如“Navbar”, 会给出很多例子 react同时在内存保存有新和旧两份virtualDOM，通过比对，决定只需要对哪些部分进行更新","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"React","slug":"React","permalink":"http://vergessenwang.github.io/tags/React/"}]},{"title":"JavaFX + SQLite实现简单系统","slug":"JavaFX-SQLite实现简单系统","date":"2020-01-20T08:45:36.000Z","updated":"2020-01-20T08:48:52.988Z","comments":true,"path":"posts/Java/2020-01-20-JavaFX-SQLite实现简单系统.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2020-01-20-JavaFX-SQLite实现简单系统.html","excerpt":"学习来源 为了完成数据库大作业，终于开始了像蔡徐坤一样的学写代码的历程 首先在IDEA中新建一个javaFX项目，在sample文件夹会自动生成三个默认文件，删掉即可，新建自己的package和类 登录模块在class上新建一个fxml文件，发现了什么不得了的东西。。好像是一个可拖拽的界面，看起来大有用处。 加载fxml文件： 12345678public void start(Stage stage)throws Exception&#123; Parent root = (Parent) FXMLLoader.load(getClass().getResource(\"login.fxml\")); Scene scene = new Scene(root); stage.setScene(scene); stage.setTitle(\"School Management System\"); stage.show();&#125; 在fxml中拖入一个AnchorPane, 运行类就会出来一个窗口。 在fxml的源代码中添加控制器 fx:controller=&quot;loginapp.LoginController&quot;","text":"学习来源 为了完成数据库大作业，终于开始了像蔡徐坤一样的学写代码的历程 首先在IDEA中新建一个javaFX项目，在sample文件夹会自动生成三个默认文件，删掉即可，新建自己的package和类 登录模块在class上新建一个fxml文件，发现了什么不得了的东西。。好像是一个可拖拽的界面，看起来大有用处。 加载fxml文件： 12345678public void start(Stage stage)throws Exception&#123; Parent root = (Parent) FXMLLoader.load(getClass().getResource(\"login.fxml\")); Scene scene = new Scene(root); stage.setScene(scene); stage.setTitle(\"School Management System\"); stage.show();&#125; 在fxml中拖入一个AnchorPane, 运行类就会出来一个窗口。 在fxml的源代码中添加控制器 fx:controller=&quot;loginapp.LoginController&quot; SQLiteStudio下载地址 基本操作就不说了，图形化界面点点点就完事了。 新建一个dbUilt库，用于操作数据库。 连接数据库： 1234567891011121314151617public class dbConnection &#123; private static final String USERNAE = \"dbuser\"; private static final String PASSWORD = \"dapassword\"; private static final String CONN = \"jdbc:mysql://localhost/login\"; private static final String SQCONN = \"jdbc:sqlite:schoolsystem.sqlite\"; public static Connection getConnection() throws SQLException&#123; try&#123; Class.forName(\"org.sqlite.JDBC\"); return DriverManager.getConnection(SQCONN); &#125; catch (ClassNotFoundException ex) &#123; ex.printStackTrace(); &#125; return null; &#125;&#125; 在fxml中，如果在使用中出现表格无法激活的情况，需要下载SceneBuilder, 并在IDEA的setting中指定JavaFX的路径到下载好的exe文件。然后就可以右键fxml文件 open in Scene Builder 这个功能更完善一点，可以搜索并配置controller，所以我还是下了一个。虽然下载速度很感人，看着YTB上的UP主秒打开链接我真的好羡慕啊。。 下载地址 还得注册一个oracle…账户 46…qq 密码 B…98 结果登不上..最后在网上找另一个可用的 注意在Scene Builder中修改完要保存一下。 拖入label，第一个命名，第二个设置为code对应的变量名。需要输入的拖入textfield。 password可以用专用PasswordField 拖入一个combobox，这是下拉框，在properties中添加 Admin/ Students, 作为选项,同样也可以在username的properties中甚至promot占位提示符。 还有一个button ，作为login键 为combobox添加枚举类型。 新建enum类option: 12345678910111213public enum option &#123; Admin,Student; private option()&#123;&#125; public String value()&#123; return name(); &#125; public static option fromvalue(String v)&#123; return valueOf(v); &#125;&#125; 登录模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class LoginModel &#123; Connection connection; public LoginModel()&#123; try &#123; this.connection = dbConnection.getConnection(); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; if(this.connection == null)&#123; System.exit(1); &#125; &#125; public boolean isDatabaseConnected()&#123; return this.connection != null; &#125; public boolean isLogin(String user, String password, String opt)throws Exception&#123; PreparedStatement pr = null; ResultSet rs = null; String sql = \"SELECT * FROM login where username = ? and password = ? and division = ?\"; try&#123; pr = this.connection.prepareStatement(sql); pr.setString(1,user); pr.setString(2,password); pr.setString(3,opt); rs = pr.executeQuery(); boolean boll1; if(rs.next())&#123; return true; &#125; return false; &#125; catch (SQLException ex) &#123; return false; &#125; finally &#123; &#123; pr.close(); rs.close(); &#125; &#125; &#125;&#125; 控制模块： 注意在Label时要选择sence里的(因为很多库都有这个，不要弄错了) 12345678910111213141516171819202122232425public class LoginController implements Initializable &#123; LoginModel loginModel = new LoginModel(); @FXML private Label dbstatus; @FXML private TextField username; @FXML private PasswordField password; @FXML private ComboBox&lt;option&gt; combobox; @FXML private Button loginButton; public void initialize(URL url, ResourceBundle rb)&#123; if(this.loginModel.isDatabaseConnected())&#123; this.dbstatus.setText(\"Connected to database\"); &#125;else&#123; this.dbstatus.setText(\"Not connected to database\"); &#125; this.combobox.setItems(FXCollections.observableArrayList(option.values())); &#125;&#125; 运行时报错，java.lang.ClassNotFoundException: org.sqlite.JDBC没有安装sqlite的driver 下载地址 实在下不动，换了另一个网站 添加库：文件 -&gt; 目录结构 -&gt; 库 -&gt; + java -&gt; 下载的包 运行成功。 分用户登录给Login键添加事件onaction。注意ActionEvent要选 javafx.event. 给admin和student分别写方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@FXML public void Login(ActionEvent event) &#123; try &#123; if (this.loginModel.isLogin(this.username.getText(), this.password.getText(), ((option) this.combobox.getValue()).toString())) &#123; Stage stage = (Stage) this.loginButton.getScene().getWindow(); stage.close(); switch (((option) this.combobox.getValue()).toString()) &#123; case \"Admin\": adminLogin(); break; case \"Student\": studentLogin(); break; &#125; &#125; else &#123; this.loginStatus.setText(\"Wrong Credential\"); &#125; &#125;catch(Exception localException)&#123; &#125; &#125; public void studentLogin()&#123; try &#123; Stage userStage = new Stage(); FXMLLoader loader = new FXMLLoader(); Pane root = (Pane) loader.load(getClass().getResource(\"/students/studentFXML.fxml\").openStream()); StudentsController studentsController = (StudentsController) loader.getController(); Scene scene = new Scene(root); userStage.setScene(scene); userStage.setTitle(\"Student Dashboard\"); userStage.setResizable(false); userStage.show(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; public void adminLogin()&#123; try &#123; Stage adminStage = new Stage(); FXMLLoader adminLoader = new FXMLLoader(); Pane adminroot = (Pane) adminLoader.load(getClass().getResource(\"/Admin/Admin.fxml\").openStream()); AdminController adminController = (AdminController) adminLoader.getController(); Scene scene = new Scene(adminroot); adminStage.setScene(scene); adminStage.setTitle(\"Admin Dashboard\"); adminStage.setResizable(false); adminStage.show(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; 这里数据连接有点问题。。不管了先学用法吧 设置Admin.fxml 。tabpane可以创建多标签的表格；右边添加Hbox；添加tableview，按需要添加列;左边添加Vbox,在里面添加所需的label可以设置padding，添加textfield可以设置margin；添加datapicker 在scene builder中可以预览效果 添加数据更新方法。在变量上右键可以快速生成get和set方法， 数据加载： 12345678910111213141516171819202122private void loadStudentData(ActionEvent event)throws SQLException&#123; try&#123; Connection conn = dbConnection.getConnection(); this.data = FXCollections.observableArrayList(); ResultSet rs = conn.createStatement().executeQuery(sql); while(rs.next())&#123; this.data.add(new StudentData(rs.getString(1),rs.getString(2),rs.getString(3),rs.getString(4),rs.getString(5))); &#125; &#125;catch (SQLException e)&#123; System.err.println(\"ERROR\"+ e ); &#125; this.idcolumn.setCellValueFactory(new PropertyValueFactory&lt;StudentData,String&gt;(\"id\")); this.fnamecolumn.setCellValueFactory(new PropertyValueFactory&lt;StudentData,String&gt;(\"fname\")); this.lnamecolumn.setCellValueFactory(new PropertyValueFactory&lt;StudentData,String&gt;(\"lname\")); this.emailcolumn.setCellValueFactory(new PropertyValueFactory&lt;StudentData,String&gt;(\"email\")); this.dobcolumn.setCellValueFactory(new PropertyValueFactory&lt;StudentData,String&gt;(\"dob\")); this.studenttable.setItems(null); this.studenttable.setItems(this.data); &#125; 添加元组： 1234567891011121314151617181920private void addStudent(ActionEvent event)&#123; String sqlInsert = \"INSERT INTO students(id,fname,lname,email,dob) VALUES (?,?,?,?,?)\"; try&#123; Connection conn = dbConnection.getConnection(); PreparedStatement stmt = conn.prepareStatement(sqlInsert); stmt.setString(1,this.id.getText()); stmt.setString(2,this.fname.getText()); stmt.setString(3,this.lname.getText()); stmt.setString(4,this.email.getText()); stmt.setString(5,this.dob.getEditor().getText()); stmt.execute(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; 清空数据： 12345678@FXML private void clearFields(ActionEvent event)&#123; this.id.setText(\"\"); this.fname.setText(\"\"); this.lname.setText(\"\"); this.email.setText(\"\"); this.dob.setValue(null); &#125; 生成jar: 文件 -&gt; 项目结构 -&gt; Artifacts -&gt;jar -&gt;from mode…depen..-&gt; 选择LoginAPP作为入口类 -&gt; build artifacts。 数据和jar要放在同一目录下才可以直接运行。 为避免JRE版本不一致，可以把jar转成exe 学完这个视频内容之后，最后用时三天总算写完了数据库大作业，不过冗余代码好多，我的OOP水平是真的烂啊..","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[]},{"title":"系统建模","slug":"系统建模","date":"2020-01-11T12:37:29.000Z","updated":"2020-01-11T12:41:43.036Z","comments":true,"path":"posts/CS/2020-01-11-系统建模.html","link":"","permalink":"http://vergessenwang.github.io/posts/CS/2020-01-11-系统建模.html","excerpt":"概念CPS系统与实时系统的区别？实时系统（Real-Time Systems） 定义：系统的正确性不仅取决于计算的逻辑结果，还取决于产生结果的时间，在计算和操作上具有性能最后期限。 实时系统通常是嵌入式的，意味着计算系统存在于一个更大的系统内部，目的是帮助系统实现其整体职责。 时间定义： 时间约束（Timing constraint）：对执行时间行为的约束（包括硬实时和软实时） 发布时间（Release Time）：作业变成为可执行的时间。如果所有的工作在系统开始执行时被释放，那么就认为没有释放时间 截止时间（Deadline）：工作被要求执行完成的时间。如果截止时间是无限的，那么工作就没有最后期限。绝对截止时间等于发布时间加上相对截止时间 响应时间（Response time）：作业从发布到执行完成的时间长度","text":"概念CPS系统与实时系统的区别？实时系统（Real-Time Systems） 定义：系统的正确性不仅取决于计算的逻辑结果，还取决于产生结果的时间，在计算和操作上具有性能最后期限。 实时系统通常是嵌入式的，意味着计算系统存在于一个更大的系统内部，目的是帮助系统实现其整体职责。 时间定义： 时间约束（Timing constraint）：对执行时间行为的约束（包括硬实时和软实时） 发布时间（Release Time）：作业变成为可执行的时间。如果所有的工作在系统开始执行时被释放，那么就认为没有释放时间 截止时间（Deadline）：工作被要求执行完成的时间。如果截止时间是无限的，那么工作就没有最后期限。绝对截止时间等于发布时间加上相对截止时间 响应时间（Response time）：作业从发布到执行完成的时间长度 特征 及时性：行为的及时性与时间约束有关，如截止时间。最后期限可能很硬或很软。时效性的重要建模问题是建模执行时间，截止时间，到达模式，同步模式和时间源。 并发性： ​ 多个操作顺序链的同时执行。围绕并发系统执行的问题与此有关： ​ a.并发线程的调度特性——线程调度 ​ b.即将到来的事件的到来模式 ​ c.线程必须同步时使用的集合点模式 ​ d.控制对共享资源访问的方法 可预测性 正确性： 正确性表明一个系统总是运行正确。 鲁棒性：鲁棒性表明系统即使在遇到新的情况（不在计划中）下也是可靠的。因此必须警惕死锁，竞争以及其他异常情况 实时操作系统实时性能定量指标包括 任务上下文切换时间 ：中断延迟，响应，恢复时间，任务响应时间 最大中断禁止时间：反映内核对外界停止中断响应的最长时间 提高内核实时性的方法：任务互斥、同步 资源有限等待：任务没能获得需要的资源会被阻塞。如果资源不是任务继续运行必备的，任务可选择有限等待该资源 优先级反转问题解决：抢占式任务调度中的资源竞争，输入输出时间不一致导致抖动，优先级本身的不确定性导致可预测性下降。多任务内核应允许动态改变任务的优先级以避免发生优先级反转现象。为防止发生优先级反转,内核能自动变换任务的优先级,这叫做优先级继承(Priority inheritance)。 CPS系统(建模对象)​ Cyber（信息技术）: 计算，通信，控制（3C技术,computation,communication, control )，并且离散，逻辑，交换的系统； ​ Physical（物理系统）： 自然的和人造的系统受物理定律的支配，并持续运行；如嵌入式、传感系统 ​ Cyber-Physical Systems（信息物理融合系统）: 网络和物理系统紧密结合在一起的系统。 CPS系统的特点 信息-物理的耦合由新的需求和应用驱动 网络工作在多个和极端的规模下，每个物理组件中的网络性能，大规模的有线和无线网络 系统的系统 新的时空约束 多个时间和空间尺度上的复杂性，动态重组/重新配置，非传统的计算和物理基板 通信/计算/控制 之间的新型交互 自动化程度高，控制回路必须在所有尺度上关闭，控制回路中有大量非技术型的精明用户 无处不在的安全和隐私需求，操作必须可靠 Notice：不是桌面计算；不是传统的，事后嵌入式/实时系统；不是今天的传感器网络. 其研究目标是物理和网络（计算，通信，控制）设计深度集成；未来工程和监控物理系统的新学科 CPS是基于实时操作系统开发的，但是由于各种结构可能是异构的，所以要进行融合。 ※MDA(模型选择/建模方法) MDA定义的三种模型—— 逐步求精 计算独立模型（CIM，Computation-Independent Model）——功能需求：描述系统的需求和将在其中使用系统的业务上下文。此模型通常描述系统将用于做什么，而不描述如何实现系统。CIM 通常用业务语言或领域特定语言来表示。 平台独立模型（PIM，Platform-Independent Model）—— 操作系统：描述如何构造系统，而不涉及到用于实现模型的技术。此模型不描述用于为特定平台构建解决方案的机制。PIM 在由特定平台实现时可能是适当的，或者可能适合于多种平台上的实现。 平台特定模型 （PSM，Platform-Specific Model）—— 硬件：从特定平台的角度描述解决方案。其中包括如何实现 CIM 和如何在特定平台上完成该实现的细节。 MARTE与UML的区别？MARTE(modeling and analysis of real time and embedded systems)是UML在嵌入式实时系统领域的建模规范，取代原有的UML-SPT（UML profile for Schedulability , Performance and Time），支持对嵌入式实时系统的非功能属性建模。弥补了UML在嵌入式实时领域非功能属性表达能力的不足。 实践实时调度算法可调度性：表示实时系统（一组实时任务）是否能够按期完成的属性 对于周期任务（p，e），任务周期性的重复。（注意任务的描述符号表示，调度算法部分会用到）周期 p = inter - release time；p&gt;0执行时间 e = maximum execution time (0 &lt; e &lt; p)利用率 U = e/p 响应时间：任务从释放时间到结束时间 RM算法和EDF算法都属于抢占式算法 RM算法(单调速率，Rate Monotonic)前提假设 所有的任务是相互独立的（它们不相互作用，不相互依赖） 所有任务都是周期的，且运行时间不变 没有任何任务因等待外部事件而阻塞。 所有任务共享一个共同的释放时间（临界时刻，critical instant） 所有的任务的截止时间等于它们的周期，即任务必须在下一个作业释放之前完成。 算法描述 最佳的静态优先级调度 根据周期分配优先权 周期较短的任务具有较高的优先级 以最短的时间执行一项工作 使用限制：$∑U_i &lt;= n*(2^{(1/n)}-1)$ 满足以上式子时才能用RM算法进行调度 EDF算法（最早截止时间优先，Earliest Deadline First）算法描述 最佳的动态优先级调度 具有较早截止时间的任务具有较高的优先级 以最早的截止时间执行任务 注意：当一个任务在执行时，这时有一个新的任务到了，即使优先级更高，当前任务还是会继续执行(类似于磁盘电梯算法) 使用限制：$∑U_i &lt;= 1$ UML(建模工具)UML (Unified Modeling Language)为面向对象软件设计提供统一的、标准的、可视化的建模语言。适用于描述以用例为驱动，以体系结构为中心的软件设计的全过程。 过程: 分析 -&gt; 设计 -&gt; 实现 -&gt; 测试 -&gt; 分析… 用例图：描述用户所看到的系统的功能行为，用例图从用户的角度来表示系统的功能，用例是系统中的一个功能单元（静态视图） 录音机用例图 类图：描述系统的静态结构（对象，属性，联系），类图表示系统的结构 序列图：描述系统对象之间的动态行为，序列图将系统的行为表示为不同对象之间的消息交互。当执行一个用例行为时，顺序图中的每条消息对应了一个类操作或引起状态转换的触发事件 。综合考虑用例图中参与者和类图中对象的关系 状态图：描述单个对象的动态行为，一个类对象所可能经历的所有历程的模型图。状态图由对象的各个状态和连接这些状态的转换组成 活动图：状态图的一个变体，用来描述执行算法的工作流程中涉及的活动，活动图描述了一组顺序的或并发的活动 UML的主要特征是支持有限状态机。状态图的两个基本概念是状态和转换。 状态图​ UML中定义了四种事件： SignalEvent：与信号相关的事件。 ​ Signal是一个异步通信的规范，所以SignalEvent是一个与异步接收信号相关的事件。 CallEvent：与调用相关联的事件。 ​ Call是一个同步通信的规范，所以CallEvent允许一个对象直接调用其中一个方法来影响另一个对象的状态。 TimeEvent：与时间流逝相关的事件，通常用tm（\\）或after（\\）表示。 几乎所有的TimeEvents都是相对的时间。也就是说，它们指定事件将在对象处于指定状态至少\\时间单位后发生。 如果对象在超时之前离开该状态，则与该持续时间关联的逻辑计时器将消失，而不会创建超时事件 ChangeEvent：与属性的值更改关联的事件。 它很少用在软件应用程序中。然而，当一个状态属性被内存映射到一个硬件上时，它可以用来指示内存地址改变的值 状态的特点： ​ 可以在状态图上捕获行为的对象被认为是被动的。 ​ 这样一个对象的行为空间被分解为存在的不相交和不相交的条件，称为状态。 ​ 转换是对导致状态改变的事件的响应。该对象可以在接收到事件（尽管不进行转换）或者进行转换时执行动作，进入或退出状态。 转换（transition） ​ 转换是从起始状态开始并在目标状态结束的弧。 ​ 转换通常具有命名的事件触发器，可选地随后是执行转换时执行的动作（即可执行语句或操作）。 ​ 过渡事件签名的格式为： ​ event-name ‘(‘ parameter-list ‘)’ ‘[‘ guard-expression ‘]’ ‘/‘ action-list ​ 注：事件可以指定形式参数列表，这意味着事件可以携带实际的参数。 ​ digit(key: keyType)/ show(key) ​ 约束（Guard）和行为执行顺序（Execution Order）： ​ guard表达式是一个布尔表达式，包含在方括号中，必须计算为true或false。 ​ 行动的执行顺序很重要，基本规则是退出-&gt;转换-&gt;进入（exit-transition-entry）。 ​ 也就是说，先行状态的退出动作首先执行，然后是转换动作，随后是后续状态的进入动作。 序列图含 Alternatives, Branches, Options, and Loops 时间自动机（Timed automata 建模与验证）​ 时间自动机是实时系统建模与验证的理论。 具有相同目的的其他形式的例子还有时间Petri网（timed Petri Nets）， ​ 时间过程代数（timed process algebras）和实时逻辑（real time logics） ​ 公平地说，以时间自动机作为输入语言的核心开发的几种模型检查器是理论应用和发展的动力。 时间自动机本质上是一个用实值变量（时间系统）进行扩展的有限自动机（包含一组有限节点和一组有限带有标记的边的图） 变量（variables）对系统中的逻辑时钟进行建模，在系统启动时用零初始化，然后以相同的速率同步增加 时钟约束（clock constraints），即边上用于限制自动机行为的约束（Guard） 当时钟值满足在边上标记约束（Guard）时，边表示的转换（transition）就可以发生。 当进行转换时，时钟可能被重置为零。 实验时间自动机工具UPPAAL 同步通信（synchronous）通过使用输入输出行为的握手同步（hand-shake synchronization）来实现 异步通信（asynchronous）使用共享变量（shared variables）来实现 ​ 为了对握手同步进行建模，字母 ∑ 定义为包括：输入动作 a？，输出动作a！，内部行为 ‘T’ 三次实验内容回顾","categories":[{"name":"CS","slug":"CS","permalink":"http://vergessenwang.github.io/categories/CS/"}],"tags":[]},{"title":"在ModelArts上用Caffe-SSD进行目标检测模型训练","slug":"在ModelArts上用Caffe-SSD进行目标检测模型训练","date":"2019-12-27T14:22:10.000Z","updated":"2019-12-27T14:23:50.534Z","comments":true,"path":"posts/DL/2019-12-27-在ModelArts上用Caffe-SSD进行目标检测模型训练.html","link":"","permalink":"http://vergessenwang.github.io/posts/DL/2019-12-27-在ModelArts上用Caffe-SSD进行目标检测模型训练.html","excerpt":"本着不再当队长的原则，这学期的深度学习实践课进了别的同学的队伍，果然，当普通队员的感觉就是……真香！ 今天服从组织安排，用华为云的ModelArts尝试跑一下Caffe框架下的SSD模型来进行目标检测。队友说，让我尽量试试，还给我发了一大堆文档，可以说是相当耐心了。认真学习。 首先是在ModelArts中创建一个GPU实例并编译好Caffe-SSD, 这里队友实在看不下去我编译时的弱智操作，帮我完成了这一步。。 准备数据集虽然模拟电梯环境采集了一些数据，但是明显有很多重复的。 所以只能在寻找另外的方法，而网上很少有所需的数据，于是打算自己爬图片做标注后用于训练。 获取图片爬取谷歌图片 打算用googleimagesdownload工具 由于图片数量较多，还需要安装chromedriver, 我的谷歌版本时版本 78.0.3904.97，下载对应版本, 放在图片存放路径的文件夹中，切换到目录运行命令： googleimagesdownload -k &quot;电动车&quot; -l 300 --chromedriver=&quot;./chromedriver 然后就开始自动下载啦~~~","text":"本着不再当队长的原则，这学期的深度学习实践课进了别的同学的队伍，果然，当普通队员的感觉就是……真香！ 今天服从组织安排，用华为云的ModelArts尝试跑一下Caffe框架下的SSD模型来进行目标检测。队友说，让我尽量试试，还给我发了一大堆文档，可以说是相当耐心了。认真学习。 首先是在ModelArts中创建一个GPU实例并编译好Caffe-SSD, 这里队友实在看不下去我编译时的弱智操作，帮我完成了这一步。。 准备数据集虽然模拟电梯环境采集了一些数据，但是明显有很多重复的。 所以只能在寻找另外的方法，而网上很少有所需的数据，于是打算自己爬图片做标注后用于训练。 获取图片爬取谷歌图片 打算用googleimagesdownload工具 由于图片数量较多，还需要安装chromedriver, 我的谷歌版本时版本 78.0.3904.97，下载对应版本, 放在图片存放路径的文件夹中，切换到目录运行命令： googleimagesdownload -k &quot;电动车&quot; -l 300 --chromedriver=&quot;./chromedriver 然后就开始自动下载啦~~~ 图片预处理筛选出符合要求的图片后，接下来进行数据增强。一方面是为了增加样本量，另一方面能够提高模型的泛化能力。 由于大小不一，先统一转为500*500 1234567891011121314from PIL import Imageimport os.pathimport globdef convertjpg(jpgfile,outdir,width=500,height=500): img=Image.open(jpgfile) try: new_img=img.resize((width,height),Image.BILINEAR) new_img.save(os.path.join(outdir,os.path.basename(jpgfile))) except Exception as e: print(e)for jpgfile in glob.glob(\"C:/Users/18771/Desktop/emotor_1/*.jpg\"): convertjpg(jpgfile,\"C:/Users/18771/Desktop/emotor_2\") 处理完其实已经没多少数据了，应该多爬一点的.. 接下来可以用labelImg标注数据了，我已经是个熟练工了。。感觉触摸板都要摸烂了。。 生成LMDB数据集将数据集划分下训练集、测试集和验证集 按VOC标准建好目录结构，把数据传到ModelArts上面 ImageSets里Main文件夹，用到4个文件： train.txt 是用来训练的图片文件的文件名列表 val.txt是用来验证的图片文件的文件名列表 trianval.txt是用来训练和验证的图片文件的文件名列表 test.txt 是用来测试的图片文件的文件名列表 用脚本生成训练集和测试集， 12345678910111213141516171819202122232425262728293031323334353637import osimport randomtrainval_percent = 0.8 # 修改训练集与测试集比例，此时train:test=8:2train_percent = 0.7 # train 占 trainval 中的 0.7 ， 后面只用 trainval，所以这里这个数值不重要fdir = '/home/ma-user/work/caffe/data/VOC1227/VOCdevkit/VOC1227/ImagesSets/Main/' # 修改对应路径xmlfilepath = '/home/ma-user/work/caffe/data/VOC1227/VOCdevkit/VOC1227/Annotations/label' # 修改对应路径txtsavepath = fdirtotal_xml = os.listdir(xmlfilepath)num=len(total_xml)list=range(num)tv=int(num*trainval_percent)tr=int(tv*train_percent)trainval= random.sample(list,tv)train=random.sample(trainval,tr)ftrainval = open(fdir + 'trainval.txt', 'w')ftest = open(fdir + 'test.txt', 'w')ftrain = open(fdir + 'train.txt', 'w')fval = open(fdir + 'val.txt', 'w')for i in list: name=total_xml[i][:-4]+'\\n' if i in trainval: ftrainval.write(name) if i in train: ftrain.write(name) else: fval.write(name) else: ftest.write(name)ftrainval.close()ftrain.close()fval.close()ftest .close() 接下来引用分好的dataset建立list文件，改下create_list.sh中的路径, 这个文件是从VOC0712中拷贝过来的，记得注释掉[[ \\$dataset == “test” &amp;&amp; \\$name == “VOC1227” ]] 不然无法生成test 文件内容详解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/bin/bashroot_dir=/home/ma-user/work/caffe/data/VOC1227/VOCdevkitsub_dir=ImagesSets/Mainbash_dir=\"$(cd \"$(dirname \"$&#123;BASH_SOURCE[0]&#125;\")\" &amp;&amp; pwd)\"for dataset in trainval test do dst_file=$bash_dir/$dataset.txt if [ -f $dst_file ] then rm -f $dst_file fi for name in VOC1227 do //if [[ $dataset == \"test\" &amp;&amp; $name == \"VOC1227\" ]] //then //continue //fi echo \"Create list for $name $dataset...\" dataset_file=$root_dir/$name/$sub_dir/$dataset.txt img_file=$bash_dir/$dataset\"_img.txt\" cp $dataset_file $img_file sed -i \"s/^/$name\\/JPEGImages\\/image\\//g\" $img_file sed -i \"s/$/.jpg/g\" $img_file label_file=$bash_dir/$dataset\"_label.txt\" cp $dataset_file $label_file sed -i \"s/^/$name\\/Annotations\\/label\\//g\" $label_file sed -i \"s/$/.xml/g\" $label_file paste -d' ' $img_file $label_file &gt;&gt; $dst_file rm -f $label_file rm -f $img_file done # Generate image name and size infomation. if [ $dataset == \"test\" ] then $bash_dir/../../build/tools/get_image_size $root_dir $dst_file $bash_dir/$dataset\"_name_size.txt\" fi # Shuffle trainval file. if [ $dataset == \"trainval\" ] then rand_file=$dst_file.random cat $dst_file | perl -MList::Util=shuffle -e 'print shuffle(&lt;STDIN&gt;);' &gt; $rand_file mv $rand_file $dst_file fidone 接下来根据建好的list文件，生成lmdb文件用于之后的训练 需要export一下openblas的路径 1234export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/ma-user/anaconda2/libsource ~/.bashrcecho &apos;export LD_LIBRARY_PATH=/home/ma-user/work/OpenBLAS:$LD_LIBRARY_PATH&apos; &gt;&gt; ~/.bashrcsource ~/.bashrc 然后调用convert_annoset生成lmdb文件 12345/home/ma-user/work/caffe/build/tools/convert_annoset --anno_type=detection --encode_type=jpg --encoded=true --shuffle=true \\--label_map_file=/home/ma-user/work/caffe/data/VOC1227/labelmap_voc.prototxt \\/home/ma-user/work/caffe/data/VOC1227/VOCdevkit/ \\/home/ma-user/work/caffe/data/VOC1227/trainval.txt \\/home/ma-user/work/caffe/data/emotor_lmdb1227 12345/home/ma-user/work/caffe/build/tools/convert_annoset --anno_type=detection --encode_type=jpg --encoded=true --shuffle=true \\--label_map_file=/home/ma-user/work/caffe/data/VOC1227/labelmap_voc.prototxt \\/home/ma-user/work/caffe/data/VOC1227/VOCdevkit/ \\/home/ma-user/work/caffe/data/VOC1227/test.txt \\/home/ma-user/work/caffe/data/emotor_lmdb1227test 训练模型修改模型中的相应参数，开跑。。 123/home/ma-user/work/caffe/build/tools/caffe train \\-solver=/home/ma-user/work/caffe/MobileNet-SSD/solver_train.prototxt \\--weights=/home/ma-user/work/caffe/MobileNet-SSD/mobilenet_iter_73000.caffemodel 美滋滋地开跑了，结果loss全是0？？？？ 还得重新看数据集有什么问题。。弄了一天，人都傻了。。 后来反应过来是文件名写错了。 当房间烧成了废墟 我看见了更皎洁的月光我看见了所有赐予我的幸福所有转瞬即逝的欢乐我看见了我违背的誓言不曾释怀的痛楚未能痊愈的伤痛压抑住的泪水我看见了我不曾哀悼的死亡没有回应的祈祷未曾开启的门 和始终开放的门我看见了被我遗弃的爱人未能实践的梦想我看见了所有给予我却不能接受的一切我看见了我期盼的却未能收到的来信我看见了所有应该发生但从未发生的一切——《尘与雪》","categories":[{"name":"DL","slug":"DL","permalink":"http://vergessenwang.github.io/categories/DL/"}],"tags":[{"name":"Caffe","slug":"Caffe","permalink":"http://vergessenwang.github.io/tags/Caffe/"},{"name":"SSD","slug":"SSD","permalink":"http://vergessenwang.github.io/tags/SSD/"},{"name":"ModelArts","slug":"ModelArts","permalink":"http://vergessenwang.github.io/tags/ModelArts/"}]},{"title":"基于Caffe的Mnist数据集手写识别","slug":"基于Caffe的Mnist数据集手写识别","date":"2019-12-23T14:33:01.000Z","updated":"2019-12-23T14:34:09.250Z","comments":true,"path":"posts/DL/2019-12-23-基于Caffe的Mnist数据集手写识别.html","link":"","permalink":"http://vergessenwang.github.io/posts/DL/2019-12-23-基于Caffe的Mnist数据集手写识别.html","excerpt":"操作指南——此文已非常之详细 注意执行convert-mnist-data是在 Build\\x64\\Release\\ 目录下，而不是存放数据的目录下, 所以用绝对路径定位到该exe文件 训练集脚本： 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\convert_mnist_data.exe train-images.idx3-ubyte train-labels.idx1-ubyte mnist_train_lmdb pause 测试集脚本： 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\convert_mnist_data.exe t10k-images.idx3-ubyte t10k-labels.idx1-ubyte mnist_test_lmdb pause 把\\examples\\mnist下的文件 lenet_solver.prototxt中的训练平台改为CPU lenet_train_test.prototxt 是要采用的训练模型的具体实现。","text":"操作指南——此文已非常之详细 注意执行convert-mnist-data是在 Build\\x64\\Release\\ 目录下，而不是存放数据的目录下, 所以用绝对路径定位到该exe文件 训练集脚本： 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\convert_mnist_data.exe train-images.idx3-ubyte train-labels.idx1-ubyte mnist_train_lmdb pause 测试集脚本： 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\convert_mnist_data.exe t10k-images.idx3-ubyte t10k-labels.idx1-ubyte mnist_test_lmdb pause 把\\examples\\mnist下的文件 lenet_solver.prototxt中的训练平台改为CPU lenet_train_test.prototxt 是要采用的训练模型的具体实现。 然而，开始训练的时候，魔鬼又出现了。。ImportError: No module named _caffe 明明之前import成功了，后来找到一个解决方案 ：把Build\\x64\\Release\\pycaffe\\caffe目录下的所有文件复制到caffe-windows\\python\\caffe目录中，也就是把原文件夹中的一部分文件用编译完成的新文件替换。 用.\\draw_net.py可以查看训练网络的可视化。 在caffe根目录下创建训练运行脚本 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\caffe.exe train --solver=examples/mnist/lenet_solver.prototxt pause 接下来参考这篇博客 最终模型存储在lenet_iter_10000 测试脚本 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\caffe.exe test --model examples/mnist/lenet_train_test.prototxt -weights=examples/mnist/lenet_iter_10000.caffemodelpause 测试结果 12I1219 00:44:56.921839 6236 caffe.cpp:331] accuracy = 0.9854I1219 00:44:56.921839 6236 caffe.cpp:331] loss = 0.0447507 (* 1 = 0.0447507 loss) 用图片进行测试,参考 脚本生成均值文件mean.binaryproto 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\compute_image_mean mnist_train_lmdb mean.binaryproto pause 准备好测试图片，png格式 标签文件lable.txt 图片测试脚本 12C:\\Users\\18771\\Desktop\\caffenew\\caffe-windows\\Build\\x64\\Release\\classification lenet.prototxt ./lenet/_iter_10000.caffemodel mean.binaryproto label.txt 8.pngpause 但是结果有问题，应该是图片格式的原因。 一下步要学习将图片转为Lmdb格式","categories":[{"name":"DL","slug":"DL","permalink":"http://vergessenwang.github.io/categories/DL/"}],"tags":[{"name":"Caffe","slug":"Caffe","permalink":"http://vergessenwang.github.io/tags/Caffe/"}]},{"title":"困兽的悲剧","slug":"困兽的悲剧","date":"2019-12-11T13:45:37.000Z","updated":"2019-12-11T14:09:23.840Z","comments":true,"path":"posts/poetry/2019-12-11-困兽的悲剧.html","link":"","permalink":"http://vergessenwang.github.io/posts/poetry/2019-12-11-困兽的悲剧.html","excerpt":"","text":"泥潭中心的狮子挣扎只能加速下沉索性不动了冬雪盖过来浑然一体的纯洁和寂静如此安心再少一点阴冷的重压带来的窒息吧它呓语着闭眼睡去第一缕春光照上它长满青苔的额头时一只火红的雀鸟飞下歪着头细看了一会啁啾细叹真是一尊栩栩如生的石狮啊风穿心而过在耳后永恒呼嚎（突然想起前几天看过的电影里那个侦探作家的一部书名，有感而发）","categories":[{"name":"poetry","slug":"poetry","permalink":"http://vergessenwang.github.io/categories/poetry/"}],"tags":[]},{"title":"AVL树、红黑树和伸展树","slug":"AVL树、红黑树和伸展树","date":"2019-12-10T04:23:05.000Z","updated":"2020-03-31T06:39:28.739Z","comments":true,"path":"posts/DataStructure/2019-12-10-AVL树、红黑树和伸展树.html","link":"","permalink":"http://vergessenwang.github.io/posts/DataStructure/2019-12-10-AVL树、红黑树和伸展树.html","excerpt":"二叉查找树二叉查找树的特征(递归) ——或者是一棵空树或者是具有如下特性的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于根结点的值； 它的左、右子树也分别是二叉排序树。 中序遍历二叉排序树可得到一个关键字的有序序列。 在一般情况下，查找和插入的时间复杂度为logN, 但是在极端情况下会退化为链表，此时查找变为顺序遍历，失去了排序树的意义。——构造的二叉查找树的形状依赖于数据项，且依赖于它们加载的顺序 二叉查找树平衡性很差（即失衡）时，可用AVL树、红黑树和伸展树进行改进。其中AVL树和红黑树是高度平衡的，伸展树是加权平衡的(将常用的数据项放在树中接近根部的位置)","text":"二叉查找树二叉查找树的特征(递归) ——或者是一棵空树或者是具有如下特性的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于根结点的值； 它的左、右子树也分别是二叉排序树。 中序遍历二叉排序树可得到一个关键字的有序序列。 在一般情况下，查找和插入的时间复杂度为logN, 但是在极端情况下会退化为链表，此时查找变为顺序遍历，失去了排序树的意义。——构造的二叉查找树的形状依赖于数据项，且依赖于它们加载的顺序 二叉查找树平衡性很差（即失衡）时，可用AVL树、红黑树和伸展树进行改进。其中AVL树和红黑树是高度平衡的，伸展树是加权平衡的(将常用的数据项放在树中接近根部的位置) AVL树定义(递归)：或者是一棵空树，或者是具有如下特性的二叉查找树 左子树和右子树的高度最多相差1； 它的左、右子树也分别是平衡二叉树。 如何调整节点以维持高度的平衡？ Step1：找到不平衡（即左右子树高度差距大于1）的最小子树的根节点（记为A） Step2：依据新插入节点与节点A的相对位置，进行相应处理。 LL型失衡: 在A结点的左孩子的左子树上插入结点,导致A结点失去平衡.——单向右旋平衡处理 RR型失衡: 单向左旋平衡处理 LR型失衡: 双向旋转先左后右平衡处理型。先把下段左旋转换为LL型失衡，再将上段右旋解决LL型失衡 RL型失衡: 双向旋转先右后左平衡处理型。先把下段右旋转换为RR型失衡，再将上段左旋解决RR型失衡 为修复失衡所进行的旋转操作可能需要对插入和删除期间所采用的访问路径执行向后遍历(当需要多次旋转时）——实现起来比较麻烦？ 红黑树红黑树是满足下列条件的二叉查找树： 每个节点都带有红色或黑色。节点的颜色由以下规则确定： 根节点是黑色的。 所有叶节点都是黑色的。 在沿着从根出发的任何路径上都不允许出现两个连续的红色节点，即：“红色”结点的两个子结点都是“黑色”的。 从任一节点到其每个子孙叶子节点的所有简单路径都包含相同数目的黑色节点（简称黑色高度） 节点X的黑色高度：从节点X到其子孙叶子节点的简单路径中的黑色链的数量。 不包括 X 结点本身，包括叶结点 外部结点的阶是零； 红黑树的黑色高度：根节点的黑色高度（称为：根节点的阶） 阶为 k 的红黑树路径长度：最短是 k，最长是 2k ——实现平衡的原因 2-3-4树的二叉树的实现本质上就是红黑树——可利用颜色翻转和旋转来等价实现 两类基本操作： 颜色翻转 实质上为4-节点分裂 当某个结点的两个孩子结点都为红色时 将两个红色孩子结点和其黑色双亲结点的颜色翻转 旋转 出现右的红色链时；有连续两个红色链时 依据两个连续的红色链的形状，进行相应的旋转处理（类似AVL树的失衡旋转规则）；对于右的红色链，进行左旋处理 伸展树实现一种恒定重排的方式：每次访问树时，都使用旋转操作重排树，使得访问过的节点位于树的根部。 优点：最近使用的数据比未使用过的数据可更快的被访问——局部性原理,可以用于缓存 自底向上的伸展(更好理解)利用旋转，将访问的节点c搬根部。有三种基本操作： Case1：若访问的节点c没有祖父节点，则：直接在c与其父节点p之间进行旋转。 Case2：若访问的节点c，其父节点p，其祖父节点g三者之间的相关位置呈LL或RR型，则：先在p和g间旋转，再在p和c间旋转。（由上至下） Case3：若访问的节点，其父节点，其祖父节点三者之间的相关位置呈LR或RL型，则：先在c和p间旋转，再在c和g间旋转。（由下至上） 自顶向下的伸展首先确定从根到访问节点的路径，然后依据路径的形状，进行“分裂”操作。最后，以目标节点作为根进行片断的重组。 每次分裂操作会将当前树分为左，中，右三个片断。左片断为中间片断的前驱，右片断为中间片断的后继；其中，前驱、后继是指中序遍历顺序。左，右片断分别插入到左右存储树中。 左连接点：指左存储树中插入新片断的位置，指向左存储树中最右下角的节点。 右连接点：右存储树中插入新片断的位置，指向右存储树中最左下角的节点。","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://vergessenwang.github.io/categories/DataStructure/"}],"tags":[{"name":"红黑树","slug":"红黑树","permalink":"http://vergessenwang.github.io/tags/红黑树/"},{"name":"AVL树","slug":"AVL树","permalink":"http://vergessenwang.github.io/tags/AVL树/"}]},{"title":"VS2017+Miniconda2编译Caffe","slug":"VS2017-Miniconda2编译Caffe","date":"2019-12-09T04:51:21.000Z","updated":"2019-12-09T04:54:06.103Z","comments":true,"path":"posts/DL/2019-12-09-VS2017-Miniconda2编译Caffe.html","link":"","permalink":"http://vergessenwang.github.io/posts/DL/2019-12-09-VS2017-Miniconda2编译Caffe.html","excerpt":"捣腾了一晚上的caffe。。环境配置什么的，真的是很容易上头。 官方安装文档 以下为踩坑过程。 【如果你的VS是2017版本，请直接看下一部分】 首先下载windows适用的caffe版本 在下载好的文件中 Copy .\\windows\\CommonSettings.props.example to .\\windows\\CommonSettings.props 打开该配置文件，按自己的电脑情况对GPU支持，CuDNN及Python支持进行配置。由于我的破本本没有独显，所以只能用CPU了。。 12&lt;CpuOnlyBuild&gt;true&lt;/CpuOnlyBuild&gt;&lt;UseCuDNN&gt;false&lt;/UseCuDNN&gt; 使用VS打开sln 文件，我的是VS2017版本而官网要求的是13或15版本，暂时不知后面将会遇到什么 问题。。 对项目的错误检查做一下设置，VS的报错有多烦人。。用过的都知道。。libcaffe项目→属性→C/C++→常规→将警告视为错误 设置为否。如果不设置的话在编译boost库的时候会由于文字编码的警告而报错。选择编译环境为Release，x64","text":"捣腾了一晚上的caffe。。环境配置什么的，真的是很容易上头。 官方安装文档 以下为踩坑过程。 【如果你的VS是2017版本，请直接看下一部分】 首先下载windows适用的caffe版本 在下载好的文件中 Copy .\\windows\\CommonSettings.props.example to .\\windows\\CommonSettings.props 打开该配置文件，按自己的电脑情况对GPU支持，CuDNN及Python支持进行配置。由于我的破本本没有独显，所以只能用CPU了。。 12&lt;CpuOnlyBuild&gt;true&lt;/CpuOnlyBuild&gt;&lt;UseCuDNN&gt;false&lt;/UseCuDNN&gt; 使用VS打开sln 文件，我的是VS2017版本而官网要求的是13或15版本，暂时不知后面将会遇到什么 问题。。 对项目的错误检查做一下设置，VS的报错有多烦人。。用过的都知道。。libcaffe项目→属性→C/C++→常规→将警告视为错误 设置为否。如果不设置的话在编译boost库的时候会由于文字编码的警告而报错。选择编译环境为Release，x64 在libcaffe上右键生成，进行编译。有点小激动，究竟能不能成功呢？。。 有惊无险 ，虽然全程都在 Unknown compiler version - please run the configure tests and report the results 接着再编译caffe，果然真正的快乐是无法持续的。。 报错：fatal error LNK1104: 无法打开文件“libboost_date_time-vc140-mt-gd-1_59.lib 应该是VS版本的问题了。 搜索了一圈解决方案，都是要改 build_win.cmd 文件的，而这个windows版本并没有这个文件，正如一开始说，必须使用 VS2013或VS2015 而我，是绝对不想再重新安装一个VS的，别问我为什么。。所以只能，重新来过。。 本部分参考文章 找到另一个windows可用的版本，源码地址 安装Cmake 教程 比较重要的是Python的配置，miniconda相关操作 在安装了miniconda之后，以管理员方式运行cmd 12conda install --yes numpy scipy matplotlib scikit-image pippip install protobuf 在第二条命令时，遇到一大串红字。 1234567891011121314151617181920212223242526272829303132333435363738Traceback (most recent call last): File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\cli\\base_command.py\", line 153, in _main status = self.run(options, args) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\commands\\install.py\", line 382, in run resolver.resolve(requirement_set) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\legacy_resolve.py\", line 201, in resolve self._resolve_one(requirement_set, req) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\legacy_resolve.py\", line 365, in _resolve_one abstract_dist = self._get_abstract_dist_for(req_to_install) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\legacy_resolve.py\", line 313, in _get_abstract_dist_for req, self.session, self.finder, self.require_hashes File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\operations\\prepare.py\", line 194, in prepare_linked_requirement progress_bar=self.progress_bar File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\download.py\", line 465, in unpack_url progress_bar=progress_bar File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\download.py\", line 316, in unpack_http_url progress_bar) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\download.py\", line 551, in _download_http_url _download_url(resp, link, content_file, hashes, progress_bar) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\download.py\", line 253, in _download_url hashes.check_against_chunks(downloaded_chunks) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\utils\\hashes.py\", line 80, in check_against_chunks for chunk in chunks: File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\download.py\", line 223, in written_chunks for chunk in chunks: File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\utils\\ui.py\", line 160, in iter for x in it: File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_internal\\download.py\", line 212, in resp_read decode_content=False): File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_vendor\\urllib3\\response.py\", line 564, in stream data = self.read(amt=amt, decode_content=decode_content) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_vendor\\urllib3\\response.py\", line 529, in read raise IncompleteRead(self._fp_bytes_read, self.length_remaining) File \"C:\\ProgramData\\Miniconda2\\lib\\contextlib.py\", line 35, in __exit__ self.gen.throw(type, value, traceback) File \"C:\\ProgramData\\Miniconda2\\lib\\site-packages\\pip\\_vendor\\urllib3\\response.py\", line 439, in _error_catcher raise ReadTimeoutError(self._pool, None, \"Read timed out.\")ReadTimeoutError: HTTPSConnectionPool(host='files.pythonhosted.org', port=443): Read timed out. pip show pip setuptools 查看pip版本是19.3.1 setuptools 是41.4.0 我怀疑是pip调用路径的问题，于是在用户环境变量中删除了本来安装的python3.5的路径 C:\\Users\\18771\\AppData\\Local\\Programs\\Python\\Python35\\Scripts\\ C:\\Users\\18771\\AppData\\Local\\Programs\\Python\\Python35\\ 重启一下，然后换用conda install protobuf命令，安装成功。 但是，为了少点坑，看了别人的博客写的，又多装了几个包 conda install --yes six pyyaml pydotplus graphviz 用VS打开sln, 重定解决方案为v141 接下来跟第一部分的操作一样，先不抱任何指望地编译libcaffe。。。 果然报错 ：无法打开包括文件: “pyconfig.h”: No such file or directory (编译源文件 ....\\src\\caffe\\layer_factory.cpp) 打开CommonSettings.props将 D:\\Anaconda3\\ 改为自己的python路径 C:\\ProgramData\\Miniconda2 编译成功。 再不抱任何指望地编译caffe。。。成功一个，失败一个 报错：fatal error LNK1181: 无法打开输入文件“cufft.lib” 打开 CommonSettings.props 将&lt;CudaDependencies&gt;cufft.lib&lt;/CudaDependencies&gt; 改成 &lt;CudaDependencies&gt;&lt;/CudaDependencies&gt; 再次尝试，报错 LINK : fatal error LNK1104: 无法打开文件“libboost_python-vc141-mt-1_65_1.lib” 这应该是VS版本的问题了，vc141就是2017的， 把 thirdparty\\Boost\\lib64-msvc-14.0 中所有的140改成141 试一下，caffe 可以编译了。 然后右键重新生成解决方案，开始全部编译。 终于 ========== 全部重新生成: 成功 16 个，失败 0 个，跳过 0 个 ========== 所有编译成功和运行需要的dll文件都会存储在Build\\x64\\Release 下 激动哭了。。 感谢前面的踩坑大佬 验证编译结果。尝试在python中调用 打开anaconda的命令行，进入caffe的examples目录，运行jupyter notebook 在打开的notebook中打开caffe自带的例子 00-calssification.ipynb 运行后 报错：ModuleNotFoundError: No module named ‘caffe._caffe’ 根据源码中readme提示操作 set PythonPath environment variable to point to &lt;caffe_root&gt;\\Build\\x64\\Release\\pycaffe, or copy folder &lt;caffe_root&gt;\\Build\\x64\\Release\\pycaffe\\caffe under &lt;python_root&gt;\\lib\\site-packages. 我选择了第二种，copy到了C:\\Users\\18771\\Anaconda3\\Lib\\site-packages中 重新运行，还是不行。突然意识到是不是python版本不一样，因为编译用的是miniconda用的是2.7，而anaconda默认的是3.7 于是copy到了C:\\ProgramData\\Miniconda2\\Lib\\site-packages中(顺带在caffe27的虚拟环境中也copy了一份..)，直接命令行运行python，import caffe 由于我比较喜欢在虚拟环境中跑程序，于是再尝试在caffe27的虚拟环境下运行，先安装numpy、 scikit-image 、protobuf包，再进入python命令行，输入import caffe, 同样运行成功。 环境配置，总算告一段落了。。","categories":[{"name":"DL","slug":"DL","permalink":"http://vergessenwang.github.io/categories/DL/"}],"tags":[{"name":"Caffe","slug":"Caffe","permalink":"http://vergessenwang.github.io/tags/Caffe/"}]},{"title":"沉默为敌","slug":"沉默为敌","date":"2019-12-03T12:45:45.000Z","updated":"2019-12-03T14:19:50.783Z","comments":true,"path":"posts/life/2019-12-03-沉默为敌.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2019-12-03-沉默为敌.html","excerpt":"辩论赛打输了，挺难受的。确实一开始就没对队友报太大希望，结果真的也没让我”失望”。 安排的一辩，上去东拉西扯3分钟，我在后面听了都觉得尴尬，不知所云，然后留给我的二辩时间不够，稿子念了不到三分之二。一辩在自由辩论的环节，也没有回答任何问题。我的室友，回答了一个问题，我已经很满足了。还有一个女生，从头到尾，一言不发。就我跟师兄在那，尽力去反驳对方观点。我觉得好累啊。怎么能这样？ 最后53:57输了。我原本对这个辩题信心十足的，可是对于队友的表现，我真的非常非常失望。 结束后一辩过来跟我道歉，我跟他说：没事。看着他愧疚的样子，我也说不出别的话来。 早两周让他们准备好反方论点，以及反驳的例子，结果昨天晚上才发来材料，短短几段。我就知道要凉了。 结束了，看着我的三页材料，特意买的一本书，觉得好气啊，又无处发作。很想问我是来请你们看戏的吗？转念一想，算了算了，一场辩论赛而已，也不是八强淘汰课。可能就是，只有我和师兄俩看得比较重要吧，其他三人都觉得无所谓。 长叹一声，没办法，人只能控制自己的行为，而无法控制别人的态度。 所以还是只能万事准备好PlanB。","text":"辩论赛打输了，挺难受的。确实一开始就没对队友报太大希望，结果真的也没让我”失望”。 安排的一辩，上去东拉西扯3分钟，我在后面听了都觉得尴尬，不知所云，然后留给我的二辩时间不够，稿子念了不到三分之二。一辩在自由辩论的环节，也没有回答任何问题。我的室友，回答了一个问题，我已经很满足了。还有一个女生，从头到尾，一言不发。就我跟师兄在那，尽力去反驳对方观点。我觉得好累啊。怎么能这样？ 最后53:57输了。我原本对这个辩题信心十足的，可是对于队友的表现，我真的非常非常失望。 结束后一辩过来跟我道歉，我跟他说：没事。看着他愧疚的样子，我也说不出别的话来。 早两周让他们准备好反方论点，以及反驳的例子，结果昨天晚上才发来材料，短短几段。我就知道要凉了。 结束了，看着我的三页材料，特意买的一本书，觉得好气啊，又无处发作。很想问我是来请你们看戏的吗？转念一想，算了算了，一场辩论赛而已，也不是八强淘汰课。可能就是，只有我和师兄俩看得比较重要吧，其他三人都觉得无所谓。 长叹一声，没办法，人只能控制自己的行为，而无法控制别人的态度。 所以还是只能万事准备好PlanB。 接下来反思一下自己：首先不够镇定，念稿子的时候手有点抖。。其次，临场反应能力还不够，有几个问题一下子没有想到反驳的点，还有就是只敢看对方，不敢看观众，至于其他的，都是超常发挥了。。 之后跟师兄交流，他说感觉我们这一届普遍比上一届沉默，微信大群都没有人说话，让他觉得有点可怕。不像他们的群，非常活跃。我一开始也认为是不是本科计算机和软件的同学都是这样，也默认了他们话都比较少。所以一开始也理解他们的性格，尝试带下节奏，就让他们好好准备，到时候能说一点是一点了。但万万没想到，会是这样的结果。 这次事件，可以说彻底改变了我对沉默群体的看法。 有人说，当你特别讨厌一种特质的时候，在你自己的身上，一定也有这个问题。确实，我承认我内向，但也不是不分场合。 我终于知道为什么人们更喜欢外向的人了，内向给人的感觉不仅是难当大任，而且是当他们因性格问题无法做好一些事情的时候，你根本无从责备，那种憋屈，真的太难受了。 纵使你有万般学识，无法表达，别人永远看不到你的内在。人们只会看到你在这件事情上失败了，并由此怀疑你是否真的有责任心和能力。虽然以前老爸也这样教育过我，但我都只是当耳边风。 感谢这场辩论赛，让我真正认识到内向与沉默的坏处。 从此以后，再不想列沉默之席。再不想交内向之友。 不快的事情，写完就忘掉吧。","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[{"name":"以人为镜","slug":"以人为镜","permalink":"http://vergessenwang.github.io/tags/以人为镜/"}]},{"title":"空心","slug":"空心","date":"2019-12-02T02:01:46.000Z","updated":"2019-12-02T07:27:11.207Z","comments":true,"path":"posts/life/2019-12-02-空心.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2019-12-02-空心.html","excerpt":"认真准备了两天系统建模的期中考试，结果简单地一匹。不过总算有时间清空一下脑子，想点别的东西了。 回顾这三个月，真快，最大的感受莫过于：东西没怎么学到，各种群倒是加了一大堆。。 人把自己置身忙碌之中，有一种麻木的充实，但是丧失了真实，你的青春不过也只有这些日子。 没错了，是被各种deadline推着走的。 看系统建模的PPT时，我注意到下面的脚注写了一个：2003 。 真可笑，十几年前的东西，我学这些究竟有什么意义？ 想想自己的时间都去了哪里？上课，简单的不想听，难的跟不上…；写作业，磨磨唧唧；写实验，全靠悟性；看工程实践的东西，理论弄了一大堆，真正要开始做了，又觉得前面的工作跟本没有抓住核心；确定了自己的方向，而没有对应的计划；说着要提高编程能力，然而跟我一年前刚拿起数据结构开始看的时候根本没有什么区别…所以，我究竟在干什么…？ 还有不分主次，不求甚解的恶习。总是把简单的先斗志昂扬地做完了，剩下看不懂的困难的一直拖一直拖，最后虎头蛇尾。 赵老师在高网考试完，同学们纷纷吐槽题目太难时曾说： 工作以后，大多数人才会发现考试、读书都是相对简单的，因为都是在跟随学习。难的是有些工作，有些设计，你首先得先想出来这是个什么性质的问题，什么范畴的问题，再去找参考。跟着别人做，或者做既定的工作很简单，自己独当一面时，才是真正的动脑筋。","text":"认真准备了两天系统建模的期中考试，结果简单地一匹。不过总算有时间清空一下脑子，想点别的东西了。 回顾这三个月，真快，最大的感受莫过于：东西没怎么学到，各种群倒是加了一大堆。。 人把自己置身忙碌之中，有一种麻木的充实，但是丧失了真实，你的青春不过也只有这些日子。 没错了，是被各种deadline推着走的。 看系统建模的PPT时，我注意到下面的脚注写了一个：2003 。 真可笑，十几年前的东西，我学这些究竟有什么意义？ 想想自己的时间都去了哪里？上课，简单的不想听，难的跟不上…；写作业，磨磨唧唧；写实验，全靠悟性；看工程实践的东西，理论弄了一大堆，真正要开始做了，又觉得前面的工作跟本没有抓住核心；确定了自己的方向，而没有对应的计划；说着要提高编程能力，然而跟我一年前刚拿起数据结构开始看的时候根本没有什么区别…所以，我究竟在干什么…？ 还有不分主次，不求甚解的恶习。总是把简单的先斗志昂扬地做完了，剩下看不懂的困难的一直拖一直拖，最后虎头蛇尾。 赵老师在高网考试完，同学们纷纷吐槽题目太难时曾说： 工作以后，大多数人才会发现考试、读书都是相对简单的，因为都是在跟随学习。难的是有些工作，有些设计，你首先得先想出来这是个什么性质的问题，什么范畴的问题，再去找参考。跟着别人做，或者做既定的工作很简单，自己独当一面时，才是真正的动脑筋。 可以说是一语点醒。我好像还是从前本科时候那种节奏和思维方式，殊不知工科是有极大不同的，你一个点没有理解到位，后面的就都是臆想。不像商科，正着反着说两句，怎么也能自圆其说。 我曾觉得有确定性的东西，更值得付出精力，现在才发现，你得深入到了一定的程度，才能获得这种确定性。或者换句话说，最本质的东西，从来不是简简单单就能看透的。 然而，其实这些都不是真正的问题。 真正的问题，是那种时时席卷而来的虚无感，淹没了一切的意义。 我好像从来没有很执着于什么东西，初时是靠的热情，后来靠惯性，能做得下去自然是好事，不想做了也可以轻易的放弃。 我从没有感觉过于淡漠是什么问题，或者说，只是因为我从来没有正视过它。 在知乎盲目搜了一下，得知一个词：感情淡漠症。 填了一个心理测试，重度，呵呵。再百度一波应该就可以准备写遗书了。 不管怎么说，确实挺符合，但我拒绝认为这是病症，只是一种处事方式。 然后，突然想到一些事情。 大概还是在小学，爷爷下葬那天，人好多，我爸骑着自行车赶过来的时候，看见我在门口哭得好大声，然后抱着我一起哭。后来，他老用这件事来证明我小时候对人感情多么深厚。他永远不会知道，我那时哭，只是一种模仿。我知道在那样的环境下，应该那样做。 高中之前，与父母待过的时间并不长。后来他们总拿小时候那几件具有共同回忆的事情来反复咀嚼，这让我经常不耐。但我从来没有说过一句埋怨的话，到了嘴边全都咽回肚子。那种在时间的长河里无法弥补的缺陷，并不是他们的错，这正是让我最感无力的地方。 我意识到，我很少与人交心，并不是因为不信任，而是根本没有心，没有什么重要的东西放在心里，也就没什么好说的，偶尔郁闷又说不出原因，所幸的是过一段时间自动会好。 不表达感情，不是因为那个人对我不重要，而是根本不懂怎样才算发自内心。正因为重视，不能像以前那样全然靠模仿，我不能在这段感情里添上虚伪的东西，最终就什么也没做了。 就像晴子生日的时候，她要我给她写一段祝福的话。我可以浮夸的写很多，但觉得太假，最后就什么也没写。 我做过太多这样伤人的事情了。 感谢那些大浪淘沙，在感情的荒漠里留下来陪我的朋友。如果不是她们主动维持，真的是不用风吹就散了。 可是，明明我看一些电影，文学作品也会流泪；看到喜欢的东西也会开心；被误解也会一直生闷气，但为什么就是无法用最正常最自然地方式去表达情感呢？ 这种事情，还可以靠后天学会吗？ 哈哈，想不到我一个研究生了，还得补小学的课。 令人窒息，不写了。 在周围所有人的哭泣、哀叹、惊慌失措中，他努力装出一副悲伤和恐惧的样子——一想起自己这种丑陋的、罪孽深重的行为，他就心如刀割。 关于这件事，你完全没有感觉。对活下来的喜悦也好，对死者的哀悼也好，你完全没有。而对于这一点你怀有强烈的罪恶感。你知道自己的没有感觉，是现代社会伦理所不容许的事情。 他想，这时候是不是应该生气，应该激动。但是他只是想想，没有实际行动。因为他既没有生气，也没有激动。 ​ —— 《悲鸣传》西尾维新","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[{"name":"真实的自我","slug":"真实的自我","permalink":"http://vergessenwang.github.io/tags/真实的自我/"}]},{"title":"BM算法","slug":"BM算法","date":"2019-11-27T15:43:22.000Z","updated":"2019-11-27T15:44:38.402Z","comments":true,"path":"posts/Algorithm/2019-11-27-BM算法.html","link":"","permalink":"http://vergessenwang.github.io/posts/Algorithm/2019-11-27-BM算法.html","excerpt":"我表示看完这两个匹配算法，头顶有点凉… BM算法与KMP算法的主要区别在于：采用从右向左进行字符的匹配比较。 BM算法中的关键问题是， 如何确定目标串中的下一轮匹配的开始位置？即如何决定目标串中指针向右跳跃的距离？——利用P中的重复模式 和 T中的失配字符 假设出现失配时， T[i]≠P[k]。则 此时坏字符为x(=T[i])，好后缀P’=P[(k+1) … (len(P)-1)]（好后缀，是已匹配的部分字符串） 如何确定目标串中查找指针的移动距离dist[i]？ 采用2种启发式方法：无需检查目标串中的所有字符即可查找到是否存在匹配子串。 启发式方法#1： 跳过字符（“坏字符”规则） CharJump[x]：依据T中的坏字符x，计算T中查找指针的跳跃距离 启发式方法#2： 重复模式（“好后缀”规则） MatchJump[k] ： 依据P中的失配位置k， 计算T中查找指针的跳跃距离","text":"我表示看完这两个匹配算法，头顶有点凉… BM算法与KMP算法的主要区别在于：采用从右向左进行字符的匹配比较。 BM算法中的关键问题是， 如何确定目标串中的下一轮匹配的开始位置？即如何决定目标串中指针向右跳跃的距离？——利用P中的重复模式 和 T中的失配字符 假设出现失配时， T[i]≠P[k]。则 此时坏字符为x(=T[i])，好后缀P’=P[(k+1) … (len(P)-1)]（好后缀，是已匹配的部分字符串） 如何确定目标串中查找指针的移动距离dist[i]？ 采用2种启发式方法：无需检查目标串中的所有字符即可查找到是否存在匹配子串。 启发式方法#1： 跳过字符（“坏字符”规则） CharJump[x]：依据T中的坏字符x，计算T中查找指针的跳跃距离 启发式方法#2： 重复模式（“好后缀”规则） MatchJump[k] ： 依据P中的失配位置k， 计算T中查找指针的跳跃距离 基本步骤Step1：对于模式串P，计算CharJump[x]和MatchJump[k]。Step2: 将T与P的第一个字符对齐。Step3: T与P进行从右向左的逐字符比较 ，直至找到一个不匹配字符或者P中所有字符都匹配成功。Step4: 若出现失配，即存在T[i]≠P[k]，此时坏字符x=T[i]，好后缀P’=P[(k+1) … (len(P)-1)]。按如下规则计算 目标串T中查找指针向右移动dist[i]： 若此时T与P已有部分字符匹配（即存在“好后缀” ） 时， BM算法将采用2种启发式方法（即坏字符规则 和好后缀规则 ） ，计算dist[i]=max(CharJump[x],MatchJump[k])。 若不存在“好后缀”，则必定是在模式串P的最后一个字符处出现失配。此时应采用启发式方法#1： 跳过字符规则（“好后缀”规则），计算设置dist[i] =CharJump[x]。 Step5: 若(i+dist[i])≤Len(T)-1，则移动模式字符串P，使之与T[i+dist[i]]右对齐，重复Step3；否则，认为T中不存在与P匹配的子串，返回匹配失败。 坏字符的两种情况 如果模式串中没有出现坏字符，那么从字符x开始的Len(P)个字符显然不可能与P匹配成功， 使目标串中查找指针直接跳过Len(P) 个字符。 即将模式串整体挪到该字符之后 如果坏字符x在模式P中出现(假设P[j]==x)，则将目标串中查找指针移动CharJump[x]，使得下一轮匹配中将字符P[j]与坏字符x进行对齐。即该坏字符与模式串中最后出现该字符的位置对齐——因为是从右向左匹配 关键问题是计算CharJump[x] 若x在P中出现，假设p[j]==x，则CharJump[x]=Len(P)-max(j)-1 —— max计算最后位置 否则， CharJump[x]=Len(P); 注意： 模式串P右移距离shift=dist[i]-Len(u)= CharJump[x]- (Len(P)-1-k) 个字符。 在第二种情况下，无法保证模式串一定是向右移动的，匹配可能会倒退，甚至进入死循环，使匹配一直无法结束。如坏字符出现在已经匹配的部分——于是需要配合好后缀来保证向前滑动。 若利用“坏字符规则，目标串中查找指针的移动距离dist=0，那么此时失配处必定不是在模式串的最后一个字符处，即此时必定存在“好后缀” 好后缀的三种情况 好的后缀可以在模式串的后缀之前位置的字符串中找到，且该字符串的前一个字符≠P[k] ——中间重合 好后缀的的后缀子串是模式串的前缀——首尾重合 模式串中找不到子串和好后缀子串前缀, 将模式串整体挪到该字符之后 关键问题： 如何计算目标串中查找指针的移动距离MatchJump? T中查找指针的移动距离dist≠模式串P的移动距离shift T中查找指针的移动距离dist=模式串P的移动距离shift+好后缀的长度 —— 打破循环Step1: MatchJump数组初始化：——默认不存在重复模式 MatchJump[k]=2*Len(p)-k-1 = Len(p)-k-1+Len(p);（k∈[0,Len(P)-2]）—— 已匹配部分长度 + 模式串长度 MatchJump[Len(P)-1] = 1，最后一个特殊处理，即第一个失配因此只移动一位（意味着：此时没有好后缀） Step2:若存在好后缀，则依据“好后缀规则 ” ， 重新调整MatchJump[k]（k∈[0,Len(P)-2]） （假定：好后缀P’为P[k+1]…P[Len(p)-1] ） 规则1：若好后缀P’在P中存在重复模式(注意是完全重复！)，且重复模式的前一个字符不等，即P[t +1]…P[Len(p)-1-k+t ]== P[k+1]…P[Len(P)-1]且P[t]≠P[k]，则MatchJump(k)=[Len(P)-1-k]+min(k-t)——要求计算重复模式的最小间隔，是因为可能有多个重复模式 —— 已匹配部分长度 + 不等字符间距 规则2：若不满足规则1，且P的前缀 为好后缀P’中的某个子后缀P”的重复模式(部分重复)，即(P”=P[t] … P[Len(p)-1]==P[0] … P[Len(p)-1-t]（t&gt;k+1)，则MatchJump(k)=[Len(P)-1-k]+min(t) 都不满足：MatchJump[k]=2*Len(p)-k-1 = Len(p)-k-1+Len(p); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;#define SIZE 256 //字符集字符数void generateBadChar(char *b, int m, int *badchar)//(模式串b，模式串长度m，模式串的哈希表)&#123; int i, ascii; for (i = 0; i &lt; SIZE; ++i) &#123; badchar[i] = -1;//哈希表初始化为-1 &#125; for (i = 0; i &lt; m; ++i) &#123; ascii = int(b[i]); //计算字符的ASCII值 badchar[ascii] = i;//重复字符被覆盖，记录的是最后出现的该字符的位置 &#125; // 打印一下badchar for (int j = 0; j &lt; m; ++j) &#123; int pos,jump; ascii = int(b[j]); pos = badchar[ascii] + 1; if (pos != 0) jump = m - pos; else jump = m; printf(\"模式串%s中第 %d 个字符 %c 最后出现的位置是 %d，charjmp值为%d\\n\", b, j + 1, b[j], pos,jump ); &#125;&#125;void generateGS(char *b, int m, int *suffix, bool *prefix)//预处理模式串，填充suffix，prefix&#123; int i, j, k; for (i = 0; i &lt; m; ++i)//两个数组初始化 &#123; suffix[i] = -1; prefix[i] = false; &#125; for (i = 0; i &lt; m - 1; ++i)//b[0,i] &#123; j = i; k = 0;//公共后缀子串长度(模式串尾部取k个出来，分别比较) while (j &gt;= 0 &amp;&amp; b[j] == b[m - 1 - k])//与b[0,m-1]求公共后缀子串 &#123; --j; ++k; suffix[k] = j + 1; //相同后缀子串长度为k时，该子串在b[0,i]中的起始下标 // (如果有多个相同长度的子串，被赋值覆盖，存较大的) &#125; if (j == -1)//查找到模式串的头部了 prefix[k] = true;//如果公共后缀子串也是模式串的前缀子串 &#125;&#125;int moveByGS(int j, int m, int *suffix, bool *prefix)//传入的j是坏字符对应的模式串中的字符下标&#123; int k = m - 1 - j;//好后缀长度 if (suffix[k] != -1)//case1，找到跟好后缀一样的模式子串（多个的话，存的靠后的那个（子串起始下标）） return j - suffix[k] + 1; for (int r = j + 2; r &lt; m; ++r)//case2 &#123; if (prefix[m - r] == true)//m-r是好后缀的子串的长度，如果这个好后缀的子串是模式串的前缀子串 return r;//在上面没有找到相同的好后缀下，移动r位，对齐前缀到好后缀 &#125; return m;//case3,都没有匹配的，移动m位（模式串长度）&#125;int str_bm(char *a, int n, char *b, int m)//a表示主串，长n; b表示模式串,长m&#123; int *badchar = new int[SIZE];//记录模式串中每个字符最后出现的位置 generateBadChar(b, m, badchar); //构建坏字符哈希表 int *suffix = new int[m]; bool *prefix = new bool[m]; generateGS(b, m, suffix, prefix); //预处理模式串，填充suffix，prefix int i = 0, j, moveLen1, moveLen2;//j表示主串与模式串匹配的第一个字符 while (i &lt; n - m + 1) &#123; for (j = m - 1; j &gt;= 0; --j) //模式串从后往前匹配 &#123; if (a[i + j] != b[j]) break; //坏字符对应模式串中的下标是j &#125; if (j &lt; 0) //匹配成功 &#123; delete[] badchar; delete[] suffix; delete[] prefix; return i + 1; //返回主串与模式串第一个匹配的字符的位置 &#125; //这里等同于将模式串往后滑动 j-badchar[int(a[i+j])] 位 moveLen1 = j - badchar[int(a[i + j])];//按照坏字符规则移动距离 moveLen2 = 0; if (j &lt; m - 1)//如果有好后缀的话 &#123; moveLen2 = moveByGS(j, m, suffix, prefix);//按照好后缀规则移动距离 &#125; i = i + max(moveLen1, moveLen2);//取大的移动 &#125; delete[] badchar; delete[] suffix; delete[] prefix; return -1;&#125;int main()&#123; string a , b ; cin &gt;&gt; a; // 目标串 cin &gt;&gt; b; // 子串 cout &lt;&lt; a &lt;&lt; \"中第一次出现\" &lt;&lt; b &lt;&lt; \"的位置(从0开始)是：\" &lt;&lt; str_bm(&amp;a[0], a.size(), &amp;b[0], b.size()); system(\"pause\"); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://vergessenwang.github.io/categories/Algorithm/"}],"tags":[{"name":"BM","slug":"BM","permalink":"http://vergessenwang.github.io/tags/BM/"}]},{"title":"KMP算法","slug":"KMP算法","date":"2019-11-26T14:48:10.000Z","updated":"2019-11-27T12:15:30.828Z","comments":true,"path":"posts/Algorithm/2019-11-26-KMP算法.html","link":"","permalink":"http://vergessenwang.github.io/posts/Algorithm/2019-11-26-KMP算法.html","excerpt":"为了避免朴素匹配算法需要向左回溯导致效率较低的缺点，引进了无需回溯的KMP算法。 KMP算法利用模式串P自身的重复模式 关注： 匹配失败，是否发生在P的第一个字符处？ 若当前轮匹配在进行第一个字符比较时就失败，那么下一轮应该是比较T[i+1]和P[1] P中是否有重复模式？ 若P中在当前轮成功匹配的子串的后缀与子串的前缀无重复模式，那么下一轮应该是比较T[i]和P[1] 若P中在当前轮成功匹配的子串的后缀与子串的前缀有重复模式，那么下一轮应该是比较T[i]和P[next[j]] 模式串的next[j] = ？ next[j]就是第j个元素前j-1个元素首尾重合部分个数加1 规定任何一个串，next[1]=0 next[i]= [P串中前 i-1 子串首尾最长匹配数 + 1] —— 首尾重合不包括本身 其他情况，next[i]= 1","text":"为了避免朴素匹配算法需要向左回溯导致效率较低的缺点，引进了无需回溯的KMP算法。 KMP算法利用模式串P自身的重复模式 关注： 匹配失败，是否发生在P的第一个字符处？ 若当前轮匹配在进行第一个字符比较时就失败，那么下一轮应该是比较T[i+1]和P[1] P中是否有重复模式？ 若P中在当前轮成功匹配的子串的后缀与子串的前缀无重复模式，那么下一轮应该是比较T[i]和P[1] 若P中在当前轮成功匹配的子串的后缀与子串的前缀有重复模式，那么下一轮应该是比较T[i]和P[next[j]] 模式串的next[j] = ？ next[j]就是第j个元素前j-1个元素首尾重合部分个数加1 规定任何一个串，next[1]=0 next[i]= [P串中前 i-1 子串首尾最长匹配数 + 1] —— 首尾重合不包括本身 其他情况，next[i]= 1 匹配过程：若某轮匹配失败，则利用next数组分别计算下一轮匹配时目标串和模式串的开始位置 若是T[i]≠P[j]导致当前轮的匹配失败，则按照下列规则开始下一轮匹配： 若next[j] ≠ 0，则将T[i..]与P[next[j]..]匹配 若next[j]==0，则将T[(i+1)..]与P[1..]匹配 nextval数组什么情况下有改进的空间？ 假设T[i] ≠P[j]导致失配 。若P[j]==P[next[j]]，此时若向右移动模式串P，将T[i]与P[next[j]]对齐进行比较必然是无意义的，因为此时T[i]必定≠P[next[j]]。 如何改进？用nextval数组代替next数组。 nextval[1]=0; for(j&gt;1;j&lt;=n;j++)若P[j]==P[next[j]]，则nextval[j]=nextval[next[j]];若P[j]≠P[next[j]]，则nextval[j]=next[j];若某轮匹配失败，则利用nextval数组计算下一轮匹配时的目标串和模式串的开始位置（类似next数组的应用） 一直比到相等为止 KMP算法近似时间复杂度为O(n+m),其中O(n)表示比较的时间， O(m)表示计算next数组的时间. 若每轮中模式串与目标串之间的不匹配都发生在模式串的第一个字符处，则KMP算法会退化到朴素模式匹配算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;void get_next(char *t, int *next)&#123; int len = strlen(t + 1); int i = 1, j = 0; next[i] = j; // 数组第二个元素设为next数组第一个值 while (i &lt; len) &#123; if (j == 0 || t[i] == t[j])//j==0是用来设置第二个值；t[i] == t[j] 是比较后缀的单个字符与前缀的单个字符？ &#123; ++i; ++j; next[i] = j; &#125; else j = next[j]; &#125; for(int k=1;k&lt;=len;++k) cout&lt;&lt;next[k]&lt;&lt;\" \"; cout&lt;&lt;endl; return;&#125;void get_nextval(char *t, int *nextval)&#123; int i = 1, j = 0; nextval[1] = 0; int len = strlen(t + 1); while (i &lt; len) &#123; if (j == 0 || t[i] == t[j]) &#123; ++i; ++j; if (t[i] != t[j])//若当前字符与前缀字符不相等 nextval[i] = j;//则当前的j为nextval在i位置的值（即next[i]） else//若当前字符与前缀字符相等 nextval[i] = nextval[j];//则将前缀字符的nextval的值赋值给nextval[i],即nextval[i]=next[next[i]]; &#125; else j = nextval[j]; &#125; for(int k=1;k&lt;=len;k++) cout&lt;&lt;nextval[k]&lt;&lt;\" \"; cout&lt;&lt;endl;&#125;//返回子串t在主串s中第pos个字母后的位置int kmp_next(char *s, char *t, int pos)&#123; int next[105]; memset(next, 0, sizeof(next)); get_next(t, next); int i = pos; int j = 1; int len_s = strlen(s + 1); int len_t = strlen(t + 1); while (i &lt;= len_s &amp;&amp; j &lt;= len_t) &#123; if (j == 0 || s[i] == t[j]) &#123; ++i; ++j; &#125; else j = next[j]; &#125; if (j &gt; len_t)//表示t串匹配成功 return i - len_t; else return 0;&#125;int kmp_nextval(char *s, char *t, int pos)&#123; int nextval[105]; memset(nextval, 0, sizeof(nextval)); get_nextval(t, nextval); int i = pos; int j = 1; int len_s = strlen(s + 1); int len_t = strlen(t + 1); while (i &lt;= len_s &amp;&amp; j &lt;= len_t) &#123; if (j == 0 || s[i] == t[j]) &#123; ++i; ++j; &#125; else j = nextval[j]; &#125; if (j &gt; len_t) return i - len_t; else return 0;&#125;int main()&#123; char t[105], s[105]; int pos; scanf(\"%s%s%d\", s + 1, t + 1, &amp;pos); // 目标串，模式串，开始查找位置 printf(\"%d\\n\", kmp_next(s, t, pos)); printf(\"%d\\n\", kmp_nextval(s, t, pos)); system(\"pause\"); return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://vergessenwang.github.io/categories/Algorithm/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://vergessenwang.github.io/tags/KMP/"}]},{"title":"Java第10章 泛型","slug":"Java第10章-泛型","date":"2019-11-07T12:19:35.000Z","updated":"2019-11-07T12:21:22.822Z","comments":true,"path":"posts/Java/2019-11-07-Java第10章-泛型.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2019-11-07-Java第10章-泛型.html","excerpt":"泛型的目的是为了实现类型的通用性，那为什么不用 Object 向上转型的方法呢？如果集合里面数据很多，某一个数据转型出现错误，在编译期是无法发现的。但是在运行期会发生java.lang.ClassCastException。泛型一方面让我们只能往集合中添加一种类型的数据，同时可以让我们在编译期就发现这些错误，避免运行时异常的发生，提升代码的健壮性。 Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数 对于泛型，只是允许程序员在编译时检测到非法的类型而已。但是在运行期时，其中的泛型标志会变化为 Object 类型。 泛型方法泛型方法既可以存在于泛型类中，也可以存在于普通的类中。如果使用泛型方法可以解决问题，那么应该尽量使用泛型方法。 定义泛型方法的规则： 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前 如 public static &lt; E &gt; void printArray( E[] inputArray ){} 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等） 123Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, 'a'); // compile-time errorPair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, 'a');Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(Integer.valueOf(8), new Character('a'));","text":"泛型的目的是为了实现类型的通用性，那为什么不用 Object 向上转型的方法呢？如果集合里面数据很多，某一个数据转型出现错误，在编译期是无法发现的。但是在运行期会发生java.lang.ClassCastException。泛型一方面让我们只能往集合中添加一种类型的数据，同时可以让我们在编译期就发现这些错误，避免运行时异常的发生，提升代码的健壮性。 Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数 对于泛型，只是允许程序员在编译时检测到非法的类型而已。但是在运行期时，其中的泛型标志会变化为 Object 类型。 泛型方法泛型方法既可以存在于泛型类中，也可以存在于普通的类中。如果使用泛型方法可以解决问题，那么应该尽量使用泛型方法。 定义泛型方法的规则： 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前 如 public static &lt; E &gt; void printArray( E[] inputArray ){} 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等） 123Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, 'a'); // compile-time errorPair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, 'a');Pair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(Integer.valueOf(8), new Character('a')); 不能实例化类型参数 1234public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;E elem = new E(); // compile-time errorlist.add(elem);&#125; 不能将静态成员的类型声明为类型参数 如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 不能创建类型参数数组 1List&lt;Integer&gt;[] arrayOfLists = new List&lt;Integer&gt;[2]; // compile-time error 类型参数不能进行catch、throw等异常处理 有界的类型参数: 限制被允许传递到一个类型参数的类型种类范围。要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。 如 public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z){} 泛型类泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。最典型的就是各种容器类，如：List、Set、Map。 例如： 1234567891011121314151617181920public class Box&lt;T&gt; &#123; private T t; public void add(T t) &#123; this.t = t; &#125; public T get() &#123; return t;&#125; //调用 Box&lt;Integer&gt; integerBox = new Box&lt;&gt;(); //右边尖括号无需再声明类型，因为编译器可以进行推断// 参数还可以是参数化类型 OrderedPair&lt;String, Box&lt;Integer&gt;&gt; p = new OrderedPair&lt;&gt;(\"primes\", new Box&lt;Integer&gt;(...));// 没有实际参数是原生类型 Box rawBox1 = new Box();// 可以将参数化类型赋值给原生类型，但不能反过来 Box rawBox2 = integerBox; // ok Box&lt;Integer&gt; intBox = rawBox1; // error// 原生类型绕过了泛型类型检查，因此要避免使用 rawBox1.set(8); // warning: unchecked invocation to set(T) 泛型类最常用的使用场景就是“元组”的使用。我们知道方法return返回值只能返回单个对象。如果我们定义一个泛型类，定义2个甚至3个类型参数，这样我们return对象的时候，构建这样一个“元组”数据，通过泛型传入多个对象，这样我们就可以一次性方法多个数据了。 泛型接口定义： 123public interface Generator&lt;T&gt; &#123; public T next();&#125; 泛型接口未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中。 123456class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125; 如果泛型接口传入类型参数时，实现该泛型接口的实现类，则所有使用泛型的地方都要替换成传入的实参类型。 123456class DataHolder implements Generator&lt;String&gt;&#123; @Override public String next() &#123; return null; &#125;&#125; 泛型类或接口可以被继承，如： interface PayloadList&lt;E,P&gt; extends List&lt;E&gt; { } 类型通配符容器中的类型之间存在继承关系，但是两个容器之间是不存在继承关系的。因此需要用到通配符? The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return typeThe wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype 类型通配符一般是使用?代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是List,List 等所有List&lt;具体类型实参&gt;的父类 。无界通配符 意味着可以使用任何对象，因此使用它类似于使用原生类型。原生类型可以持有任何类型，而无界通配符修饰的容器持有的是某种具体的类型。此处’？’是类型实参，而不是类型形参 。 如 public static void getData(List&lt;?&gt; data) {} 含通配符上限, 用 extends，如 public static void getUperNumber(List&lt;? extends Number&gt; data) {} 如此定义就是通配符泛型值接受Number及其下层子类类型。但是set() 方法会失效—— 可能是类型擦除的原因？get()方法仍可用，可能是因为获取出来的我们都可以隐式的转为其基类（或者Object基类）。所以上界描述符Extends适合频繁读取的场景。 多通配：&lt;T extends B1 &amp; B2 &amp; B3&gt; 类要在接口的前面 通配符下限, 用 super ， 如 List&lt;? super Number&gt; 表示类型只能接受Number及其三层父类类型，如 Object 类型的实例 下界通配符&lt;? super T&gt;不影响往里面存储，但是读取出来的数据只能是Object类型。原因是：下界通配符规定了元素最小的粒度，必须是T及其基类，那么我往里面存储T及其派生类都是可以的，因为它都可以隐式的转化为T类型。但是往外读就不好控制了，里面存储的都是T及其基类，无法转型为任何一种类型，只有Object基类才能装下。 PECS原则 上界&lt;? extends T&gt;不能往里存，只能往外取，适合频繁往外面读取内容的场景。 下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里，适合经常往里面插入数据的场景。 泛型擦除Java语言泛型在设计的时候为了兼容原来的旧代码，Java的泛型机制使用了“擦除”机制。 编译器虽然会在编译过程中移除参数的类型信息，但是会保证类或方法内部参数类型的一致性。泛型参数将会被擦除到它的第一个边界（边界可以有多个，重用 extends 关键字，通过它能给与参数类型添加一个边界）。在运行过程中，编译器事实上会把类型参数替换为它的第一个边界的类型。如果没有指明边界，那么类型参数将被擦除到Object。最后需要写入时，编译器会进行一次类型转换 12345Class&lt;?&gt; class1=new ArrayList&lt;String&gt;().getClass();Class&lt;?&gt; class2=new ArrayList&lt;Integer&gt;().getClass();System.out.println(class1); //class java.util.ArrayListSystem.out.println(class2); //class java.util.ArrayListSystem.out.println(class1.equals(class2)); //true 由以上例子可以看出，Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 泛型类型不能显式地运用在运行时类型的操作当中，例如：转型、instanceof 和 new。因为在运行时，所有参数的类型信息都丢失了。 解决办法 命名传统• E - Element (used extensively by the Java Collections Framework)• K - Key• N - Number• T - Type• V - Value• S,U,V etc. - 2nd, 3rd, 4th types","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"泛型","slug":"泛型","permalink":"http://vergessenwang.github.io/tags/泛型/"},{"name":"通配符","slug":"通配符","permalink":"http://vergessenwang.github.io/tags/通配符/"}]},{"title":"高网第5章 IP交付与路由","slug":"高网第5章-IP交付与路由","date":"2019-11-06T15:09:26.000Z","updated":"2020-03-11T15:41:12.232Z","comments":true,"path":"posts/network/2019-11-06-高网第5章-IP交付与路由.html","link":"","permalink":"http://vergessenwang.github.io/posts/network/2019-11-06-高网第5章-IP交付与路由.html","excerpt":"网络层本质上一个软件包 —— 所以对我们来说，网络并不是完全抽象的 在异构的网络中，通信能力、分组长度限制和时延都是不一样的，所以采用面向连接的方式比较困难—— IP协议，无连接，尽最大努力交付，适合异构网络互连 对于路由器而言，其功能由于采用end - to - end 原则而被简化，只能尽最大努力交付，只关注与它相邻的路由 —— 进步空间：更多跳的路由 交付(delivery)——物理层和链路层 用分组目的IP地址查路由表 Forwarding : 目的IP &amp; 路由表项的掩码 ==？ 路由表项的IP地址 找出匹配项中下一跳IP地址的物理地址：下一跳IP地址–&gt; ARP –&gt; 目的物理地址 ARP： 将IP与MAC地址进行绑定，完成从网络层到链路层的切换 将IP分组和目的物理地址一起交给链路层 一次交付过程包含0或多个间接交付+1个直接交付（最后的交付） 分组:（源IP地址，目的IP地址）保持不变 帧:（源物理地址，目的物理地址）逐跳改变 通过上面的两种地址，解决了网关IP和目的IP冲突的问题","text":"网络层本质上一个软件包 —— 所以对我们来说，网络并不是完全抽象的 在异构的网络中，通信能力、分组长度限制和时延都是不一样的，所以采用面向连接的方式比较困难—— IP协议，无连接，尽最大努力交付，适合异构网络互连 对于路由器而言，其功能由于采用end - to - end 原则而被简化，只能尽最大努力交付，只关注与它相邻的路由 —— 进步空间：更多跳的路由 交付(delivery)——物理层和链路层 用分组目的IP地址查路由表 Forwarding : 目的IP &amp; 路由表项的掩码 ==？ 路由表项的IP地址 找出匹配项中下一跳IP地址的物理地址：下一跳IP地址–&gt; ARP –&gt; 目的物理地址 ARP： 将IP与MAC地址进行绑定，完成从网络层到链路层的切换 将IP分组和目的物理地址一起交给链路层 一次交付过程包含0或多个间接交付+1个直接交付（最后的交付） 分组:（源IP地址，目的IP地址）保持不变 帧:（源物理地址，目的物理地址）逐跳改变 通过上面的两种地址，解决了网关IP和目的IP冲突的问题 转发(forwording)设计原则：使用尽可能少的信息实现转发 子网作为路由表项：节约路由表的存储空间，提高查表效率 还可进一步路由聚合，同时实现了隐藏网络结构的作用，自主管理网络边界使用路由器与外界相连，在不改变原有IP地址范围的条件下，网络内部任意划分子网、改变拓扑结构等，都不会影响外部的路由器选路表项 —— 应用：ISP分级路由，对于ISP 运营商来说便于管理，对于用户来说有了一个IP池可以动态分配IP 只路由到下一跳：简化路由表，每个路由器独立选路 问题：只有最后一个路由器才知道目的主机是否存在，可能造成网络震荡 —— 解决：TTL，限制生存时间 默认路由：目的IP和掩码为全0——减少占用空间，交给功能更强的路由器(可能出现路由环路，如两个路由器分别设置对方为默认路由器)，还有出于安全考虑隐藏路径的作用 特殊主机路由：使用完整IP地址作为表项，出于安全性、时延等需求—— 由此可见，特殊的需求可能违背最初的设计原则 匹配方式 分类地址可能有A、B、C类多个转发表；无分类，直连 –&gt; 非直连最长匹配 对于P2P网络：如果被指派了IP地址，那么在路由表中有表项；如果采用unnumbered P2P line编址方案，则不是IP网络，不在路由表中 NAT10.10…. 192.168… 是只在局域网使用的特殊地址 例如，科大的网站都是219.219…. 这些网站在子网内部会有一个虚拟端口 ，用于区别不同的主机 ，数据报到达局域网后会重新打包，加上主机的真正端口 —— 这些网站对外会映射为同一IP, 通过虚拟端口号来进行区分 其他之前还有一个QoS协议，用特殊的bit位来标识报文优先级，但是如果每个用户都对该位置进行设置的话，其实是无用的 笔记本无线网卡的两种模式 infrastructure Ad-hoc 可以提供自助路由功能","categories":[{"name":"network","slug":"network","permalink":"http://vergessenwang.github.io/categories/network/"}],"tags":[{"name":"IP","slug":"IP","permalink":"http://vergessenwang.github.io/tags/IP/"}]},{"title":"Java第9章 异常处理","slug":"Java第9章-异常处理","date":"2019-11-05T15:22:54.000Z","updated":"2019-11-05T15:24:30.755Z","comments":true,"path":"posts/Java/2019-11-05-Java第9章-异常处理.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2019-11-05-Java第9章-异常处理.html","excerpt":"Java的异常处理本质上是抛出异常(创建异常对象，交给运行系统处理)和捕获异常。—— 针对可恢复异常 调用栈：main –&gt; method with an exception handler –&gt; method without an exception handler –&gt; method where error occurred 当错误发生时(异常抛出)，会被反向传递至类型匹配的 exception handler 进行处理(捕获异常), 无法捕获将终止程序 使用异常处理的好处：将正常代码与错误处理代码分离开；通过调用栈传递错误对象；对错误类型进行组织和区分 异常分类三种类型的异常： 检查性异常(编译异常)：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。—— IOException， 常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等 运行时异常： 这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，但是程序员也可以根据需要进行捕获抛出。Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。—— RuntimeException，常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等。 错误： 是指程序无法处理的错误，由 Java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。例如jvm运行时出现的OutOfMemoryError以及Socket编程时出现的端口占用等程序无法处理的错误。—— Error","text":"Java的异常处理本质上是抛出异常(创建异常对象，交给运行系统处理)和捕获异常。—— 针对可恢复异常 调用栈：main –&gt; method with an exception handler –&gt; method without an exception handler –&gt; method where error occurred 当错误发生时(异常抛出)，会被反向传递至类型匹配的 exception handler 进行处理(捕获异常), 无法捕获将终止程序 使用异常处理的好处：将正常代码与错误处理代码分离开；通过调用栈传递错误对象；对错误类型进行组织和区分 异常分类三种类型的异常： 检查性异常(编译异常)：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。—— IOException， 常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等 运行时异常： 这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，但是程序员也可以根据需要进行捕获抛出。Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。—— RuntimeException，常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等。 错误： 是指程序无法处理的错误，由 Java 虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。例如jvm运行时出现的OutOfMemoryError以及Socket编程时出现的端口占用等程序无法处理的错误。—— Error 异常体系结构 把人绕晕的几个名词： 检查性异常: 不处理编译不能通过—— 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于检查异常，当程序中可能出现这类异常，要么使用try-catch语句进行捕获，要么用throws子句抛出，否则编译无法通过。 非检查性异常:不处理编译可以通过，如果有抛出直接抛到控制台 运行时异常: 就是非检查性异常 非运行时异常: 就是检查性异常 内置异常类 try-catch-fianllyfinally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。finally 是防止资源泄露的有效工具 try…catch…; try….finally……; try….catch…finally… catch块可以有多个，注意try块只能有一个,finally块是可选的。在有多个catch块的时候，是按照catch块的先后顺序进行匹配的，一旦异常类型被一个catch块匹配，则不会与后面的catch块进行匹配。 catch 不能独立于 try 存在 try语句可以被嵌套, 每次进入try语句，异常的前后关系都会被推入堆栈 在 try/catch 后面添加 finally 块并非强制性要求的。 try 代码后不能既没 catch 块也没 finally 块。 try, catch, finally 块之间不能添加任何代码 try…catch…. 捕获异常时，大的异常(Exception类)放在下方，小的异常放在上方，否则，在异常捕获时，小的异常将不能被捕获，因为全在大的异常类中捕获到。 一个典型的例子： 123456789try&#123; //待捕获代码 &#125;catch（Exception e）&#123; System.out.println(\"catch is begin\"); return 1 ；&#125;finally&#123; System.out.println(\"finally is begin\"); return 2 ;&#125; 以上代码会返回2，catch中的return语句会被跳过，所以注意千万不要在finally块中使用return 但是也有特殊：finally不一定被执行，例如 catch 块中有退出系统的语句 System.exit(-1); finally就不会被执行 throw跟throws的区别如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。 123public void test() throws Exception &#123; throw new Exception();&#125; throws表示一个方法声明可能抛出一个异常，throw表示此处抛出一个已定义的异常（可以是自定义需继承Exception，也可以是java自己给出的异常类）。用throw手动抛出一个异常对象 throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由方法去处理异常，真正的处理异常由此方法的上层调用处理。 如果是不受检查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。必须声明方法可抛出的任何检查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误 自定义异常在 Java 中你可以自定义异常。 所有异常都必须是 Throwable 的子类。 如果希望写一个检查性异常类，则需要继承 Exception 类。—— 一般情况下不自定义检查异常。 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类 自定义异常并使用： 1234567891011121314151617181920212223242526class MyException extends Exception &#123; private int detail; MyException(int a)&#123; detail = a; &#125; public String toString()&#123; return \"MyException [\"+ detail + \"]\"; &#125;&#125;public class TestMyException&#123; static void compute(int a) throws MyException&#123; System.out.println(\"Called compute(\" + a + \")\"); if(a &gt; 10)&#123; throw new MyException(a); &#125; System.out.println(\"Normal exit!\"); &#125; public static void main(String [] args)&#123; try&#123; compute(1); compute(20); &#125;catch(MyException me)&#123; System.out.println(\"Caught \" + me); &#125; &#125;&#125; 有些程序员认为检查异常是程序里的瑕疵，试图通过非检查异常来绕过，并不推荐这种做法。 方法覆盖在当前方法被覆盖时，覆盖他的方法必须抛出相同的异常或异常的子类 父类的方法没有声明异常，子类在重写该方法的时候不能声明异常； 如果父类的方法声明一个异常exception1，则子类在重写该方法的时候声明的异常不能是exception1的父类； 如果父类的方法声明的异常类型只有非运行时异常（运行时异常），则子类在重写该方法的时候声明的异常也只能有非运行时异常（运行时异常），不能含有运行时异常（非运行时异常 一篇详细的文章","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[{"name":"异常","slug":"异常","permalink":"http://vergessenwang.github.io/tags/异常/"}]},{"title":"NLP预处理语言模型演进","slug":"NLP预处理语言模型演进","date":"2019-11-03T14:36:12.000Z","updated":"2019-11-03T14:46:26.504Z","comments":true,"path":"posts/NLP/2019-11-03-NLP预处理语言模型演进.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-11-03-NLP预处理语言模型演进.html","excerpt":"在进行核心步骤关系抽取之前，还需要经历一系列基础的NLP处理环节。 模型的预训练最初被用在图像和视频领域的深度学习中，能有效解决训练数据少的问题，同时还能极大加快任务训练的收敛速度。经过预处理后的数据再用于下游的分词、命名实体识别等任务时可以取得更好的效果。 语言模型是一串词序列的概率分布。具体来说，语言模型的作用是为一个长度为m的文本确定一个概率分布P，表示这段文本存在的可能性。在实践中，如果文本的长度较长，P(wi | w1, w2, . . . , wi−1)的估算会非常困难。因此，研究者们提出使用一个简化模型：n元模型（n-gram model）。在n元模型中，传统的方法一般采用频率计数的比例来估算n元条件概率。当n较大时，机会存在数据稀疏问题，导致估算结果不准确。为了缓解n元模型估算概率时遇到的数据稀疏问题，Bengio在2003年提出了神经网络语言模型（NLM），是为Word Embedding的想法的雏形。 Word Embedding作为NLP里的早期预训练技术，词嵌入（Word Embedding）或者分布式向量（Distributional Vectors）是将自然语言表示的单词转换为计算机能够理解的向量或矩阵形式的技术。有了一个词的向量之后，各种基于向量的计算就可以实施，如用向量之间的相似度来度量词之间的语义相关性。其基于的分布式假设就是出现在相同上下文的词意思应该相近。Word Embedding也有其局限性，比如：难以对词组做分布式表达；无法解决多义词问题，这对情感分析任务的影响非常大。此外，Word Embedding对于应用场景的依赖很强，所以针对特殊的应用场景可能需要重新训练，这样就会很消耗时间和资源。","text":"在进行核心步骤关系抽取之前，还需要经历一系列基础的NLP处理环节。 模型的预训练最初被用在图像和视频领域的深度学习中，能有效解决训练数据少的问题，同时还能极大加快任务训练的收敛速度。经过预处理后的数据再用于下游的分词、命名实体识别等任务时可以取得更好的效果。 语言模型是一串词序列的概率分布。具体来说，语言模型的作用是为一个长度为m的文本确定一个概率分布P，表示这段文本存在的可能性。在实践中，如果文本的长度较长，P(wi | w1, w2, . . . , wi−1)的估算会非常困难。因此，研究者们提出使用一个简化模型：n元模型（n-gram model）。在n元模型中，传统的方法一般采用频率计数的比例来估算n元条件概率。当n较大时，机会存在数据稀疏问题，导致估算结果不准确。为了缓解n元模型估算概率时遇到的数据稀疏问题，Bengio在2003年提出了神经网络语言模型（NLM），是为Word Embedding的想法的雏形。 Word Embedding作为NLP里的早期预训练技术，词嵌入（Word Embedding）或者分布式向量（Distributional Vectors）是将自然语言表示的单词转换为计算机能够理解的向量或矩阵形式的技术。有了一个词的向量之后，各种基于向量的计算就可以实施，如用向量之间的相似度来度量词之间的语义相关性。其基于的分布式假设就是出现在相同上下文的词意思应该相近。Word Embedding也有其局限性，比如：难以对词组做分布式表达；无法解决多义词问题，这对情感分析任务的影响非常大。此外，Word Embedding对于应用场景的依赖很强，所以针对特殊的应用场景可能需要重新训练，这样就会很消耗时间和资源。 ELMo Word Embedding本质上是个静态的方式，即训练完了单词的表达就固定了，不会跟着上下文场景的变化而改变。为了解决这个问题，出现了ELMO（Embedding from Language Models）的训练方案。ELMO采用了典型的两阶段过程，第一个阶段是利用语言模型进行预训练；第二个阶段是在做下游任务时，从预训练网络中提取对应单词的网络各层的Word Embedding作为新特征补充到下游任务中。通过加入双层双向的LSTM网络结构，ELMo引入上下文动态调整单词的embedding后，多义词问题得到了解决。但是ELMo的缺点在将LSTM作为特征抽取器时抽取能力不够强。 GPT除了以ELMo为代表的这种基于特征融合的预训练方法外，NLP里还有一种典型做法，称为“基于Fine-tuning的模式”，而GPT就是这一模式的典型开创者，用到了目前NLP里最强的特征提取器Transformer。Transformer 是谷歌大脑在2017年底发表的论文 attention is all you need中所提出来的seq2seq模型，是一个叠加的自注意力机制（Self Attention）构成的深度网络。相比于LSTM的迭代训练，Transformer的训练是并行的，使用了位置嵌入来理解语言的顺序，使用自注意力机制和全连接层来进行计算。 GPT（Generative Pre-Training）是指生成式的预训练，也采用两阶段过程，第一个阶段是利用语言模型进行预训练，第二阶段通过Fine-tuning的模式解决下游任务。GPT的预训练虽然仍然是以语言模型作为目标任务，但是采用的是单向的语言模型，这限制了其在更多应用场景的效果，比如阅读理解这种任务。 BERT针对GPT单向模型的限制，出现了被大为追捧的BERT模型。BERT模型的全称是双向transformer编码表达，BERT采用和GPT完全相同的两阶段模型，首先是语言模型预训练；其次是使用Fine-Tuning模式解决下游任务。和GPT的最主要不同在于在预训练阶段采用了类似ELMO的双向语言模型，当然另外一点是语言模型的数据规模要比GPT大。BERT最大优势在于，可以对具体任务进行特征步充，因此几乎可以做任何NLP的下游任务，具备很强的普适性。 参见之前写的 参考链接1 参考链接2","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"Word Embedding","slug":"Word-Embedding","permalink":"http://vergessenwang.github.io/tags/Word-Embedding/"},{"name":"BERT","slug":"BERT","permalink":"http://vergessenwang.github.io/tags/BERT/"}]},{"title":"NLTK+LTP进行中文处理","slug":"NLTK-LTP进行中文处理","date":"2019-11-02T01:08:09.000Z","updated":"2019-11-02T01:09:36.905Z","comments":true,"path":"posts/NLP/2019-11-02-NLTK-LTP进行中文处理.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-11-02-NLTK-LTP进行中文处理.html","excerpt":"安装NLTKNLTK是一个NLP工作平台，可以和一些NLP库配合使用。 激活虚拟环境，因为原本已经安装了 pyltp ，不想再开新的环境了… 继续安装： 1234pip install numpyconda install scipypip install Tornadopip install nltk 前两个是高性能数学计算软件包，第三个是网络包 作为一个非洲人，果然安装nltk的过程并不顺利 报错信息： 12Could not find a version that satisfies the requirement nltk (from versions: )No matching distribution found for nltk 切换成 conda 命令，居然好了…本非颇为不适","text":"安装NLTKNLTK是一个NLP工作平台，可以和一些NLP库配合使用。 激活虚拟环境，因为原本已经安装了 pyltp ，不想再开新的环境了… 继续安装： 1234pip install numpyconda install scipypip install Tornadopip install nltk 前两个是高性能数学计算软件包，第三个是网络包 作为一个非洲人，果然安装nltk的过程并不顺利 报错信息： 12Could not find a version that satisfies the requirement nltk (from versions: )No matching distribution found for nltk 切换成 conda 命令，居然好了…本非颇为不适 在pycharm新建一个项目，指定解释器，新建py文件，执行如下代码： 1234567import sysimport osimport nltkfrom importlib import reloadreload(sys)nltk.download() 然后出现了 WinError10060错误 ，血统纯正。 只能手动下数据包了，git地址 后面的过程老是导入出错，卡了好久，把网上所有的方法试了一遍，最后居然是因为。。没有重启pycharm试试，之前一直在解释器中运行的，后来用脚本就可以了。也不知道是重启还是脚本的原因，反正数据本身是没有问题的，如果导入出错，一定是路径设置的不对！ 把packages中的文件解压，文件件重命名为nltk_data , 放在C 盘根目录下…是的，就是这么粗暴… 设置用户变量NLTK_DATA C:\\nltk_data 运行脚本 123import nltknltk.data.find('C:\\\\') # 设置路径from nltk.book import * 解决方法参考 导入LTP语言处理模型之前已经安装过pyltp自然语言处理库, 这里只需要导入模型。 安装可参看之前写的 在ltp模型 下载v3.4.0.zip版本, 在KGQA目录下，修改ltp.py里的ltp模型文件的存放目录 分词实现用的是CRF模型 测试代码 1234567891011121314import sysimport osfrom importlib import reloadfrom pyltp import Segmentorreload(sys)model_path = \"C:\\\\Users\\\\18771\\\\Desktop\\\\data\\\\ltp_data_v3.4.0\\\\cws.model\"segmentor = Segmentor() # 实例化分词模块segmentor.load(model_path) # 加载分词库words = segmentor.segment(\"晚秋的哀牢山宛如一个成熟的睡美人，轻柔的晨风从身边掠过，拂遍林海奇峰，挽起霞霭，任南迁的候鸟洗礼，猿啸与松涛齐鸣，青山共斜阳万里。\")print(\"|\".join(words)) 输出结果 1晚秋|的|哀牢山|宛如|一个|成熟|的|睡美人|，|轻柔|的|晨风|从|身边|掠过|，|拂|遍|林海|奇峰|，|挽|起|霞霭|，|任|南迁|的|候鸟|洗礼|，|猿啸|与|松涛|齐鸣|，|青山|共|斜阳|万|里|。 词性标注及命名实体识别词性标注依旧用的是CRF算法，遵从北大词性标注规范。 测试代码 12345678910111213141516171819202122import sysimport osfrom importlib import reloadfrom pyltp import *reload(sys)sent = \"晚秋|的|哀牢山|宛如|一个|成熟|的|睡美人|，|轻柔|的|晨风|从|身边|掠过|，|拂|遍|林海|奇峰|，|挽|起|霞霭|，|任|南迁|的|候鸟|洗礼|，|猿啸|与|松涛|齐鸣|，|青山|共|斜阳|万|里|。\"model_path = \"C:\\\\Users\\\\18771\\\\Desktop\\\\data\\\\ltp_data_v3.4.0\\\\pos.model\"model_path2 = \"C:\\\\Users\\\\18771\\\\Desktop\\\\data\\\\ltp_data_v3.4.0\\\\ner.model\"words = sent.split(\"|\")postagger = Postagger() # 实例化词性标注类postagger.load(model_path)postags = postagger.postag(words)recongnizer = NamedEntityRecognizer() # 实例化命名实体识别类recongnizer.load(model_path2)netags = recongnizer.recognize(words,postags)for word,postag,netag in zip(words,postags,netags): print(word+\"/\"+postag + \"/\" + netag) 识别出： 1哀牢山/ns/S-Ns 依存句法树结合使用NLTK和LTP可以构造依存句法树 测试代码 12345678910111213141516171819202122232425262728293031323334import sysimport osfrom importlib import reloadfrom pyltp import *import nltkfrom nltk.tree import Tree # 导入nltk treefrom nltk.grammar import DependencyGrammar # 导入依存句法包from nltk.parse import *import rereload(sys)words = \"苏州 的 拙政园 是 旅游胜地 。\".split(\" \")model_path = \"C:\\\\Users\\\\18771\\\\Desktop\\\\data\\\\ltp_data_v3.4.0\\\\pos.model\"model_path2 = \"C:\\\\Users\\\\18771\\\\Desktop\\\\data\\\\ltp_data_v3.4.0\\\\parser.model\"postagger = Postagger() # 实例化词性标注类postagger.load(model_path)postags = postagger.postag(words)parser = Parser() # 将词性标注和分词结果都加入分析器进行句法解析parser.load(model_path2)arcs = parser.parse(words,postags)arclen = len(arcs)conll = \"\"for i in range(arclen): # 构建conll标准数据结构 if arcs[i].head == 0: arcs[i].relation = 'ROOT' conll += \"\\t\" + words[i] + \"(\" + postags[i] + \")\" + \"\\t\" + postags[i] + \"\\t\" + str(arcs[i].head) + \"\\t\" + arcs[i].relation + \"\\n\"print(conll)conlltree = DependencyGraph(conll) # 转换为依存句法图tree = conlltree.tree() # 构建树结构tree.draw() # 显示输出的树 会在NLTK中输出一个依存树的图，我就不贴图了。。不会传图。。","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"NLTK","slug":"NLTK","permalink":"http://vergessenwang.github.io/tags/NLTK/"},{"name":"LTP","slug":"LTP","permalink":"http://vergessenwang.github.io/tags/LTP/"}]},{"title":"遥远的BERT模型...","slug":"遥远的BERT模型","date":"2019-11-01T01:22:22.000Z","updated":"2019-11-01T01:23:45.168Z","comments":true,"path":"posts/NLP/2019-11-01-遥远的BERT模型.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-11-01-遥远的BERT模型.html","excerpt":"Transformer 是谷歌大脑在2017年底发表的论文 attention is all you need 文章解读 中所提出来的seq2seq模型，BERT就是从transformer 中衍生出来的预训练语言模型。 现在很多处理效果非常好的模型，都融合了BERT , 模型排名 transformer原理相比于LSTM的迭代训练，transformer的训练是并行的，使用了位置嵌入来理解语言的顺序，使用自注意力机制和全连接层来进行计算。 主要分为两部分： 编码器：把自然语言序列映射成隐藏层的数学表达 字向量与位置嵌入：由于没有迭代计算需要提供每个字的位置信息，从而让模型学到位置之间的依赖关系和自然语言的时序特征 自注意力机制：求词向量的点积，即余弦距离，最后得到 N * N 注意力矩阵，第 i 行表示第 i 个字 与 每一个字的相关程度，沿着最后一个维度做softmax归一化，是概率之和为1形成概率分布。 注意力矩阵的作用就是得到一个权重的概率分布，然后用其点乘词向量，就可以得到加权后的线性组合，使得每个字向量都含有当前句子内所有字向量的信息 残差连接：避免梯度消失 归一化：把隐藏层归一为标准正态分布，加速收敛 前馈：进行两层线性映射并用激活函数激活；然后重复3、4 解码器：把隐藏层映射为自然语言序列，用于下游的命名实体识别、语义关系抽取、摘要生成、情感分类等","text":"Transformer 是谷歌大脑在2017年底发表的论文 attention is all you need 文章解读 中所提出来的seq2seq模型，BERT就是从transformer 中衍生出来的预训练语言模型。 现在很多处理效果非常好的模型，都融合了BERT , 模型排名 transformer原理相比于LSTM的迭代训练，transformer的训练是并行的，使用了位置嵌入来理解语言的顺序，使用自注意力机制和全连接层来进行计算。 主要分为两部分： 编码器：把自然语言序列映射成隐藏层的数学表达 字向量与位置嵌入：由于没有迭代计算需要提供每个字的位置信息，从而让模型学到位置之间的依赖关系和自然语言的时序特征 自注意力机制：求词向量的点积，即余弦距离，最后得到 N * N 注意力矩阵，第 i 行表示第 i 个字 与 每一个字的相关程度，沿着最后一个维度做softmax归一化，是概率之和为1形成概率分布。 注意力矩阵的作用就是得到一个权重的概率分布，然后用其点乘词向量，就可以得到加权后的线性组合，使得每个字向量都含有当前句子内所有字向量的信息 残差连接：避免梯度消失 归一化：把隐藏层归一为标准正态分布，加速收敛 前馈：进行两层线性映射并用激活函数激活；然后重复3、4 解码器：把隐藏层映射为自然语言序列，用于下游的命名实体识别、语义关系抽取、摘要生成、情感分类等 BERT语言模型就是用来求一个句子出现的概率 BERT模型的全称是双向transformer编码表达。 只用到了编码器的部分，在每句话的句头添加一个特殊字符，让句子中的所有信息向这个字符汇总，就可以根据这个字符的hidden state 完成一些分类。 训练： MASKED LM : 随机遮盖或替换任意字词，让模型通过上下文的理解预测，做Loss时只计算被遮盖部分的Loss Next Sentence Prediction : 在句子中加特殊符号判断是否上下文相关，实际是一个分类问题 参数： 看到作者这句 但是经过我的实际测试, 结合我目前正在研究的命名实体识别, 语义分析, 关系抽取和知识图谱的需求, 发现其实这个参数比较过剩, 把参数缩减到2千万, 但即使这样, 使用一块11GB显存的2080Ti显卡, 训练维基百科语料的BERT也需要一周的时间 2千万。。。一周。。。11GB显存。。。感觉可以告辞了呢。。。 在数据集不够的情况下，使用BERT这种参数这么多的模型，训练会产生严重过拟合，泛化能力差的情况 就我们的项目而言，在现有条件下，基本可以告别这种方法了吧。。。 序列模型的深度学习建议使用PyTorch","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"BERT","slug":"BERT","permalink":"http://vergessenwang.github.io/tags/BERT/"},{"name":"Transformer","slug":"Transformer","permalink":"http://vergessenwang.github.io/tags/Transformer/"}]},{"title":"HMM与Viterbi算法","slug":"HMM与Viterbi算法","date":"2019-10-30T16:17:44.000Z","updated":"2019-10-30T16:25:30.761Z","comments":true,"path":"posts/NLP/2019-10-31-HMM与Viterbi算法.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-31-HMM与Viterbi算法.html","excerpt":"HMM作为一个生成式概率图模型，可以被用来处理序列标注的问题，如分词、词性标注，以及命名实体标注。 它把分词问题转为字的分类问题(序列标注问题)——由字构词，不依赖事先编制好的词表，但仍然需要分好词的训练语料 ，单字S，开始B-中间M-结尾E ， 已知观察序列求对应的形式化序列 HMM描述的是一个从 隐状态序列(如实体标记，所属集合是N种标签) 生成 可观测结果(如可读文本，所属集合是M个汉字) 的过程 第一假设是第 t 个时刻的隐状态只跟前一时刻 t - 1 时刻的隐状态有关，计算一个转移概率 —— N * N 的转移概率矩阵 第二个假设是观测独立，任意时刻观测 $o_t$ 只依赖 当前时刻的 隐状态 $i_t$, 计算一个发射概率—— N * M 的发射概率矩阵","text":"HMM作为一个生成式概率图模型，可以被用来处理序列标注的问题，如分词、词性标注，以及命名实体标注。 它把分词问题转为字的分类问题(序列标注问题)——由字构词，不依赖事先编制好的词表，但仍然需要分好词的训练语料 ，单字S，开始B-中间M-结尾E ， 已知观察序列求对应的形式化序列 HMM描述的是一个从 隐状态序列(如实体标记，所属集合是N种标签) 生成 可观测结果(如可读文本，所属集合是M个汉字) 的过程 第一假设是第 t 个时刻的隐状态只跟前一时刻 t - 1 时刻的隐状态有关，计算一个转移概率 —— N * N 的转移概率矩阵 第二个假设是观测独立，任意时刻观测 $o_t$ 只依赖 当前时刻的 隐状态 $i_t$, 计算一个发射概率—— N * M 的发射概率矩阵 那么如何用HMM来解决序列标注问题呢？ 首先是通过监督学习的方式获取参数，即首先有一些文本和标注对应的现有数据，然后训练一个HMM来拟合这些数据。最简单的方式是直接用极大似然估计来估计参数 假设我们已经通过建模学习到了初始概率、转移概率和发射概率这三大参数，就可以通过文本倒推出标记。 很显然，从HMM的假设和计算过程可以看出，求得的只是当前时刻的最优标注，不一定能得出全局最优序列路径 —— 解决： 维特比算法 维特比算法使用了动态规划算法来解决类似HMM和CRF的预测问题，找到概率最大路径，即文本处理中最优的实体标注序列。 它的简单原理可理解为：在每一个时刻，计算当前时刻落在每种隐状态的最大概率，并记录这个最大概率是从前一时刻哪一个隐状态转移过来的，最后再从结尾达到最大概率的那个隐状态回溯，就可以得到最有可能的最优路径。 有两个 N * M 的矩阵，第一个行 i 表示隐状态，列 j 表示时刻，矩阵单元表示第 j 时刻落到隐状态 i 的最大可能概率；第二个矩阵记录的是这个最大可能概率是从第 i - 1 时刻的哪一个隐状态 i 转移过来的， 即 最大可能概率的转移路径 关键在于计算最大可能概率。需要用到第一个矩阵，与HMM中的另外三个矩阵进行运算获得。 最优路径：假设有一条最优路径在 t 时刻通过一个隐状态 $i_t$ , 那么从 $i_t$ 到最优路径终点 $i_T$ 相对于 这段距离里所有可能出现的路径，也必须是最优的。 因此：从最后一步达到的最大概率的隐状态，根据第二个矩阵记录的转移状态向前回溯至第一时刻，就可以找到最优路径了。由此可以看出，第一个矩阵只用到了最后一列，在实际中可以用不断覆盖的方式的减少存储占用。 很显然，相对于HMM，Viterbi算法增加了一个时刻的概念，我的理解是这样其实是在求平均值…所以算法的复杂度为 $O(TN^2)$ 在实际的预测中，为了防止计算结果的下溢，将乘法变为取对数之后的加法 学习来源及git源码","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"HMM","slug":"HMM","permalink":"http://vergessenwang.github.io/tags/HMM/"},{"name":"Viterbi算法","slug":"Viterbi算法","permalink":"http://vergessenwang.github.io/tags/Viterbi算法/"}]},{"title":"KG子任务划分","slug":"KG子任务划分","date":"2019-10-30T08:32:26.000Z","updated":"2019-10-30T08:33:40.318Z","comments":true,"path":"posts/NLP/2019-10-30-KG子任务划分.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-30-KG子任务划分.html","excerpt":"首先我们需要考虑的是目前的搜索存在的问题。 当我们打开一个搜索引擎的时候，目前其实是想得到答案。然而，现在的互联网是一个基于HTML的网页结构以及相互直接通过URL相互链接。这种链接中有太多的无用信息，在其中寻找所需的信息往往是一个费时费力的过程。基于知识图谱的问答或搜索系统，可以从一定程度上解决这个问题。 KG的本质 Web角度：像建立文本之间的超链接一样建立数据之间的语义链接，并支持语义搜索 NLP视角：怎样从文本中抽取语义和结构化数据 KR视角：怎样利用计算机符号来表示和处理知识 AI视角：怎样利用知识库来辅助理解人的语言 DB视角：用图的方式去存储知识 传统KE的问题传统知识工程在规则明确、边界清晰、应用封闭的应用场景取得了巨大成功。缺点是体系是自上而下的：严重依赖专家和人的干预 。 解决方式：大规模自动知识获取 。基于大数据、ML，充分利用现代计算机的强大算力，从大量数据中自动进行信息挖掘。 这种数据驱动的知识获取是自下而上的，以维基百科页面内容为例： graph LR A[Wikipedia] -->B(预处理器 schema定义训练数据构造) B --> C{是否分类} C -->|未分类| D[分类器文本,句法分类] C -->|已分类| E[抽取器CRFmodel] D --> E E --> F[infobox] 以其为基础建立的数据库有：YAGO、 CN-DBpedia(以后仔细学习下API)等 知识图谱富含实体、概念(is)、属性(has)、关系等信息。以RDF或图的形式存储","text":"首先我们需要考虑的是目前的搜索存在的问题。 当我们打开一个搜索引擎的时候，目前其实是想得到答案。然而，现在的互联网是一个基于HTML的网页结构以及相互直接通过URL相互链接。这种链接中有太多的无用信息，在其中寻找所需的信息往往是一个费时费力的过程。基于知识图谱的问答或搜索系统，可以从一定程度上解决这个问题。 KG的本质 Web角度：像建立文本之间的超链接一样建立数据之间的语义链接，并支持语义搜索 NLP视角：怎样从文本中抽取语义和结构化数据 KR视角：怎样利用计算机符号来表示和处理知识 AI视角：怎样利用知识库来辅助理解人的语言 DB视角：用图的方式去存储知识 传统KE的问题传统知识工程在规则明确、边界清晰、应用封闭的应用场景取得了巨大成功。缺点是体系是自上而下的：严重依赖专家和人的干预 。 解决方式：大规模自动知识获取 。基于大数据、ML，充分利用现代计算机的强大算力，从大量数据中自动进行信息挖掘。 这种数据驱动的知识获取是自下而上的，以维基百科页面内容为例： graph LR A[Wikipedia] -->B(预处理器 schema定义训练数据构造) B --> C{是否分类} C -->|未分类| D[分类器文本,句法分类] C -->|已分类| E[抽取器CRFmodel] D --> E E --> F[infobox] 以其为基础建立的数据库有：YAGO、 CN-DBpedia(以后仔细学习下API)等 知识图谱富含实体、概念(is)、属性(has)、关系等信息。以RDF或图的形式存储 领域知识图谱的三个问题： 需要哪些业务知识？ ——分析实际应用需求 已有知识如何用最好的方式在计算机中存储？——建立从数据到知识库中实体、概念、关系的映射 如何基于问题寻求答案？—— 利用知识库中实体、概念、 关系解释现象的过程 知识表示怎样用计算机符号来表示人脑知识，及如何用符号运算进行推理 基于数理逻辑的知识表示现在主流的是RDF: RDF三元组语义模型 RDF图：有向标记图——存整图(多元关系) RDFS: 更加细分 通过OWL(本体论)对RDF模式进行拓展，能表示更复杂的类和属性 基于向量空间学习的分布式知识表示在保留语义的同时，将KG中的实体和关系映射到连续的稠密和低维向量空间。 KG-Emdedding: 要用到张量分解、神经网络、距离模型等知识 知识抽取 文本预处理 分词，词性标注，语法解析，依存分析 命名实体识别，实体链接 关系抽取，事件抽取 抽取方法 知识工程： 用正则表达式、模板匹配、规则约束——人工干预较多 基于本体的抽取：对应KR中的图、Embedding—— 主要是为了后续知识推理 基于模型的抽取：模型有SVM/Logistic/CRF/LSTM 等，训练有有监督学习、无监督聚类、远程监督——自学习 知识存储用关系型数据库存抽取完的三元组数据，然后导入到图数据库中是主流做法，不做深入对比。 知识问答问句 –&gt; 语义解析 –&gt; 问题语义表示 语义表示方法： 基于符号 基于问题模板 基于子图 基于分布式 知识推理有些问题并不是一步就可以获得答案的，需要进行多步推理才能知道。 按解决方法分类： 基于描述逻辑：本体推理 基于统计规则挖掘 基于路径排序学习方法(PRA) 基于关联规则挖掘犯法(AMIE) 基于表示学习与神经网络: 将实体和关系都表示为向量，用向量计算代替图遍历","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"KG","slug":"KG","permalink":"http://vergessenwang.github.io/tags/KG/"}]},{"title":"LSTM模型浅析","slug":"LSTM模型浅析","date":"2019-10-28T16:07:36.000Z","updated":"2019-10-28T16:09:33.769Z","comments":true,"path":"posts/NLP/2019-10-29-LSTM模型浅析.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-29-LSTM模型浅析.html","excerpt":"在对神经网络类算法模型一无所知的时候，我就曾想过信息与时序的问题，并陷入混乱中…今天开始看BiLSTM的原理时，才发现早就有了相应的解决方案… 神经网络的灵感来自于人脑神经元的工作方式，然而为了在计算机中实现，依然是个跟加权有关的数学问题，权重决定了信息的重要程度。每个节点虽然有多个输入输出，但是一种状态下只是二值问题。神经网络的隐藏层越多，处理复杂问题的能力也就越强。 历史模型的局限普通的神经网络(NN)：各输入层之间没有运算连接，无法表示上下文关系 $h_t = sigmoid(W_x * x_t + b)$ 循环神经网络(RNN): 其实比较类似于进位加法链，上一次运算的结果会加入到下一次运算中。这种基于时序的处理，只包含了上文信息，而忽略了下文信息。如果用增加依赖步数的方式，会导致把精力都集中在记忆大量的输入信息上，从而使建模能力下降。还有一个问题是RNN比较难以训练，逐步求导的梯度下降方式可能产生梯度爆炸问题 $h_t = tanh(W_x x_t + W_h h_{t-1} +b)$ 双向循环神经网络(BRNN): 再增加一个向后的网络，使得未来信息被包含进来。然而，仍然存在存取的上下文信息范围有限的问题，随着网络环路的不断递归，隐含层的影响是会不断衰减的，即长期依赖问题，这就引出了关于权重的考虑，什么样的信息是重要的，需要在后续的计算中一直保留呢？ 于是出现了 LSTM 长短期记忆(LSTM): 核心是基于门函数的自我衡量的机制，通过记忆门与遗忘门来控制之前的影响，相比于RNN，多了一个输入和输出，它们控制的是长期记忆。LSTM用细胞状态来表示内部复杂的处理过程。 双向长短期记忆(BiLSTM): 即增加一个反向的LSTM。两个方向的结果拼接后得最终结果。 门控循环单元（GRU）：将忘记和输入门结合成一个“更新门”，它还合并了单元状态和隐藏状态，并做了一些其他更改。由此产生的模型比标准的LSTM模型更简单，并且越来越受欢迎。","text":"在对神经网络类算法模型一无所知的时候，我就曾想过信息与时序的问题，并陷入混乱中…今天开始看BiLSTM的原理时，才发现早就有了相应的解决方案… 神经网络的灵感来自于人脑神经元的工作方式，然而为了在计算机中实现，依然是个跟加权有关的数学问题，权重决定了信息的重要程度。每个节点虽然有多个输入输出，但是一种状态下只是二值问题。神经网络的隐藏层越多，处理复杂问题的能力也就越强。 历史模型的局限普通的神经网络(NN)：各输入层之间没有运算连接，无法表示上下文关系 $h_t = sigmoid(W_x * x_t + b)$ 循环神经网络(RNN): 其实比较类似于进位加法链，上一次运算的结果会加入到下一次运算中。这种基于时序的处理，只包含了上文信息，而忽略了下文信息。如果用增加依赖步数的方式，会导致把精力都集中在记忆大量的输入信息上，从而使建模能力下降。还有一个问题是RNN比较难以训练，逐步求导的梯度下降方式可能产生梯度爆炸问题 $h_t = tanh(W_x x_t + W_h h_{t-1} +b)$ 双向循环神经网络(BRNN): 再增加一个向后的网络，使得未来信息被包含进来。然而，仍然存在存取的上下文信息范围有限的问题，随着网络环路的不断递归，隐含层的影响是会不断衰减的，即长期依赖问题，这就引出了关于权重的考虑，什么样的信息是重要的，需要在后续的计算中一直保留呢？ 于是出现了 LSTM 长短期记忆(LSTM): 核心是基于门函数的自我衡量的机制，通过记忆门与遗忘门来控制之前的影响，相比于RNN，多了一个输入和输出，它们控制的是长期记忆。LSTM用细胞状态来表示内部复杂的处理过程。 双向长短期记忆(BiLSTM): 即增加一个反向的LSTM。两个方向的结果拼接后得最终结果。 门控循环单元（GRU）：将忘记和输入门结合成一个“更新门”，它还合并了单元状态和隐藏状态，并做了一些其他更改。由此产生的模型比标准的LSTM模型更简单，并且越来越受欢迎。 英文参考文章 中文参考文章 LSTM的应用领域 one to many: 如给出一个图片，生成描述语句；由一个单词写出一篇诗 many to one : 如 视频分类 many to many: 结构对应如手写识别 或 不对应 如给一个视频生成描述 总之，与序列有关的都可以用该模型来处理，特别是上下文有关的情况 在实践中，一般先用CNN抽取特征，再用LSTM进行序列学习 神经网络是一个工具，很多库都已经实现了，不用多度担心其中的数学问题和实现难度，更应该关心的是你的问题到底适应什么样的网络结构，训练数据多大，能承受多深的神经网络。这考验的其实是工程能力 实现LSTM的训练对内存要求较高，训练一般就是10~20 的序列长度, 预测的长度没有太大限制。参数设置就是炼丹… 了解一种DL框架，如TensorFlow , PyTorch, 内部都已经集成了LSTM，知道如何调用就行","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"CNN","slug":"CNN","permalink":"http://vergessenwang.github.io/tags/CNN/"},{"name":"LSTM","slug":"LSTM","permalink":"http://vergessenwang.github.io/tags/LSTM/"}]},{"title":"KBQA中的一些问题","slug":"KBQA中的一些问题","date":"2019-10-27T16:57:09.000Z","updated":"2019-10-27T17:06:58.328Z","comments":true,"path":"posts/NLP/2019-10-28-KBQA中的一些问题.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-28-KBQA中的一些问题.html","excerpt":"QA知识来源：结构化知识(KB)、半结构化知识、非结构化知识、文本摘要、机器翻译 这里的KB主要有：Freebase,DBPedia,Yago 等现有知识库 知识库KB：RDF + SPARQL，问题—在高异质性的KB中写SPARQL语句很困难 KBQA : 由于缩写、同义词、数学换算等可能导致失配 —&gt; 同义转换 —&gt; 用CRF 计算候选匹配排名 —&gt; 有反馈的特定排名(要与用户交互，实现困难) 统计方法和神经学习方法的主要区别： 统计：人工设计规则和特征；从数据中学习权重 神经：特征和权重都是从数据中学习来的，需要极大的训练数据集 同义问题转换：从原始问句中抽象出实体(基于主题实体和上下文寻找抽象)，将含抽象实体的问题通过重排转为已有问题模板。通过问题类型接口（基于Bi-LSTM）获取答案。","text":"QA知识来源：结构化知识(KB)、半结构化知识、非结构化知识、文本摘要、机器翻译 这里的KB主要有：Freebase,DBPedia,Yago 等现有知识库 知识库KB：RDF + SPARQL，问题—在高异质性的KB中写SPARQL语句很困难 KBQA : 由于缩写、同义词、数学换算等可能导致失配 —&gt; 同义转换 —&gt; 用CRF 计算候选匹配排名 —&gt; 有反馈的特定排名(要与用户交互，实现困难) 统计方法和神经学习方法的主要区别： 统计：人工设计规则和特征；从数据中学习权重 神经：特征和权重都是从数据中学习来的，需要极大的训练数据集 同义问题转换：从原始问句中抽象出实体(基于主题实体和上下文寻找抽象)，将含抽象实体的问题通过重排转为已有问题模板。通过问题类型接口（基于Bi-LSTM）获取答案。 答案的扩展：给出直接和相关答案。 —&gt; 深拷贝？(这里没看懂) 冷启动问题：众包…(告辞) QA进化：生成富多样性的问题集，依旧需要众包干预 总结：这篇论文讲的主要是在已有的知识库查询中，如何提高自然语句转为SQL语句准确率，由于我们并不打算在项目中用SQL语句，故不对实现做深入了解。后面还有根据问题对相应网页进行操作如填写表单，这种高级内容就不看了吧…也许以后的百度音箱能实现… 思考：也许需要重新审视一下端到端这个概念了，真正含义是给出一个复杂的包含各种条件约束的自然语句问题，直接给出确切答案。那么很显然传统的语句查询无法同时处理这么多的条件，而在KB中我们可以沿着关系用一种传递的方式去查询，那么问题来了，如果确定关系约束的先后顺序，不至于由于顺序错误中断查询过程，似乎是一个难度较大的问题。所以，我们的项目只能尽量简化问题了… 值得进一步学习：Bi -LSTM模型, CRF模型 本文内容学习自：CCKS19_ATT_XifengYan","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"QA","slug":"QA","permalink":"http://vergessenwang.github.io/tags/QA/"}]},{"title":"Socket编程实践","slug":"Socket编程实践","date":"2019-10-26T11:30:03.000Z","updated":"2019-10-26T11:33:14.658Z","comments":true,"path":"posts/network/2019-10-26-Socket编程实践.html","link":"","permalink":"http://vergessenwang.github.io/posts/network/2019-10-26-Socket编程实践.html","excerpt":"之前写过socket编程的原理 , 正好高级网络实验课要写socket程序，故总结一下实践中的一些问题。 Winsock实现由于我的系统是windows，所以采用Winsock接口。 MFC提供了两个类用以封装Windows Sockets API CAsyncSocket类：具有一定网络编程经验的开发人员 CSocket类：由CAsyncSocket类派生，简化网络编程 需要包含Winsock2.h，Winsock32.dll和ws2_32.lib 端口选择：端口1024以前的端口号都是系统保留的或是作为公共服务的，应尽量选择大于1024的端口号 WinSock初始化Windows 下的 socket 程序依赖 Winsock.dll 或 ws2_32.dll，必须提前加载。 调用任何一个Winsock函数之前都必须检查协议栈安装情况，使用函数WSAStartup() 调用winsock DLL","text":"之前写过socket编程的原理 , 正好高级网络实验课要写socket程序，故总结一下实践中的一些问题。 Winsock实现由于我的系统是windows，所以采用Winsock接口。 MFC提供了两个类用以封装Windows Sockets API CAsyncSocket类：具有一定网络编程经验的开发人员 CSocket类：由CAsyncSocket类派生，简化网络编程 需要包含Winsock2.h，Winsock32.dll和ws2_32.lib 端口选择：端口1024以前的端口号都是系统保留的或是作为公共服务的，应尽量选择大于1024的端口号 WinSock初始化Windows 下的 socket 程序依赖 Winsock.dll 或 ws2_32.dll，必须提前加载。 调用任何一个Winsock函数之前都必须检查协议栈安装情况，使用函数WSAStartup() 调用winsock DLL 1234567891011121314151617181920212223#include &lt;WinSock2.h&gt;#pragma comment(lib, \"ws2_32.lib\") //加载 ws2_32.dllvoid main()&#123; WORD wVersionRequested; //指定使用的版本号 WSADATA wsaData; //返回关于Winsock实现的详细信息 wVersionRequested = MAKEWORD(2, 2); // 用宏获得版本号 if (WSAStartup(wVersionRequested, &amp;wsaData) != 0)//初始化ws2_32.dll动态库 &#123; printf(\"WSAStartup() failed!\\n\");//Winsock初始化错误 exit(-1); &#125; if (wsaData.wVersion != wVersionRequested) &#123; printf(\"The version of Winsock is not suited!\\n\");//Winsock版本不匹配 WSACleanup();//结束对ws2_32.dll的调用 exit(-1); &#125; //说明ws2_32.dll正确加载 printf(\"Load ws2_32.dll successfully!\\n\"); system(\"pause\");&#125; 创建套接字当type指定为SOCK_STREAM或SOCK_DGRAM时，因为系统已明确使用tcp和udp来工作，protocol可指定为0 123456789101112#define SERV_PORT 6789 // 定义端口#define SERV_IP \"127.0.0.1\" //定义IP/* 创建套接字*/SOCKET ssock = socket(AF_INET, SOCK_STREAM, 0); // 设置IP地址族，socket类型，协议类型,创建一个套接字//初始化socket addr_in结构sockaddr_in server;memset(&amp;server, 0, sizeof(server)); //数据清零server.sin_family = AF_INET; // IP地址类型server.sin_addr.s_addr = inet_addr(SERV_IP); //将IP转成网络字节序server.sin_port = htons(SERV_PORT); //将端口号转为网络字节序printf(\"Socket OK!\\n\"); 编译时报错：Use inet_pton() or InetPton() instead or define _WINSOCK_DEPRECATED_NO_WARNINGS to disable deprecated API warnings 问题的解决：1、用所提示的新函数代替inet_addr函数。2、修改VS配置，告诉它我就要旧函数，修改方法：项目-&gt;属性-&gt;C/C++-&gt;常规-&gt;SDL检查，将“是”改为“否”，即可 主机序与网络字节序主机序：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序。分为大端和小端两种方式 测试主机序 1234567891011121314#include &lt;stdio.h&gt;//判断本机的字节序//返回true表为小段序。返回false表示为大段序bool am_little_endian ()&#123; unsigned short i=1; return (int)*((char *)(&amp;i)) ? true : false;&#125;int main()&#123; if(am_little_endian()) printf(\"本机字节序为小段序!\\n\"); else printf(\"本机字节序为大段序!\\n\"); return 0;&#125; 本机测试结果为：小端序 网络字节序：TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian排序方式。 于是，在数据处理时涉及到字节顺序转换的问题。这里用inet_addr htons 处理 绑定端口(服务器)123456789/*绑定套接字和端口 */int iSockErr =0;//建立一个绑定，参数类型需要强转,中间的参数表示指向SOCKADDR结构的地址iSockErr = bind(ssock, (struct sockaddr*)&amp;server, sizeof(sockaddr)); if (iSockErr == SOCKET_ERROR) &#123; WSAGetLastError();//根据不同的错误类型进行不同的处理 exit(1);&#125;printf(\"Bind OK!\\n\"); 监听端口(服务器)1234567/* 监听连接请求 */ iSockErr = listen(ssock, 128); // 限定同时建立连接的客户端数量 if (iSockErr == SOCKET_ERROR) &#123; WSAGetLastError();//根据不同的错误类型进行不同的处理 exit(1); &#125; printf(\"Listenning......\\n\"); 发起连接(客户端)在客户端使用connect请求建立连接时，将激活建立连接的三次握手，用来建立一条到服务器TCP的连接。 1234567/* 发起连接请求*/int iSockErr = 0;iSockErr = connect(sock, (struct sockaddr*)&amp;server, sizeof(sockaddr));if (iSockErr == SOCKET_ERROR) &#123; WSAGetLastError();//根据不同的错误类型进行不同的处理 exit(1);&#125; 处理连接请求(服务器)accept用于面向连接的服务器端，在IP协议族中，只用于TCP服务器端 accept接受一个socket的连接请求，同时返回一个新的socket，新的socket用来在服务器与客户端之间传递和接收信息 此时socket表示处于监听状态的socket，地址是客户机的IP地址 12345/*阻塞等待客户端发起连接，三次握手成功建立连接后会返回一个新的文件描述符指向客户端socket,用于真正数据传输*/ SOCKADDR client; int nSize = sizeof(SOCKADDR); SOCKET csock = accept(ssock, (SOCKADDR*)&amp;client, &amp;nSize); printf(\"Connect OK!\\n\"); 获取客户端的数据并处理(服务器)12345678910111213141516171819202122232425262728293031// 客户端 while (1) &#123; char buffer[1024] = \"\\0\"; printf(\"Input the string you want transfer-------------\\n\"); scanf(\"%s\", buffer); if (send(sock, buffer, sizeof buffer, 0) != SOCKET_ERROR) &#123; if (recv(sock, buffer, sizeof buffer, 0) != SOCKET_ERROR) printf(\"Received datagram from TCP server:%s\\n\", buffer); &#125; &#125;// 服务器 while (1) &#123; char buffer[1024] = \"\\0\"; printf(\"Waiting for message from client-------------\\n\"); if (recv(csock, buffer, sizeof buffer, 0) != SOCKET_ERROR) //从recv缓冲区读入数据，没有数据会阻塞 &#123; for (int i = 0; i &lt; sizeof buffer; i++) &#123; char ch = buffer[i]; if (ch &gt;= 'a'&amp;&amp;ch &lt;= 'z') buffer[i] = ch - 32; &#125; ////给cilent发转为大写的数据 send(csock, buffer, sizeof buffer, 0); &#125; Sleep(500); &#125; 关闭套接字123456//关闭套接字closesocket(ssock);closesocket(csock);//终止 DLL 的使用WSACleanup(); Linux实现Windows 下的 socket 程序和 Linux 思路相同，但细节有所差别： 1) Windows 下的 socket 程序依赖 Winsock.dll 或 ws2_32.dll，必须提前加载。 2) Linux 使用“文件描述符”的概念，而 Windows 使用“文件句柄”的概念；Linux 不区分 socket 文件和普通文件，而 Windows 区分；Linux 下 socket() 函数的返回值为 int 类型，而 Windows 下为 SOCKET 类型，也就是句柄。 3) Linux 下使用 read() / write() 函数读写，而 Windows 下使用 recv() / send() 函数发送和接收。 4) 关闭 socket 时，Linux 使用 close() 函数，而 Windows 使用 closesocket() 函数。 服务器端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt; // 包含 sockaddr_in 结构体#include &lt;ctype.h&gt; // 大小写转换#include &lt;string.h&gt; // 包含bzero#define SERV_PORT 6666#define SERV_IP \"127.0.0.1\"int main() &#123; int lfd,cfd; struct sockaddr_in serv_addr,client_addr; socklen_t client_addr_len,client_IP_len; char buf[BUFSIZ],client_IP[BUFSIZ]; int n,ret; lfd = socket(AF_INET, SOCK_STREAM, 0); //创建一个套接字，返回文件描述符指向服务器socket if (lfd == -1) &#123; perror(\"socket error\"); // 如果在连接状态先关掉server，那么并不会真正关闭，端口还占用，下一次启动就会出现问题 exit(1); &#125; //结构体初始化 bzero(&amp;serv_addr, sizeof(serv_addr)); // 缓冲区清零 serv_addr.sin_family = AF_INET; // IP地址类型 serv_addr.sin_port = htons(SERV_PORT); //将端口号转为网络字节序 serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); //将IP转成网络字节序，INADDR_ANY自动获取当前网卡上有效IP ret = bind(lfd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)); //建立一个绑定，参数类型需要强转 if (ret == -1) &#123; perror(\"bind error\"); exit(1); &#125; ret = listen(lfd, 128); // 限定同时建立连接的客户端数量 if (ret == -1) &#123; perror(\"listen error\"); exit(1); &#125; client_addr_len = sizeof(client_addr); //阻塞等待客户端发起连接，三次握手成功建立连接后会返回一个新的文件描述符指向客户端socket,用于真正数据传输 cfd = accept(lfd, (struct sockaddr*)&amp;client_addr, &amp;client_addr_len); if (cfd == -1) &#123; perror(\"accept error\"); // 如果在连接状态先关掉server，那么并不会真正关闭，端口还占用，下一次启动就会出现问题 exit(1); &#125; printf(\"client IP：%s,client port:%d\\n\", inet_ntop(AF_INET, &amp;client_addr.sin_addr.s_addr,client_IP,sizeof(client_IP), ntohs(client_addr.sin_port)); while (1) &#123; n = read(cfd, buf, sizeof(buf)); //从read缓冲区读入数据，没有数据会阻塞 for (int i = 0; i &lt; n; i++) &#123; buf[i] = toupper(buf[i]); &#125; write(cfd, buf, n); // socket双向通信，故有两个缓冲区，双向全双工 // read 和 write 缓冲区在内核中， 而char buf[] 是用户定义的，在stack中 &#125; close(lfd); close(cfd); return 0;&#125; 客户端 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; // memset 的头文件#include &lt;arpa/inet.h&gt; // 包含 sockaddr_in 结构体#define SERV_PORT 6666#define SERV_IP \"127.0.0.1\"int main() &#123; int cfd; struct sockaddr_in serv_addr; // socklen_t serv_addr_len; char buf[BUFSIZ]; int n; cfd = socket(AF_INET, SOCK_STREAM, 0); //结构体初始化 memset(&amp;serv_addr,0,sizeof(serv_addr); // 指针清空，防止默认取随机值 serv_addr.sin_family = AF_INET; // IP地址类型 serv_addr.sin_port = htons(SERV_PORT); //将端口号转为网络字节序 inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr); connect(cfd,(struct sockaddr*)&amp;serv_addr,sizeof(serv_addr)); // linux 会隐式bind while (1) &#123; fgets(buf, sizeof(buf), stdin);//输入要处理的数据，没有数据会阻塞 write(cfd, buf, strlen(buf); // 将从键盘接收的数据写入write n = read(cfd, buf, sizeof(buf)); write(STDOUT_FILENO, buf, n); &#125; close(cfd); return 0;&#125;","categories":[{"name":"network","slug":"network","permalink":"http://vergessenwang.github.io/categories/network/"}],"tags":[{"name":"C/S","slug":"C-S","permalink":"http://vergessenwang.github.io/tags/C-S/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://vergessenwang.github.io/tags/TCP-IP/"},{"name":"Socket","slug":"Socket","permalink":"http://vergessenwang.github.io/tags/Socket/"}]},{"title":"不能用一种猛兽克制另一种猛兽","slug":"不能用一种猛兽克制另一种猛兽","date":"2019-10-16T14:08:32.000Z","updated":"2019-10-16T14:12:36.299Z","comments":true,"path":"posts/life/2019-10-16-不能用一种猛兽克制另一种猛兽.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2019-10-16-不能用一种猛兽克制另一种猛兽.html","excerpt":"","text":"可能我身体里的电池是二手的，新奇和幻灭交织着，加剧了消耗，在极短时间将其拔空。 在椅子上呆坐了一会，预感到它即将从虚空的深渊里爬出来。 我们不能看到一个人生命中全部的雪，每个人都在他自己的生命里，孤独地过冬。 我坐在从起点站出发去往市里的公车上，头倚着窗户，脑海里盘旋着这句话。 我喜欢坐起点出发的公车，喜欢在非节假日，一个人逛街。当我的情绪被耗干的时候。 车上零星的上来几个老头老太太，到小学门口下车，挤成一团，早早地等着他们的小祖宗。路过很多绿河青柳，桥的名字都一律地很有诗意。很有人间气息，可我面无表情。 要飘到高空的时候，得用什么东西把自己绑住。于是我在一个个商场里进进出出。为了克制一只猛兽，我放出了另一只猛兽。它沉沉压着我的双肩，像浸过水的稻草。直到连体力都被抽干。 它们嗅了嗅干枯的躯壳，终于渐渐离去了。 坐着等公交的时候，心算了一下好像被多收了钱。可是完全不想动。最终还是回去找了她们重算，这样多的钱就可以打滴滴了。 总是这样，用各种莫名其妙的借口。消耗。 重又坐到宿舍的椅子上，反思着白天发生的事情。 每个人都是一个正弦波，频率和相位一致，才能共振。否则，要么充斥着恼人的冲突，要么甚至合为一条无波的曲线。 我的振幅太小了，大概始终只能当个谐波。被迫提高振幅，就会加剧消耗。又给自己找了一个完美借口。 八点了，想起来还没吃饭。拖着游魂般的步子，路过玩滑板的少年。 真实的灵魂，不能直视。 明日又在大地中完整，这才是我打碎一切的真情。","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[{"name":"脱缰时刻","slug":"脱缰时刻","permalink":"http://vergessenwang.github.io/tags/脱缰时刻/"}]},{"title":"Anaconda、py2neo和Neo4j搭建KG简单环境","slug":"Anaconda、py2neo和Neo4j搭建KG简单环境","date":"2019-10-12T15:57:30.000Z","updated":"2019-10-12T16:01:03.973Z","comments":true,"path":"posts/NLP/2019-10-12-Anaconda、py2neo和Neo4j搭建KG简单环境.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-12-Anaconda、py2neo和Neo4j搭建KG简单环境.html","excerpt":"安装Anaconda官网下载地址 安装时不勾选Add Anaconda to my PATH environment variable因为勾选将会影响其他程序的使用 勾选Register Anaconda as my default Python 3.6 常用命令参考 在Anaconda Prompt中输入 conda list ，可以查看已经安装的包名和版本号 创建虚拟环境conda create -n &lt;env_name&gt; &lt;package_names&gt; 如 conda create -n KGQA python=3.5 激活环境activate &lt;env_name&gt; 退出deactivate 在当前环境中安装包 conda install &lt;package_name&gt; , 然鹅很多包都没法用conda渠道安装，还是要用pip才行。根据本项目安装了flask、py2neo、pyltp和bs4 还可以用requirement.txt文件来批量安装依赖包conda install --yes --file requirements.txt pyltp包安装出错解决期间报错 1PackagesNotFoundError: The following packages are not available from current channels: - pyltp 换成 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyltp 命令进行安装 ，仍然不行, 说是找不到wheels 找到了一个py3.5版本wheels源码链接, 参看 将下载好的文件放在此时Prompt命令行对应的文件夹中，如我的是 (KGQA) C:\\Users\\18771 然后执行pip install pyltp-0.2.1-cp35-cp35m-win_amd64.whl 即可安装成功wheels文件 输入conda list 发现有了pyltp安装包","text":"安装Anaconda官网下载地址 安装时不勾选Add Anaconda to my PATH environment variable因为勾选将会影响其他程序的使用 勾选Register Anaconda as my default Python 3.6 常用命令参考 在Anaconda Prompt中输入 conda list ，可以查看已经安装的包名和版本号 创建虚拟环境conda create -n &lt;env_name&gt; &lt;package_names&gt; 如 conda create -n KGQA python=3.5 激活环境activate &lt;env_name&gt; 退出deactivate 在当前环境中安装包 conda install &lt;package_name&gt; , 然鹅很多包都没法用conda渠道安装，还是要用pip才行。根据本项目安装了flask、py2neo、pyltp和bs4 还可以用requirement.txt文件来批量安装依赖包conda install --yes --file requirements.txt pyltp包安装出错解决期间报错 1PackagesNotFoundError: The following packages are not available from current channels: - pyltp 换成 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyltp 命令进行安装 ，仍然不行, 说是找不到wheels 找到了一个py3.5版本wheels源码链接, 参看 将下载好的文件放在此时Prompt命令行对应的文件夹中，如我的是 (KGQA) C:\\Users\\18771 然后执行pip install pyltp-0.2.1-cp35-cp35m-win_amd64.whl 即可安装成功wheels文件 输入conda list 发现有了pyltp安装包 在Pycharm中切换解释器在pycharm中将项目解释器切换到上面新建的环境 settings -&gt; project interpreter -&gt; add local -&gt; 找到Anconda3文件夹 -&gt; envs -&gt; KGQA -&gt; python.exe 图数据库neo4j的使用对比于关系型数据库，图数据库的最大好处在于，跨表检索时不需要复杂的连接操作——而我个人的理解是，这种操作的复杂性被转移到了图数据库的最初设计中，所以知识图谱问题的本质，其实是一个数据库设计的问题，这其中涉及到我们要用什么——应用需求，存什么——概念设计，怎么存——逻辑和物理设计，怎么呈现——问答可视化 存储类型实体(节点)——实体分类 关系(边)——关系类型 实体和关系的属性——以键值对存储 下载安装Neo4j官网下载速度真令人崩溃 国内镜像及文档——然而好像也打不开 还好找到一个云盘链接 新建环境变量：变量名NEO4J_HOME 路径C:\\Users\\18771\\Desktop\\知识图谱\\neo4j-community-3.5.5-windows\\neo4j-community-3.5.5 Win+X+A快捷键以管理员身份运行命令行，切换到bin所在目录，输入neo4j.bat console 启动服务，运行端口为7474 在浏览器中打开，默认的可视乎host是bolt://localhost:7687，默认的用户是neo4j，默认的密码是：neo4j，第一次成功connect到Neo4j服务器之后，需要重置密码。 进入界面后就可以开始编写Cypher语句创建数据了 py2neo将数据导入Neo4jPycharm上运行起github上一个KG的demo 修改neo_db目录下的配置文件config.py,设置图数据库的账号和密码。 切换到neo_db目录下，执行python create_graph.py 建立知识图谱 此时报错 1py2neo cannot import name 'NodeSelector' 尝试 pip install git+https://github.com/nigelsmall/py2neo.git#egg=py2neo 不行。这个github上给的解决方法是升级到v3 , 而实际上我目前的py2neo版本已经是4.3.0版本 解决：将 NodeSelector 改为 NodeMatcher 接着运行，又报错 1FileNotFoundError: [Errno 2] No such file or directory: './raw_data/relation.txt' 因为windows父级目录是 ../ 再次运行，又粗线了… 1UnicodeDecodeError: 'gbk' codec can't decode byte 0x96 in position 15: illegal multibyte sequence 更改一下打开格式 with open(&quot;../raw_data/relation.txt&quot;) as f: 改为 with open(&quot;../raw_data/relation.txt&quot;, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f: 这下运行导入成功了，在localhost:7687可以看到导入的数据","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"Anaconda","slug":"Anaconda","permalink":"http://vergessenwang.github.io/tags/Anaconda/"},{"name":"py2neo","slug":"py2neo","permalink":"http://vergessenwang.github.io/tags/py2neo/"},{"name":"pyltp","slug":"pyltp","permalink":"http://vergessenwang.github.io/tags/pyltp/"},{"name":"Neo4j","slug":"Neo4j","permalink":"http://vergessenwang.github.io/tags/Neo4j/"}]},{"title":"Java前四章笔记","slug":"Java前四章笔记","date":"2019-10-11T12:33:53.000Z","updated":"2020-03-11T15:36:48.343Z","comments":true,"path":"posts/Java/2019-10-11-Java前四章笔记.html","link":"","permalink":"http://vergessenwang.github.io/posts/Java/2019-10-11-Java前四章笔记.html","excerpt":"CH1文档 参考书：Java编程思想(英文版第 4版) Java 核心技术(英文版第 9版） 补充知识：JavaEE 数据库 软件设计 Java虚拟机原理 Leetcode刷题 .java -&gt; (编译器) -&gt; .class -&gt; (Java虚拟机) -&gt; 机器码程序 编译：javac HelloWorldApp.java 运行：java HelloWorldApp arg1 arg2 JRE 只包含虚拟机，没有编译器 文档型注释：/* documentation / main方法public static void main(String[] args) 以上写法只是通常用的：public和static的位置可以交换；args 可以任意命名，如argv； 作为程序入口，必须是public 才能在任意地方被访问到 由于在启动程序时还没有任何对象，所以只能static方法——无需使用对象就可以调用静态方法 每个类可以有一个main方法，这是一个常用于对类进行单元测试的技巧。当该类所属的应用程序的main方法被执行时，该类本身的main将不会被执行","text":"CH1文档 参考书：Java编程思想(英文版第 4版) Java 核心技术(英文版第 9版） 补充知识：JavaEE 数据库 软件设计 Java虚拟机原理 Leetcode刷题 .java -&gt; (编译器) -&gt; .class -&gt; (Java虚拟机) -&gt; 机器码程序 编译：javac HelloWorldApp.java 运行：java HelloWorldApp arg1 arg2 JRE 只包含虚拟机，没有编译器 文档型注释：/* documentation / main方法public static void main(String[] args) 以上写法只是通常用的：public和static的位置可以交换；args 可以任意命名，如argv； 作为程序入口，必须是public 才能在任意地方被访问到 由于在启动程序时还没有任何对象，所以只能static方法——无需使用对象就可以调用静态方法 每个类可以有一个main方法，这是一个常用于对类进行单元测试的技巧。当该类所属的应用程序的main方法被执行时，该类本身的main将不会被执行 一些细节Java不只是一种语言，而是一个包含各种可重用代码的库以及安全性、可移植性、垃圾回收机制的平台。 相比于C++,java没有头文件、指针运算、结构、联合、操作符重载、虚基类等。 程序设计语言的成功更多取决于其支撑系统的能力，而不是优美的语法。 访问修饰符用于控制程序的其他部分对这段代码的访问级别。 将类作为一个加载程序逻辑的容器，程序逻辑定义了应用程序的行为。Java中的全部内容都必须放在类中，所有的函数都属于某个类的方法，因此main方法必须有一个外壳类而且必须是静态的。 类名采用驼峰命名法，且文件名要与公共类名相同。 Java中所有数据类型所占的字节数是与平台无关的，也没有无符号类型。绝大多数应用程序都采用double类型来表示浮点数。没有f或F后缀的浮点数默认为double类型。 检验一个值是否为NaN, 不能用 x == NaN ,因为所有非数值的值都是不相同的。 但是可用 Double.isNaN(x) 方法 CH2 OOP对象：实例域值(状态) + 方法(行为) 优点：模块化、信息隐藏、代码重用、易维护 设计：首先从设计类开始，然后再往每个类中添加方法。分析问题时名词对应数据域，动词对应方法 原则 数据封装(data encapsulation)：隐藏内部状态，所有对象之间的交互通过方法来实现；同时可以完全改变存储数据的方式，而不会影响外部使用 继承 ：可以通过扩展一个类来创建一个新类，并自定义方法和数据域。但是只能有一个父类——单继承 class Cat extends Animals 接口接口不是类，而是类的功能的描述，并不给出每个功能的具体实现。接口中所有方法默认属于public，但是在类中实现时必须显式声明为public 接口中可以定义常量，接口中的域默认为public static final。不能含有实例域或静态方法——接口没有实例，可以将接口看做没有实例域的抽象类 。但是一个类可以实现一个或多个接口——接口相比于抽象类的优势，类只能单继承。接口可以提供多继承的好处，并同时避免其复杂性和低效性 1234567891011121314151617//接口声明interface Bicycle&#123; void changeGear(int newValue); void speedUp(int increment);&#125;//类实现class ACMEBicycle implements Bicycle&#123; int speed = 0; int gear = 0; public void changeGear(int newValue)&#123; gear = newValue; &#125; public void speedUp(int increment)&#123; speed = speed + increment; &#125;&#125; 类必须实现接口中的所有方法，否则会出现编译错误 Interfaces form a contract between the class and the outside world, and this contract is enforced at build time by the compiler 接口不能用new运算符，但是可以声明一个接口类型的变量，该变量必须引用实现了接口的类对象 12Bicycle mybike;mybike = new ACMEBicycle(...) 接口也可以被扩展 Java8 之后，可在接口中实现简单静态方法了，但是这些方法不能引用实例域。这样就无需为该接口编写伴随类了——面向接口编程.. 考虑一个问题：当接口中新增方法时，是否所有伴随类都要对应改变——接口扩展或default方法(接口演化) default方法出现在Java8 之后，实不实现都可以，主要是为了兼容以及按需实现 超类优先——接口与超类的冲突：如果一个类从超类继承的方法与它所实现的接口中的某个默认方法同名，那么实际上只有超类的方法有效——主要是为了与Java7兼容 接口之间的冲突：需要重写 包 A package is a namespace that organizes a set of related classes and interfaces 使用包的主要原因是确保类名的唯一性，建议将域名逆序作为包名。 CH3 Java基础变量 实例变量——放在heap 类变量：静态变量，仅有一个，类和所有对象共享——放在方法区的静态域 局部变量：方法内部定义的变量，只对该方法可见。编译器不会给局部变量设置默认值，故一定要初始化——放在stack 参数 命名变量：单个词全小写gear 多个词从第二个单词开始首字母大写 gearRatio 常量全大写，_隔开 NUM_GEARS 类名：每个单词的首字母大写 方法名：第一个单词为小写动词 Java内存区域划分 栈：在函数中定义的基本类型变量和对象的引用变量都在函数的栈内存中分配。栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。 堆：通过new生成的对象都存放在堆中，对于堆中的对象生命周期的管理由Java虚拟机的垃圾回收机制GC进行回收和统一管理。优点是可以动态分配内存大小，缺点是由于动态分配内存导致存取速度慢。 方法区：是各个线程共享的内存区域，它用于存储class二进制文件，包含了虚拟机加载的类信息、常量(常量池)、静态变量(静态域)、即时编译后的代码等数据。包括： 常量池：常量池在编译期间就将一部分数据存放于该区域，包含以final修饰的基本数据类型的常量值、String字符串。 静态域：存放类中以static声明的静态成员变量。 程序计数器：当前线程所执行的行号指示器。通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。 更多关于Java内存分配内容参看 关键字及保留字 不太熟悉的关键字： 关键字 含义 assert 用来进行程序调试 finally 用于处理异常情况，用来声明一个基本肯定会被执行到的语句块 native 用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的 strictfp 用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范 synchronized 表明一段代码需要同步执行 transient 声明不用序列化的成员域 volatile 表明两个或者多个变量必须同步地发生变化 基本数据类型 boolean : true and false 整型值和布尔值不能相互转换 byte – short – int – long(字面量加L) 没有unsigned类型，字面量0x 十六进制 0b 二进制 float – double 字面量加F或D或用科学计数法 要求极高精度时，用java.math.BigDecimal class 所有数值类型所占据的字节数与平台无关 char : 16 bit Unicode ‘\\u0000’ ~’\\uffff’ —— 建议不要使用，用java.lang.String class抽象类型来处理 为了可读性，经常会在数值字面量中加入‘_’ 。但是要注意只能放在数字之间，不能用于： At the beginning or end of a number —— 数字首末 Adjacent to a decimal point in a floating point literal ——小数点前后 Prior to an F or L suffix —— F/L 之前，x/b 前后 In positions where a string of digits is expected —— 字符型数字 数组内置方法 长度：.length 复制：System class 中有 public static void arraycopy(Object src, int srcPos,Object dest, int destPos, int length) java.util.Arrays class 提供的方法 Searching an array for a specific value to get the index at which it is placed (the binarySearch() method). Comparing two arrays to determine if they are equal or not (the equals() method). Filling an array to place a specific value at each index (the fill() method). Sorting an array into ascending order. This can be done either sequentially, using the sort() method, or concurrently, usingthe parallelSort() method introduced in Java SE 8 位运算符对整数的二进制位进行处理，得到某个位的值。 &amp; and | or ^ xor ~ not >&gt;&gt; 无符号右移，高位补0 &gt;&gt; 高位补符号位 没有无符号左移 利用&amp;结合使用适当的2的幂，可以用掩码技术把其他位掩掉，只保留其中的某一位 如n &amp; 0b1000 注意： &amp; 和 | 不采用短路方法 控制语句在for循环中：If the variable that controls a for statement is not needed outside of the loop, it’s best to declare the variable in the initialization expression. for(int i = 1; i &lt; n; i++) 枚举循环 for(int item : numbers) 加了标签的break或 continue 语句可以同时跳出多层循环 CH4 类和对象构造器不要在构造器中定义与实例域重名的局部变量，因为会屏蔽实例域，而这些局部变量只能在构造器内部访问。当被屏蔽时可用this.来访问实例域 ，如 this.name = name this还可以用来调用同一类的另一个构造器，这样可以减少构造器公共部分的代码 Java允许重载任何方法，而不仅仅是构造器方法 仅当类没有提供任何构造器时，系统才会提供一个默认的无参构造器 调用构造器的具体步骤：—— 一般也应按以下顺序声明类，构造器通过new运算符调用，正因为构造器与类名一样，new才知道调用哪个，构造完毕返回一个引用 所有数据域被初始化为默认值(0,false,null) 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块——只要构造类的对象，这些块就会被执行。编译器会把初始化块(包括static初试化块)复制到每一个构造器中，因此可以实现复用 如果构造器第一行调用了第二个构造器，则执行第二个构造器 执行这个构造器的主体 参数传递可以传基本数据类型、引用数据类型，但是不允许传方法——可以传对象，再调用对象的方法 基础类型参数传值，实际上在方法内部复制了一份，内部改变对外部传入的原始值没有影响。随着方法执行完毕，这份复制也随之消失。 引用类型参数也是传的值，只不过这个值是引用，即地址。复制的也是地址，指向同一个区域，可以对所指对象进行修改。 方法返回值返回值声明为类时，可返回该类及其子类——也可以重写一个方法，使它返回子类，此为协变返回类型 ​ 具体来说：协变返回类型（Covariant Return Type），指的是当一个类被继承之后，该类中方法的返回类型变成子类对应的类型，这个改变后的返回类型就叫协变返回类型。—— 在方法重写中常用 返回值声明为接口时，可返回实现了该接口的类 this关键字this指向被构造的对象 当实例域被构造器或方法的参数屏蔽时，可在构造器和方法的内部用this关键字访问对象的实例域——还有个方法就是参数直接起不一样的名字 this关键字还可以用在构造器的第一行，用来调用该类的另一个构造器，称之为显式构造方法的调用——这样可以省略构造器的公共部分，如 123public Rectangle(int width, int height)&#123; this(0, 0, width, height);&#125; 访问修饰符默认为package-private 类修饰符有public和默认，成员另还有private和protected protected 能被本包所有类及其他包中该类的子类访问 static修饰符属于类且不属于类对象的变量和函数，建议用类名直接访问 一个常用的静态常量System.out: 1234public class System&#123; ... public static final PrintStream out = ...;&#125; 其中用static使得不需要创建对象就可以调用，final 用来防止被修改 静态方法没有this参数，所以不能访问实例域，但是可以访问自身类中的静态域，或者通过对象引用间接访问实例域和实例方法 使用静态方法的情况：无需访问实例域；只需访问静态域 嵌套类作用：加强封装，对只在一个地方使用的类进行合理的组织 嵌套类作为外围类的成员，因此可以被声明为private或protected 非静态嵌套类——内部类：可以访问外围类的所有成员，包括私有的。由此可见，内部类具有访问特权。在创建内部类实例之前，必须首先创建外围类的实例。 OuterClass.InnerClass innerObject = outerObject.new InnerClass(); 编译器修改了所有内部类的构造器，添加一个外围类引用的参数，用来访问外围类 静态嵌套类不能访问外部类的其他成员，而且跟静态方法一样，通过外围类名进行访问。静态类可以有静态域和方法——只隐藏即可，无需访问外部 局部类：不用public或private访问说明符声明，可以对外部世界完全隐藏 。不仅可以访问外围类，还可以访问final类的局部变量。局部类访问final局部变量或外围类参数的过程，称为变量捕获？—— 编译器在检测到对局部变量的访问之后，会在局部类的构造器中中拷贝一份局部变量，为了保证数据的一致性，所以必须为final 局部类和内部类都不能定义或声明静态方法，如果有静态域，必须是final的 匿名类：声明和实例化同时进行，而且仅创建这个类的一个对象，因此不用命名。可以实现接口，也可以是对超类进行扩展。因为没有名字，所以没有构造器，只能将构造器参数传递给超类构造器—— 访问权限及内部成员限制跟局部类一样 12345678// 实现接口,接口没有构造器，不能传参new InterfaceType()&#123; methods and data&#125;// 扩展超类new SuperType(construction parameters)&#123; inner class methods and data&#125; 枚举类型通过enum关键字来定义，如 1public enum Day &#123; SUNDAY, MONDAY, TUESDAY, WEDNESDAY,THURSDAY, FRIDAY, SATURDAY &#125; 枚举类型有一系列预定义的常量实例，也可以添加构造器、方法和域。比较时用== 不用equals() 所有枚举类型都是Enum类的子类，继承的方法有 String toString()——返回枚举常量名 static Enum valueOf(Class enumClass,String name) ——返回指定名字、给定类的枚举常量 values() ——返回一个包含全部枚举值的数组 如Day[] values = Day.values() int ordinal() 返回枚举常量在enum声明中的位置，从0开始计数 int compareTo(E other) 判断次序 通常与for......each 结合用来遍历","categories":[{"name":"Java","slug":"Java","permalink":"http://vergessenwang.github.io/categories/Java/"}],"tags":[]},{"title":"NER中的编码转换","slug":"NER中的编码转换","date":"2019-10-10T15:57:45.000Z","updated":"2020-05-13T00:51:53.799Z","comments":true,"path":"posts/NLP/2019-10-10-NER中的编码转换.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-10-NER中的编码转换.html","excerpt":"命名实体识别(NER)的作用：关系抽取、事件抽取、知识图谱(分构建和应用两个方向，构建目前人工干预还是需要很多)、问答系统、机器翻译… 通用实体分类：人名、地名、组织机构名、日期时间、专用名词 学术上的分类： 三大类：实体类、时间类、数字类 七小类：人名、地名、组织机构名、时间、日期、货币、百分比 相关算法早期：基于字典，基于规则 传统ML：HMM MEMM CRF DL: RNN-CRF CNN-CRF 学术界近期方法：注意力模型，迁移学习，半监督学习 —— 有时间了解下 BiLSTM + CRF 从双向神经网络输出的结果为什么还要经过CRF的处理？—— 输出的是一系列标签的概率，而且每个字之间是相互独立的，利用CRF的条件转移概率矩阵，可以改善输出结果 本次主要学习实体抽取前对中文字的词性标注后的编码转换，这是进行更深入信息抽取的基础工作","text":"命名实体识别(NER)的作用：关系抽取、事件抽取、知识图谱(分构建和应用两个方向，构建目前人工干预还是需要很多)、问答系统、机器翻译… 通用实体分类：人名、地名、组织机构名、日期时间、专用名词 学术上的分类： 三大类：实体类、时间类、数字类 七小类：人名、地名、组织机构名、时间、日期、货币、百分比 相关算法早期：基于字典，基于规则 传统ML：HMM MEMM CRF DL: RNN-CRF CNN-CRF 学术界近期方法：注意力模型，迁移学习，半监督学习 —— 有时间了解下 BiLSTM + CRF 从双向神经网络输出的结果为什么还要经过CRF的处理？—— 输出的是一系列标签的概率，而且每个字之间是相互独立的，利用CRF的条件转移概率矩阵，可以改善输出结果 本次主要学习实体抽取前对中文字的词性标注后的编码转换，这是进行更深入信息抽取的基础工作 加载数据获取训练数据集：采用github上的中文NER数据 数据导入 1234567891011121314151617181920212223def load_sentences(path): # 存放数据集 sentences = [] # 临时存放每一个句子 sentence = [] for line in codecs.open(path, 'r', encoding='utf8'): # 去掉两边空格 line = line.strip() if not line: # 是否读完一个句子 if len(sentence) &gt; 0: sentences.append(sentence) sentence = [] else: if line[0] == \" \": continue else: word = line.split() assert len(word) &gt;= 2 sentence.append(word) # 确保最后一个句子被读入 if len(sentence) &gt; 0: sentences.append(sentence) return sentences 首先检查是否为BIO编码格式，如 123456789101112开 O始 O修 O建 O莫 B-LOC斯 I-LOC科 I-LOC到 O圣 B-LOC彼 I-LOC得 I-LOC堡 I-LOC BIO检验先进行检验，如果不符合，做相应的处理进行转换 123456789101112131415161718def check_bio(tags): # 检查输入的编码是否符合BIO编码，如I一定在B之后;不符合则进行调整 for i, tag in enumerate(tags): if tag == 'O': continue tag_list = tag.split(\"-\") if len(tag_list) != 2 or tag_list[0] not in set(['B', 'I']): return False if tag_list[0] == 'B': continue elif i == 0 or tags[i-1] == 'O': # 前一位置为O，且当前位置不为B,则转换为B,即I-ORG转为B-ORG tag[i] = 'B' + tag[1:] elif tags[i-1][1:] == tag[1:]: # 判断尾部三位是否合法 continue else: # 如果编码类型完全不一致，则从B开始编码 tags[i] = 'B' + tag[1:] return True 转为BIOES格式然后将BIO格式转为BIOES格式 12345678910111213141516171819def bio_to_bioes(tags): new_tags = [] for i, tag in enumerate(tags): if tag == 'O': new_tags.append(tag) elif tag.split('-')[0] == 'B': # 若不是最后一个，且后面一个开头为I，则是一个正确的开头 if i + 1 &lt; len(tags) and tags[i+1].split('-')[0] == 'I': new_tags.append(tag) else: new_tags.append(tag.replace('B-','S-')) # 不是开头，则换成单字 elif tag.split('-')[0] == 'I': if i + 1 &lt; len(tags) and tags[i+1].split('-')[0] == 'I': # 是正确的中间字 new_tags.append(tag) else: new_tags.append(tag.replace('I-','E-')) # 不是中间，换成结尾 else: raise Exception('非法编码') return new_tags 综合处理 123456789101112131415161718def update_tag_scheme(sentences, tag_scheme): # 编码更新 for i, s in enumerate(sentences): tags = [w[-1] for w in s ] # 取出标记部分 if not data_utils.check_bio(tags): s_str = \"\\n\".join(\" \".join(w) for w in s) raise Exception(\"输入的句子应为BIO编码，请检查输入句子%i:\\n%s\" % (i, s_str)) if tag_scheme == \"BIO\": for word,new_tag in zip(s,tags): word[-1] = new_tag if tag_scheme == 'BIOES': new_tags = data_utils.bio_to_bioes(tags) for word,new_tag in zip(s,new_tags): # 重组 word[-1] = new_tag else: raise Exception(\"非法目标编码\")","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"NER","slug":"NER","permalink":"http://vergessenwang.github.io/tags/NER/"}]},{"title":"VMware无法在Windows运行问题解决","slug":"VMware无法在Windows运行问题解决","date":"2019-10-08T16:22:50.000Z","updated":"2019-10-08T16:24:14.464Z","comments":true,"path":"posts/OS/2019-10-09-VMware无法在Windows运行问题解决.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2019-10-09-VMware无法在Windows运行问题解决.html","excerpt":"今天，想用虚拟机看下没有联网的主机的路由器是什么样的。对着VMware的图标，一阵猛戳，然鹅，无事发生。 首先，回忆了一下这阵时间我都做了什么特别的操作。 之前关闭了系统ASRL , 会不会是跟共用内存有什么关闭，恢复ASRL，不行。 然后查看了一下系统服务，发现VM的四个服务都是开启的，重启试试，不行。 会不会是BIOS的问题，然而最近我并没有修改，也没有更新过，排除。 难道是之前没有正常退出？仔细回忆，并没有这种情况。 准备卸载重装，发现有个修复工具，修复完还是老样子。 折腾了半天，卸载了原来的VM，顺便安装了最新的15版本。美滋滋的优雅双击，……我%&amp;@#！*&amp;#@","text":"今天，想用虚拟机看下没有联网的主机的路由器是什么样的。对着VMware的图标，一阵猛戳，然鹅，无事发生。 首先，回忆了一下这阵时间我都做了什么特别的操作。 之前关闭了系统ASRL , 会不会是跟共用内存有什么关闭，恢复ASRL，不行。 然后查看了一下系统服务，发现VM的四个服务都是开启的，重启试试，不行。 会不会是BIOS的问题，然而最近我并没有修改，也没有更新过，排除。 难道是之前没有正常退出？仔细回忆，并没有这种情况。 准备卸载重装，发现有个修复工具，修复完还是老样子。 折腾了半天，卸载了原来的VM，顺便安装了最新的15版本。美滋滋的优雅双击，……我%&amp;@#！*&amp;#@ 于是依旧不能以正确方式上网的我，开始在百度以浪费生命流搜索姿势寻求解决方案，果然啊……浪费生命 这时，我的鼠标开始随机游走。终于，不知为何，它来到了右下角，点开了带有小月亮的消息栏，一排跟VM有关的通知栏点亮了这个又冷又饿的夜晚。 VMware Workstation Pro 无法在 Windows 上运行 要是我没有关系专注模式，应该早就发现了这个问题。但是，弹消息很烦…….以防万一，还是打开了通知模式。 具体的问题是：微软的新发布的一个更新（KB4524147），微软目前似乎并没有推出补丁来修复这个问题，只能将这个补丁卸载并暂停windows更新 这万恶的自动更新，停都停不掉。 解决：控制面板 -&gt;程序与功能 -&gt; 左上角 查看已安装的更新 -&gt; 发现我是10月5号更新的 ，卸载这个KB4524147 这都更新了些啥啊，卸载重启老半天。 另外：关闭自动更新，居然显示最多只能暂停35天…好吧，还挺牛…为啥每次重启完电脑风扇就狂转？服了这小破电脑了 颤抖小手，再次双击，成功辣！ 又要重新新建虚拟机…明天再弄吧…","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://vergessenwang.github.io/tags/虚拟机/"},{"name":"Windows更新","slug":"Windows更新","permalink":"http://vergessenwang.github.io/tags/Windows更新/"}]},{"title":"KG简要构建流程","slug":"KG简要构建流程","date":"2019-10-06T13:43:07.000Z","updated":"2019-10-06T13:44:26.374Z","comments":true,"path":"posts/NLP/2019-10-06-KG简要构建流程.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-06-KG简要构建流程.html","excerpt":"知识图谱可以简单理解为语义网络或多关系图——图结构 涉及技术数据获取 爬虫抓取自己所需的数据——公开或半公开数据 数据库读取已有数据——业务数据 API——第三方数据 所有的数据需要整合到MySQL之类的数据库中——数据持久化 数据预处理 数据清洗：去掉无关信息，提前做字段对齐(数据融合中要用到) 知识抽取：从非结构化文本抽取关键信息 消歧分析：实体统一——比较关键的步骤","text":"知识图谱可以简单理解为语义网络或多关系图——图结构 涉及技术数据获取 爬虫抓取自己所需的数据——公开或半公开数据 数据库读取已有数据——业务数据 API——第三方数据 所有的数据需要整合到MySQL之类的数据库中——数据持久化 数据预处理 数据清洗：去掉无关信息，提前做字段对齐(数据融合中要用到) 知识抽取：从非结构化文本抽取关键信息 消歧分析：实体统一——比较关键的步骤 导入数据到知识图谱 数据筛选——业务所需的知识 知识图谱设计——类似于数据库设计，需要耗费较多时间 批量导入——高效导入历史数据，此时数据已经处理为node-relationship 格式 MySQL -&gt; MySQL Connector -&gt; APOC -&gt; Neo4j 可用neo4j数据库从MySQL中导入数据 可用APOC插件，可实现功能 索引管理：加快查找 图算法：PR 、中心算法 、社区检测 实用函数：域名提取，时间和日期，数字格式转换等 空间函数：地理编码、位置计算、空间与时间搜索等 数据集成：JSON、JDBC、CSV等数据加载——数据传导 图形重构：节点合并、属性规范化与分类等 虚拟节点/关系：创建虚拟图——类似于虚表 Cypher操作：Cypher语句和脚本运行 触发器 增量导入——实时导入更新数据 基于Canal的数据库增量日志解析 Canal Server -&gt; Canal Client -&gt; Kafka producer 基于Kafka的实时分布式消息 Kafka producer -&gt; Kafka -&gt; Kafka consumer -&gt; Neo4j Driver 应用层的搭建基于业务需求在分布式或微服务平台上搭建数据模型 Neo4j -&gt; Restful API 或 Spark Graph X 如抽取实体的相关特征，构建特征工程 基于特征工程用逻辑回归(常用于二分类问题)、GBDT、SVM、神经网络等方法搭建模型——更复杂的模型如DL，需要更多的数据。 定义目标函数：模型的实例化 优化目标函数：训练模型——梯度下降法(迭代比较低效)，随机梯度下降法(参数更新只依赖一个样本，非常高效) 优化目标函数 模型评估：准确率(存在样本不均衡问题，两种错误代价相同问题)、AUC 微服务：将功能按进行细分，每个功能对应一个服务，运行在独立的进程，服务间采用轻量级的通信机制，通常是基于HTTP协议的RESTful API ——基于协议的通信方式，与语言无关。但是不要多度拆分","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"KG","slug":"KG","permalink":"http://vergessenwang.github.io/tags/KG/"}]},{"title":"Jieba分词包使用","slug":"Jieba分词包使用","date":"2019-10-04T09:01:01.000Z","updated":"2019-10-05T14:10:15.777Z","comments":true,"path":"posts/NLP/2019-10-04-Jieba分词包使用.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-04-Jieba分词包使用.html","excerpt":"目前来说，分词和词性标注一般都是同时完成的，而且技术已经相对成熟。 今天来学习下Python里面Jieba库的使用，下一步重点要解决的是命名实体识别的问题。 安装Jieba包安装：命令行pip install jieba pip用于安装及维护Python包。 然后因为特殊原因并不能连上，我真的是笑嘻嘻 换上清华的镜像 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jieba 光速安装完毕 顺便升级下pip python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip 所用算法基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图 (DAG) 采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合 对于未登录词，采用了基于汉字成词能力的 HMM 模型 可以看出，是一种词典和统计相结合的分词方法 jieba原理","text":"目前来说，分词和词性标注一般都是同时完成的，而且技术已经相对成熟。 今天来学习下Python里面Jieba库的使用，下一步重点要解决的是命名实体识别的问题。 安装Jieba包安装：命令行pip install jieba pip用于安装及维护Python包。 然后因为特殊原因并不能连上，我真的是笑嘻嘻 换上清华的镜像 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jieba 光速安装完毕 顺便升级下pip python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pip 所用算法基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图 (DAG) 采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合 对于未登录词，采用了基于汉字成词能力的 HMM 模型 可以看出，是一种词典和统计相结合的分词方法 jieba原理 分词模式 精确模式，试图将句子最精确地切开，适合文本分析——默认 jieba.cut 方法接受三个输入参数: 需要分词的字符串；cut_all 参数用来控制是否采用全模式；HMM 参数用来控制是否使用HMM 模型 全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义——列出所有可能的分词 搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词——更适合用于专门文本分析，如特征向量分析 jieba.cut_for_search 方法接受两个参数：需要分词的字符串；是否使用 HMM模型。该方法适合用于搜索引擎构建倒排索引的分词，粒度比较细——搜索引擎模式 jieba.cut以及 jieba.cut_for_search 返回的结构都是一个可迭代的 generator，可以使用 for循环来获得分词后得到的每一个词语(unicode)，或者用jieba.lcut 以及jieba.lcut_for_search 直接返回list 词性标注使用jieba.posseg模块来进行词性标注，利用了HMM和viterbi算法 12345import jieba.posseg as pseg#查看词性words = pseg.cut(\"国庆节快乐\")for word, flag in words: print('%s %s' % (word, flag)) 输出 12国庆节 t快乐 a ICTCLAS 汉语词性标注集 自定义词典 加载自定义词典： jieba.load_userdict(file_name)file_name 为文件类对象或自定义词典的路径 。词典格式和 dict.txt一样，一个词占一行；每一行分三部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。file_name若为路径或二进制方式打开的文件，则文件必须为 UTF-8 编码。 jieba.del_word(&quot;XXX&quot;) 使得某个词语不会出现 jieba.add_word(&quot;XXX&quot;) 添加新词到字典中 jieba.suggest_freq(&quot;XXX&quot;, True) 调整某个词语的词频，使得其在设置的词频高是能分出，词频低时不能分出 分词器更改分词器（默认为jieba.dt）的 tmp_dir 和 cache_file属性，可分别指定缓存文件所在的文件夹及其文件名，用于受限的文件系统 新建自定义分词器：jieba.Tokenizer(dictionary=DEFAULT_DICT) ，可用于同时使用不同词典。jieba.dt 为默认分词器，所有全局分词相关函数都是该分词器的映射。","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"Jieba","slug":"Jieba","permalink":"http://vergessenwang.github.io/tags/Jieba/"},{"name":"分词","slug":"分词","permalink":"http://vergessenwang.github.io/tags/分词/"},{"name":"词性标注","slug":"词性标注","permalink":"http://vergessenwang.github.io/tags/词性标注/"}]},{"title":"实用算法前三章笔记","slug":"实用算法前三章笔记","date":"2019-10-02T13:42:35.000Z","updated":"2020-03-31T06:38:17.409Z","comments":true,"path":"posts/DataStructure/2019-10-02-实用算法前三章笔记.html","link":"","permalink":"http://vergessenwang.github.io/posts/DataStructure/2019-10-02-实用算法前三章笔记.html","excerpt":"CH0参考书： 《程序员实用算法》 《编程珠玑》(第二版) 《算法导论》 课前：阅读代码并验证其性能，调研STL库 课后：加深对算法设计思想的理解。(自己理解了一个问题跟用自己的话向别人解释是有很大区别的) 本课程的重点：依据问题定义、输入数据的特征和要求输出的数据的特征，分析广泛的解决方案（数据结构+算法），并选择最佳的解决方案 CH1 绪论重点：算法的概念、算法与相关术语的关联难点：算法时间复杂度的估算","text":"CH0参考书： 《程序员实用算法》 《编程珠玑》(第二版) 《算法导论》 课前：阅读代码并验证其性能，调研STL库 课后：加深对算法设计思想的理解。(自己理解了一个问题跟用自己的话向别人解释是有很大区别的) 本课程的重点：依据问题定义、输入数据的特征和要求输出的数据的特征，分析广泛的解决方案（数据结构+算法），并选择最佳的解决方案 CH1 绪论重点：算法的概念、算法与相关术语的关联难点：算法时间复杂度的估算 什么是算法： 描述了特定问题的有限求解步骤； 指为了解决特定问题，而操作数据的方式； 指求解问题的策略 五大特征：有穷性、确定性、可行性、零或多个输入、一或多个输出 五大要求：正确性、可读性、健壮性、高效率、低存储 程序： 指为计算机处理问题而编制的一组指令 算法 + 数据结构 = 程序 数据结构 性质相同的数据元素的有限集合及其上的关系的有限集合（数据+结构） 是描述现实世界实体的数据模型及其上的操作在计算机上的表示和实现 包括逻辑结构和存储结构/物理结构 数据类型：系统定义的int, char等，用户自定义的struct类型。也可采用typedef将类型名重命名，以增加代码的可读性。 数据结构的选择是与具体问题以及相应的约束密切相关的。 而且有时候采用一些特殊的存储结构，可以使得解决算法相当巧妙。 时间复杂度一般我们用大O来进行比较，但是这只是一个大致的比较，在相差比较大的时候很有用。如果两个算法的大O是一样，则还要从实际运算时间去比较，因为可能有的语句涉及到了调用，本身需要多步执行，这样在实际运行的时候就会有很大的差异。 另外数据本身的规律也会影响时间复杂度，如在排序算法中经常会比较最好和最坏情况。 空间复杂度内存 + 栈空间 经典的节省空间方法：bitmap 通过在C++中对分配空间后的地址进行计算，可得知每次分配的内存实际上都是大于数据类型本身的大小的。在这里，是直接算的首末地址的差值，注意与用sizeof的时候涉及的数据对齐问题相区别。 申请1~8B：实际分配32B；申请9~16B：实际分配40B；申请17~24B：实际分配48B。申请分配内存空间1次，额外开销为： 24~31B 由此看见，每一次分配内存实际都会有额外的开销，会降低Cache的存储密度从而降低算法的执行性能，同时内存的分配和销毁也是一个耗时的工作。要尽量减少分配内存的次数，可以用内存池等方法来解决。 代码优化 尽量减少输入输出 扩展缓冲区 减少函数调用的次数 限制计算密集型操作（浮点运算，除法运算）； 确定最耗时的操作，并提高其性能 可用测量和跟踪工具（如， Profiler，AQTime） 影响选择算法的决定性因素 问题时间和空间的约束 存何种信息，数据结构 输入输出数据的特征 CH2 线性表参考: 实用算法第2章 编程珠玑 1.4 13.4 重点：理解线性表的逻辑特点；掌握线性表两种存储结构的特点、实现（C定义）及其基本操作的实现、适用范围；掌握算法的描述方法：伪代码和算法流程图；会粗略分析算法的时间复杂度（三种情况下）和内存开销。 难点：对于给定的应用需求——设计数据结构的一般过程 判断是否需要用到DS？——操作对象为：取值为同种类型的很多数据，且这些数据间存在某种关系 或者 某些共性操作 判断是否适合用线性表来刻画同类数据之间的关系？（逻辑结构）——被操作的数据之间没有天然的一对多 和 多对多的关系 ；对已存储的数据进行处理时，处理顺序 有明显的唯一的先后次序关系 设计线性表的存储结构（包括：存储哪些数据（包括数据类型和取值）？顺序存储/链式存储的选择？） （数据+存储结构）——取决于数据处理时的最频繁操作，为静态操作，还是动态操作？ 编码实现数据的存储结构—— 学会画图设计DS并实现 利用线性表的基本操作来解决问题 四类数据结构： 集合：元素间无任何关系，即关系集合是空集： S={} 如C中的枚举 线性：1:1 树形：1:n 图形：n:n 图形渲染的例子： 红 —— 线性 紫—— 树形 基本操作 创建空的线性表 销毁已有线性表 查找直接后继和直接前驱 插入一个元素 删除一个元素 存储结构：顺序表和链表两种方式 健壮性：从数据操作的位置 和 空间是否上溢或下溢 两个方面来考虑 顺序表在内存中连续存储的线性表 ，用下标来表明线性特征 静态定义：数组12345#define List_Size 100/*分配空间的大小*/Typedef Struct&#123;int elem[List_Size ]; /*存储空间*/int len; /*实际长度*/&#125;SqList_static; 类似STL:vector 在编译的时候， 系统在函数栈中分配连续的内存空间。当静态顺序表所在的函数执行完毕后，由系统来回收所开辟的内存空间。 缺点：空间分配不够灵活 动态定义：指针123456#define List_Size 100 /*分配空间的大小*/typedef struct&#123;int *elem; /*顺序表的存储空间*/int len; /*实际长度*/int ListSize ; /*当前分配的空间大小*/&#125; Sqlist; 用malloc() realloc() free() 手动管理空间分配，实现了灵活，但增加了开销——CH1 中的内容可知，每次分配内容都是有额外开销的 malloc原理 关于malloc之后再仔细研究一下 初始化 123456789int InitSqList(SqList *L)//构造一个空的顺序表L&#123;L-&gt;elem=(int *) malloc(List_Size *sizeof(int));if (L-&gt;elem==NULL)exit(EXIT_FAILURE);L-&gt;len=0;L-&gt;ListSize =List_Size;return 1;&#125; 静态 VS 动态都是连续的空间，增、删、查的方式一样；区别在于对内存的分配和回收方式上 由此可以看出：数组≠顺序表 并不是只有链表中才能有指针 不要建立 “数组形式即为顺序表，有指针即为链表的刻板印象” 插入元素12345678910111213141516171819Status ListInsert_Sq( SqList &amp;L, int i, ElemType e)&#123;// 位置合法性的判断if ( i&lt;1 || i&gt;L.len +1 ) return 0;// 上溢时增加空间的分配if( L.len &gt;= L.listsize)&#123;newbase = (ElemType *) realloc(L.elem,(L.listsize+ LISTINCREMENT)*sizeof(ElemType));if ( newbase == NULL ) exit(OVERFLOW);L.elem = newbase;L.listsize += LISTINCREMENT;&#125;// 插入元素for ( j = L.len; j &gt;= i; j--) L.elem[j] = L.elem[j-1];L.elem[i-1] = e;L.len++;return 1;&#125; 删除元素12345678Status ListDelete_Sq( SqList &amp;L, int i) &#123;// 位置合法性的判断if ( i&lt;1 || i&gt;L.len ) return 0;// 删除for ( j = i; j &lt; L.len ; j++) L.elem[j-1] = L.elem[j];L.len--;return 1;&#125; 链表用链来表明线性特征 123456struct Node&#123;int data;struct Node *next&#125;;&#125;;Typedef struct Node *Link;Link head; 插入算法有头结点1234567891011121314Status ListInsert(LinkList &amp;L, int i, ElemType e)&#123;// 有头结点，无须对i为1的插入位置作特殊处理p = L; j = 0; // 对p,j初始化; *p为L的第j个结点while( p != NULL &amp;&amp; j&lt;i-1)&#123; p = p-&gt;next; j++; // 寻找第i-1个结点的位置&#125;if( p == NULL || j&gt;i-1) return ERROR;// i小于1或大于表长s = (LinkList )malloc(sizeof(LNode)); // 生成新结点if ( s == NULL ) exit(OVERFLOW);// 空间分配不成功，报错返回s-&gt;data = e; s-&gt;next = p-&gt;next; // 插入L中p-&gt;next = s;return OK;&#125; 无头结点123456789101112131415161718192021Status ListInsert(LinkList &amp;L, int i, ElemType e) &#123;// 无头结点，须对i为1的插入位置作特殊处理if ( i==1)&#123;s = (LinkList )malloc(sizeof(LNode)); // 生成新结点if ( s == NULL ) exit(OVERFLOW); // 空间分配不成功，报错返回s-&gt;data = e; s-&gt;next = L; // 插入到链表L中L = s; // 修改链头指针L&#125;else&#123;p = L; j = 1; // 对p,j初始化; *p为链表的第j个结点while( p != NULL &amp;&amp; j&lt;i-1)&#123;p = p-&gt;next;j++; // 寻找第i-1个结点的位置&#125;if( p == NULL || j&gt;i-1) return ERROR;// i小于1或大于表长s = (LinkList )malloc(sizeof(LNode)); // 生成新结点*sif ( s == NULL ) exit(OVERFLOW); // 空间分配不成功，报错返回s-&gt;data = e; s-&gt;next = p-&gt;next; // 插入到链表L中p-&gt;next = s;&#125;return OK;&#125; 区别在于是否对i为1的插入位置作特殊处理 ,实际上是对于第一个结点而言是否有前驱结点 STL:list 是一个双向链表 12345678910Struct Node&#123;ElemType data;struct Node *prior;struct Node *next;&#125;;typedef struct Node * Link;typedef struct &#123;Link head, tail;int len;&#125;DLinkList;","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://vergessenwang.github.io/categories/DataStructure/"}],"tags":[{"name":"线性表","slug":"线性表","permalink":"http://vergessenwang.github.io/tags/线性表/"}]},{"title":"几种分词算法对比","slug":"几种分词算法对比","date":"2019-10-01T15:17:25.000Z","updated":"2019-10-05T11:39:34.744Z","comments":true,"path":"posts/NLP/2019-10-01-几种分词算法对比.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-10-01-几种分词算法对比.html","excerpt":"句法语义分析：对于给定的句子，进行分词、词性标记、命名实体识别和链接、句法分析、语义角色识别和多义词消歧 信息抽取：从给定文本中抽取重要的信息。比如时间、地点、人物、事件、原因、结果、数字、日期、货币、专有名词等。涉及到实体识别、时间抽取、因果关系抽取等关键技术 文本挖掘：包括文本聚类、分类、信息抽取、摘要、情感分析，以及对挖掘的信息和知识的可视化、交互化表达界面。目前主流的技术都是基于统计机器学习的 问答系统(我目前研究的方向)： 对一个自然语言表达的问题，由问答系统给出一个精准的答案。需要对自然语言查询语句进行某种程度的语义分析，包括实体链接、关系识别，形成逻辑表达式，然后到知识库中查找可能的候选答案并通过一个排序机制找出最佳的答案——目前基于知识图谱的问答系统还是挺好用的 分词是中文NLP的基础。","text":"句法语义分析：对于给定的句子，进行分词、词性标记、命名实体识别和链接、句法分析、语义角色识别和多义词消歧 信息抽取：从给定文本中抽取重要的信息。比如时间、地点、人物、事件、原因、结果、数字、日期、货币、专有名词等。涉及到实体识别、时间抽取、因果关系抽取等关键技术 文本挖掘：包括文本聚类、分类、信息抽取、摘要、情感分析，以及对挖掘的信息和知识的可视化、交互化表达界面。目前主流的技术都是基于统计机器学习的 问答系统(我目前研究的方向)： 对一个自然语言表达的问题，由问答系统给出一个精准的答案。需要对自然语言查询语句进行某种程度的语义分析，包括实体链接、关系识别，形成逻辑表达式，然后到知识库中查找可能的候选答案并通过一个排序机制找出最佳的答案——目前基于知识图谱的问答系统还是挺好用的 分词是中文NLP的基础。 基于词表的分词算法基于词典的分词过度依赖词典和规则库，因此对于歧义词和未登录词的识别能力较低；其优点是速度快，效率高 正向最大匹配法正向最大匹配法，对于输入的一段文本从左至右、以贪心的方式切分出当前位置上长度最大的词。正向最大匹配法是基于词典的分词方法，其分词原理是：单词的颗粒度越大，所能表示的含义越确切。 12345678910111213141516171819202122def cut_words(raw_sentence, word_dic): max_length = max(len(word) for word in words_dic) # 统计词典中最长的词 sentence = raw_sentence.strip() words_length = len(sentence) cut_word_list = [] # 存储切分好的词 while words_length &gt; 0: max_cut_length = min(max_length,words_length) subsentence = sentence[0:max_cut_length] while max_cut_length &gt; 0: if subsentence in words_dic: cut_word_list.append(subsentence) break elif max_cut_length == 1: cut_word_list.append(subsentence) break else: max_cut_length -= 1 subsentence = subsentence[0:max_cut_length] sentence = sentence[max_cut_length:] words_length -= max_cut_length words = \"/\".join(cut_word_list) return words 逆向最大匹配法从右至左。 只需改变切分方式 subsentence = sentence[-max_cut_length:] sentence = sentence[0:-max_cut_length] 并将切分好的序列逆序 cut_word_list.reverse() , 再join即可 结果分析 1234请输入您要分词的序列我毕业于中南财经政法大学金融系，现在在中国科技大学学软件工程。分词结果我/毕业/于/中南财经政法大学/金融系/，/现在/在/中国/科技/大/学学/软件工程/。 可以看出：从后向前的分词方法有很大的缺陷 FMM和BMM难以解决歧义问题——解决：双向最大匹配法 双向最大匹配算法 双向最大匹配法是将正向最大匹配法得到的分词结果和逆向最大匹配法的到的结果进行比较，从而决定正确的分词方法。 启发式规则： 如果正反向分词结果词数不同，则取分词数量较少的那个——单词的颗粒度越大，所能表示的含义越确切 如果分词结果词数相同 分词结果相同，就说明没有歧义，可返回任意一个 分词结果不同，返回其中单字较少的那个 实现：将FMM和BMM的返回值改为切分好的序列，经比较之后返回更为准确的分词结果 123456789101112131415161718192021222324252627282930import FMM2import BMM2def bimm_cut_words(raw_sentence, words_dic): fmm_word_list = FMM2.cut_words(raw_sentence, words_dic) bmm_word_list = BMM2.cut_words(raw_sentence, words_dic) fmm_word_list_len = len(fmm_word_list) bmm_word_list_len = len(bmm_word_list) if bmm_word_list_len != fmm_word_list_len: if bmm_word_list_len &lt; fmm_word_list_len: return bmm_word_list else: return fmm_word_list else: fsingle = 0 bsingle = 0 issame = True for i in range(len(fmm_word_list)): if fmm_word_list[i] != bmm_word_list[i]: issame = False if len(fmm_word_list[i]) == 1: fsingle += 1 if len(bmm_word_list[i]) == 1: bsingle += 1 if issame: return fmm_word_list elif fsingle &gt; bsingle: return bmm_word_list else: return fmm_word_list 基于词典的问题：即使只是去切分一个句子，仍然需要2~3秒的处理时间，这在处理大文本的时候，很显然将成为性能的瓶颈。 分析算法可知，基于词典的遍历，在匹配时也是用的蛮力搜索，可以说是相当的暴力，基本上没有任何优化，只实现了基本的功能。 基于统计模型的分词算法基于N-gram语言模型的分词方法利用统计信息找出一条概率最大的路径。 当样本量很大的时候，基于大数定律，一个短语或者词语出现的概率可以用其频率来表示。——用统计方法的前提是有大量的样本。同时基于1阶马尔科夫假设：一个词wi出现的概率只与它前面的wi-1有关 $P(w_i | w_{i-1}) = count (w_i,w_{i-1})/count(w_{i-1})$ 基于序列标注的分词算法基于HMM的分词方法(生成式)把分词问题转为字的分类问题(序列标注问题)——由字构词，不依赖事先编制好的词表，但仍然需要分好词的训练语料 单字S，开始B-中间M-结尾E ， 已知观察序列求对应的形式化序列 基于CRF的分词方法(判别式)同HMM一样，也是基于序列标注，但它是一个判别式模型。不仅考虑了文字词语出现的频率信息，同时考虑上下文语境，具备较好的学习能力，因此其对歧义词和未登录词的识别都具有良好的效果；其不足之处是训练周期较长，计算量较大 分词所使用的是Linear-CRF，它由一组特征函数组成，包括权重λ和特征函数f，特征函数f的输入是整个句子s、当前posi、前一个词位li-1，当前词位li HMM VS 最大熵 VS CRF CRF， HMM都常用来做序列标注的建模，像分词、词性标注，以及命名实体标注 隐马模型一个最大的缺点就是由于其输出独立性假设，导致其不能考虑上下文的特征，限制了特征的选择 最大熵隐马模型则解决了隐马的问题，可以任意选择特征，但由于其在每一节点都要进行归一化，所以只能找到局部的最优值，同时也带来了标记偏见的问题，即凡是训练语料中未出现的情况全都忽略掉 条件随机场则很好的解决了这一问题，他并不在每一个节点进行归一化，而是所有特征进行全局归一化，因此可以求得全局的最优值。 基于深度学习的端到端的分词方法需要大量的语料 输入层是一个embedding层，经过双向LSTM网络编码，输出层是一个CRF层。经过双向LSTM网络输出的实际上是当前位置对于各词性的得分， CRF层的意义是对词性得分加上前一位置的词性概率转移的约束，其好处是引入一些语法规则的先验信息 学习来源：网页云课堂《动手学中文分词》","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[{"name":"HMM","slug":"HMM","permalink":"http://vergessenwang.github.io/tags/HMM/"},{"name":"词典","slug":"词典","permalink":"http://vergessenwang.github.io/tags/词典/"},{"name":"CRF","slug":"CRF","permalink":"http://vergessenwang.github.io/tags/CRF/"}]},{"title":"NLP知识简要梳理","slug":"NLP知识简要梳理","date":"2019-09-29T14:29:06.000Z","updated":"2020-05-13T00:52:27.731Z","comments":true,"path":"posts/NLP/2019-09-29-NLP知识简要梳理.html","link":"","permalink":"http://vergessenwang.github.io/posts/NLP/2019-09-29-NLP知识简要梳理.html","excerpt":"等我草草刷完一遍NLP领域的相关知识，才发现工程实践的综合性太强了，几乎涉及到了NLP的所有！核心知识！而且还要结合KG!暴风哭泣，我好害怕做到一半做不出来。。。啊，我好菜啊。。。我怎么什么都不懂。。。 自然语言：语音、文字 NLP：研究语言能力和语言应用的模型，建立算法框架来实现这样的语言模型，并完善和评测。最终用于设计各种实用系统。 是语言学、计算机科学、统计学的交叉学科。属于AI领域的子领域。 处理粒度：文档库 -&gt; 文章 - &gt; 段落 -&gt; 句子 -&gt; 词 发展历程以语言学为基础：建立基本语言规则，使用数理逻辑进行推理，建立模型或理解语言——语法语义，形式语言理论 以统计学为基础(目前)：在足够大的数据的基础上，分析规则，产生智能。业务知识相对不重要——对材料的数量有要求 未来的趋势是深度学习等AI最新技术","text":"等我草草刷完一遍NLP领域的相关知识，才发现工程实践的综合性太强了，几乎涉及到了NLP的所有！核心知识！而且还要结合KG!暴风哭泣，我好害怕做到一半做不出来。。。啊，我好菜啊。。。我怎么什么都不懂。。。 自然语言：语音、文字 NLP：研究语言能力和语言应用的模型，建立算法框架来实现这样的语言模型，并完善和评测。最终用于设计各种实用系统。 是语言学、计算机科学、统计学的交叉学科。属于AI领域的子领域。 处理粒度：文档库 -&gt; 文章 - &gt; 段落 -&gt; 句子 -&gt; 词 发展历程以语言学为基础：建立基本语言规则，使用数理逻辑进行推理，建立模型或理解语言——语法语义，形式语言理论 以统计学为基础(目前)：在足够大的数据的基础上，分析规则，产生智能。业务知识相对不重要——对材料的数量有要求 未来的趋势是深度学习等AI最新技术 NLP的研究内容 信息检索：搜索引擎，要求分词歧义处理、文档质量判断、去重 机器翻译 文档分类：基于距离的文本聚类 问答系统：基于答案库 信息过滤 自动文摘 信息抽取：将无结构的数据整理成结构化的数据以供检索——命名实体抽取 文本挖掘 舆情分析：情感分析——基于监督的文本分类 词库匹配 基于正负样本构建分类器 机器写作：形式语言处理 如自动股评：先分为行情和预测两部分，每一部分都可以有多种文法来自动生成句子 文稿机器校对 OCR或语音识别 困难场景：语言的多样性、多变性、歧义性 学习：数学模型——概率图模型、隐含马尔科夫过程、最大熵模型、条件随机场 语料：定义、作用、获得途径 基于语言学的理论描述语言的三种途径：穷举法、文法(产生式系统描述)、自动机法 形式语言 集合论 字符串——语言是一定规律的字符串的有限或无限的集合 连接 集合乘积 闭包 图论(离散数学) 形式语法是一个四元组(非终结符，终结符，产生式(推理规则)，初始符) ==&gt; 句子 推导 规约——中间有多次推导 文法的构造：一般来说，根据语言构造文法没有太直接的方法可用，它需要构造者本人所具有的经验。同一种语言可有多种文法。 形式语言的应用： 一些结构化语言：如SQL语法图 机器写作 自动机理论四型文法：——类似于数据库的设计范式 正则文法——3型文法，顺序线性产生 左右线性正则文法是等价的 上下文无关文法——2型文法 上下文有关文法——1型文法 无约束文法——0型文法 越规范越易于处理 有限自动机(DFA)： M 五元组 (输入符号，状态集合，映射，初始状态，终止状态) 对于任意一个正则文法，总可以确定一个对应的DFA 下推自动机(PDA)： 可看成一个带有附加下推存储器(一个堆栈)的有限自动机 七元组 对于上下文无关文法，可以构造一个下推自动机。由于正则文法是上下文无关文法的子集，因此也可以出离正则文法 线性界限自动机——对应上下文有关文法 图灵机——对应无约束文法 自动机的应用： 单词自动查错纠正 编辑距离 词性消歧 状态转换机 形式语言的缺陷 对于汉语这样的大型自然语言系统，难以构造精确的文法 语法正确的句子可能是无意义的 解决：基于大量预料，采用统计学手段建立模型 统计自然语言处理只有在数据不够充足的情况下，我们才需要更加借助业务知识。 n元语言模型通过概率，计算某个句子的概率。——条件概率，为了简化计算并减少空间占用，只计算与前一个字有关的概率 一般步骤 收集大量语料：基础工作，工作量最大 对语料进行统计分析，得出知识(概率)——例如n元文法 针对场景建立算法 ，即使是计算简单的概率也有很多复杂的算法可以运用，有些可以直接标注 解释或应用结果 性能评价常用指标：交叉熵、困惑度 数据平滑：加法平滑、古德-图灵估计法、Jelinek-Mercer平滑方法 语言模型的缺陷 在训练语言模型时所采用的的语料往往来自多种不同的领域，这些综合型语料难以反映不同领域之间在语言使用规律上的差异，而语言模型恰恰对于训练文本的类型、主题和风格都非常敏感——非常依赖语料库，数据来源是多领域而应用比较专业时效果往往比较差 n元语言模型的独立性假设前提是当前词出现的概率仅与前面的n-1个词相关，这种假设比较脆弱 应用：——选择最高概率的做出结果输出 语音识别歧义消除 汉语分词问题 概率图模型基于图的概率表示，计算联合分布的概率 有向图——贝叶斯网； 无向图——马尔科夫网 不同视角： 图 -&gt; 图导出的独立关系 -&gt; 图导出的因子分解 An Introduction to Conditional Random Fields 分类器产生式模型：朴素贝叶斯——先估算联合概率密度，再用贝叶斯公式，在少量样本情况下，可以取得更好的精确率 判别式模型：logistics回归——直接估算，在样本增加的情况下，逐渐逼近前者的精确率 两者关系 朴素贝叶斯 -&gt;(序列化) -&gt; 隐马尔可夫 -&gt;(去掉一些限制条件) -&gt; 条件随机场 logistics回归 -&gt;(序列化) -&gt; 条件随机场 马尔科夫及HMM马尔科夫链的应用： 压缩算法 排队论 语言识别 基因预测 搜索引擎鉴别网页质量的RP值 隐马尔可夫的应用： 语音识别 分词 缺陷： 只能根据顺序(马尔科夫性)来计算，有些特征没有办法刻画——解决最大熵 生成式模型，需要给出状态和符号之间的联合概率分布，把观察符号割裂为相互独立的验资结构，无法提现依赖关系，标注偏置——解决：条件随机场 最大熵模型在只掌握了未知分布的部分信息的情况下，符合已知知识的可能有多个，但是熵值最大的概率分布最真实地反映了事件的分布情况 数学表达：特征 参数估计：GIS算法 最大熵马尔科夫模型：因为加入了特征，克服了马尔科夫只能适应线性的缺陷 条件随机场(最难理解)给定随机变量X的条件下，随机变量Y的马尔科夫随机场。 参数化形式 特征模板 前向-后向算法 具体理论部分以后细看吧…这会真滴看不懂 CRF应用：把NLP问题转为标注问题——命名实体识别，标注，句法分析，词法分析 收集大量已经标注好的语料 建立特征模板，由软件系统自动扫描语料并按模板生成特征函数。对重复出现的特征进行强化 训练，参数估计，确立模型 给模型输入观测序列，模型预测其标注序列 汉语分词自动分词，命名实体识别，词性标注 存在的问题分词规范问题：切分粒度 歧义切分问题：交集型、组合型、多义组合型——问题不大 未登陆词问题：人名、地名、组织名、术语、术语、新词——占比98%，主要关注问题 分词发展基于词典 -&gt; 最少词数分词 -&gt; 用统计模型解决分词歧义 -&gt; 无词典统计方法分词 词典：——精度不高，但简单性能好 正向最大匹配法、逆向最大匹配法、双向匹配法 逐词遍历法 基于词表的分类法 实现：树、散列表、布隆过滤器 统计方法： N-最短路径方法 基于词的n元语法模型——语言模型 由字构词——把分词问题看成标注问题，即CRF——不适用于海量数据 基于词感知机算法 生成式和判别式相结合 词典其实可以看成一种没有上下文关系，只有词的特殊语料库。 性能指标 精确率 召回率 $F$值——前两个指标的调和平均 中文分词十年回顾 命名实体识别(发展较差) 基于多特征的命名实体识别模型 基于CRF 未登录词处理方法(重要)基于规则的方法、机器学习方法 词性标注汉语语法分析“三姐妹”：分词(较成熟)、实体命名识别(发展较差)、词性标注(较成熟)。 在工程实现里，词性标注和分词同时完成 基于HMM的方法——相比于CRF对语料的要求更宽松，基于较少的标注就可以得到不错的结果，速度也更快 文本分类选取适当的特征及权重，将文本量化映射为样本空间中的样本。 通过在样本空间构建适当的分类器或聚类解决文本分类问题，通过计算向量余弦计算文本相似度。 文本特征选择方法 基于文本频率的特征提取方法——太高太低都不行 信息增益法——熵的差值 $X^2$统计量——关联程度 互信息法——共现程度 LDA模型(较难)抽词建立文档 分类器性能评测 应用： 网页自动分类 判断垃圾邮件 情感分析 句法分析 基于PCFG——上下文无关 结构分析 浅层句法分析——完全句法分析的简化版，包括语块识别与分析和语块依附关系两部分 baseNP —— 转成标注问题 依存关系——以动词为中心 判别式 序列标注 语义分析语义消歧 篇章分析指代消解——技术难度极高 自动抽取文摘—— 给句子打分，抽取每段中的高分句子。句子之间必须做篇章衔接性的处理，即句子消融。过程：对原文进行分词 -&gt; 特征分析统计 -&gt; 计算词的权重 -&gt; 根据主题词计算句子的权重 -&gt; 根据摘要句生成摘要 基于LDA的单文档摘要 多文档摘要：基于单文档抽取的句子，如何解决排列问题，如何上下文融合 问答系统问题分析 + 信息检索 + 答案抽取 基于问题-答案对的问答系统——根据日常经验形成的有问题-答案数据库 基于自由文本的问答系统——只有知识库，没有标准答案对。对答案进行分析后，知识库抽取信息对原问题中的句子进行替换，这可能会产生多个句子，所以还需要将这些句子拿去与原文匹配，找出存在的证据。每找出一次证据，给句子加分，最后选出得分最高的句子。 极其复杂，几乎用到了NLP中所有技术 问题分析：问句分类，主题识别，语法分析，指代消解，命名实体识别，名词短语，动词短语抽取 信息检索：文本检索，隐语义析取，相似度计算 答案提取：文档摘要 工具中文分词工具 语料库： LIAVC：香港城市大学建立 LDC中文树库 WordNet FrameNet EDR 北京大学综合型知识语言库 知网 概念层次网络 词性标注： tagger 语言模型： SRILM HMM: HTK: 主要用于大规模语音识别系统 最大熵： openNLP：有java的API MALLET NLTK：python CRF: CRF++ 分词： ICTCLAS/NLPIR Jieba——python 庖丁解牛——java 命名实体识别： Stanford NER: 英文，CRF 问答机器人： 图灵机器人 关于语料：要么提供明确的业务逻辑，比如在信息的哪一个部分能够提取到所需的信息；或者提供一个词典，词典中的都是想摘取的信息；要不基于大量标注好的学习材料，建立一个学习模型 顶尖会议及人物中文信息学会 ccks 赵海 有兴趣可以参加会议相关比赛…","categories":[{"name":"NLP","slug":"NLP","permalink":"http://vergessenwang.github.io/categories/NLP/"}],"tags":[]},{"title":"高级网络前四章笔记","slug":"高级网络前四章笔记","date":"2019-09-26T13:50:24.000Z","updated":"2019-09-26T13:58:17.075Z","comments":true,"path":"posts/network/2019-09-26-高级网络前四章笔记.html","link":"","permalink":"http://vergessenwang.github.io/posts/network/2019-09-26-高级网络前四章笔记.html","excerpt":"在赵老师的第一节高级网络结束之后，各位同学表示很开心，能学到很多前沿的东西，了解计算机网络的核心。他们兴致冲冲的说：”要不，咱们回去退课吧！….” 不过三周的学习过后，暂时还跟得上，可能因为还在讲一些基础的内容。 CH0教材《TCP/IP协议族》然而教材只包含上课内容的极小一部分，很多东西要自己拓展学习。 其他参考书：《计算机网络自顶向下》 《TCP/IP详解》 社区：http://www.ietf.org/rfc.html 基础 硬件：网卡(适配器)的原理——加上MAC地址，串并转换 软件： 查看端口情况 netstat -ano 列出运行中的端口 TASKLIST /FI &quot;PID eq 1048&quot; 查询使用端口的程序名 taskkill /f /t /im 程序名 终止进程 netstat -aon|findstr &quot;端口号&quot; 查询是哪个进程在占用端口 tasklist|findstr &quot;进程号&quot; 查询是哪个程序在占用 taskkill /pid 进程号 /f 终止进程 网络分层协议","text":"在赵老师的第一节高级网络结束之后，各位同学表示很开心，能学到很多前沿的东西，了解计算机网络的核心。他们兴致冲冲的说：”要不，咱们回去退课吧！….” 不过三周的学习过后，暂时还跟得上，可能因为还在讲一些基础的内容。 CH0教材《TCP/IP协议族》然而教材只包含上课内容的极小一部分，很多东西要自己拓展学习。 其他参考书：《计算机网络自顶向下》 《TCP/IP详解》 社区：http://www.ietf.org/rfc.html 基础 硬件：网卡(适配器)的原理——加上MAC地址，串并转换 软件： 查看端口情况 netstat -ano 列出运行中的端口 TASKLIST /FI &quot;PID eq 1048&quot; 查询使用端口的程序名 taskkill /f /t /im 程序名 终止进程 netstat -aon|findstr &quot;端口号&quot; 查询是哪个进程在占用端口 tasklist|findstr &quot;进程号&quot; 查询是哪个程序在占用 taskkill /pid 进程号 /f 终止进程 网络分层协议 分析：用抓包软件获取数据报并分析其二进制对应的内容 高级： 多线程时，如何处理线程与端口的对应关系 proxy 代理的原理 协议4.4BSD 源码分析 Hourglass模型：简化核心网 软件定义网络SDN (如OpenFlow) 集中式可编程管控——复杂路由,数据平面和控制平面分离 网络虚拟化 NFV ，云化池化虚拟 TCP/IP 向 RCP 演进的趋势——重新给路由器将入处理功能，内容区块作为连接 对网络设备潜力进行开发的智能应用，如无线结点用于导航 新的应用需求和通信技术对协议的推进 课程要求 学会将C/S 、P2P 模型与Socket、以太网等观点有机结合起来理解 熟悉TCP/IP 协议 、 网络体系结构、 擅长Socket 编程 CH1发展简史 第一个网络ARPANET——冷战产物——不同主体之间通信采用的协议不同，比较复杂——网络 第一个协议NCP(复杂链路) -&gt; TCP/IP(简单链路)——协议 第一个无线网络Aloha, 解决了信道碰撞冲突 -&gt; 以太网 UNIX 学术版发布 ——OS ISPs 创立 —— 运营 InternetInternet(因特网)是Internet(网际网)的子集，产生于协议、技术和应用需求的多重推动。 基于TCP/IP协议 体系结构：主机连到某一物理网络，各物理网络通过路由器互连，国际ISP通过NAP(network access point)互连 Internet标准—— RFC（Request For Comments）——如一些常见的协议： 0791 Internet Protocol 1256 ICMP Router Discovery Messages 1460 Post Office Protocol 1788 ICMP Domain Name Messages 标准的种类：Required、Recommended 、Elective 、Limited use 、Not recommended 分析协议的角度 三个要素：Syntax 语法、Semantics 语义 、Timing 时序 依赖于哪些技术 应用的驱动力是什么，对于新的需求有无更好的策略 可以想象一下协议运行的过程，用到什么算法，时序是怎样的，时间复杂度是多少，还有无改进之处 例如语言、交通规则都可视为一种协议，可尝试理解这里面的要素 课堂例子：一个工作10年的建筑系女生最后去了硅谷…她会经常用自己的话去描述学到的东西。转专业的同学，要学会发挥自己的专业优势 如何阅读和评论文献关注领域顶尖组织和会议：了解前沿问题 与自己研究领域直接相关的论文——热点问题或具有首创性和前瞻性 仔细反复阅读 新观点和新技术提出的历史依据和原因 解决方案的价值 Does it solve an important problem? 创新之处 new problem? new solutions? new evaluation methods/techniques? 带来的启发 同时还要找出论文的局限和缺陷(难点) Check assumptions, problem settings Check how fast the solution works, how long the solution can sustain… 如何评论 不要用原文内容，用自己的话进行阐述 3个重点 + 1个缺陷 好的论文结构——具体内容以后写论文时可再回头来研究 Abstract (1/8~1/4 page) Introduction section (1 page) Background section (0.5~0.75 page) Design section (3.5 page) Implementation section (1 page) Evaluation section (3.5 page) Discussion section (0.75 page) Related work section (0.5~0.75 page) Conclusion section (0.25~0.5 page) 反正，多读多看就完事了…看的少也看不出什么缺陷来… CH2 OSI &amp; TCP/IP关于分层 好处：降低复杂性，易拓展等 缺点：效率较低 特征：每层关注自己的细节，并为上层提供服务。通过协议与同层通信 不同节点：层次组成不同，作用不同 横向理解：虚通信，对等实体，协议，PDU 纵向理解：封装与解封，服务，接口 OSI七层概念模型各层功能 物理层：bit传输 链路层：hop - to - hop 网络层：host - to - host 传输层：end - to - end 可靠 会话层：SYN同步 表示层：编/解码，加/解密，数据压缩/解压缩 TCP/IP 四层模型中的协议族 应用层：注意端口号 基于TCP: FTP HTTP SMTP DNS? 基于UDP: DNS TFTP SNMP (socket) 传输层：TCP-6 UDP-17——封装端口号 网络层：IP(IPV4 -&gt; IPV6) ICMP IGMP ARP RARP——封装IP 网际层：LANs MANs WANs——封装MAC 注意区别 OSI vs. ISO Physical address vs. MAC address —不是很能区别 Network address vs. IP address CH3 底层网络技术传输介质UTP双绞线：五种质量型号 差别在于单位距离上的螺旋的数目 第三类：传输频率为16MHz，主要用于10base-T 第四类：传输频率为20MHz，主要用于10/100base-T 第五类：外套一种高质量的绝缘材料,传输频率为100MHz。主要用于100base-T和10base-T网络，这是最常用的以太网电缆 为什么帧的最小长度为64KB，这与10Base - T 的物理媒介有关——那么，到底为什么？ 同轴电缆 基带电缆：50Ω，可传输数字信号 宽带电缆：75Ω，可传输模拟信号，远距离传输 ——物理学证明了视频信号最优化的衰减特性发生在77 欧姆 光纤 全反射，传输速率受到光/电转换速率的制约 单模光纤：激光源，可远距离传输 多模光纤：发光二极管 LAN(局域网)技术：Ethernet, Token Ring, FDDI, WLAN 由于局域网中物理线路是直连的，故是一个冲突域，可能发生碰撞冲突 帧格式：结合教材 WAN(广域网)技术： 点对点WAN: PPP —— 一种数据链路层协议 ADSL PPP工作的点对点链路可能是串行的拨号电话线、SONET/SDH链路、X.25连接或者ISDN电路。 PPP也是点对点隧道协议（PPTP）和第二层隧道协议（L2TP）的基础，这些协议可用于创建虚拟专用网。如VPN 交换 WAN: Frame Relay -帧中继(虚电路), ATM(面向连接的分组交换) —— 宽带交换技术 还有一些早期技术：PSTN(电路) X.25(虚电路) DDN(电路) ISDN(电路) FR -&gt; SMDS(无连接，分组) -&gt; ATM 同步传输 SONET/SDH ——物理层协议 这些技术其实还没弄很懂…. 交换的三种类型：报文、电路、分组(数据报、虚电路) 一个典型的计算题：分组交换中35个用户同时有11个及以上用户在传输的概率 从35中选11个*(0.1)^(11)​….我不会输这个公式，对不起！得出的概率小于0.0004 在拥塞发生之后，任何剩余用户均不能传输，所有情况综合起来的条件概率为1，所以并不包含二项分布的第二部分 物理设备 Repeater 转发器/ Hub 集线器 Bridge 网桥/ L2 switch 二层交换机 Router 路由器/ L3 switch 三层交换机 Gateway 网关 —— 所有层，在异构传输层中间作为代理 区别：Default gateway vs. Gateway—— 默认网关是一个路由器？ CH4 IP编址分类IP地址：涉及到类型判断和网络号提取，主要是二/十进制转换的计算 特殊地址： 全1：表示当前网络的受限广播地址，当一个报文的目的地址为该地址时，这个报文将会被发送给本网络中的所有主机。但是路由器并不会将该报文转发到该网络外，故称为受限广播地址。 全0 ：表示本网络上的本主机地址，当一个主机刚加入网络时还没有IP地址，这时它将以全0地址作为源地址，全1 地址作为目的地址，向全网广播一个报文，DHCP服务器收到这样的报文之后就会进行IP分配的相关应答 网络号不为全0或全1 ，主机号全1：直接广播地址，用于标识对特定网络的广播。当一个路由器将报文的目的地址设置为该地址时，这个报文将会被发送给该地址对应的特定网络中的所有主机。该特定网络中的所有主机都会接收这个报文 网络号不为全0或全1 ，主机号全0：网络地址，用来标识这个网络，包含这个网络中的所有主机 网络号全0，主机号不为全0或全1 ：本网特殊主机地址，可作为目的地址向本网特定主机发送报文，因为本网内主机的网络号必然是相同的，仅通过主机号就可以对不同主机进行区分。 网络号为127，主机号任意：环回地址，一般用作测试，报文以该地址作为目的地址时，报文将只会在机器内部进行接收和处理，而不会被发送到外部网络上。自己发自己收，所以是环回 10.+ 24位 , 172.16~172.31 + 16位 , 192.168 + 16位：专用地址，仅在局域网内部使用，无法被外部访问。可用来节省IP地址，或者保证局域网的安全性 路由器的一个接口能连多个IP网(集线器，总线型)，但是多个接口不能连同一IP网——后者因为接口用IP来唯一标识？ P2P WAN :避免直连端口构成的子网浪费地址，解决方法 把两个路由器当做一个虚拟路由器，互连端口作为内部总线 把路由器当做交换机，分配同一子网的IP 工业界：IP地址借用，多端口共用IP，路由器内部多了报文流量但节省了地址空间 分类IP编址容易造成地址的浪费 -&gt; 无类IP编址——涉及掩码问题、子网划分 在分配子网和主机时，要考虑到全0和全1 的特殊情况。子网所需 IP = 主机数 + 路由器接口数 + 2 要点 确定掩码 确定每个网络的IP地址范围 128，192，224，240，248，252，254，255 /1， /2， /3， /4， /5， /6， /7， /8 路由聚合 -&gt; 超网","categories":[{"name":"network","slug":"network","permalink":"http://vergessenwang.github.io/categories/network/"}],"tags":[{"name":"IP","slug":"IP","permalink":"http://vergessenwang.github.io/tags/IP/"},{"name":"读文献","slug":"读文献","permalink":"http://vergessenwang.github.io/tags/读文献/"}]},{"title":"虚拟机安装Deepin","slug":"虚拟机安装Deepin","date":"2019-09-23T16:07:14.000Z","updated":"2019-09-23T16:08:44.385Z","comments":true,"path":"posts/OS/2019-09-24-虚拟机安装Deepin.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2019-09-24-虚拟机安装Deepin.html","excerpt":"今天在学习一个项目的时候要用到虚拟机开数据库服务器，于是打开了我很久以前安装的虚拟机，发现里面是CentOS系统。看起来真的没有什么使用的欲望…可能是我没花太多心思去配置，但是怎么说呢，就是感觉有点原始…于是寻思着换个操作系统试试，之前的台式安过Ubuntu了，所以干脆试试国产的Deepin 安装Deepin操作系统首先，在VMware的虚拟机管理中删掉现在的虚拟机。我文件夹地址是C:\\Users\\18771\\Documents\\Virtual Machines 里面有一个虚拟机文件夹，突然发现这个机器占了7GB外加，心疼我仅100G可用的SSD… 下载完Deepin镜像后，新建虚拟机 -&gt; 自定义 -&gt; 下一步 -&gt; 稍后安装操作系统 -&gt; Linux Ubuntu64 -&gt; 下一步… -&gt; 创建新的虚拟盘 -&gt; 将虚拟盘存储为单个文件 -&gt; 下一步.. -&gt; 完成 -&gt; 编辑虚拟机设置 -&gt; 使用ISO镜像，选择下载好的Deepin -&gt; 开机 -&gt; 完成相应配置，用户名 ve**en 密码 123456 安装完，界面确实挺惊艳的。","text":"今天在学习一个项目的时候要用到虚拟机开数据库服务器，于是打开了我很久以前安装的虚拟机，发现里面是CentOS系统。看起来真的没有什么使用的欲望…可能是我没花太多心思去配置，但是怎么说呢，就是感觉有点原始…于是寻思着换个操作系统试试，之前的台式安过Ubuntu了，所以干脆试试国产的Deepin 安装Deepin操作系统首先，在VMware的虚拟机管理中删掉现在的虚拟机。我文件夹地址是C:\\Users\\18771\\Documents\\Virtual Machines 里面有一个虚拟机文件夹，突然发现这个机器占了7GB外加，心疼我仅100G可用的SSD… 下载完Deepin镜像后，新建虚拟机 -&gt; 自定义 -&gt; 下一步 -&gt; 稍后安装操作系统 -&gt; Linux Ubuntu64 -&gt; 下一步… -&gt; 创建新的虚拟盘 -&gt; 将虚拟盘存储为单个文件 -&gt; 下一步.. -&gt; 完成 -&gt; 编辑虚拟机设置 -&gt; 使用ISO镜像，选择下载好的Deepin -&gt; 开机 -&gt; 完成相应配置，用户名 ve**en 密码 123456 安装完，界面确实挺惊艳的。 网络连接功能美滋滋的打开设置，结果没有WIFI模块，什么鬼，这我怎么快乐的网上冲浪？不行，我要冲浪 由于某种特殊的原因，最近不能愉快的上谷歌，只能在百度查，那查的真是令人感觉在浪费生命… 如何把Windows里的文件直接拖到虚拟机kali——即安装VMware tools 我可以直接拖文件了，舒服了 在虚拟机里查了半天，并没有查到无线网卡信息… 两个小时过去了，这时我已经有点出离愤怒… 会不会是因为无线网卡已经被本机占用了呢？于是我关闭了本机的WIFI，并重启了虚拟机，好像有点眉目了… 盲生似乎已经发现了华点。 首先在本机的设备器中，确认有VMnet1 和 VMnet8，因为用的无线所以没选桥接模式，用VMnet8的NAT模式 在VM的编辑中选择虚拟网络编辑器，点击左下角的恢复默认。重新将网络适配器设置NAT模式，重启了一下虚拟机。 啊！我的天啦，我真的有网了！我真的好开心啊！(黄晓明版杨过夸张大笑) 冷静下来的我，意识到当我第一次装CentOS的时候，装好了就有网了。所以这里的原因很就是：用NAT方式只能同时让一台虚拟机上网，新的机器需要重新配置 划重点：在VM的编辑中选择虚拟网络编辑器，点击左下角的恢复默认 其实，这个问题纠结的原因就在于我没有理解虚拟机的工作原理，把在一个电脑上安装Deepin和在虚拟机中安装Deepin这两个问题弄混了，所以才浪费了很多时间。 重要的不是对解决方案的积极寻找，而是首先深入理解你面临的问题。 三个小时过去了，我可以睡觉了…","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"Deepin","slug":"Deepin","permalink":"http://vergessenwang.github.io/tags/Deepin/"},{"name":"虚拟机","slug":"虚拟机","permalink":"http://vergessenwang.github.io/tags/虚拟机/"}]},{"title":"工程实践申请成功啦，开熏","slug":"工程实践申请成功啦，开熏","date":"2019-09-23T06:17:50.000Z","updated":"2020-03-11T15:40:58.204Z","comments":true,"path":"posts/Project/2019-09-23-工程实践申请成功啦，开熏.html","link":"","permalink":"http://vergessenwang.github.io/posts/Project/2019-09-23-工程实践申请成功啦，开熏.html","excerpt":"申请成功的感想今天和两个组员一起去见了孟老师，老师人很nice , 对我们几个基本没啥经验的同学没有过多的质疑。不过老师考虑到了我们目前的编程能力去做这个一个大型的知识图谱自动化项目还是有点难度，最终的项目内容可能有点区别。 如果你想做自己喜欢的东西，就要主动做出选择；如果你对这个选择没有足够的信心，就要做好充分的准备。大不了失败了再尝试一次。 同时还是要感谢老爹的鼓励，前几天跟他视频时讲到这个问题，我还怕我把课题讲出来他不太懂，果然还是低估了老爹的理解能力。他强调一定要做一份类似可能性计划书的重要性，好吧，我信了。（其实，我就是把看资料的笔记重新改了改，论记笔记的重要性…) 他还说，不要太担心，这种实践性的项目就是让人练手的，基本都会通过的，好吧… 不管怎样，还是拿到了自己喜欢的课题，很开心。","text":"申请成功的感想今天和两个组员一起去见了孟老师，老师人很nice , 对我们几个基本没啥经验的同学没有过多的质疑。不过老师考虑到了我们目前的编程能力去做这个一个大型的知识图谱自动化项目还是有点难度，最终的项目内容可能有点区别。 如果你想做自己喜欢的东西，就要主动做出选择；如果你对这个选择没有足够的信心，就要做好充分的准备。大不了失败了再尝试一次。 同时还是要感谢老爹的鼓励，前几天跟他视频时讲到这个问题，我还怕我把课题讲出来他不太懂，果然还是低估了老爹的理解能力。他强调一定要做一份类似可能性计划书的重要性，好吧，我信了。（其实，我就是把看资料的笔记重新改了改，论记笔记的重要性…) 他还说，不要太担心，这种实践性的项目就是让人练手的，基本都会通过的，好吧… 不管怎样，还是拿到了自己喜欢的课题，很开心。 以下是之前准备的一些内容 准备方向关于项目 目前国内知识图谱的应用现状是怎样的 相关理论在这个项目中的具体体现，还有哪些同层次的实现方法 项目从数据获取到最终应用的运行流程 技术选型(细节这块不是很懂) 目前项目的要求有什么缺陷和问题 关于自己 为什么对这个方向感兴趣 是否有相关经验，可结合个人经历说些开发经验，毕竟我觉得这是一个偏工程多点的项目 如无，今后的发展方向是什么，将在小组内担任何种角色 课题理解目前知识图谱普遍采用了语义网框架中RDF(Resource Description Framework,资源模式框架)模型来表示数据。语义网是万维网之父蒂姆·伯纳斯-李(Tim Berners-Lee)在1998年提出的概念，其核心是构建以数据为中心的网络，即Web of Data；这是相对于我们目前的万维网是Web of Pages而提出的。 爬虫抓取原始数据 从半结构化网页中诱导通用模板 待爬队列，已爬队列 DPS OR BPS 采用Scrapy引擎(或其他)处理后获得预处理数据，存储在Mysql数据库(或其他)中 后续更新：新的网站URL加入待爬队列——可能涉及到跟已有数据的一致性验证问题 预处理后的数据转成三元组 指代消解：最大熵模型、SVM模型 识别命名实体及关系抽取： CRF-SVM联合分类器(或其他)——适合半结构化数据 条件随机场：识别属性和尾实体 支持向量机：判断三元组的语义关系 抽取后的数据存在图数据库Neo4j(或其他三元组数据库)——该数据库提供可视化接口 如果是多数据源，还涉及到知识融合问题 实体名称匹配，可采用相似度匹配 余弦相似 欧氏距离 编辑距离 属性融合——消除歧义 属性相似度 自动生成问题和答案——知识推理 整理该应用领域常见的问题 将问题转为图数据库查询语句SPARQL(或其他) 在图数据库中搜索答案 基于 Elasticsearch(或其他)搭建一个简易实体语义搜索引擎 平台化 用户登录验证 数据导入 默认自动生成的问题 自定义查询接口: 构建中英文知识问答模块 对答案进行可视化渲染后呈现 清空数据 现有工具(部分开源，这里仅了解到的一小部分) 本体知识建模(schema): Protégé 三元组数据库：Apache Jena、RDF4J 、gStore 、AllegroGraph 、GraphDB 三元组抽取： DeepDive 、Reverb 、OLLIE 、Wandora 知识融合：LIMES 、Dedupe 、SILK 、RIMOM 、Falcon-AO 、 Lily 知识图谱推理：Jena 、Drools 语义搜索: Elasticsearch 知识问答系统： gAnswer","categories":[{"name":"Project","slug":"Project","permalink":"http://vergessenwang.github.io/categories/Project/"}],"tags":[]},{"title":"中秋记叙","slug":"中秋记叙","date":"2019-09-15T17:06:17.000Z","updated":"2020-03-11T15:37:33.310Z","comments":true,"path":"posts/life/2019-09-16-中秋记叙.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2019-09-16-中秋记叙.html","excerpt":"","text":"一月的时候，我背着穿到上海的四件毛衣，在微雨而几乎无人的下午，独自一人在拙政园里闲逛。空气潮湿而阴冷，墙愈白，瓦愈黑。地上的树叶落了一层，塘里枯败的荷枝耷拉着，几只灰褐的鸳鸯自顾戏水。一整个的园子，仿佛从没人来过。 留得残荷听雨声，大概是这样的意境。 而今中秋同瑞哥还有时节再游一趟，却又是另一种心情。 强烈的日光照的云天通透，园里的树叶郁郁葱葱，掩去了大半的热浪，到底是古人避暑的地方。小孩子指着鱼儿叽叽喳喳，风伴着阵阵蝉鸣。田田荷叶簇拥着接近成熟的莲蓬的高枝，偶尔在边缘遇见几朵睡过头而迟来的荷花。 水光潋滟晴方好，大概是这样的意境。 而后还有留园的青苔古树，窗里春秋；网师园的游园惊梦，灯影风声；苏博的吴地遗珍；裕兴记的六月黄面；松鹤楼的松鼠桂鱼，还有苦乐共享的夜谈。 一个人独自生活的时候，其实是很坚强的，一旦被感情包裹，就会变得很脆弱，因为对信任的人打开了门。很多遥远而隐秘的事情，拿来作为笑谈，倒也很有意思。 大概所有觉得幸运的时刻，此后都要用寂寞来偿还。 送走二人后，一个人回到学校，默默喝了两瓶豆奶。 一瓶敬友情，一瓶敬明天。","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[]},{"title":"自我表达与被认同感","slug":"自我表达与被认同感","date":"2019-09-10T03:44:37.000Z","updated":"2020-03-11T15:37:25.500Z","comments":true,"path":"posts/movie/2019-09-10-自我表达与被认同感.html","link":"","permalink":"http://vergessenwang.github.io/posts/movie/2019-09-10-自我表达与被认同感.html","excerpt":"开学五门考试终于完了，想来赵振刚老师和郭燕老师真是神仙老师啊，一个给我们布置了五次作业还在Q群里语音讲题，一个专门录了一套视频放到B站上，平时学习的较深，但是考试的时候都是很基础很细节的东西，教育不只为通过考试，这大概也是学习的真正意义。 于是有点放飞自我，翻了翻以前想看的电影，看完了《波西米亚狂想曲》和《鸟人》 听着皇后乐队的现场版，敲着这篇文章 一个一口豁牙不自觉露出傻笑然后用抿紧嘴巴羞涩低头的野路子歌手，出道之路凭借超强的个性和天赋顺风顺水，偶尔遇到与制作人意见不合，没关系，冒险的结果是好的。乐队内部矛盾的激化，最后弗雷迪再经历一系列打击之后明白了谁是真正重要的人，虽然他最终为自己的出格付出了生命的代价，但总体来说这算是一个励志喜剧了，他的人生停在了辉煌的顶点。","text":"开学五门考试终于完了，想来赵振刚老师和郭燕老师真是神仙老师啊，一个给我们布置了五次作业还在Q群里语音讲题，一个专门录了一套视频放到B站上，平时学习的较深，但是考试的时候都是很基础很细节的东西，教育不只为通过考试，这大概也是学习的真正意义。 于是有点放飞自我，翻了翻以前想看的电影，看完了《波西米亚狂想曲》和《鸟人》 听着皇后乐队的现场版，敲着这篇文章 一个一口豁牙不自觉露出傻笑然后用抿紧嘴巴羞涩低头的野路子歌手，出道之路凭借超强的个性和天赋顺风顺水，偶尔遇到与制作人意见不合，没关系，冒险的结果是好的。乐队内部矛盾的激化，最后弗雷迪再经历一系列打击之后明白了谁是真正重要的人，虽然他最终为自己的出格付出了生命的代价，但总体来说这算是一个励志喜剧了，他的人生停在了辉煌的顶点。 一个有隔空移物超能力但除了用来开门没啥卵用的导演兼演员，本来靠演爆米花电影在好莱坞有了一席之地，却打算在百老汇也实战一番拳脚，他改编了卡佛的原著，并找到一个以体验为名行流氓之事的有那么一点点才华的配角，然而事情并没有那么顺利，作为电影情节来说，这是必然的。他似乎有轻微的精神分裂，或者说过去的成就对他影响太大，正如那位极有艺术家气质的女评论家所言，好莱坞就是请几个猴子去拍也会有大把的人涌进电影院去看，而戏剧不一样，它是艺术。最终，他穿着一条短裤跑过人潮汹涌的街区，并用自己鼻子上的鲜血换来了那位评论家所著的头条。这部电影的奥妙之处在于，一种电影现实与真实现实，被迫行为和神经质内心的交织。 我喜欢把事物进行对比，这次也一样，虽然只是两部随机选择的电影。 音乐和戏剧是两种比较典型而且个性较强的艺术形式，必然会带来个人情感表达与大众认同之间的冲突。 弗雷迪不是一个好儿子，作为从印度来的移民，他的父亲始终恪守着“善言，善思，善行”的正派言行，而他似乎在最后生命即将终结的时候才浪子回头，请求朋友的原谅，参加为非洲筹款的慈善演唱。然而，从头到尾，你对他的那些可恶行径恨不起来，天才往往比较自我，他很有才华，That’s him , 想反还会为他的误入歧途感到惋惜。 里根也不是一个好父亲，他一心只想着挽救自己过气的事业，忽略了进过戒毒所的女儿。一开始他的演技平平无奇，自我怀疑让他几近崩溃，最终他把一个真实的自己展现在舞台上，他举着手型的枪，一本正经的说着台词，一开始你觉得很滑稽，然而你会幡然醒悟，他在说自己，明白他说：我只想成为你希望的样子，我现在每分钟都祈祷能成为别人，只要不是我自己…我不存在，我甚至不在这里…一切都不重要了… 时意味着什么。 很多人隐藏着真实的自己，因为害怕被大众所遗弃，那种真实的丑陋，也许会带来骂名。这两部电影很好的融合了自我表达与被认同感之间的矛盾。有勇气揭露真实的人，才能让作品直指人心，这种勇气本身就已经值得钦佩。 迎合大众的人往往带着面具，表达自我的大多有段曲折凄凉的经历。 名利与真实，只是一个选择问题。 关键是，你想成为谁。 命运青睐勇者。 —— 布莱恩·辛格 《波西米亚狂想曲》","categories":[{"name":"movie","slug":"movie","permalink":"http://vergessenwang.github.io/categories/movie/"}],"tags":[]},{"title":"组成原理","slug":"组成原理","date":"2019-09-09T15:24:53.000Z","updated":"2019-09-09T15:26:18.919Z","comments":true,"path":"posts/CS/2019-09-09-组成原理.html","link":"","permalink":"http://vergessenwang.github.io/posts/CS/2019-09-09-组成原理.html","excerpt":"作业一：什么是计算？什么是计算机？计算机和计算机理论之间的关系？现代计算机和理论如何联系起来？ 计算理论的发展计数和进制：起源于农业生产的需要，在中西方同时诞生了十进制，使人能用手指进行计数。中国古代还有八卦——二进制，算盘——十六进制，天干地支——十二进制和六十进制。玛雅日历——二十进制。 数学第一个突破：把连续的实变问题转换成数学可以表达的问题。 第二个突破：用离散的数字计算机来求解这些问题。 可计算性：衡量一个问题是否可以求解，标准是能不能通过图灵机分解成有穷的步骤从而再现出来。 把质的复杂转换成量的复杂 解析函数在基础系{1,$x$, $x^2$,….} 下的表示 可积函数在某个正交系下的Fourier级数表示 拓扑空间中用一簇集开集表示一个点 连续问题离散化的标准基表示，如有限元方法，图像处理中的小波变换 二进制：布尔代数，香农把数字继电器电路和二进制统一起来“A Symbolic Analysis of Relay and Switching Circuits”","text":"作业一：什么是计算？什么是计算机？计算机和计算机理论之间的关系？现代计算机和理论如何联系起来？ 计算理论的发展计数和进制：起源于农业生产的需要，在中西方同时诞生了十进制，使人能用手指进行计数。中国古代还有八卦——二进制，算盘——十六进制，天干地支——十二进制和六十进制。玛雅日历——二十进制。 数学第一个突破：把连续的实变问题转换成数学可以表达的问题。 第二个突破：用离散的数字计算机来求解这些问题。 可计算性：衡量一个问题是否可以求解，标准是能不能通过图灵机分解成有穷的步骤从而再现出来。 把质的复杂转换成量的复杂 解析函数在基础系{1,$x$, $x^2$,….} 下的表示 可积函数在某个正交系下的Fourier级数表示 拓扑空间中用一簇集开集表示一个点 连续问题离散化的标准基表示，如有限元方法，图像处理中的小波变换 二进制：布尔代数，香农把数字继电器电路和二进制统一起来“A Symbolic Analysis of Relay and Switching Circuits” 计算工具的演进帕斯卡的自动进位加法器：从驱动方式来说是靠人力拨动的外动力机械加法器，从进位和计算的机制上来说是靠发条和齿轮进位的内动力加法器。没有程序存储的概念 巴贝奇的差分机：基于提花织布机改进，完全实现了程序存储的概念，可以进行对数、微积分等函数的运算。包括存储室、运算室、控制室、打印机。编程卡是外部输入 图灵机：把一个数字问题用机械可求解可穷尽的过程再现出来的理论模型。最初发明是为了解决希尔伯特二十三个问题之一：用公理化的方法证明一个问题是可解的。图灵机从行为层面模拟人脑 图灵机停机：取决于两个因素1.计算完成 2.控制器中预存的状态被满足。停机并不意味着可计算性的成立，可能代表着某种条件已穷尽 图灵测试：通过对某种行为的测试来判断是否为智能体。 数字计算机：从功能层面模拟人脑。 ENIAC：采用十进制，用于计算火炮的弹道运算速度，电子管。用开关、插头和插座来编程。 冯·诺依曼机：用存储程序的方式实现更高效的编程，让程序可以自动执行。采用二进制电路更简单，指令和数据混合存储——普林斯顿结构（分开存储——哈佛结构） 冯·诺依曼结构冯·诺依曼结构采用存储程序的工作方式，在不需人工干预的条件下，自动取值和执行，因此必须具备功能模块： 将程序和原始数据输入计算机——输入→指令由操作码和地址码组成 以二进制形式存储程序和数据——主存→按地址访问，线性编址(当时主要是穿孔纸带，故速度很慢) 逐条取指令和操作数执行——控制器CU→控制流由指令流产生 算术和逻辑运算——运算器ALU→核心部件 运算结果输出——输出 操作人员通过I/O设备与主机进行通信。 现代计算的改进在内存容量指数级提升后，CPU和内存之间的数据传输带宽成为了瓶颈。 现代计算机为了实现并行，进行了很多的优化： 以存储器为核心，并采用层次化的寄存器—cache—主存—辅存结构 指令流水线和分支预测 多核CPU 更高速的I/O方式：程序中断、DMA、通道等 各部件通过总线连接 其实，以上的所有改进都可以总结为：如何充分利用CPU的处理能力，如何加快数据在各部件之间的传输 拓展：为何不采用哈佛结构？哈佛体系实际上将存储时简化的复杂度转移到了程序运行时，对程序和数据的动态链接和物理映射需要更多的硬件支持，内部也要采用两套总线。 在实际运用中，简单的DSP嵌入式应用因为不需要运行太多的任务多采用哈佛结构，多用于安全性较高的工控领域。 在现代计算机中，CPU内部的Cache是有L1-I和L1-D的哈佛结构的。 所以说冯`诺依曼机采用普林斯顿结构只是用整体层面而言的。 存储器数据的表示ASCII码表：0–48(0011 0000); 大写A–65(0100 0001)；小写a–97(0110 0001) 数制转换：整数除二取余，小数乘二取整 原码 补码：用模实现加减法的统一，多表示一个数 反码：负数 补码 - 1 移码：比较大小，符号与补码相反 IEEE 754标准：阶码 +127 数据的存储从什么地方开始存—大/小端：现代网络通信中一般采用大端模式，即对一个主存字中的多个字节，按从高位字节到低位字节存放—看主存地址而不是数据的高位 如何便于存取——数据对齐：编译器和链接器划分的最小存储单元确定对齐方式，如双字节、四字节对齐。注意：如果是结构体整体，那么以最长成员作为结构体本身的对齐方式 其他LOAD直接寻址的访存次数：一般情况下需要先取指令再访存取数，但是LOAD指令可以同时进行，故只需访存一次。 配置实验环境安装masm5用于搭建汇编环境 我安装在E盘 安装DosBox和Debug工具DosBox用于在64系统下使用masm5 将debug.exe放在某盘如E盘的根目录下，然后运行dosbox, 会发现它默认有一个虚拟的Z盘。 输入mount c e:\\ 表示在dosbox 中虚拟出一个C盘，然后把本机的E盘挂载上去，就可以访问本机的文件了。 -&gt; c: -&gt;dir -&gt; masm5 即可查看本机E盘中的masm相关文件, 常用指令 编译：masm file.asm 链接：link file.obj 运行：file.exe 返回根目录 -&gt;debug 出现 -_ 光标表示debug程序成功开始运行","categories":[{"name":"CS","slug":"CS","permalink":"http://vergessenwang.github.io/categories/CS/"}],"tags":[{"name":"硬件","slug":"硬件","permalink":"http://vergessenwang.github.io/tags/硬件/"},{"name":"底层原理","slug":"底层原理","permalink":"http://vergessenwang.github.io/tags/底层原理/"}]},{"title":"中断、异常和系统调用","slug":"中断、异常和系统调用","date":"2019-09-07T16:33:11.000Z","updated":"2019-09-07T16:34:38.129Z","comments":true,"path":"posts/OS/2019-09-08-中断、异常和系统调用.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2019-09-08-中断、异常和系统调用.html","excerpt":"这三者都是应用程序和操作系统内核之间的接口。 作用和区别当硬件外设与计算机的交互的时候，为了快速响应，需要中断机制。 在程序执行中出现了一些程序设计人员没有预料到的情况，如除0，导致当前指令执行失败，为了解决这种错误，需要异常处理机制。 在保证系统安全性的同时为用户应用程序提供灵活的访问接口，需要系统调用机制。应用程序主动向OS发出服务请求 响应和处理中断：异步，持续进行，应用程序并不会感知到中断的存在，对用户透明 异常：同步，必须当前错误处理完了才能继续执行，处理方式是杀死或重新执行指令 系统调用：同步或异步，等待和持续","text":"这三者都是应用程序和操作系统内核之间的接口。 作用和区别当硬件外设与计算机的交互的时候，为了快速响应，需要中断机制。 在程序执行中出现了一些程序设计人员没有预料到的情况，如除0，导致当前指令执行失败，为了解决这种错误，需要异常处理机制。 在保证系统安全性的同时为用户应用程序提供灵活的访问接口，需要系统调用机制。应用程序主动向OS发出服务请求 响应和处理中断：异步，持续进行，应用程序并不会感知到中断的存在，对用户透明 异常：同步，必须当前错误处理完了才能继续执行，处理方式是杀死或重新执行指令 系统调用：同步或异步，等待和持续 中断处理机制实际上是对三种方式的统称。 硬件处理 CPU初始化时设置中断使能标志 依据内部或外部事件设置中断标志 依据中断向量调用相应中断服务例程 中断：设备驱动 异常：异常服务例程 系统调用：系统调用表 -&gt; 系统调用实现 此时三种情况都会索引中断向量表，根据自身的所需的处理转到不同的例程，及软件处理 内核软件处理 现场保存(编译器): 汇编语言过程保存寄存器值并设置新的堆栈 中断服务处理(服务例程) 清除中断标记(服务例程) 现场恢复(编译器) 中断嵌套硬件中断服务例程可被打断，中断请求会保持到CPU做出响应 不同中断源优先级不同，比如有更高速设备的请求 有时需要临时禁止中断请求，比如电源处理 异常服务例程可被打断 硬件中断优先级更高，如执行缺页处理时有磁盘I/O中断 异常本身也可嵌套，如缺页处理时又出现缺页 系统调用与函数调用系统调用：INT 和 IRET 指令 ，调用时会有堆栈和特权级的切换，因此开销更大，具体开销有： 切换引导机制 建立内核堆栈 验证参数 内核态映射到用户态的地址空间 内核态独立地址空间 函数调用：CALL 和 RET 指令，没有堆栈切换 堆栈切换的意思是用户态和内核态使用不同的堆栈 基于X86的中断处理中断和异常在不同的CPU上有不同的表现形式，X86分成中断和异常两种类型，但在实现方式上是统一的 中断源中断 外部中断：串口、硬盘、网卡、时钟… 软件中断：THE INT n 指令，通常用于系统调用(陷入) 异常 程序错误 软件异常：INTO INT 3 BOUND 机器检查出的异常 CPU与OS的中断处理每个中断或异常关联一个中断服务例程ISR, 关系存储在中断描述符表IDT中，IDT的起始地址和大小保存在中段描述符表寄存器IDTR中 1. 确定ISR的地址(中断初始化) CPU在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中中断控制器（如：8259A）是否发送中断请求过来，如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量； CPU根据得到的中断向量（以此为索引）到IDT中找到该向量对应的中断描述符，中断描述符里保存着中断服务例程的段选择子； CPU使用IDT查到的中断服务例程的段选择子从GDT中取得相应的段描述符，段描述符里保存了中断服务例程的段基址和属性信息，此时CPU就得到了中断服务例程的起始地址，并跳转到该地址 2. 切换到ISR段描述符中会设定ISR的特权级，如CS的低两位00 代表内核态，33 代表用户态 产生中断之后都会转为内核态，对于内核态 -&gt; 内核态 与 用户态 -&gt; 内核态 处理方式略有区别，前者只需压入EIP CS EFLAGS；后者有堆栈和特权级的切换,因此还要把用户态的堆栈地址ESP SS压到内核态堆栈 需要理解的一点是，程序的状态，实际上就是各个寄存器中的值，保存了这些值也就保存了程序的状态。 具体流程参见中断处理 保护端点和保护现场的区别这是一个困扰了我很久的问题，硬件处理中的保护断点与软件处理中的保护现场究竟有什么区别？ 保护断点：由系统自动完成，方便中断服务程序执行完后，可以返回到断点处继续运行。这里的断点指的是PC寄存器的内容，因为转入中断服务程序需要装载新的指令地址，一般是压栈。 保护现场：指的是进入中断服务程序或子程序后，由于寄存器有限，主程序和中断服务程序或子程序中用到相同的寄存器，所以为防止冲突，在中断服务程序前或在子程序前用进栈指令保护那些可能受到冲突的寄存器，然后在返回前恢复。也就是说，一个程序的运行状态，是用各种寄存器中的值来描述的，现场信息一般指的是PSW 、中断屏蔽寄存器和CPU 中某些寄存器的值。","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"中断","slug":"中断","permalink":"http://vergessenwang.github.io/tags/中断/"},{"name":"系统调用","slug":"系统调用","permalink":"http://vergessenwang.github.io/tags/系统调用/"}]},{"title":"进程fork的原理","slug":"进程fork的原理","date":"2019-09-07T16:06:25.000Z","updated":"2020-03-08T15:31:02.538Z","comments":true,"path":"posts/OS/2019-09-08-进程fork的原理.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2019-09-08-进程fork的原理.html","excerpt":"创建新进程需要创建新进程的场景： 系统初始化 执行创建新进程的系统调用 用户请求创建 初始化批处理任务 Unix 系统调用：fork/exec 先用fork() 复制出一个不同PID的子进程，然后用exec()重写当前新创建的子进程。之所以要安排两步，是为了在fork之后允许子进程处理父进程的文件描述符，这就可以完成对标准I/O文件和标准错误文件的重定向。","text":"创建新进程需要创建新进程的场景： 系统初始化 执行创建新进程的系统调用 用户请求创建 初始化批处理任务 Unix 系统调用：fork/exec 先用fork() 复制出一个不同PID的子进程，然后用exec()重写当前新创建的子进程。之所以要安排两步，是为了在fork之后允许子进程处理父进程的文件描述符，这就可以完成对标准I/O文件和标准错误文件的重定向。 具体来说 fork() 创建一个继承的子进程 复制父进程所有变量和内存。只读的内存区是共享的 复制父进程除区分PID的寄存器以外所有的寄存器 子进程返回0，父进程返回子进程PID,这个返回值就是childPID 对于新创建的子进程来说，它的子进程PID就是0 注意：fork()循环两次会产生四个进程！而不是三个！ 对于内核线程共享地址空间，对于用户进程是直接复制。 exec() 重写子进程 在pid = = 0 的条件下执行，即要先验证是否为新创建的子进程 第一个参数为将要执行的文件名/bin/** ,第二个参数为指向变量数组的指针，第三个参数为指向环境变量数组的指针用于将终端类型和根目录等信息传给程序 执行会把整个地址空间内容改变 对于父进程，满足pid &gt; 0 它会执行waitpid系统调用，等待直至子进程终止。 可以看出，这两步操作中，第一步的复制是开销昂贵且没有的必要的。于是有了改进：vfork() 加快对exec 的调用。 现在的系统支持写时复制(COW)技术，即把复制延迟到某一进程想要对共享的内存进行改写时才进行。 init特殊进程因为用到了fork() 很容易想到鸡生蛋蛋生鸡的问题，第一个进程到底是怎么产生的呢？ 用户态进程创建之前，首先要创建一个内核态init进程，然而这个init进程是系统中的第二个进程即1号进程，它产生于0号进程idle 进程。 这个内核态的kernel_init 执行init函数转成用户态的第一个进程，读入一个说明终端数量的文件，然后为每个终端创建一个新的进程，就可以运行各种用户态的进程了。 上述过程可描述为：0号进程-&gt;1号内核进程-&gt;1号用户进程（init进程）-&gt;getty进程-&gt;shell进程 参见：Linux下1号进程的前世(kernel_init)今生(init进程) 代码例子1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#define SIZE 5int nums[SIZE] = &#123;0,1,2,3,4&#125;;int main()&#123;int i;pid_t pid;pid = fork();if( pid == 0)&#123;for(i = 0; i &lt; SIZE; i++)&#123; nums[i] *= -i ; printf(\"CHILD:%d\", nums[i]); &#125;&#125;else if (pid &gt; 0)&#123; wait(NULL); for(i = 0; i &lt; SIZE; i++)&#123; printf(\"PARENT:%d\",nums[i]); &#125;&#125;return 0;&#125; 上述代码最终的输出结果为： CHILD:0 CHILD:-1 CHILD:-4 CHILD:-9 CHILD:-16 PARENT:0 PARENT:1 PARENT:2 PARENT:3 PARENT:4 很明显可以看出子进程是在一块新的内存区域对数据进行改写，所以父进程的数组内容不会受到影响","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"进程","slug":"进程","permalink":"http://vergessenwang.github.io/tags/进程/"}]},{"title":"数据库概念","slug":"数据库概念","date":"2019-09-07T04:16:18.000Z","updated":"2020-03-11T15:38:51.383Z","comments":true,"path":"posts/database/2019-09-07-数据库概念.html","link":"","permalink":"http://vergessenwang.github.io/posts/database/2019-09-07-数据库概念.html","excerpt":"概论DB、DBMS与DBS的概念区别数据：载荷信息的符号。如数字、文字、图像、音频、视频等 数据库：长期储存在计算机内、有组织的(数据模型、冗余度小、独立性高、易拓展)、可共享的大量数据的集合。 数据库管理系统：用户和OS之间用于管理数据的基础软件，包括数据定义、组织、存取、联系、操纵、事务管理和运行管理(安全性保护、完整性检查、并发控制、数据库恢复)等功能 数据库系统：DB + DBMS + DBA + 应用程序 数据独立性物理独立性：应用程序与物理存储——外模式/模式映像(模式修改时对应改变映像，基于外模式的应用无需修改) 逻辑独立性：应用程序与逻辑结构——模式/内模式映像(同理) 从底层保证了应用程序的稳定性","text":"概论DB、DBMS与DBS的概念区别数据：载荷信息的符号。如数字、文字、图像、音频、视频等 数据库：长期储存在计算机内、有组织的(数据模型、冗余度小、独立性高、易拓展)、可共享的大量数据的集合。 数据库管理系统：用户和OS之间用于管理数据的基础软件，包括数据定义、组织、存取、联系、操纵、事务管理和运行管理(安全性保护、完整性检查、并发控制、数据库恢复)等功能 数据库系统：DB + DBMS + DBA + 应用程序 数据独立性物理独立性：应用程序与物理存储——外模式/模式映像(模式修改时对应改变映像，基于外模式的应用无需修改) 逻辑独立性：应用程序与逻辑结构——模式/内模式映像(同理) 从底层保证了应用程序的稳定性 数据模型对现实世界的模拟/抽象，容易为人理解且易在计算机上实现。数据模型是数据库系统的核心和基础 概念模型(现实 - &gt; 信息)：信息模型，数据库设计人员从用户角度进行数据库设计，要有较强的语义表达能力 E-R——要会根据描述信息画E-R图 联系本身也是一种实体型，也可以有属性 逻辑模型和物理模型(信息 -&gt; 机器) 逻辑模型：数据库设计人员借助工具从计算机系统的角度建模，用于DBMS实现 物理模型：物理存取方式，由DBMS完成 数据模型的组成要素 数据结构(静态特征)：对象和联系 数据操作(动态特征)：值的操作 数据完整性约束：制约和依存规则 常用的数据模型 层次：树，一对多，记录必须按路径查看完整意义。如IBM的IMS数据库 完整性约束与树结构有关 用冗余节点法(复制)和虚拟结点法(引用)将多 - 多 转成 一 - 多 存储结构：顺序邻接法，子女-兄弟链接法，层次序列链接法(深度优先遍历) 查询效率优于关系，不低于网状—-于此同时，更新效率较低 网状模型的一个特例 网状：间接表示多对多，如BDTG系统 一对实体间可以有多种联系 用联结记录法将多 - 多 转成 一 - 多 链表存储 操作语言复杂 关系 一个关系对应一张表(不允许嵌套)，一个主码确定一个元组，元组中每一个分量必须是不可分的数据项 关系模式即表头，是对表格的描述 存取路径对用户透明，利于开发但查询效率较低——查询请求优化 数据库系统结构开发人员角度 三级模式(二级映像) 外模式(子模式/用户模式)——View 局部数据或对同一数据的约束不同，跟具体应用有关的逻辑表示 一个应用只有一个外模式 模式(逻辑模式)——数据库的中心，应最先确定 对所有用户共享全部数据的逻辑结构和特征的描述 一个数据库只有一个模式，一个模式可有多个外模式 内模式(存储模式) 数据库内部的表示方法，如存储方式、索引组织、压缩加密等 一个数据库只有一个内模式 模式(Schema)对应抽象的型，实例对应具体的值。 最终用户角度 单用户 主从式 分布式 客户/服务器 浏览器/服务器 数据库系统组成DB + DBMS + Application + DBA + Hardware(内存、磁盘、传输率) + Software + User/Developer DBA职责 决定信息内容和结构，存储结构和存取方式，安全性要求和完整性约束条件——设计 监控数据库的使用和运行，如周期转储，故障恢复，监视审计文件——运维 调优、重组织、重构——优化 关系数据库关系建立在集合代数的基础上，是笛卡尔积的子集 笛卡尔积：所有域的所有取值的不重复组合，可表示为一个二维表，行为元组，列为域 域：当域的范围相同时，可以用属性名来进行区别 码：候选码可以唯一标识一个元组，对应一个主属性；所有属性都是候选码称为全码；可选定一个候选码为主码 三类关系 基本表：实际存在，数据的逻辑表示。最基本的一条性质：分量必须取原子值 查询表：临时表 视图表：虚表/导出表 关系模式是型，关系是值。笼统称为关系，用上下文区别 关系模式形式化表示：R(U,D,DOM,F) DOM是U = {A1,A2,A3...}中的属性向域D的映象集合，如DOM(Student-Person)=Person，映象通常直接说明为属性的类型、长度，F是属性依赖关系的集合 关系操作集合操作方式。 查询：选择、投影、连接、除、并、差、交、笛卡尔积 更新：插入、删除、修改 SQL具有关系代数(关系运算)和关系演算(用谓词)的双重特点 关系代数(重要) 集合运算符：只能行操作，要求属性的个数和域相同(笛卡尔积除外） $U$ 并 $-$ 差 ：由于不能做≠ 判断，所以一般借助差来实现诸如 “没有”之类的条件 $∩$ 交 $×$ 笛卡尔积：{m目k1个元组的集合} × { n目k2个元素的集合} = k1 × k2 个 m + n 目新元组 专门关系运算符：行列操作 具体运算参考 $σ$ 选择：行，在对列的范围进行控制的情况下选出行 $π$ 投影：列，投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行） $⋈$ 连接：结果来自多个关系 注意区分自然连接(去掉重复属性)和等值连接(对重复属性按表进行区分) 含空值的称为悬浮元组 $÷$ 除 象集的概念 先找出某值的象集，再看该象集是否真包含右边的关系 简单理解：假设集合A中有属性a,b ,集合B有属性b, 则找出的是，B中所有的b都在A中有等值b的对应a。前提是有公共属性 常用于“全部”，先用投影找出全部信息作为被除数；“至少”，一般是至少一个的情况 综合操作是先用连接确定要从哪些表中获取信息，然后对属性的域进行控制选择满足条件的行，再用投影选出所需的属性，生成特定的视图表 交、连接、除可用其余5种运算代替，但是引入可以简化表达 关系演算语言(了解，反正也看不懂..)刻画客体的性质或几个客体间关系的模式叫谓词 元组关系演算语言 ALPHA 域关系演算语言 QBE 元组演算和关系代数对比应用的例子 真的给我整蒙了… 完整性约束 实体完整性：主属性not null且unique，必须满足的不变性 参照完整性：外码是对应其他表(被参照关系)主码的本表(参照关系)非主码属性，取空值或被参照表的主码，foreign key reference,必须满足的不变性 用户定义完整性：具体领域的语义约束，结合实际情况 如 CHECK (Ssex=&#39;女&#39; OR Sname NOT LIKE &#39;Ms.%&#39;) SQL命令一览 SQL是关系数据库语言的工业标准。 分为数据定义、数据查询、数据更新、数据控制四大部分 定义模式定义模式：CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; 实际上定义了一个命名空间，可包含基本表、视图、索引等数据库对象 删除模式：DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt; CASCADE全部删除，RESTRICT还有对象时无法执行 创建对象时如果没有指定模式，默认根据搜索路径SHOW search_path;使用模式列表的第一个模式 基本表涉及多个属性列的完整性约束条件要定义在后面的表级完整性约束条件，如对外键的约束FOREIGN KEY (外键属性名) REFERENCES 参照表名(参照表的主键) 或有多个主键 PRIMARY KEY (主键1 ，主键2) 视图特点： 虚表，是从一个或几个基本表（或视图）导出的表 只存放视图的定义，不存放视图对应的数据 基表中的数据发生变化，从视图中查询出的数据也随之改变 作用： 视图能够简化用户的操作——基于视图的视图 视图使用户能以多种角度看待同一数据 ——数据库共享 视图对重构数据库提供了一定程度的逻辑独立性——无需改变外模式就实现某些使用需求 视图能够对机密数据提供安全保护 适当的利用视图可以更清晰的表达查询 创建CREATE VIEW &lt;视图名&gt; [(&lt;列名&gt; [,&lt;列名&gt;]…)] AS &lt;子查询&gt; [WITH CHECK OPTION]; WITH CHECK OPTION 代表对视图进行UPDATE，INSERT和DELETE操作时要保证更新、插入或删除时的行仍然满足视图定义中的子查询中的条件表达式 DBMS实现视图查询的方法：视图消解法，一般转换成等价的对基本表的查询 删除DROP VIEW &lt;视图名&gt;[CASCADE]; 索引从如何加快查询速度的角度去考虑，很多算法题也会涉及到这些思路。 顺序文件：按序排列，一个索引对应一条记录 B+树：动态平衡，一个索引对应一个块，索引记录该块内最大值 散列：查找快，但是仅能用于判断存在性，不能按范围查找。有同位冲突问题 位图 CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名)&gt;[&lt;次序&gt;],....); 次序为升序ASC或降序DESC,默认为升序 DMBS自动选择合适索引作为存取路径，用户不能显式地选择索引 适合建立索引的列：经常被使用，如WHERE 或 ORDER BY ; 主键或外键；值唯一 查询单表SELECT..COUNT/AVG/SUM/MIN/MAX..FROM...AS...WHERE...GROUP BY....HAVING.../ORDER BY...ASC|DESC; WHERE 和 HAVING 的区别：WHERE 用于从基表或视图选择满足条件的元组，HAVING 用于从组中选择满足条件的组 常用条件 DISTINCT 去掉重复行 [NOT] BETWEEN...AND... [NOT] LIKE &#39;匹配字符串&#39;字符匹配 % _ 如果字符串本身有% 或_ , 要在前面加 \\ 并在后面加上一句ESCAPE&#39;\\&#39; [NOT] IN(value1,value2...) IS [NOT] NULL IS不能用等号代替 AND OR NOT 还有一些比较运算符&lt; = &gt; &lt;= &gt;= !=... 连接连接条件中字段类型必须是可比的，但名字不必相同 等值与非等值对同名列要根据 表名.列名 的形式进行区分 连接执行方法 嵌套循环法：穷举 排序合并法：先排序再merge 索引连接：只与索引字段比较 自然连接根据两个表中同名的列而进行连接的，当列不同名时，自然连接将失去意义。且语法中没有on 即在等值连接的基础上把重复列去掉 自身连接属性自相关 如：查间接先修课(先修课的先修课)SELECT FORST.Cno,SECOND.Cpno FROM Course FIRST,Course SECOND WHERE FIRST.Cpno = SECOND.Cno; 要对属性起别名进行区分 外连接不满足条件的也输出 ，如连接的某表中有些属性是空值。 可有左外连接和右外连接 例：SELECT Student.Sno,Sname,Sage,Cno,Grade FROM Student LEFT OUT JOIN SC ON(Student.Sno = SC.Sno); 嵌套 含IN的子查询：SELECT Sno FROM SC WHERE Cno IN(SELECT Cno FROM Course WHERE Cname = &#39;计算机&#39;); 含比较运算符：SELECT Sno,Cno FROM SC X WHERE Grade &gt;= (SELECT AVG(Grade) FROM SC Y WHERE Y.Sno = X.Sno); 当子查询对父查询有依赖关系时，会将外层查询的元组的属性按顺序传给内层去处理 含ANY/SOME/ALL：与比较运算符搭配使用，放在子查询括号之前。有时候可以用聚集函数MAX/MIN代替实现ANY/ALL之类的查询 含[NOT] EXISTS : 上面的三种都可以用某种形式的EXISTS来实现 子查询不能使用ORDER BY 如果嵌套有很多层的话，其实用连接查询更简单 子查询还可以用在FROM子句中，这时生成的临时派生表是主查询对象 集合参与查询的列数必须相同，对应的数据类型也相同 UNION [ALL] 并集，加上ALL保留重复元组 INTERSECT 交集 EXCEPT 差集 更新插入插入元组：INSERT INTO &lt;表名&gt; [(&lt;属性列1&gt;[,&lt;属性列2 &gt;…)] VALUES (&lt;常量1&gt; [,&lt;常量2&gt;]… ); 插入子查询：例如 12345INSERTINTO Dept_age(Sdept,Avg_age) SELECT Sdept，AVG(Sage) FROM Student GROUP BY Sdept; 修改UPDATE &lt;表名&gt; SET &lt;列名&gt;=&lt;表达式&gt;[,&lt;列名&gt;=&lt;表达式&gt;]…[WHERE &lt;条件&gt;]; 主码不允许修改 删除DELETE FROM &lt;表名&gt; [WHERE &lt;条件&gt;]; 空值约束条件： 有NOT NULL约束条件的不能取空值 加了UNIQUE限制的属性不能取空值 码属性不能取空值 空值与另一个值（包括另一个空值）的算术运算的结果为空值；空值与另一个值（包括另一个空值）的比较运算的结果为UNKNOWN。 完整性 正确性：符合实际 相容性：符合逻辑 例子： 1234567891011121314CREATE TABLE SC ( Sno CHAR(9) NOT NULL， Cno CHAR(4) NOT NULL， Grade SMALLINT, PRIMARY KEY(Sno,Cno)， FOREIGN KEY (Sno) REFERENCES Student(Sno) ON DELETE CASCADE /*级联删除SC表中相应的元组*/ ON UPDATE CASCADE, /*级联更新SC表中相应的元组*/ FOREIGN KEY (Cno) REFERENCES Course(Cno) ON DELETE NO ACTION /*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/ ON UPDATE CASCADE /*当更新course表中的cno时，级联更新SC表中相应的元组*/ ); 完整性约束命名子句：CONSTRAINT &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt; 对约束命名更利于后续操作，如删除ALTER TABLE Student DROP CONSTRAINT C4; 断言CREATE ASSERTION&lt;断言名&gt;&lt;CHECK 子句&gt;可以定义涉及多个表的或聚集操作的比较复杂的完整性约束 例 12345CREATE ASSERTION ASSE_SC_CNUM2 CHECK(60 &gt;= ALL (SELECT count(*) FROM SC GROUP by cno,TERM) ); 触发器一种特殊的存储过程，当表中发生特殊事件时执行。触发器主要用于保证数据的完整性。 只能定义在基本表上，不能定义在视图上 12345CREATE TRIGGER &lt;触发器名&gt; &#123;BEFORE | AFTER&#125; &lt;触发事件&gt; ON &lt;表名&gt; REFERENCING NEW|OLD ROW AS&lt;变量&gt; FOR EACH &#123;ROW | STATEMENT&#125; [WHEN &lt;触发条件&gt;]&lt;触发动作体&gt; 安全性实现方法 用户身份鉴别 存取控制技术 自主存取控制：限制存取权限 强制存取控制：数据本身设置安全性标记 TS&gt;=S&gt;=C&gt;=P 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体 仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体 视图技术 审计技术 数据加密存储和加密传输 授权1234GRANT &lt;权限&gt;[,&lt;权限&gt;]... ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]…TO &lt;用户&gt;[,&lt;用户&gt;]...[WITH GRANT OPTION]; 全部权限：ALL PRIVILIGES 全部用户：PUBLIC 允许再授权：WITH GRANT OPTION 不允许循环授权 权限回收 123REVOKE &lt;权限&gt;[,&lt;权限&gt;]... ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…FROM &lt;用户&gt;[,&lt;用户&gt;]...[CASCADE | RESTRICT]; 也可以定义一个具有某种权限角色CREATE ROLE &lt;角色名&gt;，直接将角色赋给用户 范式 1NF: 每个分量必须是不可分开的数据项 2NF: 每一个非主属性都完全函数依赖于任何一个候选码(不存在对主键的部分函数依赖) 解决：对部分依赖属性分解成多个表 3NF: 不存在属性对主键的传递依赖 BCNF: 不存在主属性对码的部分依赖和传递依赖——即不能由属性反推出主码 如果一个关系数据库中的所有关系模式都属于BCNF，那么在函数依赖范畴内，它已实现了模式的彻底分解，达到了最高的规范化程度，消除了插入异常和删除异常 不能说规范化程度越高的关系模式就越好。 数据库设计数据库设计分6个阶段 需求分析 概念结构设计 逻辑结构设计 物理结构设计 数据库实施 数据库运行和维护 联系转换方法： 法一：新建一个联系表，要建立联系的表中的属性组成联系表的主键——多用于多对多 法二：主键+联系写到另一个要联系的表中——外键，多用于一对一，一对多 数据库恢复事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 事务是恢复和并发控制的基本单位 事务的ACID特性： 原子性（Atomicity）:操作要么都做，要么都不做 一致性（Consistency）:事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态 隔离性（Isolation）:一个事务的执行不能被其他事务干扰 持续性（Durability ）:一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。 利用存储在后备副本、日志文件和数据库镜像中的冗余数据来重建数据库 恢复策略： 事务故障：反向扫描文件日志，对该事务的更新操作执行逆操作 系统故障：正向扫描日志文件，重做(REDO) 和撤销 (UNDO) 介质故障：重装数据库，重做已完成的事务 并发控制事务是并发控制的基本单位 主要任务 对并发操作进行正确调度 保证事务的隔离性 保证数据库的一致性：避免发生丢失修改(修改覆盖)、不可重复读(有改删增)、读脏数据(有回滚) 主要技术 封锁 排它锁(X)：写锁，其他事务不能读或改 共享锁(S)：读锁，其实事务可读不可改，读锁上可再加读锁 封锁协议 一级：修改加X, 避免丢失修改 二级：一级 + 读数加S读完就释放 ，避免丢失修改和读脏数据 三级：一级 + 读数加S事务完才释放，进一步避免了不可重复读 避免活锁(类似饥饿)：FCFS 避免死锁： 死锁预防：一次封锁法–效率低；顺序封锁法–难实现 诊断(超时法–可能误判，不够及时；等待图法检测回路)并解除死锁(kill或抢占) 时间戳 乐观控制法 多版本并发控制 冲突可串行化一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是冲突可串行化的调度。 冲突可串行化调度是可串行化调度的充分条件","categories":[{"name":"database","slug":"database","permalink":"http://vergessenwang.github.io/categories/database/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://vergessenwang.github.io/tags/SQL/"}]},{"title":"传输层&网络层","slug":"传输层-网络层","date":"2019-09-04T14:12:41.000Z","updated":"2020-03-11T15:41:33.676Z","comments":true,"path":"posts/network/2019-09-04-传输层-网络层.html","link":"","permalink":"http://vergessenwang.github.io/posts/network/2019-09-04-传输层-网络层.html","excerpt":"基本概念协议定义了在两个或多个对等通信实体之间交换的报文格式和顺序，以及发收报文或其他事件所采取的动作。 语法：传输数据的格式、信号电压 语义：要完成的控制信息、响应、差错控制等功能 时序：执行顺序、条件 协议是水平的，服务是垂直的。 边缘网接入技术家庭接入：DSL(利用数字电话线)、电缆(利用电视线)、FTTH(光纤到户)、拨号(传统电话线，速度慢)和卫星、以太网、WIFI HFC(混合光纤同轴)：是在电缆接入的主干线上用光纤传输，用户共享传输速率。电缆调制调解器会将HFC网络分为上行和下行两个信道，所以不会产生碰撞。 公司接入：以太网(用户接入速率100Mbps~1Gbps, 服务器1Gbps~10Gbps)和WIFI 广域无线接入：3G、4G(第四代广域无线网络)、LTE(长期演进，源于3G)","text":"基本概念协议定义了在两个或多个对等通信实体之间交换的报文格式和顺序，以及发收报文或其他事件所采取的动作。 语法：传输数据的格式、信号电压 语义：要完成的控制信息、响应、差错控制等功能 时序：执行顺序、条件 协议是水平的，服务是垂直的。 边缘网接入技术家庭接入：DSL(利用数字电话线)、电缆(利用电视线)、FTTH(光纤到户)、拨号(传统电话线，速度慢)和卫星、以太网、WIFI HFC(混合光纤同轴)：是在电缆接入的主干线上用光纤传输，用户共享传输速率。电缆调制调解器会将HFC网络分为上行和下行两个信道，所以不会产生碰撞。 公司接入：以太网(用户接入速率100Mbps~1Gbps, 服务器1Gbps~10Gbps)和WIFI 广域无线接入：3G、4G(第四代广域无线网络)、LTE(长期演进，源于3G) 核心网交换技术分组交换：需要存储转发机制和路由选择协议的支持。按需分配 时延：处理时延 + 排队时延(变动的) + 传输时延 + 传播时延 流量强度：La/R 吞吐量：多段链路的吞吐量取决于瓶颈链路 总共有M个用户时，同时有N个用户在发送数据的概率 电路交换：需要TDM和FDM复用技术。连接稳定 因特网结构接入ISP + 区域ISP + IXP + 第一层ISP + 内容提供商 对等层ISP不相互结算，通过IXP接入高层ISP费用更低，这两种方式可以减少费用。 内容提供商的数据中心更靠近低层ISP，绕开高层ISP，可以在减少延迟的同时也降低费用 报文&amp;报文段&amp;数据报&amp;帧 应用层报文指的是在端系统的应用程序之间按照某种协议进行信息交换的分组. 运输层报文段指的是通过TCP/UDP等运输层协议对应用层报文进行封装后所形成的分组, 报文段对报文的传输参数进行了一定的设置, 使其具有了某种特性, 比如面向连接, 确保传递等. 网络层数据报是对运输层报文段和目的地址进行封装后产生的分组. 数据报确定了分组的目的地, 使得分组可以通过网络层从发送方传送到接收方. 链路层帧是对网络层数据报的封装, 它添加了下一个节点的具体地址, 使得分组能够传递到下一个节点 传输层UDP基于IP协议增加： 复用/分用 简单的错误校验 source port + dest port + length + checksum checksum发送方校验和计算：计算所有16位整数的和，进位加在和后面，结果按位取反；接收方检验时将所有字节与检验和相加结果应该为全1 提供”Best effort”服务，UDP段可能丢失或非按序到达 优点：无建立连接的延迟，无需维护连接状态，头部开销少，没有拥塞控制应用程序可更好的控制自己的发送时间和速率 应用：流媒体(现在的语音和图像其实更多是用TCP，因为大多数防火墙会拦截UDP)，DNS，SNMP(简单网络管理协议)——适用于实时服务，且能容忍一定的分组丢失 TCP可靠数据传输协议(rdt)在不可靠的底层信道上实现可靠信道 数据单向传输，控制信息双向流动 可能产生位错误：接收方利用校验和检测位错误，利用确认机制在错误发生(NAK)时要求重传分组,ARQ协议——0-1停等协议 可能ACK/NAK本身有错误，导致重复传递分组，接收方无法对新发来的分组进行判断：增加序列号，接收方丢弃重复分组，而且可以省去NAK(收到重复ACK时代表出错) 可能丢包(数据报或ACK）：需要定时器，发送方等待合理时间之后重传，即使由于延迟最后又到了也能用序号机制处理重复分组。即使知道RTT，对于每一个分组也仍然需要定时器来记录对应的时间。 停等协议中发送方利用率(L/R)/(RTT+ L/R)极低，网络协议限制了物理资源的利用 流水线机制与滑动窗口协议利用等待时间，在收到ACK之前连续发送多个分组 窗口：更大的序列号范围，更大的存储空间缓存分组 滑动窗口：随着协议的运行，窗口在序列号空间内向前滑动(窗口数 &lt; 序列号数) 滑动窗口协议：GBN ，SR Go-Back-N 协议 ACK(n): 到n(包含n)之前的分组均已被正确接收——累积确认机制 多个分组共用一个timer,发送base分组时启动 超时Timeout(n)：重传序列号 &gt;= n 的还未收到ACK的所有分组——可能造成资源浪费 接收方没有缓存，乱序到达的分组直接丢弃，重新确认序列号最大的按序到达分组 缺陷：重传分组太多 Selective Repeat 协议基于GBN修改确认机制和对乱序分组的处理 接收方对每个分组单独确认 接收方缓存乱序到达分组 每个分组有一个timer 避免序列号重叠问题：$N_S+ N_R &lt;= 2^K$ 窗口长度必须&lt;=序号空间大小的一半 TCP原理TCP在IP层提供的不可靠服务基础上实现可靠数据传输。用到了上述的：*流水线机制，累积确认，单一重传定时器，超时或收到重复ACK时触发重传结合了GBN和SR的优点 段结构 序列号：segment第一个字节的编号 ACKs: 希望接收到的下一个字节的序列号，采用累计确认 定时器超时时间的设置：$EstimatedRTT$ + 安全边界 $EstimatedRTT = (1 - \\alpha)EstimatedRTT + \\alphaSampleRTT$ 用多个SampleRTT的指数加权移动平均求估计RTT $\\alpha$ 一般取0.125 $DevRTT = (1 - \\beta)DevRTT + \\beta|SampleRTT-EstimatedRTT|$ 用方差求RTT的变化值即安全边界，$\\beta$ 一般取0.25 $TimeoutInterval = EstimatedRTT + 4*DevRTT$ 快速重传机制：即在定时器超时之前重传，因为真正发生超时的时候，根据上述的计算公式timeoutinterval也会变得很大，所以在收到重复的三个ACK之后，马上重传，每次重传后将超时时间加倍 流量控制：接收方通过在segment头部字段将rcvwindow告诉发送方，发送方据此控制发送数据量 $rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]$ 三次握手四次挥手看图示流程更好理解，注意各个步骤中SYN ACK FIN 等信号的区别 拥塞控制原理相比于可靠数据传输对端到端的传输控制，拥塞控制更多的考虑整个网络的全局性问题。相比于流量控制考虑的是接收方的处理能力，拥塞控制考虑的是整个网络的处理能力 主要表现为分组丢失和排队延迟过大。由于分组丢失和定时器超时都会重发，导致有效分组更少，整体吞吐量进一步下降。同时，在多跳传输中，当分组被dropd掉时，任何用于该分组的上游处理全都白费了，这是对整个网络资源的另一种浪费，在这种情况下，当每个路由器都在做无用功时，吞吐量趋近0。 控制方法： 端到端：端系统通过观察loss , delay 等网络行为判断是否发生拥塞——TCP采用 网络辅助：路由器向发送方反馈网络拥塞信息 ——ATM(异步传输模式) TCP拥塞控制 拥塞窗口：$CongWin &gt;= LastByteSend - LastByteAcked$ 则发送速率为 $rate ≈ CongWin / RTT$ 可以看到拥塞窗口是可以动态调整的 感知拥塞：发送loss事件(timeout或3个重复的ACK)之后，发送方降低速率。速率调整的方法： 加性增-乘性减(AIMD) 每个RTT将CongWin增大一个MSS(TCP一次能传输的数据的最大值，不包括协议头开销)——谨慎增加，拥塞避免 发生loss后将CongWin减半 慢启动(SS) 收到每个ACK将CongWin翻倍，指数型增长 综合运用 设置一个慢启动阈值变量 ssthresh，用来控制是采用SS还是AIMD 开始用SS, 达到ssthresh后改为AIMD 当收到3个重复ACK时，CongWin/2并且将ssthresh更新为前CongWin/2，即又开始线性增长 当发生timeout事件时，直接将CongWin设为1并且将ssthresh更新为前CongWin/2 ，然后开始SS——因为超时表明拥塞更加严重 平均吞吐量计算：期间发送的总MSS数量 / 耗费的RTT数 MSS数量跟发送窗口数W有关 网络层核心功能：转发和路由 路由算法确定通过网络的端到端路径，转发表确定本路由器如何转发分组。 两类分组交换网络服务模型：无连接的数据报网络和连接的虚电路网络 相比于传输层，网络层服务是在网络核心实现的主机到主机服务 虚电路一条从源主机到目的主机类似于电路的逻辑连接，与电路交换的区别是，采用分组交换且每个分组在传输时会利用链路的全部带宽。但同时也具备了电路交换预分配资源的优点，从而使得服务性能有一定的保证 每个分组携带虚电路标识VCID 而不是目的主机地址。同一条虚电路在不同链路段上的VCID 可能是不同的 经过的每个网络设备会维护每条经过它的虚电路连接状态，利用VC转发表记录、改写输入输出VCID 信令协议在建立时一次性确定路径 应用：ATM 、帧中继网络等 数据报无连接，分组携带目的地址。由于路径是不确定的，所以需要路由算法构建转发表。 转发时并不是针对某一具体地址，而是一个地址范围，相当于对转发表进行聚合。最长前缀匹配优先 端系统更为智能，可以自适应、性能控制和差错恢复。(VC的端系统为电话机、传真机) 可以理解为技术进步带来的功能转移，更复杂的处理放到上层去做——简化网络，复杂边缘 应用：Internet IP协议首部结构理解各字段的含义 版本号：一般为IPv4, 即 4H 首部长度：占4位，以4字节为单位。一般不含可选字段时首部长度为20字节，即首部字段为5H 服务类型：一般不使用，00H 总长度：占16位，指的是首部+数据的长度。因此最长数据为 65535B - 20B = 65515B，但是链路层有MTU限制，而且不同链路的MTU也会不同，所以还需要分片和重组机制，路由器只分不装，目的主机负责重组 标识：和源IP目的IP共同标识一个IP分组，取原IP分组的标识 标志位：占3位，保留位 + DF(Don’t Fragment) +MF(More Fragment) 片偏移：相对原IP分组的偏移量，以8字节为单位，每个片长是8的整数倍，计算时要注意取整 生存时间TLL：剩余跳数，转发一次减1，为0 时路由器将其丢弃同时向源主机发送一个ICMP报文 协议：TCP为6 UDP为17 首部校验和：同UDP, 只对首部校验，由于TLL等字段会发生变化，所以要逐跳校验 IP地址IP子网：具有相同网络号的设备接口，彼此间不跨越路由器(第三层及上层网络设备)就可以进行物理联通 有类编址 A类(50%): 子网占8位，最高位固定为0 ，0.0.0.0~127.255.255.255 B类(25%): 子网占16位，最高两位固定为10，128.0.0.0~191.255.255.255 C类(12.5%): 子网占24位，最高三位固定为110，192.0.0.0~223.255.255.255 D类(6.25%): 子网占32位，最高四位固定为1110，224.0.0.0~239.255.255.255 E类(6.25%): 子网占32位，最高四位固定为1111，240.0.0.0~255.255.255.255 A、B、C类可以分配做主机IP地址，注意一些全0(本机)或全1(广播)或127(环回)的特殊地址 还有一部分保留的私有地址(可复用): A类 10 B类 172.16~172.31 C类 192.168.0~192.168.255 子网划分借用主机号的一部分，用子网掩码按位与来提取子网地址 无类域间路由(CIDR)地址格式：a.b.c.d/x 可以将多个子网聚合成一个较大的子网，构成超网，这种路由聚合可以大幅减少路由表内容 IPv6(128bit)更多地址，同时改进首部格式以快速处理转发数据报和支持QoS 首部长度固定40字节——不含可选区，但基本首部之外可含无需路由器处理的拓展首部 版本、优先级、流标签 载荷长度、下一个首部、跳步限制 源地址、目的地址 不允许分片——要分只能在源主机分 不含校验和域，加快处理速度 新版ICMP,：新增 如 包过大的ICMP报文，多播组管理功能 不使用掩码，采用CIDR的...../x 形式表示地址前缀 格式：16bit 4个16进制数一组，共8组。可多个0可省略 过渡技术： 隧道：IPv6封装到IPv4数据部分，完成封装的路由器支持双协议栈 DHCP获取IP地址硬编码：静态配置 DHCP协议：动态主机配置协议，租赁IP地址。服务器为客户配置IP、掩码、默认网关和DNS，即插即用，允许地址重用 要接入的主机广播 DHCP discover 源端口0.0.0.0 68 目的端口255.255.255.255 67 DHCP服务器利用 DHCP offer 响应 主机请求IP DHCP request DHCP服务器分配IP DHCP ack DHCP采用C/S模式，用UDP封装，服务器默认端口67 网络地址转换(NAT)节省IPv4地址，内外IP变动相互隔离，只需通过NAT转换表重定向，增加内部设备的安全性。 争议：要对端口进行处理，违背了层次关系 NAT穿透：如何访问位于内网的服务器或主机 静态配置NAT, 来自特定端口被转发给服务器 利用即插即用互联网网关设备协议IGD 自动配置 中继服务器桥接 ICMP协议差错报告报文：目的不可达，源抑制，超时，参数问题，重定向 网络探询报文：回声请求与应答报文——ping，时间戳请求与应答报文 不发送的情况： 对ICMP报文本身不发 只对第一个IP数据报分片发送，后续分片不发 多播IP数据报不发 特殊地址 如0.0.0.0 或 127.0.0.0 不发 封装到IP数据部分 Traceout 是ICMP的一个应用，通过逐渐增加TTL，依次获得该路径上的路由器名称和IP，选择一个不被使用的端口这样到达目的主机后会返回一个目的端口不可达ICMP报文，终止跟踪。 路由算法静态路由: 手工配置, 更新慢，优先级高 动态路由：及时更新 基于全局信息：链路状态路由算法——OSPF(TCP) 基于Dijkstra算法(单源最短路径) 可能存在震荡现在：由于动态更新，路径一直变来变去 基于局部信息：距离 - 向量路由算法——RIP(最多15跳的内部路由,UDP) 基于Bellman-Ford方程(动态规划) 根据邻居信息和局部链路费用变化异步更新，有变化时才告知邻居 无穷计数问题：好消息传的快，坏消息传的慢，因为要参考未变化的邻居发来的信息 解决方法：毒性逆转 重点 时延计算 socket 通信步骤 可靠数据传输，FSM描述不想看了.. 往返时间估计 TCP/IP五层协议：应用-运输-网络-链路-物理 OSI七层参考模型：应用-表示-会话…. CRC校验码: 原m 位信息左移 生成多项式最高阶 位低位补0，与生成多项式对应的除数进行异或，得到的余数为冗余码 海明码 子网划分：在主机号上进行划分，注意点分十进制与二进制的转换，变长子网划分类似于变长指令拓展，或同一子网由两个不同区间拼接 IP数据报分片: 注意每个分片都要加上首部，片偏移要用起始位 / 8 TCP和UDP的特点和区别 TCP滑动窗口 发送窗口： 已发送并收到确认 || 已发送未收到确认 | 可用窗口 || 不允许发送 接收窗口：已确认并交付主机 || 允许接收的序号 || 不允许接收 拥塞控制及快速重传：区分超时和3个重复ACK时拥塞窗口的变化，注意阈值可能 &lt; 慢启动的$2^n$ TCP的三次握手及四次挥手 握手：SYN = 1, seq = x –&gt; SYN =1, ACK =1 ,seq = y , ack = x +1 –&gt; ACK =1 ,seq = x + 1, ack = y + 1 为什么要四次挥手客户端要等待2MSL：保证最后一个确认报文段无法到达时可以重传；使本次连接所产生的所有报文从网络消失，防止出现已失效的连接请求占用资源。由此可见客户端更早请求关闭，实际上更晚真正关闭 路由选择(距离-向量法) 添加没有的路由，注意跳数 + 1 替换已有的较长路由 更新过时路由","categories":[{"name":"network","slug":"network","permalink":"http://vergessenwang.github.io/categories/network/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://vergessenwang.github.io/tags/TCP-IP/"}]},{"title":"数据结构与C语言","slug":"数据结构与C语言","date":"2019-09-01T15:23:25.000Z","updated":"2020-03-31T06:38:35.354Z","comments":true,"path":"posts/DataStructure/2019-09-01-数据结构与C语言.html","link":"","permalink":"http://vergessenwang.github.io/posts/DataStructure/2019-09-01-数据结构与C语言.html","excerpt":"基于实验楼 C语言实验语言热度排行 果然是犹豫不决学Java… “不管你懂多少延续、闭包、异常处理，只要你不能解释为什么 while(*s++=*t++); 的作用是复制字符串，那你就是在盲目无知的情况下编程，就像一个医生不懂最基本的解剖学就在开处方” Linux 不以文件后缀来区分可执行文件，Linux 下的可执行文件后缀理论上是可以任意更改的。 C语言教程 基本命令编译：gcc -c **.c 生成对象文件 链接：gcc -o ** **.o 生成没有后缀的可执行文件 同时进行：gcc -o ** **.c 执行：./**","text":"基于实验楼 C语言实验语言热度排行 果然是犹豫不决学Java… “不管你懂多少延续、闭包、异常处理，只要你不能解释为什么 while(*s++=*t++); 的作用是复制字符串，那你就是在盲目无知的情况下编程，就像一个医生不懂最基本的解剖学就在开处方” Linux 不以文件后缀来区分可执行文件，Linux 下的可执行文件后缀理论上是可以任意更改的。 C语言教程 基本命令编译：gcc -c **.c 生成对象文件 链接：gcc -o ** **.o 生成没有后缀的可执行文件 同时进行：gcc -o ** **.c 执行：./** 数据类型gcc 编译器为每个int类型分配四个字节（32 个二进位）。在存储单元中的存储方式是：用整数的补码形式存放。所以当 4 个字节的整数类型取值范围是 -2^31 到（2^31-1）。无符号的基本整型表示为 unsigned int，和 int 类型占有的字节数相同，取值范围是 0 到（2^32-1） 字符型数据在存储时，并不是把该字符本身存放到内存单元中，而是把该字符相应的 ASCII 码值存放到该存储单元中。——真正代表了数据含义的是数据类型，而不是二进制本身。用小写表示的字符的 ASCII 码比用大写表示的 ASCII 码大 32。 存储字符串常量时还要自动在其末尾加上 ‘\\0’ 作为字符串结束的标志，所以&quot;b&quot;会占用两个字节而&#39;b&#39;是一个字节 要将一个字符串存放在变量中，必须使用字符数组。C 语言中没有字符串类型，字符串都是存储在字符型数组中的。处理字符串时要加上string.h头文件 在强制类型转换时，得到一个所需类型的中间数据，而原来变量的类型未发生变化 C 库&lt;stdlib.h&gt;中的函数 int atoi(const char *str)把参数 **str** 所指向的字符串转换为一个整数（类型为 int 型） atoi(),itoa() 与强制类型转换的区别atoi(),itoa()是整型数和字符串表示的整型数字之间的转换，是函数调用实现的。对内建基本类型之间的强制类型转换是在编译时实现的，对数值可能会截断、重新解释（不能用(int)直接把表示数字的字符串转成数字，好像要 -&#39;0&#39;) 运算符自增运算符 (++) 和自减运算符 (–) 只能用于变量，而不能用于常量或表达式。如 5++ 或者 (a+b)++ 都是不合法的 字符 (char) 型数据和整形数据进行运算，就是把字符的 ASCII 代码与整形运算 输入输出在 printf 函数中，在格式符 “f” 的前面加 “7.2”。表示的意思是在输出时，指定数据占 7 列，其中小数占 2 列。主要是使小数点对齐，输出时更加美观 %d：按照整型数据的实际长度输出。 %md：以m指定的字段宽度输出，右对齐。加 -左对齐 %ld：输出长整型数据。 %mld：输出指定宽度的长整型数据。 在输入函数时，用 %c 格式声明输入字符时，空格字符和转义字符都是作为有效字符输入，所以输入时中间不要有空格 main函数的参数argc和argvint main(int argc,char *argv[]) = int main(int argc,char **argv)其参数argc和argv用于运行时,把命令行参数传入主程序 int argc英文名为arguments count(参数计数)。运行程序传送给main函数的命令行参数总个数,包括可执行程序名,其中当**argc=1时表示只有一个程序名称,此时存储在argv[0]**中. char **argv:英文名为arguments value/vector(参数值)。用来存放指向字符串参数的指针数组！指针数组！指针数组！不是字符串本身每个元素指向一个参数,空格分隔参数,其长度为argc. argv[0] 指向程序运行时的全路径名 argv[1]指向程序在DOS命令中执行程序名后的第一个字符串 argv[2] 指向执行程序名后的第二个字符串 argv[argc]为NULL 参考Eastmount的博客 命令行运行程序时，要在可执行文件名后加上参数 条件语句while和do…while和 while 语句不同， do...while 语句中的 while（）；后面是有“；”的 另外，当 while 后面的表达式的第一次值为“真”时，两种循环得到的结果是相同的；否则，二者结果不相同(do…while会先执行一次） 要注意的细节 #include&lt;stdio.h&gt;不要忘记写#和.h scanf()函数中的表列是地址表列，要加&amp;，数组不用加 float的精度只有6~7位，double是15~16位，long double是18~19位 在 Linux 系统下，Ｃ 源文件若调用了 math 库里的函数，则编译时要加上-lm（是字母 l ，不是数字１），表示链接到 math 库。 打印数组时要换行可以用一个全局变量整除来控制 C语言知识点字符 c = getchar(); putchar(c); 输入结尾判定getchar() != EOF 通过getchar()获得的数字实际上是一个该数字的ASCII码，用于数值计算时要用c - &#39;0&#39; 数组 a == &amp;a[0] 每个元素是同一数据类型，只能逐个引用(常用for循环)，不能一次引用整个数组。 编译器会为数组分配一段连续内存，二维数组先行后列 定义可以用常量和符号常量，如#define SIZE 10 int a[SIZE];,但一定不能包含变量(访问可用变量)。为了便于后续更改，一般采用符号常量 定义的同时对全部元素赋初值，可以不指定数组长度，如int a[] = {0,1,2,3,4}; 对于二维数组，第一维可以不指定但第二维必须指定 （emmm，发布博文时报错，可能是双大括号的原因，这里删去了，试下能发布的话就是这个原因） 一维数组用例：冒泡排序 二维数组用例：矩阵最大值及行列号——打擂台法 字符数组与字符串 字符数组：char a[] = {&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;}; 长度为4 字符串：char a[] = &quot;abcd&quot;; 以双引号赋值时，系统自动加上&#39;\\0&#39;结束符，长度为5 &lt;string.h&gt; gets(str); puts(str); strcat(str1,str2); strlen(str); strcpy(str1,str2); strcmp(str1,str2); 函数化结构 在程序中用到的所有函数，必须“先定义，后使用” 自定义的函数要在main函数调用之前声明或定义。 函数声明的作用是把有关函数的信息（函数名、函数类型、函数参数的个数与类型）通知编译系统，在进行到 main 函数调用时知道他们是函数而不是变量或其他对象。 有参函数在调用函数时，主调函数通过参数向被调函数传输数据，要注意被调用函数返回值的类型 在定义函数中指定的形参，在未出现函数调用时，他们并不占内存中的存储单元。在发生函数调用时，函数形参被临时分配内存单元；调用结束，形参单元被释放。所以要注意函数内部变量的作用域 C语言中函数不能嵌套定义，但是可以嵌套调用 要访问其他源文件的变量：extern ——用头文件的方式更好#ifndef....#define....#endif 要自己的变量不被访问：static 初始化一次，一直占用空间，循环调用时会共享 指针 变量是对程序中数据存储空间的抽象 指针变量的类型，是指针变量所指向的变量的类型，而不是自身的类型 注意：多维数组中指针的各种运算 数据结构数据结构实验 时空复杂度在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 T(n) 的同数量级（它的同数量级有以下：1，log(2)n，n，n log(2)n ，n 的平方，n 的三次方，2 的 n 次方，n!），找出后，f(n) = 该数量级，若 T(n)/f(n) 求极限可得到一常数 c，则时间复杂度 T(n) = O(f(n))。 计算空间复杂度主要看可变部分，包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。一个算法所需的存储空间用 f(n)表示：S(n)=O(f(n))。其中 n 为问题的规模，S(n)表示空间复杂度。 线性表 集合中必存在唯一的一个”第一个元素”； 集合中必存在唯一的一个”最后的元素”； 除最后元素之外，其它数据元素均有唯一的”后继”； 除第一元素之外，其它数据元素均有唯一的”前驱”。 线性表有顺序和链式两种存储结构 顺序表易随机存取，已使用的空间存储密度大；不易增删，空间固定难扩充 123456typedef struct&#123; Elemtype *elem; //存储空间基址 int length; //当前长度 int size; //当前分配的表长大小&#125;SqList; 插入：先判断表是否已满 –&gt; 判断插入位置是否越界 –&gt; 从最后一个元素开始向后移动一位 –&gt; 插入值，length + 1；平均移动一半元素 T(n) = O(n) 归并算法T(n) = O(n + m) 12345678910void merge(SqList *A,SqList *B,SqList *C)&#123; int i=1,j=1,k=1; while(i &lt;= A-&gt;length &amp;&amp; j &lt;= B-&gt;length) if(A-&gt;elem[i] &lt;= B -&gt;elem[j]) C-&gt;elem[k++] = A-&gt;elem[i++]; else C-&gt;elem[k++] = B-&gt;elem[j++]; while(i &lt;= A-&gt;length) C-&gt;elem[k++] = A-&gt;elem[i++]; while(i &lt;= B-&gt;length) C-&gt;elem[k++] = B-&gt;elem[j++]; C-&gt;length = A-&gt;length + B-&gt;length;&#125; 链表12345typedef struct LNode&#123; ElemType data; // 数据域 struct LNode *next; // 指针域&#125;LNode, *LinkList; LinkList h头指针数据域为空，指针域指向单链表的第一个节点，可以避免对链表的第一个结点做特殊处理。因为对于无头结点的空表，插入值时可以直接对第一个结点的数据域赋值，而无需新建一个结点，或者直接改变第一个指针指向的地址为新结点 尾结点指针域为NULL LNode *p; 常用指向结点的指针变量p，一般直接赋值为某个已存在结点 p = (LinkList)malloc(sizeof(LNode)); free(p); 为要插入的新结点分配空间，删除某结点要释放空间 相比于头插法，尾插法需要多一个尾指针 另外，对于删除操作，可以使用一个暂存已删除结点的avail链表，下次分配时先用链表中的结点，并可以用指针操作在O(1)的复杂度实现整个链表的删除 反转链表由于链表不支持随机访问，所以交换头尾值的方法并不可行，最好还是直接改变指针域方向 123456789101112LNode reverseList(LinkList head) &#123; LNode next = null; LNode pre = null while (head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre;&#125; 循环链表通常只设一个尾指针 连接两个单循环链表：O(1) 1234p = RA -&gt; next; // 找到A的头结点RA -&gt; next = RB -&gt; next -&gt; next; //A尾连B的第一个结点，注意不是头结点free(RB -&gt; next); //记得删除B的头结点RB -&gt; next = p; //B尾连A头 双向链表12345typedef struct dlnode&#123; ElemType data; struct dlnode *prior,*next;&#125;DLNode,*DLinkList; 删除结点 123p -&gt; prior -&gt; next = p -&gt; next;p -&gt; next -&gt; prior = p -&gt; prior;free(p); 双向循环链表没有空指针域 栈和队列(受限线性表)栈通常我们称表尾端为栈顶，表头端为栈底。栈上溢是一种出错状态，下溢则是一种正常状态，常用作程序转移控制条件 可以解决例如数值转换、括号匹配、迷宫求解、表达式求值和汉诺塔等等问题。 也有顺序存储结构和链式存储结构两种表示方法 顺序实现结构体： 12345typedef struct&#123; SElemType *base; //栈尾指针 SElemType *top; //栈顶指针 int size; //栈的大小&#125;SqStack; 链式实现结构体： 1234typedef struct node&#123; ElemType data; struct node *next;&#125;StackNode; 对于链栈，若新申请一个结点时t = NULL 则表示链满；申请成功用头插法插入到top结点前并更新top 多栈共享存储空间：两个栈的栈底分别设在存储空间的两端，向中间延伸，相遇时溢出。 队列允许插入元素的一端称为队尾，允许删除元素的一端称为队头 应用于操作系统调度任务队列。 顺序实现： 1234typedef struct&#123; ElemType elem[MAXSIZE]; int rear,front;&#125;SeQueue; 由于队首指针会不断向后移动，前面空间无法利用，造成一种假溢出，于是可以将首尾连起来，构成循环队列。为了区分队满队空，要留出一个空间，队空 sq -&gt; front == sq -&gt; rear 队满sq -&gt; front == (sq -&gt; rear + 1) % MAXSIZE 链表实现： 123456789typedef struct QNode&#123; QElemType data; struct QNode *next;&#125;QNode, *QueuePtr;typedef struct&#123; QueuePtr front; //队头指针 QueuePtr rear; //队尾指针&#125;LinkQueue; 入队时空链表要特殊处理，因为此时都指向同一个结点(对头指针多做一个指向p结点的操作)： 12345678void In_LQueue(LQueue *Lq,ElemType x)&#123; QNode *p; p = (QNode*)malloc(sizeof(QNode)); p -&gt; data = x; p -&gt; next = NULL; if(Lq -&gt; rear == NULL) Lq -&gt; front = Lq -&gt; rear = p; else &#123;Lq -&gt; rear -&gt; next = p; Lq -&gt; rear = p;&#125;&#125; 出队时同理，当成为空表时，对尾结点多做一个指向新的头结点的操作。 树用孩子兄弟法将任意的一棵树转成一个没有右孩子二叉树。 树不能为空，二叉树可以为空。二叉树左右子树不能交换，而树的左右子树可以交换 二叉树重要性质 第 i 层最多 $2^{i-1}$ 个结点 k 层树最多 $2^k-1$ 个结点 $n_0 = n_2 + 1$ 完全二叉树性质假设对各节点从上到下，从左到右依次编号1~n,则对任意节点a编号i，有 ： 当n为偶数时，n1=1，n为奇数时，n1=0 如果i=1,则节点i是根节点，无双亲 如果i&gt;1,则节点i的双亲节点为$\\lfloor i/2\\rfloor$ 如果2i&lt;=n，则i的左孩为2i，如果2i&gt;n，则i无左孩 如果2i+1&lt;=n,则i的右孩为2i+1，否则i无右孩 顺序存储：由于位置隐含了亲子关系，故可用顺序存储的索引来表示关系，元素按在完全二叉树的顺序存储。问题是有很多空闲空间且不便于修改 二叉链式存储： 12345typedef struct BiTNode&#123; TElemType data; //数据 struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree; 三叉链表多一个双亲指针 遍历以递归的方式先序遍历： 123456789Status PreOrderTraverse(BiTree T, void (*visit)(TElemType))&#123; if (T) &#123; visit(T-&gt;data); PreOrderTraverse(T-&gt;lchild, visit); PreOrderTraverse(T-&gt;rchild, visit); &#125;&#125; 用栈实现迭代的中序遍历： 123456789101112void iterInorder(treePointer node)&#123; int top = -1; treePointer stack[MAX_STACK_SIZE]; for(;;)&#123; for(;node;node = node -&gt; lchild) push(node); node = pop(); if(!node) break; printf(\"%d\",node -&gt; data); node = node -&gt; rchild; &#125;&#125; 用队列实现层序遍历： 12345678910111213void LevelOrder(BinTree BT) &#123; if (!BT) return; Queue Q; BinTree T; Q = CreatQueue(MaxSize); //创建变初始化队列 Add(Q,BT); while(!IsEmpty(Q))&#123; T = Delete(Q); printf(\"%d \", T-&gt;Data); //访问队列中的结点 if (T-&gt;Left) Add(Q,T-&gt;Left); if (T-&gt;Right) Add(Q,T-&gt;Right); &#125; &#125; 由二叉树的先/后/层序遍历结合一个中序遍历可以唯一确定一个二叉树 递归判断二叉树相等： 123int equal(BinTree first,BinTree second)&#123; return ((!first) &amp;&amp; (!second) || (first &amp;&amp; second &amp;&amp; (first -&gt; data == second -&gt; data) &amp;&amp; equal(first -&gt; lchild,second -&gt; lchild) &amp;&amp; equal(first -&gt; rchild,secnd -&gt; rchild)));&#125; 线索二叉树充分利用空指针域，存放中序遍历的前驱或后继。要设置一个标志位表明存放的是指向孩子的指针还是指向前驱或后继的指针 则可以在O(n)时间内实现中序遍历 堆基于完全二叉树，对关键字值有特殊的约束——可以用数组实现 从堆顶删除，从堆底插入，中途可能要做多次调整 常用来实现OS中的优先级队列 插入大顶堆： 12345678910111213void insert_max_heap(element item,int *n)&#123; int i; if(HEAP_FULL(*n))&#123; fprintf(stderr,\"the heap is full.\\n\"); exit(1); &#125; i = ++(*n); while((i !=1)&amp;&amp;(item.key &gt; heap[i/2].key))&#123; heap[i] = heap[i/2]; // 比待插入元素值小则下沉到左子树 i /= 2; &#125; heap[i] = item;&#125; 最大-最小堆各层交替为最小层和最大层，根结点位于最小层 插入删除操作检查从根到待插入位置路径上的相关结点，根据值大小进行相关调整 应用：双端优先队列 双端堆根结点无元素，左子树是最小堆，右子树是最大堆 若 i 是最小堆中的一个结点，则在最大堆中对应的同一位置结点是 $ i + 2^{\\lfloor log_2 i \\rfloor -1}$ 对应位置相互移动时无需调整，在插入时要用这种方式腾出一个位置 二叉搜索树 所有关键字都不同(所以在插入操作中要先判断是否重复)，中序遍历有序 迭代查找： 12345678tree_pointer search(tree_pointer tree,int key)&#123; while(tree)&#123; if(key == tree -&gt; data) return tree; else if (key &lt; tree -&gt; data) tree = tree -&gt; left_child; else tree = tree -&gt; right_child; &#125; return null;&#125; 删除有两个子树的非叶结点：用左子树中最大元素或右子树中最小元素代替被删除结点位置——不同于AVL树，没有平衡要求 平衡二叉树对树高有约束的二叉搜索树，左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树 构造与调整方法平衡二叉树的常用算法有红黑树、AVL、Treap 等。 最小二叉平衡树的节点的公式如下 $F(n)=F(n-1)+F(n-2)+1$ 这个类似于一个递归的数列，可以参考 Fibonacci 数列，1 是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量 哈弗曼树也称最优二叉树，它是带权路径长度最小的二叉树。 常用于解决最短、最少类构造问题 败者树(选择树)每个父结点记录较小子树，一直向上比较，直至根结点表示所有记录中最小的结点——区别于堆，非叶结点并不是记录，而是比较结果 常用于外部排序的有序段多路平衡归并，可大幅减少比较次数。$O(nlog_2 k)$ 森林转为二叉树：先将每个树转成二叉树，再把后一个树挂在前一个树的右孩子位置 树的后根遍历—森林中序遍历—二叉树中序遍历 ，先序三者对应 并查集指针由孩子结点指向父亲结点 由于没有重复元素，可以用数组实现，索引表示元素值，值域表示其双亲结点，根结点父亲用-1表示 合并：让一棵树的根指针直接指向另一个树的根 合并可能产生退化问题，优化方式： 加权规则：结点数多的做父亲 路径压缩 应用：等价类 图在有向图的邻接表存储中，链表代表的是该顶点的出边表 ，逆邻接表存储入边表 1234567891011121314151617181920/* * 邻接表存储结构 */typedef struct EdgeNode&#123; int adjvex; //顶点的位置 struct EdgeNode *next; //指向下一条边的指针&#125;EdgeNode, *EdgeLink;typedef struct VexNode&#123; VexType data; //顶点数据 EdgeNode *firstEdge; //指向第一条依附该顶点的边的指针&#125;VexNode, AdjList[MAX_NUM];typedef struct&#123; AdjList adjList; int vexNum, edgeNum; //顶点数和边数&#125;ALGraph; DFS&amp;BFS深度优先搜索是树的先根遍历的推广，广度优先搜索是树的按层次遍历的推广。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* * 递归从第i个结点深度优先遍历图 */void DFS(ALGraph G, int i)&#123; EdgeLink p; visited[i] = TRUE; printf(\"%c \", G.adjList[i].data); p = G.adjList[i].firstEdge; while (p) &#123; if (!visited[p-&gt;adjvex]) &#123; DFS(G, p-&gt;adjvex); &#125; p = p-&gt;next; &#125;&#125;/* * 深度优先遍历 */Status DFSTraverse(ALGraph G)&#123; int i; for (i = 0; i &lt; MAX_NUM; i++) &#123; visited[i] = FALSE; &#125; for (i = 0; i &lt; G.vexNum; i++) &#123; if (!visited[i]) &#123; DFS(G, i); &#125; &#125; return OK;&#125;/* * 广度优先遍历 */Status BFSTraverse(ALGraph G)&#123; int i; EdgeLink p; LinkQueue Q; InitQueue(&amp;Q); for (i = 0; i &lt; MAX_NUM; i++) &#123; visited[i] = FALSE; &#125; for (i = 0; i &lt; G.vexNum; i++) &#123; if (!visited[i]) &#123; visited[i] = TRUE; printf(\"%c \", G.adjList[i].data); EnQueue(&amp;Q, i); while (!IsEmpty(Q)) &#123; DeQueue(&amp;Q, &amp;i); p = G.adjList[i].firstEdge; while (p) &#123; if (!visited[p-&gt;adjvex]) &#123; visited[p-&gt;adjvex] = TRUE; printf(\"%c \", G.adjList[p-&gt;adjvex].data); EnQueue(&amp;Q, p-&gt;adjvex); &#125; p = p-&gt;next; &#125; &#125; &#125; &#125; return OK;&#125; 无向图中的极大连通子图称为连通分量，如果是有向图中的任意一对顶点都有路径，那么这个就是强连通图，相应的它的极大连通子图就称为强连通分量。 一个连通图的一个极小连通子图，它包含所有顶点，但足以构成一棵树的 n-1 条边，加一条边必定会形成环，这个就称为生成树 关节点：删除该点及关联边后的新图至少含两个连通分支 双连通图：不含关节点的连通图 最小生成树权值最小的生成树为最小生成树，可以用 kruskal（克鲁斯卡尔）算法：按权值递增加边，保证加入后不构成环路——中间可能构成森林 Prim（普里姆）算法：从单一节点树开始加边并构成一个树——中间始终是一个树 Sollin算法：第一步形成包含所有树的森林，之后每一步为每棵树选一条边——森林融合成树 单源多目标最短路径Dijkstra 算法采用的是贪心策略 ，具体实现 完全最短路径法一：多次调用Dijkstra 算法 法二：计算代价矩阵 判断任意两个顶点之间是否存在一条路径，可以通过传递闭包矩阵和自反传递闭包矩阵解决 说实话这部分，没看太懂…开学考试完了再回头好好理解一下 算法汇总最大子序和12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#define SIZE 13int longestsum(int n[]);int main()&#123; int a[SIZE]; int i,rs; printf(\"please input %d number:\\n\",SIZE); for(i =0;i &lt; SIZE;i++)&#123; scanf(\"%d\",&amp;a[i]);&#125; rs = longestsum(a); printf(\"The longest subquence sum is %d\",rs); return 0;&#125;int longestsum(int n[])&#123; int thissum=0,i,maxsum; maxsum = n[0]; for(i =0;i &lt; SIZE;i++)&#123; thissum += n[i]; if(thissum &gt; maxsum)&#123;maxsum = thissum;&#125; else if(thissum &lt; 0)&#123;thissum = 0;&#125; &#125; return maxsum;&#125; 更多常规算法 一元多项式相加 O(m + n)特别注意：两系数之和为0的情况 12345678910111213141516171819202122232425262728293031323334353637383940int poltn_add(Node *&amp;A,Node *&amp;B)&#123; Node *p,*q,*p1,*m; p=A-&gt;next; p1=A; q=B-&gt;next; while (p&amp;&amp;q) &#123; if (p-&gt;exp &lt; q-&gt;exp) &#123; p = p-&gt;next; p1 = p1-&gt;next; &#125; else &#123; if (p-&gt;exp &gt; q-&gt;exp) &#123; m = q; q = q-&gt;next; m-&gt;next = p; p1-&gt;next = m; p1 = m; &#125; else &#123; p-&gt;coef = p-&gt;coef + q-&gt;coef; if (p-&gt;coef != 0) &#123; p = p-&gt;next; p1 = p1-&gt;next; m = q; m = q; q = q-&gt;next; free(m); &#125; &#125; &#125; &#125; return 0;&#125; 如果是更多的多项式相加，可以创建中间多项式，用两两相加实现 多项式相乘，也可以分解成一系列的加法运算 更详细解法 等价关系和等价类定义：集合S上的关系≡≡,称为S上为等价关系，当且仅当它在S上是对称的，自反的，传递的。 时间和空间的开销是O(m+n). 关键步骤： 12345678910111213141516171819202122232425262728printf(\"Enter a pair of numbers (-1 -1 to quit):\" );//循环输入等价关系的元素对scanf(\"%d%d\",&amp;i,&amp;j);while(i&gt;=0)&#123; x=(node_pointer)malloc(sizeof(node)); if(IS_FULL(x)) &#123; fprintf(stderr,\"the memory is full\\n\"); exit(1); &#125; //插入到第i个链表的前端 x-&gt;data=j; x-&gt;link=seq[i]; seq[i]=x; x=(node_pointer)malloc(sizeof(node)); if(IS_FULL(x)) &#123; fprintf(stderr,\"the memory is full\\n\"); exit(1); &#125; //插入到第j个链表的前端 x-&gt;data=i; x-&gt;link=seq[j]; seq[j]=x; printf(\"Enter a pair of numbers (-1 -1 to quit):\" ); scanf(\"%d%d\",&amp;i,&amp;j);&#125; 分别插入到对方的链表中。输出时每遍历到一个新的位置，改变其标志位，以后不再输出。 稀疏矩阵十字链表存储 O(max{col,row} + terms)多种存储方式 在十字链表中，数组的每一行的非零元素结点构成一个带头结点的循环链表，每一列的非零元素结点也构成一个带头结点的循环链表，这种组织方法使同一非零元素结点既处在某一行的链表中，又处在某一列的链表中。因此非零元素结点中设有两个指针域：指针域down指向其同列的下一个非零元素的结点，right域指向其同行的下一个非零元素结点。除这两个域外，结点中还应设有存放该非零元素的行值、列值、元素值的域。 结构体： 12345678910typedef int ElemType;typedef struct OLNode&#123; int row, col; union &#123; struct OLNode *next; //表头结点使用next域 ElemType e; //表中元素结点使用e域 &#125;uval; struct OLNode *down, *right;&#125;OLNode,*OLink; 详细解释 用三元组法比较简单可用数组实现，转置时直接在新的数组中交换原来的行列即可。这种转置的复杂度很高 O(row col terms) 改进：先确定原矩阵中每列非零元素对应转置矩阵的每行非零元素位置，就可以从起始位置开始处理 矩阵乘法：…以后再看 迷宫问题回溯法 字符串匹配对朴素串匹配 O( n * m)进行改进：可以先比较第一个和最后一个字符，可以在一定程度上减少比较次数 KMP算法O( n + m)：主串不回退，模式串的后缀与前缀在多大程度上重合，next数组首位为0，第二位为1，之后是前后缀匹配的长度或将前后缀匹配数组后移一位，next数组首位置-1","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://vergessenwang.github.io/categories/DataStructure/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://vergessenwang.github.io/tags/C语言/"},{"name":"树","slug":"树","permalink":"http://vergessenwang.github.io/tags/树/"},{"name":"栈","slug":"栈","permalink":"http://vergessenwang.github.io/tags/栈/"},{"name":"队列","slug":"队列","permalink":"http://vergessenwang.github.io/tags/队列/"}]},{"title":"进程同步和通信","slug":"进程同步和通信","date":"2019-08-24T15:33:47.000Z","updated":"2020-03-08T15:30:40.759Z","comments":true,"path":"posts/OS/2019-08-24-进程同步和通信.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2019-08-24-进程同步和通信.html","excerpt":"信号量与管程互斥只是进程间关系的一个方面，很多时候，进程间还需要进行同步和通信，因此就需要更高级的同步互斥方法。 信号量(抽象数据类型) 一个整型sem , 两个原子操作 P() : sem - 1 , 若 sem &lt; 0 等待，否则继续 V()：sem + 1, 若 sem &lt;= 0 , 唤醒一个等待的P 互斥：二进制信号量 mutex = new Semaphore(1); 条件同步：计数信号量 fullBuffers = new Semaphore(0); emptyBuffers = new Semaphore(n); 相比于锁机制，可以实现进程的并行。","text":"信号量与管程互斥只是进程间关系的一个方面，很多时候，进程间还需要进行同步和通信，因此就需要更高级的同步互斥方法。 信号量(抽象数据类型) 一个整型sem , 两个原子操作 P() : sem - 1 , 若 sem &lt; 0 等待，否则继续 V()：sem + 1, 若 sem &lt;= 0 , 唤醒一个等待的P 互斥：二进制信号量 mutex = new Semaphore(1); 条件同步：计数信号量 fullBuffers = new Semaphore(0); emptyBuffers = new Semaphore(n); 相比于锁机制，可以实现进程的并行。 实现细节12345678910111213141516171819classSemaphore&#123; int sem; WaitQueue q;&#125;Semaphore::P()&#123; sem--; if(sem &lt; 0)&#123; Add this thread t to q; block(p); &#125;&#125;Semaphore::V()&#123; sem++; if(sem &lt;= 0)&#123; // 由于先释放一个资源，所以要判断= Remove a thread t from q; wakeup(t); &#125;&#125; 存在问题 开发代码时容易出错：使用的信号量已经被占用；忘记释放信号量 不能处理死锁 管程(模块)最初是从编程语言的层面提出的，而不是os层面。通过在高级语言中设计管程机制，简化开发中对同步互斥的操作，实现语言的并发机制。 可以把管程理解成一个特殊的空间。 一个Lock ：指定临界区, 还没有拿到锁的进程挂在entry queue上，等待进入管程 0或n个条件变量：已进入管程的进程在并发访问临界区时所受到的约束，等待进程挂在对应条件变量的等待队列(queues associated with x,y….conditions)上 wait()：释放锁进入睡眠 signal() 实现细节12345678910111213141516171819class Condition&#123; int num Waiting = 0; WaitQueue q;&#125;Condition::Wait(lock)&#123; numWaiting++; Add this thread t to q; release(lock); //释放锁，允许其他进程进入管程执行(要是先睡眠就没有办法释放了) schedule(); // 当前进程睡眠，调度一个就绪进程继续执行 require(lock); // 再次获得锁才能再次进行wait循环&#125;Condition::Signal()&#123; if(numWaiting &gt; 0)&#123; Remove a thread t from q; wakeup(t); // 将一个睡眠进程置为就绪状态 numWaiting--; &#125;&#125; 区别于信号量的V操作，signal不一定会做减法。 例：生产者消费者问题12345678910111213141516171819202122classBoundedBuffer&#123; Lock lock；// 拿到锁才能进入管程访问临界区，同一时刻只有一个进程可以进入,不管是生产者还是消费者 int count = 0；// 缓存区占用空间 Condition notFull,notEmpty;&#125;BoundedBuffer::Deposite(c)&#123; lock -&gt; Acquire(); while(count == n) notFull.Wait(&amp;lock); // 区满等待 Add c to the buffer; count++; notEmpty.Signal(); // 唤醒一个消费者 lock -&gt; Release();&#125;BoundedBuffer::Remove(c)&#123; lock -&gt; Acquire(); while(count == 0) notEmpty.Wait(&amp;lock); Remove c from buffer; count--; notFull.Signal(); lock -&gt; Release();&#125; 存在的问题当一个正在执行的进程A发出signal操作后，将会调度一个就绪的进程B，那么这个时候到底要执行那一个进程呢？ Hansen方法：让进程A继续执行，完成release操作，这个时候可能存在多个就绪进程去抢占lock Hoare方法：让进程B继续执行，此时不会有抢占问题。用if代替while 经典同步问题的实现读者写者问题读者优先已经有读者时，下一个读者也可以进入，只是需要用原子操作来改变count变量。可能造成写者一直等待 写者 123sem_wait(WriteMutex);write;sem_post(WriteMutex); 读者 1234567891011sem_wait(CountMutex);if(Rcount == 0) sem_wait(WriteMutex);++Rcount;sem_post(CountMutex);read;sem_wait(CountMutex);--Rcount;if(Rcount == 0) sem_post(WriteMutex);sem_post(CountMutex); 写者优先同理，写者之间不互斥 哲学家就餐问题思路一：先拿左再拿右。可能同时拿左，造成死锁 思路二：右边不在把左边放回，随机等待一会再重复。可能造成饥饿 思路三：将就餐的的动作视为互斥。每次允许一人吃饭，效率降低，有三个叉子浪费了 思路四：要么不拿要么拿两把，把状态当临界资源，改变状态是一个互斥操作。 我正学到这，老爸走进来，我跟他说了这个问题，他说这还不好办，把筷子从中间一砍啊！ 真妙啊….. 1234567891011121314151617181920212223242526272829303132333435void philosopher(int i)&#123; while(true) &#123; think(); take_forks(i); eat(); put_forks(i); &#125;&#125;void take_forks(int i)&#123; P(mutex); state[i] = hungry; test_take_left_right_forks(i); V(mutex); P(s[i]); // 没拿到叉子就阻塞&#125;void test_take_left_right_forks(int i)&#123; if(state[i] == hungry &amp;&amp; state[left] != eating &amp;&amp; state[right] != eating)&#123; // 判断可否同时拿到两把叉子 state[i] = eating; v(s[i]); &#125;&#125;void put_fork(int i)&#123; P(mutex); state[i] = thinking; test_take_left_right_forks(left); // 奥妙之处，帮助邻居判断，满足条件把叉子给邻居并其唤醒 test_take_left_right_forks(right); V(mutex);&#125; 进程通信(IPC)为了解决进程间竞争关系（间接制约关系）而引入进程互斥；为了解决进程间松散的协作关系( 直接制约关系)而引入进程同步； 为了解决进程间紧密的协作关系而引入进程通信。互斥是一种特殊的同步，进程同步是一种进程通信。 进程之间互相交换信息的工作称之为进程通信IPC （InterProcess Communication）（主要是指大量数据的交换）。进程同步往往只有传递信号的作用，不能传递数据。 详见：进程的同步、互斥、通信的区别 从发送路径上看，可分为：直接通信和间接通信(通过一个消息队列发送和接收消息) 从对是否正确发送消息的处理方式来看，可分为：同步阻塞(直到正确发送才进行下一步)和异步非阻塞 进程间的通信可以分为两种模型，分别为： 共享内存(Shared Memory): 直接通信。开辟一段新的贡献资源段，然后两个进程之间进行数据信息等的交互，该过程不受CPU的控制。 消息传递(Message Passing)：间接通信。将相关的信息传给内核，然后内核将其转发 信号类似于一种异步打断机制，用软件中断通知事件处理。 具体实现：需要接受信息的应用程序会在OS中注册一个handler函数，在收到传来的信号时，OS从内核态返回用户态，并把应用程序的堆栈指针设置为handler函数的入口地址 信号与信号量的区别： 信号(signal)：是一种处理异步事件的方式。信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程外，还可以发送信号给进程本身。linux除了支持unix早期的信号语义函数，还支持语义符合posix.1标准的信号函数sigaction。 信号量(Semaphore)：进程间通信处理同步互斥的机制。在多线程环境下使用，它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。 信号比较高效但不能传数据。 管道|可以进行数据交换。一个进程的输出作为另一个的输入，完成重定向。 管道是一种虚文件，实际上是内核的一块缓存区，之所以称之为虚文件，因为对于左边进程而言它就像一个接收文件，对右边进程而言它就像一个数据发送文件。 具体实现：创建管道，创建两个新的进程，由于子进程继承父进程的文件描述符，这时把管道当做一种文件来处理，并分别设置两个子进程的管道写端和管道读端 消息队列管道的建立依赖于进程间的父子关系，而且传输的数据是字节流，没有结构化关系。消息队列可以解决这两个问题，将消息作为字节序列存储在消息数组中 共享内存管道和消息队列都是间接通信。共享内存实现的是直接通信，可以快速大量地传输数据，但是会有一致性问题。 SOCKET更多用在网络进程通信。相关内容以前已经写过。","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"信号量","slug":"信号量","permalink":"http://vergessenwang.github.io/tags/信号量/"},{"name":"读者写者问题","slug":"读者写者问题","permalink":"http://vergessenwang.github.io/tags/读者写者问题/"},{"name":"哲学家就餐问题","slug":"哲学家就餐问题","permalink":"http://vergessenwang.github.io/tags/哲学家就餐问题/"}]},{"title":"基于MySQL的数据库操作实验","slug":"基于MySQL的数据库操作实验","date":"2019-08-15T15:00:43.000Z","updated":"2020-03-11T15:40:38.362Z","comments":true,"path":"posts/database/2019-08-15-基于MySQL的数据库操作实验.html","link":"","permalink":"http://vergessenwang.github.io/posts/database/2019-08-15-基于MySQL的数据库操作实验.html","excerpt":"安装MySQL在MySQL官网下载社区版，我下载的是8.0.17版本。安装时选择Developer Default 一路执行，可以看到有安装上Server/Workbench/For Excel/Shell/Router 以及 C++/Python/NET等多种语言Connector 默认使用TCP/IP协议，端口为3306 设置超级用户root的密码l**3 创建一个普通用户–我的名字–123456 ，如果把host改成localhost 将只能在本地登录，身份设置为DB Admin windows下服务名为MySQL80 我喜欢手动开启不常用的服务，这里没有选择开机启动 Router暂时用不到，没有配置 安装完毕自动启动了一个shell和一个workbench","text":"安装MySQL在MySQL官网下载社区版，我下载的是8.0.17版本。安装时选择Developer Default 一路执行，可以看到有安装上Server/Workbench/For Excel/Shell/Router 以及 C++/Python/NET等多种语言Connector 默认使用TCP/IP协议，端口为3306 设置超级用户root的密码l**3 创建一个普通用户–我的名字–123456 ，如果把host改成localhost 将只能在本地登录，身份设置为DB Admin windows下服务名为MySQL80 我喜欢手动开启不常用的服务，这里没有选择开机启动 Router暂时用不到，没有配置 安装完毕自动启动了一个shell和一个workbench 基本操作登录workbench→Database→connect to database→输入用户名→store in…输入密码，进入主界面 新建数据库选择schemas中的一个数据库右键create schema ,命名创建 修改数据库选中要修改的数据库，右键alter schema 删除数据库选中要修改的数据库，右键drop schema 新建、修改、删除数据表注意：所有的操作最后都需要进行刷新才能看到效果，右键数据表refresh all 选中要建表的数据库中的tables, 右键新建。点击column name 下的空白格按需求新建表项，Apply之后左侧就会有相应的信息 修改和删除同数据库操作 添加用户选择server→users and privileges →查看已登录账号的Administrative roles中是否有useradmin权限，若有→add acount 安装PowerDesigner一路next，地区选USA，最后覆盖一下dll文件 基本操作新建概念模型右键workspace→new→conceptual data model 新建完之后选中右边的entity, 然后点击中间空白处新建一个Entity ,右键properties进行属性Attributes设置 建立Entity之间的联系，就是用relationship 和inheritance 把关系连起来 注：概念模型与逻辑模型 建立物理模型工具栏tools→generate physical data model →选择相应的DBMS 注意：先建立了概念模型之后才能生成相应的物理模型 生成完毕会多一个物理模型编辑窗口，选中关系连线如relationship，右键properties，可以在preview中查看代码。在join中选择要建立联系的属性 检验模型的正确性tools → check model 配置数据源windows系统 控制面板 — 管理工具 — ODBC数据源 — 用户DSN — 添加 MySQL OBDC 8.0 Unicode Driver 填上名称，主机127.0.0.1 管理员账密 ，用Test测试一下连接 ，不是开机启动的话，要在services.msc 服务中开启 MySQL80 。连接成功后选择一个数据库 由物理模型自动生成MySQL表选中物理模型编辑页，打开工具栏 database → connect →ODBC machine datasource →选择配置的数据源，输入账密。 连接成功后， database → generate database 生成的SQL语句要进行正确性验证之后，才能执行真正生成数据库。打开MySQL workbench , open SQL Script运行 refresh all 即可在MySQL看到来自Powerdesigner的模型生成的数据库 在实验楼中完成操作部分实验 实验中值得注意的地方CHAR 和 VARCHAR 的区别CHAR 的长度是固定的，而 VARCHAR 的长度是可以变化的，比如，存储字符串 “abc”，对于 CHAR(10)，表示存储的字符将占 10 个字节(包括 7 个空字符)，而同样的 VARCHAR(12) 则只占用4个字节的长度，增加一个额外字节来存储字符串本身的长度，12 只是最大值，当你存储的字符小于 12 时，按实际长度存储。 ENUM和SET的区别ENUM 类型的数据的值，必须是定义时枚举的值的其中之一，即单选，而 SET 类型的值则可以多选。 SQL约束MySQL通常的约束：主键(primary key)、默认值(default)、唯一(unique)、外键(foreign key)、非空(not null) 一个表可以有多个外键，每个外键必须 REFERENCES (参考) 另一个表的主键，被外键约束的列，取值必须在它参考的列中有对应值。外键既能确保数据完整性，也能表现表之间的关系。 如 FOREIGN KEY(sid) REFERENCES student(sid) 常用操作语句单表操作123456SELECT name,age FROM employee WHERE age&gt;25 AND age&lt;30; // 不包含边界SELECT name,age FROM employee WHERE age BETWEEN 25 AND 30 ; // 包含SELECT name,age,phone,in_dpt FROM employee WHERE in_dpt IN (&apos;dpt1&apos;,&apos;dpt3&apos;); // 从不连续的范围中找SELECT name,age,phone FROM employee WHERE name LIKE &apos;J%&apos;;SELECT name,age,salary,phone FROM employee ORDER BY salary DESC;SELECT MAX(salary) AS max_salary,MIN(salary) FROM employee; // as重命名 关键字 LIKE 用于实现模糊查询，常见于搜索功能中。和 LIKE 联用的通常还有通配符，代表未知字符。SQL中的通配符是 _ 和 % 。其中 _ 代表一个未指定字符，% 代表不定个未指定字符 默认情况下，ORDER BY 的结果是升序排列，而使用关键词 ASC 和 DESC 可指定升序或降序排序 5 个内置函数： COUNT 函数可用于任何数据类型(因为它只是计数)，而 SUM 、AVG 函数都只能对数字类数据类型做计算，MAX 和 MIN 可用于数值、字符串或是日期时间数据类型 多表操作子查询只有在结果来自一个表时才有用。 1234SELECT of_dpt,COUNT(proj_name) AS count_project FROM project GROUP BY of_dpt HAVING of_dpt IN(SELECT in_dpt FROM employee WHERE name=&apos;Tom&apos;); HAVING 关键字可以的作用和 WHERE 是一样的，都是说明接下来要进行条件筛选操作。区别在于 HAVING 用于对分组后的数据进行筛选 连接查询结果来自多个表时，要进行连接 123456789SELECT id,name,people_numFROM employee,departmentWHERE employee.in_dpt = department.dpt_nameORDER BY id;//orSELECT id,name,people_numFROM employee JOIN departmentON employee.in_dpt = department.dpt_nameORDER BY id; 综合应用例：使用连接查询的方式，查询出各员工所在部门的人数与工程数，工程数命名为 count_project。 1234SELECT name, people_num, COUNT(proj_name) AS count_projectFROM employee, department, projectWHERE in_dpt = dpt_name AND of_dpt = dpt_nameGROUP BY name, people_num; 数据库操作目前 Mysql 没有提供重命名数据库名称的方法。 重命名表名称 12345RENAME TABLE 原名 TO 新名字;ALTER TABLE 原名 RENAME 新名;ALTER TABLE 原名 RENAME TO 新名; 新建：create 删除：drop 列操作123ALTER TABLE 表名字 ADD COLUMN 列名字 数据类型 约束;或：ALTER TABLE 表名字 ADD 列名字 数据类型 约束; 新增加的列，被默认放置在这张表的最右边。如果要把增加的列插入在指定位置，则需要在语句的最后使用AFTER关键词(“AFTER 列1” 表示新增的列被放置在 “列1” 的后面)。如果想放在第一列的位置，则使用 FIRST 关键词 如 ALTER TABLE employee ADD weight INT(4) DEFAULT 120 AFTER age; 删除列: 用drop代替add 重命名: 重命名语句后面的 “数据类型” 不能省略。 1ALTER TABLE 表名字 CHANGE 原列名 新列名 数据类型 约束; 当原列名和新列名相同的时候，指定新的数据类型或约束，就可以用于修改数据类型或约束 另外一种改变数据类型的方式 1ALTER TABLE 表名字 MODIFY 列名字 新数据类型; 值操作12UPDATE 表名字 SET 列1=值1,列2=值2 WHERE 条件;DELETE FROM 表名字 WHERE 条件; 注意都要加上WHERE关键字，不用的话相当于对整个表进行操作，即整列修改或删除表中所有记录 其他操作索引建立索引可以加快查询速度。 12345ALTER TABLE 表名字 ADD INDEX 索引名 (列名);//orCREATE INDEX 索引名 ON 表名字 (列名);//查看索引SHOW INDEX FROM 表名字; 在使用 SELECT 语句查询的时候，语句中 WHERE 里面的条件，会自动判断有没有可用的索引。 视图作为提供给用户的虚拟表。 数据库中只存放了视图的定义，而没有存放视图中的数据，这些数据存放在原来的表中； 使用视图查询数据时，数据库系统会从原来的表中取出对应的数据； 视图中的数据依赖于原来表中的数据，一旦表中数据发生改变，显示在视图中的数据也会发生改变； 在使用视图的时候，可以把它当作一张表。 1CREATE VIEW 视图名(列a,列b,列c) AS SELECT 列1,列2,列3 FROM 表名字; 表的操作语句同样适用于视图。 导入纯数据文件：LOAD DATA INFILE &#39;文件路径和文件名&#39; INTO TABLE 表名字; 导入导出的文件都必须在指定的路径下进行，在 mysql 终端中查看路径变量：show variables like &#39;%secure%&#39;; 在移动至该路径时需要权限，所以实现了安全的导入。 SQL语句：source *.sql 可以在文件中包含更多的操作 导出只保存数据 SELECT 列1，列2 INTO OUTFILE &#39;文件路径和文件名&#39; FROM 表名字; 不能有同名文件 备份与恢复把数据库的结构，包括数据、约束、索引、视图等全部另存为一个文件。 mysqldump 是 MySQL 用于备份数据库的实用程序。它主要产生一个 SQL 脚本文件，其中包含从头重新创建数据库所必需的命令 CREATE TABLE INSERT 等。","categories":[{"name":"database","slug":"database","permalink":"http://vergessenwang.github.io/categories/database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://vergessenwang.github.io/tags/MySQL/"}]},{"title":"Python处理数据后用于查看动态排名","slug":"Python处理数据后用于查看动态排名","date":"2019-08-14T14:56:27.000Z","updated":"2020-05-13T00:53:03.368Z","comments":true,"path":"posts/Python/2019-08-14-Python处理数据后用于查看动态排名.html","link":"","permalink":"http://vergessenwang.github.io/posts/Python/2019-08-14-Python处理数据后用于查看动态排名.html","excerpt":"利用脚本实现将历史数据排名转化为动态柱状图图表。源码由见奇开发。 在VS Code中配置Python开发环境先检查Python版本和环境变量配置是否可用，命令行输入python --version ，发现不是内部命令，想起来新换的电脑还没有安装。 官网下载最新版本Windows x86-64 executable installer ，安装时记得勾选 add toPATH 在VS Code中安装Python和pylint插件，安装完pylint提示： 12You are using pip version 19.0.3, however version 19.2.2 is available.You should consider upgrading via the &apos;python -m pip install --upgrade pip&apos; command pip是python的包管理工具，按提示升级python -m pip install --upgrade pip","text":"利用脚本实现将历史数据排名转化为动态柱状图图表。源码由见奇开发。 在VS Code中配置Python开发环境先检查Python版本和环境变量配置是否可用，命令行输入python --version ，发现不是内部命令，想起来新换的电脑还没有安装。 官网下载最新版本Windows x86-64 executable installer ，安装时记得勾选 add toPATH 在VS Code中安装Python和pylint插件，安装完pylint提示： 12You are using pip version 19.0.3, however version 19.2.2 is available.You should consider upgrading via the &apos;python -m pip install --upgrade pip&apos; command pip是python的包管理工具，按提示升级python -m pip install --upgrade pip 尝试输入代码，运行成功。 前提：数据第一行为省份，第一列为年份(由远至近)，中间部分为数据 编写Python代码完成csv数据转换123456789101112131415import csvf = open('horse_data.csv','r',encoding = 'gbk')reader = csv.reader(f)province = f.readline()province = province.split(',')f2 = open('horse.csv','w',encoding = 'gbk',newline ='')writer = csv.writer(f2)writer.writerow(['name','type','value','date'])for line in reader: for i in range(1,26) : if line[i]: writer.writerow([province[i],'',line[i],line[0]]) range中的内容根据具体数据文件而定，注意是到第二个参数的前一位。 修改config相关内容，适配自己的数据，达到较好的展示效果。 打开bargraph导入处理好的数据即可。","categories":[{"name":"Python","slug":"Python","permalink":"http://vergessenwang.github.io/categories/Python/"}],"tags":[{"name":"可视化","slug":"可视化","permalink":"http://vergessenwang.github.io/tags/可视化/"}]},{"title":"雀鹰与该隐——《德米安》","slug":"雀鹰与该隐——《德米安》","date":"2019-08-13T14:25:21.000Z","updated":"2020-03-11T15:39:58.422Z","comments":true,"path":"posts/reading/2019-08-13-雀鹰与该隐——《德米安》.html","link":"","permalink":"http://vergessenwang.github.io/posts/reading/2019-08-13-雀鹰与该隐——《德米安》.html","excerpt":"当我渴望离开第一个座位时，我自己也不清楚我要去哪儿。我只知道，我要坐在很后面。 ​ 我不认为自己是个智者。我曾经是一个探索者，现在也还依然是。但是我不在从群星和书本中寻觅，而是开始聆听我血液滂湃不已的教义。 ​ 每个人的生命代表一条通往他自己的道路，代表他在这条路上所做的尝试。 ​ 每个人身上都存留者出生时的痕迹——远古时代的黏液和蛋壳，直至终了为止。有些人从不曾变成人类，而是继续当青蛙、蜥蜴和蚂蚁。人人尝试走出深渊，朝各自的目标努力，我们可以彼此了解，但真正能够深刻了解自己的，却只有每个人本身。","text":"当我渴望离开第一个座位时，我自己也不清楚我要去哪儿。我只知道，我要坐在很后面。 ​ 我不认为自己是个智者。我曾经是一个探索者，现在也还依然是。但是我不在从群星和书本中寻觅，而是开始聆听我血液滂湃不已的教义。 ​ 每个人的生命代表一条通往他自己的道路，代表他在这条路上所做的尝试。 ​ 每个人身上都存留者出生时的痕迹——远古时代的黏液和蛋壳，直至终了为止。有些人从不曾变成人类，而是继续当青蛙、蜥蜴和蚂蚁。人人尝试走出深渊，朝各自的目标努力，我们可以彼此了解，但真正能够深刻了解自己的，却只有每个人本身。 两个世界该隐​ 我们不需要对人畏惧。假如你惧怕某人，那代表你赋予了他这个权利。 ​ 他会用鼓励、警告、嘲笑和讽刺的方式，把我变得更加独立。直到今天我终于了解：人生在世最无聊的是，走在一条由他人引导的自我之路上。 强盗​ 我还看到他异常孤独且沉默的样子，仿佛一颗行星在众人之间，被一股属于自己的气流所包围，运行在自己的轨道上。 ​ 我们常常可以经由仔细观察，正确地知道某人的想法或感觉，多半也能预料他下一刻的行为。 ​ 敏锐的嗅觉是训练出来的。这样一只寻找几公里外的雌蛾的夜蛾如果集中意志力想要飞向一片星辰，是行不通的。它只会寻找对它有意义的、有价值的东西，只会寻找它需要的、必须拥有的东西。只要动物或人类把自己的全部意志集中在特定的事物上，他就能达到目标。 ​ 比起动物，人类拥有更大的空间，具有更强烈的好奇心。不过，相对的，却也局限在一个狭隘的圈圈里，没办法超越。除非我非常重视我的愿望，除非它确实和我合二为一，我才能带着坚定意志完成它。 ​ 当我渴望离开第一个座位时，我自己也不清楚我要去哪儿。我只知道我要坐在很后面。 ​ 我每次都非常坚定地注视他的眼睛。几乎所有人都难以忍受这种凝视，遇到这种情况，都会变得不安。假如你突如其来坚定地注视某人的眼睛，而他却没有丝毫惶恐，那就放弃吧！你绝对无法在他身上达成目的。 ​ 德米安所指的上帝和恶魔、普世认同的神圣世界和禁锢的魔鬼世界，与我的想法不谋而合。原来我的问题是所有人的问题、一切生命和思想的问题。 ​ 生活跟你的想法并不一致。思想只有在付诸生活中实行，才有价值。 ​ 他无法忍受那种为了说话而说话的对谈。他对我的事，除了纯粹好奇之外，还有太多理性激辩和闲聊的玩乐成分，总之，缺乏认真的参与感。他说，机巧的谈论根本没有价值。只会让我们远离自己。远离自己是一种罪过。我们必须完全在自身中爬行，就像一只乌龟一样。 碧翠丝​ 我漠不关心地面对外界，终日只顾谛听内心的声响，这条禁忌的、黑暗的河流在暗地里澎湃奔腾。 ​ 我贪婪地呼吸着湿润的凋零气味，它仿佛在回答、抚慰我的心灵。啊，生命尝起来何等的淡而无味。 ​ 酒醉并不好玩，让人极为痛苦，然而它蕴含某些成分，充满甜美的魅力，既是反叛和疯狂，也是生命和灵魂。 ​ 我的生命没有目标，我鄙视这个世界！我冷漠而盲目地踽踽独行；我的心沉默、怯懦地退缩在角落。 ​ 我从未真正融入同伴之中。置身他们当中，我却依然孤独，并因此更为痛苦。 ​ 上帝借由各种途径使人变得孤独，好让我们可以走向自己。 ​ 现在我有了爱慕和崇拜的对象，我再度拥有梦想，生命再度充满想象，充满色彩，充满神秘的灵感——让我完全无视其他存在。我不再追求不负责任的安全感，而开始肩负责任和自我要求。 ​ 我用碧翠丝的身影布置我的圣坛，让它取代一切。我的目标不在于欲望的满足，而是纯洁；我要的是美和智慧，而非幸运。 ​ 这个画中人，是我的心灵，我的命运，我的魔鬼。我生我死将是如此，我命运之歌的音调和节奏将是如此。 ​ 命运和性格乃思想之名。 ​ 再度相逢，我不再感到任何激动，唯有一股淡淡的和谐、一阵柔情的预感：你我相连在一起，但不是你本人，而是你的形象；你是我命运的一部分。 奋力冲破蛋壳的鸟​ 鸟奋力冲破蛋壳。这颗蛋是这个世界。若想出生，就得摧毁一个世界。这只鸟飞向上帝。这个上帝的名字是阿布拉克萨斯。 ​ 他是上帝，也是魔鬼。 ​ 爱情不再是起初那种让我惊恐的、兽性的、阴暗的性冲动，也不再是我在碧翠丝画中呈现的那种天真、超越世俗的爱慕了。它是天使和撒旦，人类和动物，至高的良善和极端的邪恶。 ​ 只有一点我做不大：撕裂那个暗藏在内心的目标，把自己描绘在什么地方，就像其他人那样。他们很清楚自己想成为教授、法官、医生或艺术家，他们知道需要花多少时间来达成，也知道这将会带给他们何种优势。然而我办不到。也许我还得寻觅，继续探索好几年，最后一事无成，达不成任何目标。 ​ 我只是尝试着过自己想要的生活而已。为何如此艰难呢？ ​ 对她而言，没有所谓的太好和太珍贵，也没有所谓的太坏和太卑劣。 ​ 我总是全神贯注在自己身上。我热切渴望能够真正活过一次，即使只是短暂的一次：我期盼对世界贡献出一些自己的东西，跟这个世界建立关系，并且和它搏斗。 ​ 事实上，并没有所谓的偶然。如果一个人迫切需要某样东西，然后找到了这个东西，那么赋予这种机会的就不是偶然，而是他自己，是他本身的渴望和迫切带领他去找到它。 ​ 眼前这些非理性的、紊乱的、异样的自然形体，究竟来自外在，还是内在的印象。 ​ 所有可能性，诸如愿望、选择，皆与我们同在。 ​ 但是个人的世界又在哪里？假如我们本身已经具备了一切，我们为何还要努力追求？ ​ 这些两脚动物，它们都有成为人类的机会，可是，只有在它们预知这个机会，甚至学习把它转化为自觉，这个机会才属于它们。 雅各的战斗​ 假如大自然把您创造成一只蝙蝠，您就不应该想着变成一只鸵鸟。有时候您觉得自己很特别，有时候您谴责自己选择了跟大部分人不同的路，但您必须学习放弃这种思考方式。您去看看火、看看云吧。 ​ 阿布拉克萨斯从来不反对您的想法，从来不否定您的幻梦。 ​ 假如我们怨恨一个人，我们恨的是在他形象中的某些东西，这些东西也是我们本身所拥有的。凡是我们本身没有的东西，并不能激动我们的心。 ​ 大部分人走的是一条简单的路，我们走的却是一条坎坷的路。但还是要走下去。 ​ 我生活在我的梦中，其他人也生活在梦中，只不过那不是他们自己的梦，差别就在此。 ​ 我开始觉得他很无聊，我也对自己的反应感到吃惊，因为他明显表达了痛苦和绝望，却没有引起我的共鸣，我唯一的感觉只是：我帮不了你。 ​ 假如你无法发现自己，那么你也无法找到灵魂。 ​ 每个人都必须感受一些寂寞的煎熬，大部分人都无法忍受，于是不久又再度和他人建立联系。 ​ 我突然明白，皮斯托利斯对我的意义和他给我的一切，正是他所不能成为或给予自己的东西。他为我指引了一条道路，就连这条道路也必须越过他并离开他，离开这位引导者。 ​ 当我猛力挥击，以为自己打中的是一个强者，一个骁勇善战的人，没想到竟然是一个默默忍耐的人，一个默默投降、无力抵抗的人。 ​ 一个成熟的人没有任何职责，除了：寻找自己。坚定地成为自己，不论走向何方，都往前探索自己的路。 ​ 我不是为了写作、为了布道、为了画画而来，不管是我或任何人都一样。这一切只是附带产生的。每个人的职责只有回归自己。他最后死去时的身份，可以是作家或疯子，可以是先知或罪犯——但这些不是他的职责，无关紧要。他的职责是：找到自己的命运，不是一个随意的命运，而且在那之中尽情生活，全心全意、不受动摇地生活。除此之外，其他一切都不完整，是一种逃避的企图，是想要逃回群体的样板中，是为了适应自己内心的恐惧。 ​ 我没有办法如此赤裸和孤独地生活，我也是一只贫穷、虚弱的狗，这只狗需要温暖和食物，偶尔也想要和同类亲近。任何人如果只要命运，不要其他东西的话，他就不再拥有同类，会变得相当孤独，围绕他身边的只有冰冷的世界。 夏娃夫人​ 到处都有人聚集，到处都是群体生活，到处都有人逃避自己的命运，为了温暖而逃回群体里！ ​ 现在到处都在流行组织、联合群众，没有一处找得到自由和爱。所有这些联合，从学生团体，合唱团，乃至于国家，都是一种强迫性组合，一种出自害怕、畏惧和逃避困境的结盟，而它的内部却是腐败和老旧的，几乎要瓦解了。 ​ 人只有在跟自己本身无法相处时，才会产生畏惧。他们害怕，是因为他们从来不了解自己。 ​ 你只要看看学生们常去的酒馆就知道了！只要看看有钱人常去的娱乐场所就知道了！这些地方毫无希望！亲爱的辛克莱，欢乐不可能来自这一切。这些心生恐惧而彼此联合的人，内心其实充满了害怕和敌意，对彼此不信任。 ​ 他们过度崇拜消失的“自由”、崇拜他们的学生时代，如同作家或浪漫主义者把崇拜献给童年那般。到处都一样！他们在过去四处寻找“自由”和“快乐”，却又感到无比害怕，因为可能会被人提醒自己的职责，被人督促自己该走的路。 ​ 即使你已经获得自己，即使你已经放弃童年的幸福，你还是可以看到世界在闪烁，还是可以品尝孩子专属的天真和惊慌。 ​ 没有一个梦可以永远持续，每个梦都会被新的梦取代，我们不可以想要紧抓任何一个梦。 ​ 欧洲以惊人的毅力，创造出威力强大的新武器，但最后却在深层、巨大的灵魂中萎缩，它赢得了整个世界，却用来毁灭自己。 ​ 我们唯一承认的义务和命运是：每个人应该完全做自己，符合自然在他身上孕育的本质，并服膺这个本质，不确定的未来准许每个人创造它想带给我们的事物。 ​ 他将之视为他的命运，不抱任何希望地爱着一颗星星，因此创造了一套纯粹的生命哲学，涵盖了放弃、沉默和忠贞的痛苦。他向那颗星星跳去。就在这一跳，他的心里闪过一个念头：这是不可能的！他摔得粉身碎骨，躺在沙滩上。他不懂爱。假如在跳的那一刻拥有信心，坚持相信梦想会实现，他就会往天上飞去，和那颗星星结合在一起。 ​ “爱不必请求，”她说，“也不可要求。爱必须成为自己明确肯定的力量。它便不再是被牵引，而是去牵引。” ​ 那是一个绝望的情人，他把自己完全缩回他的内心，因为自己仿佛被爱烧毁了。他失去了这个世界，再也看不到蔚蓝的天空和翠绿的森林。但是他的爱仍在增长，他宁愿死去和毁灭，也不愿放弃拥有他所爱的美人。他的爱烧毁了他心中的其他一切，变得强大异常，一直牵引着。于是她来了。他付出爱，同时也找到自己。而大部分的人，得到爱却失去了自己。 ​ 有时候我清楚地感觉到，是我的本质指引我去追求，并不是她这个人，而她只是我内心的一个象征，唯一的目的是带领我更深入地去寻找自己。 ​ 通过想象，我似乎有些了解，如何可以持续、永恒地拥有爱情了。 ​ 我享受这种远离她所带来的稳定感和独立味道。 结束与新生​ 以前，我经常思考为什么人不能为理想而活。现在，我却看到许多人甚至全部的人为一个理想而死。不过它不是一个个人自由选择的理想，却是大家所共同约定的理想。 ​ 不管这些人相信的是什么，或者想要的是什么，他们都准备好了，他们是有用的，未来将从他们之中成形。 ​ 这些与对象并没有密切关系。他们的杀戮只是内心的抒发、心碎的投射，因而想要发怒、杀人、毁灭和死亡，为的是能够重新诞生。一个巨鸟奋力冲破蛋壳，这颗蛋是这个世界，而世界必须毁灭。","categories":[{"name":"reading","slug":"reading","permalink":"http://vergessenwang.github.io/categories/reading/"}],"tags":[{"name":"黑塞","slug":"黑塞","permalink":"http://vergessenwang.github.io/tags/黑塞/"}]},{"title":"临界区互斥的软件及抽象方法","slug":"临界区互斥的软件及抽象方法","date":"2019-08-12T07:57:47.000Z","updated":"2020-03-08T15:31:17.630Z","comments":true,"path":"posts/OS/2019-08-12-临界区互斥的软件及抽象方法.html","link":"","permalink":"http://vergessenwang.github.io/posts/OS/2019-08-12-临界区互斥的软件及抽象方法.html","excerpt":"临界区在每个进程中，访问互斥资源的代码段称为临界区。为了实现对资源互斥，在每一个时刻，只允许一个进程进入临界区执行相应的代码。如何控制一个进程进入，而其他进程被”卡住”，就是接下来要解决的问题。 互斥的四个条件 忙则等待：任何两个进程不能同时处于临界区 不应对CPU的速度和数量做任何假设 让权等待：临界区外运行的进程不得阻塞其他进程，不能忙等 有限等待：不得使进程无限期等待进入临界区 基本实现机制 基于硬件的禁用中断——无法进行上下文切换，失去了并发，在多CPU中都不能工作。更严重的是，无法限制响应中断所需的时间，因为时钟中断也被屏蔽了，在临界区中的进程无法被停止 基于软件的方法（如Peterson算法） 更高级的抽象（锁，信号量，管程）","text":"临界区在每个进程中，访问互斥资源的代码段称为临界区。为了实现对资源互斥，在每一个时刻，只允许一个进程进入临界区执行相应的代码。如何控制一个进程进入，而其他进程被”卡住”，就是接下来要解决的问题。 互斥的四个条件 忙则等待：任何两个进程不能同时处于临界区 不应对CPU的速度和数量做任何假设 让权等待：临界区外运行的进程不得阻塞其他进程，不能忙等 有限等待：不得使进程无限期等待进入临界区 基本实现机制 基于硬件的禁用中断——无法进行上下文切换，失去了并发，在多CPU中都不能工作。更严重的是，无法限制响应中断所需的时间，因为时钟中断也被屏蔽了，在临界区中的进程无法被停止 基于软件的方法（如Peterson算法） 更高级的抽象（锁，信号量，管程） 软件方法的演进进程临界区处理的抽象结构(此处及以后均用伪代码表达) 123456do&#123; enter section critical section exit section reminder section //提醒其他线程&#125;while(1); 单标志法(交替进入)设置一个共享变量int turn = i; 表示现在轮到哪个进程 对于第i个进程，enter section：while(turn != i)； exit section: turn = j; 缺点：实现了互斥，但不满足前进属性。必须交替执行，违背“空闲让进” 双标志法先检查(先看排队)设置一个数组int flag[n]; 当flag[i] = 1时表示进程 i 有进入临界区的意愿 对于第i个进程，enter section：while(flag[j] == 1)；flag[i]=1; 若无进程进入临界区则置自己的标志位 exit section: flag[i] = 0; 缺点：不满足互斥。可能同时查询同时置位，同时进入临界区。根本原因是置位过程被打断。 双标志法后检查(先抢位置)enter section：flag[i]=1； while(flag[j] == 1); 缺点：满足互斥，但可能死锁。同时置位后都停在while死循环，都无法进入。 Peterson算法(两个进程)同时使用 turn 和 flag enter section：flag[i]=1；turn = j; while(flag[j] == 1 &amp;&amp; turn == j); 先“谦让”一下，让对方先进，如果对方恰好有进入的意愿，则自己保持等待；对方不进则自己进。 Bakery算法(n个进程) 进入临界区之前，进程接收一个数字(请求号)，数字小的进入 若数字相同，比较进程号，i &lt; j 则 i 进 编号方案总是按照枚举的增加序列生成数字 软件方法的缺点 需要进程间共享数据项 while循环需要CPU忙等 实现上需要硬件原子指令LOAD和STORE的支持 更高级的抽象操作系统基于硬件的中断、原语提供更高级的编程抽象来简化并行编程。 硬件基础通过特殊的内存访问电路提供特殊的原子操作指令 TestAndSet：从内存读值判断是否为1，内存值设为1 12345boolean TestAndSet(boolean *target)&#123; boolean rv = *target; *target = True; return rv;&#125; Swap：交换内存中的值 12345viod Swap(boolean *a,boolean *b)&#123; boolean temp = *a; *a = *b; *b = temp;&#125; 以上指令虽然由多条操作组成，但在体系结构中已经被封装成了一条机器指令，由硬件逻辑直接实现，不会被中断。 锁(抽象数据结构)忙等锁 class Lock{int value = 0;} 加锁/解锁 Lock :: Acquire(){while(TestAndSet(value));} 锁被释放前一直等待，直到得到锁 Lock :: Release(){value = 0;} 释放锁，唤醒等待进程 以上方法支持n个进程，但是仍然是忙等，使用忙等方式的锁称为自旋锁 改进： 无忙等锁(增加一个等待队列) class Lock{int value = 0;WaitQueue q;} 123456Lock :: Acquire()&#123; while(TestAndSet(value))&#123; add this TCB to wait queue q; schedule(); &#125;&#125; 12345Lock :: Release()&#123; value = 0; remove one thread t from q; wakeup(t);&#125; 挂到阻塞队列后，睡眠等待，让出CPU。因为有上下文切换的开销，更适用于临界区较长的情况。 基于Swap的锁 共享数据 int lock = 0; enter section：key=1; while(key == 1){Swap(lock,key);} exit section: lock = 0; 只有lock为0时，才能通过Swap使得key为0 ，打破while循环。 可能存在的问题优先级反转造成死锁：若一个低优先级的进程拥有临界区，一个高优先级进程获得CPU并等待临界区，那么低优先级进程就无法获得CPU以继续执行释放锁，导致死锁。根本原因是互斥资源占用顺序和CPU优先级不匹配，解决优先级反转问题有优先级天花板(priority ceiling)和优先级继承(priority inheritance)两种办法，其实就是对低优先级进程的优先级进行提升。 基于忙等的方式都可能存在优先级反转问题，所以还可以用睡眠与唤醒的方式来解决。","categories":[{"name":"OS","slug":"OS","permalink":"http://vergessenwang.github.io/categories/OS/"}],"tags":[{"name":"进程","slug":"进程","permalink":"http://vergessenwang.github.io/tags/进程/"},{"name":"Peterson算法","slug":"Peterson算法","permalink":"http://vergessenwang.github.io/tags/Peterson算法/"},{"name":"锁","slug":"锁","permalink":"http://vergessenwang.github.io/tags/锁/"}]},{"title":"TCP/IP协议下Socket编程原理","slug":"TCP-IP协议下Socket编程原理","date":"2019-08-11T13:25:57.000Z","updated":"2020-03-11T15:35:00.881Z","comments":true,"path":"posts/network/2019-08-11-TCP-IP协议下Socket编程原理.html","link":"","permalink":"http://vergessenwang.github.io/posts/network/2019-08-11-TCP-IP协议下Socket编程原理.html","excerpt":"在学习Socket编程之前，首先要了解基本的网络体系结构相关知识。参看网络模型对应关系 不同于应用层之上的Web编程，Socket编程处于应用层和网络层之间，这种API本质上是通过应用进程向OS发出系统调用实现的。 典型的网络API Unix的Socket 微软的WINSOCK AT&amp;T的TLI","text":"在学习Socket编程之前，首先要了解基本的网络体系结构相关知识。参看网络模型对应关系 不同于应用层之上的Web编程，Socket编程处于应用层和网络层之间，这种API本质上是通过应用进程向OS发出系统调用实现的。 典型的网络API Unix的Socket 微软的WINSOCK AT&amp;T的TLI Socket最初是面向TCP/IP协议栈接口，目前是事实上的工业标准，通信模型是C/S架构，为应用进程间通信提供抽象。 如果只看应用层，在同一主机上可能同时运行多个应用程序，那么如何确定通信对象呢？这个时候就需要借助传输层协议，形成IP+端口机制。 标识通信端点（对外）：IP地址+端口号 OS/进程管理套接字（对内）：套接字描述符 这种内部套接字管理方式类似于文件的抽象，当应用进程创建套接字时，OS分配一个数据结构并返回套接字描述符，每一个进程维护一张Socket描述符表，表项指向一个Socket数据结构 。 Socket数据结构1234567891011struct sockaddr_in &#123;short int sin_family; /* Address family */unsigned short int sin_port; /* Port number */struct in_addr sin_addr; /* Internet address */unsigned char sin_zero[8]; /* Same size as struct sockaddr */&#125;; sockaddr_in 声明端点地址，TCP/IP协议族的sin_family值为AF_INET Socket API函数常用socket函数 创建：socket(protofamily, type, proto) 返回套接字描述符 protofamily = PF_INET type = SOCK_STREAM/SOCK_DGRAM/SOCK_RAW 其中 流式套接字SOCK_STREAM (TCP)、数据报套接字SOCK_DGRAM (UDP) 工作在传输层，原始套接字SOCK_RAW 工作在网络层。SOCK_RAW 可以处理ICMP、IGMP等网络报文、特殊的IPv4报文、可以通过IP_HDRINCL套接字选项由用户构造IP头，创建时需要特殊权限。 protocol参数一般取0 例如 123struct protoent *p;p = getprotobyname(\"tcp\");SOCKET sd = socket(PF_INET,SOCK_STREAM,p -&gt; p_proto); 关于TCP/IP参数为什么两者不同，理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx。当然AF_INET和PF_INET的值是相同的，混用也不会有太大的问题。关于PF_INET和AF_INET的区别 关闭：int closesocket(SOCKET sd); 与文件类似，当多个进程共享一个套接字，调用后只能将引用计数减1，至0时真正关闭 对于同一进程中的多个线程只计数一次，因此一个线程调用之后其他线程也无法再访问 绑定本地端点地址：int bind(sd, localladdr,addrlen) localaddr对应sockaddr_in 客户程序一般不调用，服务器端需要绑定熟知端口号，同时服务器端由于可能有多个IP地址，还需要一个地址通配符：INADDR_ANY,意即所匹配的任一地址有效，不指定具体IP地址。 在Linux系统中，1024以下的端口只有拥有root权限的程序才能绑定。 监听：int listen(sd,queuesize); 仅用于服务器端的TCP连接 新的Client的连接请求先被放在接收队列中，直到Server程序调用accept函数接受连接请求 连接：connect(sd,saddr,saddrlen); 仅用于客户端，但TCP和UDP均可 saddr即要连接的远程服务器套接字 响应连接请求：newsock = accept(sd, caddr, caddrlen); 仅用于服务器端的TCP连接 从监听状态的连接请求队列取出最前的一个，创建一个新的套接字来描述来与特定的Client交换信息，因为TCP是点对点协议，这样才能实现并发。 接收/发送消息： TCP方式： int send(sd, *buf, len, flags); int recv(sd, *buf, len, flags); UDP方式： int sendto(sd, *buf, len, flags, destaddr, addlen); int recvfrom(sd,*buf, len, flags,senderadde,saddrlen); 由于UDP是无连接的，所以需要指定发送/接收数据的对方 获得或改变socket属性: int getsockopt(int sd, int level, int optname, char *optval, int *optlen); int setsockopt(int sd, int level, int optname, char *optval, int *optlen); 常用属性： SO_RCVTIMEO，SO_SNDTIMEO：获得或设置socket发送/接收的timeout SO_SNDBUF，SO_RCVBUF：获得或设置socket发送/接收的buffer大小 SO_BROADCAST：获得或设置socket状况，使之可以广播发送数据报（只能用于UDP方式） SO_REUSEADDR：设置该socket绑定的端口可以被重用。 网络字节顺序转换 在TCP/IP结构中虽然没有表示层，但是还是要完成相应的数据格式转换功能 htons()–”Host to Network Short” htonl()–”Host to Network Long” ntohs()–”Network to Host Short” ntohl()–”Network to Host Long” 服务器IP地址解析 客户端将服务器域名或十进制IP地址转换成二进制IP地址 inet_addr() 十进制 → 二进制(网络字节顺序) gethostbyname 域名→ 二进制，返回一个指向hostent结构的指针，*h_addr_list 表示的是主机的ip地址，注意，这个是以网络字节序存储的。 1234567struct hostent &#123; char *h_name; /* official name of host */ char **h_aliases; /* alias list */ int h_addrtype; /* host address type */ int h_length; /* length of address */ char **h_addr_list; /* list of addresses */&#125; 同理，还有getservbyname返回一个servent指针实现服务名→端口号；getprotobyname返回protoent指针实现协议名→协议号 Socket TCPsocket调用基本流程 TCP客户端软件流程 确定服务器IP地址与端口号 创建套接字 分配本地端点地址（IP地址+端口号）——由系统自动完成，所以bind一般只用在服务器端 连接服务器（如果是UDP，指定服务器端点地址，构造UDP数据报） 遵循应用层协议进行通信 释放连接 循环TCP服务器流程 创建(主)套接字，绑定熟知端口号 设置(主)套接字为被动监听模式，准备用于服务器 调用accept()函数接受下一个连接请求，创建新套接字用于与该客户建立连接 遵循应用层协议，反复接受客户请求，构造并发送响应 完成为特定客户服务后，关闭与该客户之间的连接，返回步骤3 并发TCP服务器流程主线程： 创建(主)套接字，绑定熟知端口号 设置(主)套接字为被动监听模式，准备用于服务器 调用accept()函数接受下一个连接请求，创建一个新的子线程处理该客户响应 子线程： 创建新的套接字接受一个客户的服务请求 遵循应用层协议，与特定客户进行交互 完成为特定客户服务后，关闭与该客户之间的连接，终止线程 在实际过程中，会有一个主线程和多个子线程同时运行，实现并发。","categories":[{"name":"network","slug":"network","permalink":"http://vergessenwang.github.io/categories/network/"}],"tags":[{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://vergessenwang.github.io/tags/TCP-IP/"},{"name":"Socket","slug":"Socket","permalink":"http://vergessenwang.github.io/tags/Socket/"}]},{"title":"VUE踩坑记录（一）","slug":"VUE踩坑记录（一）","date":"2019-03-28T02:05:05.000Z","updated":"2020-03-06T12:43:02.110Z","comments":true,"path":"posts/frontend/2019-03-28-VUE踩坑记录（一）.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2019-03-28-VUE踩坑记录（一）.html","excerpt":"Q1：以前的el挂载点是body；但是在Vue2.0中，是一个名为#app的CSS选择器，template是将会替换挂载元素的模板。（官方：不推荐root实例挂载到 或，且所有的挂载元素都会被Vue生成的DOM替换） Q2：旧版中没有router，先重新建一个不含router的项目开始学习。 Q3 ：ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。","text":"Q1：以前的el挂载点是body；但是在Vue2.0中，是一个名为#app的CSS选择器，template是将会替换挂载元素的模板。（官方：不推荐root实例挂载到 或，且所有的挂载元素都会被Vue生成的DOM替换） Q2：旧版中没有router，先重新建一个不含router的项目开始学习。 Q3 ：ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。Q4：自定义标签123456export default &#123; name: &apos;App&apos;, components: &#123; HelloWorld &#125;&#125; Q5: div里面的代表模板，可以访问到12345data () &#123; return &#123; msg: &apos;Welcome to Your Vue.js App&apos; &#125; &#125; 中对应的msg Q6:创建一个组件。首先创建一个.vue文件，分为template、script、style三部分，export导出一个对象，对vue的各自属性进行定义。使用时先用import引用，再用components注册，就可以使用该标签 Q7:webpack原理——了解完了简单配置 Q8：设备像素比devicePixelRatio简单介绍 Q9：SVG图标字体制作 Q10: （已弃用sublime，改用vs code）如何在sublime中新建.vue格式的文件首先安装sublime包插件时出现There are no packages available for installationctrl+`打开控制台找原因：Error downloading channel. HTTP error 404 downloading https://packagecontrol.io/channel_v3.json.找到一个下载地址：https://download.csdn.net/download/ming_221/9944588然后在sublime设置：preferences-&gt;package settings -&gt; package control -&gt; settings-user添加一条本地渠道（该文件绝对路径）：123456&quot;channels&quot;:[ &quot;/Users/18771/AppData/Roaming/Sublime Text 3/channel_v3.json&quot;], 核心问题还是……科学上网啊​ 问题解决，开始安装插件新建文件模板插件 SublimeTmpl：在安装包的templates中新建vue.tmpl一个可用模板参见http://www.imooc.com/article/33817?block_id=tuijian_wzPreferences&gt;Package Settings&gt;SublimeTmpl&gt;Menu中新增vuevue语法高亮插件 Vue Syntax Highlight: 模板绑定语法高亮Preferences&gt;Package Settings&gt;SublimeTmpl&gt;Settings -Users中设置123456&#123; &quot;vue&quot;: &#123; &quot;syntax&quot;: &quot;Packages/vue-syntax-highlight/vue.tmLanguage&quot;, &quot;extension&quot;: &quot;vue&quot; // default_extension &#125;&#125; 但是好像没效果，新版sublime没有文件夹，只有.package文件。也不知道怎么绑定。最后还要手动在右下角选：）所以，我是不是要换一个编辑器了…嗯，换了一个VS code装起插件来简直不要太爽，界面也好看，开心地像个二十几岁的孩子… Q11: 科学上网——已用ss解决 Q12: CSS预编译：stylus，sass, less Q12:前后端分离，通过ajax请求进行交互；对接之前，前端通过Mock模拟后台数据 Q13: vue-cli生成的webpack配置解析中没有-build/dev-server.js: 新版本的vue已将dev-server.js与webpack.dev.conf.js合并了，上面的操作webpack.dev.conf.js中配置就好了 Q14:VS code快速注释，CTRL+k 然后CTRL+c Q15: express is not defined :没有npm installjson-server获取服务器数据只能用get方式，而express支持post方式获取数据。npm install express –-save 具体含义但是安装完了之后，package.js中有了包”express”: “^4.16.4”,，可以仍然显示没有定义：express在4.0之后，需要安装the executable（执行器express-generator）才能执行express命令，npm install express-generator终端运行npm run dev 编译通过，但是api没有配置成功，发现还是新版本webpack.dev.conf.js请求本地数据的配置的问题：参见要添加到devServer中，注意别忘了逗号在8080调用api显示成功，但是不美观，没有格式化。安装Google插件JSON Viewer,接口调用成功 Q16: 整体缩进 Ctrl+】 Q17:在static中将css进行reset Q18: vscode 新建vue模板:user snippets中设置，新建后输入vue按tab键，模板代码就出来了 Q19: 安装 stylus-loader后出现Cannot find module ‘stylus’原因：需要安装stylus 再安装stylus-loader再进行npm install解决：重新安装npm install stylus --save-dev npm install stylus-loader --save-dev Q20:快速复制一行 按住Ctrl+Alt+Down，即可以在下面快速复制一行，按住Ctrl+Alt+Up，即可以在上面快速复制一行。 Q20:Flex布局 实现三等分 Q21:vue-router实现跳转，router.map is not a function报错原因：2.0已经没有map和start方法参考文档将12345678let app = Vue.extend(App);var router = new VueRouter();router.map(&#123; &apos;/goods&apos;: &#123; component: goods &#125;&#125;); 替换为123456789const routes = [ &#123;path: &apos;/goods&apos;, component: goods&#125;, &#123;path: &apos;/ratings&apos;, component: ratings&#125;, &#123;path: &apos;/seller&apos;, component: seller&#125;];const router = new VueRouter(&#123; routes&#125;); 将router.start(app, &#39;#app&#39;);替换为123456789/* eslint-disable no-new */new Vue(&#123; el: &apos;#app&apos;, router, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;); 一个用法的实例编译通过后又出现问题：Failed to resolve directive: link原因：vue的版本升级后，取消了v-link指定，取而代之的为 router-link。router-link组件支持用户在具有路由功能的应用中点击导航。 通过 to 属性指定目标地址，默认渲染成带有正确链接的 a标签，可以通过配置 tag 属性生成别的标签。解决：a v-link=”{path:’/goods’}”商品/a替换为router-link to=”/goods”商品/router-link (markdown转义不会弄，没加标签&lt;&gt;)总算路由成功！！！ Q22：在webpack中配置alis可以简化路径 Q23:设置默认路由router.go后页面一直刷新原因：router的设计模式是参考了浏览器的window.history相关API，同history.go, router.go接受的参数应该为Number解决一：不用router.go ,直接在routes中增加 {path: &#39;/&#39;, component: goods},解决二（更好）：用router.push方法 Q24: CSS预编译语法 引用父选择符： &amp; Q25: 标签最好设置为display：block 扩大可点击范围&amp;.router-link格式设置不生效&amp;.active选中标签高亮不生效原因：选择器有点问题。当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名active-class=”activeClass”解决：在router-link中加上tag=”li”，通过&amp; &gt; li将其渲染成li标签来选择router-link。在router中全局配置linkActiveClass: ‘active’重命名激活标签，激活时标签通过&amp;.active来选择 Q26:通过stylus的mixin方法实现通用一像素伪类的绝对定位，同时全局定义base根据不同设备缩放（主要是通过调整scaleY使得DPI*缩放=1）问题：tab-item字体被压扁原因：border-1px那个方法改变了scaleY压缩了字体。用transform做了个3d坐标轴，然后每个轴都要写上文字节点ul，问题是放在三个平面内的文字会跟各自平面一起被变形和压扁解决：不用border-1px方法了… “tab border-1px”还原为tab以后再找解决方法，现在这个不重要，知道保持像素的方法就行 Q27:Vue-resource 实现Ajax请求（vue-resource已经不再是官方推荐的ajax库了，请使用axios）npm install vue-resource –saveVue的每个实例在生命周期中有一个钩子函数created。response.body()返回一个json类型的对象,通过api拿到数据后传给组件，组件通过props接收问题：”TypeError: Cannot read property ‘avatar’ of undefined”原因：页面进行了渲染和请求接口获取数据，异步进行，所以获取数据没有完成时，页面已经进行渲染，所以第一次报使用未定义变量。解决： 父组件 &lt;:src=”seller.avatar”&gt; 子组件 用v-bind: 方法引用问题：图片无法显示原因：if (response.erron === ERR_OK) 改成不等号。检查到头都大了：） Q28:要判断状态码时最好设置为一个常量，便于后续修改","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://vergessenwang.github.io/tags/vue/"}]},{"title":"迟来的2018年感悟","slug":"迟来的2018年感悟","date":"2019-03-27T14:46:19.000Z","updated":"2019-08-27T05:52:09.594Z","comments":true,"path":"posts/life/2019-03-27-迟来的2018年感悟.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2019-03-27-迟来的2018年感悟.html","excerpt":"一切终于尘埃落定，却又不知从何说起了。 感觉很多事情，就像坐滑滑梯。前面长长的攀登，不过是为了滑下去的那快乐或恐惧的几秒钟，尽管短得如同梦中。等你滑到尽头呆坐在地上的时候，才反应过来，哦，原来是这种感觉啊。 “哦，原来是这种感觉。”这就是我所理解的人生的意义。体验，感受，仅此而已。 只为值得的事情去努力，没有那么多两全其美的事情。什么都无法放弃的人，什么都无法改变。","text":"一切终于尘埃落定，却又不知从何说起了。 感觉很多事情，就像坐滑滑梯。前面长长的攀登，不过是为了滑下去的那快乐或恐惧的几秒钟，尽管短得如同梦中。等你滑到尽头呆坐在地上的时候，才反应过来，哦，原来是这种感觉啊。 “哦，原来是这种感觉。”这就是我所理解的人生的意义。体验，感受，仅此而已。 只为值得的事情去努力，没有那么多两全其美的事情。什么都无法放弃的人，什么都无法改变。 我还是很想读书，如今终于得偿所愿，心情却很平和。甚至在复试被老师吐槽编程能力太弱时，会冒出“干脆刷掉我好了”这样的念头，我也不知道为什么，可能是担心这条路太冒险了，会离正常的轨道越来越远吧。哎，真是矛盾啊。理想主义与逃避，往往只有一线之隔。不管怎么说，未来我可以有更多选择。 大概得了一种“崇拜什么，就想把这种东西变成属于自己的东西，得到了又觉得不过如此”的病。不过我对钱没有什么想法，这可能是我是个赚钱废物的原因吧…净整些没用的。瑞哥说她理想的生活是考古和文学，我想了想，说我以后想去山里隐居。她说：那我要去山里把你挖出来。哈哈哈，可爱的瑞哥。隐居是不可能隐居的，有个堆满精装书的小狗窝就满足了。 我大概只是运气好吧，今年扩招了。原来，很多看起来厉害的人，也不过是普通人。“谁终将点燃闪电，必长久如云漂泊。”考前日日复习到一两点的那些天，我已觉得很遥远了，只是它们替我应证了这句格言，没有任何令别人惊讶的成果是可以一蹴而就的。钦慕别人的成就，不如感叹别人的汗水。 说到底，我也放弃了很多，才走到这一步。 只在努力有用的地方努力，不值得的放弃，没用的看天意。这是我在2018年学到的最重要的道理。 赫里内勒多·马尔克斯上校最终失去了与战争的一切关联。曾几何时一段真实的经历，一股青春年代不可抗拒的激情，如今对他而言已经成为遥远的注脚：虚无而已。 ——《百年孤独》","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[{"name":"又是一年","slug":"又是一年","permalink":"http://vergessenwang.github.io/tags/又是一年/"}]},{"title":"我，是一个概率","slug":"我，是一个概率","date":"2019-02-19T15:49:09.000Z","updated":"2020-03-11T15:38:33.457Z","comments":true,"path":"posts/thinking/2019-02-19-我，是一个概率.html","link":"","permalink":"http://vergessenwang.github.io/posts/thinking/2019-02-19-我，是一个概率.html","excerpt":"这个问题得先从人脑说起。 从微观角度来，神经元细胞及相互间错综复杂的神经突触构成神经网络。对于一个神经元细胞而言，尽管有多种输入，但仅有一个输出。同时，连接结构的复杂性导致了网络中必然存在回路。 为了解决这个回路问题，数学家皮茨提出了“模运算” 的方法，这个方法剥离了时间，顺序只有在计算后才能得到，而这个链条本身，成为了一段记忆。基于这种描述，冯·诺依曼提出了程序存储的概念。","text":"这个问题得先从人脑说起。 从微观角度来，神经元细胞及相互间错综复杂的神经突触构成神经网络。对于一个神经元细胞而言，尽管有多种输入，但仅有一个输出。同时，连接结构的复杂性导致了网络中必然存在回路。 为了解决这个回路问题，数学家皮茨提出了“模运算” 的方法，这个方法剥离了时间，顺序只有在计算后才能得到，而这个链条本身，成为了一段记忆。基于这种描述，冯·诺依曼提出了程序存储的概念。然而，我想说的是，也许正是这种剥离，造成了失真，导致了人脑科学与人工智能之间的分歧。假如说一开始人脑和机器都有已经预设好的结构及少量信息，那么最后导致人脑和计算机仍有本质区别的原因是什么？或者说计算机要达到何种程度才会有像人脑一样的性能？ 我觉得关键，不在于信号输入的节点，而在于联系，也及被模运算剥离的那种后验顺序。想象一下，假定只有三个输入节点，但是在时间维度上，每一个刻度都有8种可能的输入，那么这一特定时间点的输出就不会是确定的，而成了一个概率问题。 对机器而言，失去了确定性，机器还能称之为机器吗？这跟古人拜佛求雨、卜龟算卦有什么区别？ 由此可见，逻辑并不是人脑的核心，关系即神经机制才是。本体论仍然划开了人脑与计算机的界限。那种输入的顺序，来自信息并产生信息。信息，又是什么？ 有个问题困惑了我很久：如果所有能证明我身份的东西被付之一炬，我如何证明，我就是我？ 等一下，我好像卡在了这里。好了，我继续。 用基因序列？不同人之间碱基对的构成元素有什么分别吗？如果完全相同的克隆人，放到不同的环境中去，最后拿来比较时，他们相同吗？很显然是不同的。 纯物质角度太过形而上学了。我觉得，是一个个时间截面上的信息状态，组成了人。也就是说，在物质的角度上还必须加上一个时间的维度，四维空间构成了人。类比人脑，物质是逻辑，时间是机制，信息构成人。 物质一般是和空间不可分割的。同样，这是一个概率问题。电子是波函数，函数是同一的。从量子的角度讲，是先有被观测的坍缩，然后才有去描述位置的参照系。 “时间就是不让一切同时发生的那个东西，空间就是不让一切合为一体的东西。不让一切都发生在我身上。” 永远不要过分追求同一性，不然你会发现自己根本不复存在。若只关注构成物质的统一，那么，原来我只是生活在n维空间的四维映射上的一个坍缩…… 以忒修斯之船类比，如果身体的每一个细胞都更新过一次，我还是不是我？ 也就是单纯来看结构关系，去除物质的影响。 突然间，我又困惑了。 或者，这种更新顺序本来就是信息的一部分，即便最终结果完全一样，但是如果中间的过程遗失了，仍然无法做出判断。 也就是说，时空本质上就不可分割。时间没有最小粒度，时间本身也是靠物质变更来观测的，而物质变更是一个概率问题。那么每时每刻唯一确定的，只有概率。 答案找到了，我是一个概率…… “我们所说的真实建立在若干个确凿的观察点上，这些观察点之间都是我们靠想象和理论精心搭建的纸模型 ”——惠勒","categories":[{"name":"thinking","slug":"thinking","permalink":"http://vergessenwang.github.io/categories/thinking/"}],"tags":[]},{"title":"谁能改变河水的流向","slug":"谁能改变河水的流向","date":"2019-01-13T14:57:37.000Z","updated":"2020-03-11T15:39:37.608Z","comments":true,"path":"posts/life/2019-01-13-谁能改变河水的流向.html","link":"","permalink":"http://vergessenwang.github.io/posts/life/2019-01-13-谁能改变河水的流向.html","excerpt":"广州冬天还不算太冷，我把围巾裹了两圈，坐在花城广场的台阶上等着音乐节开场。手里的红茶还是温热的，地板有点凉。周围都是耸入云霄的大厦，这里，像是疲惫的人群喘息的洞口。 乐队登场了。是来自广西的马帮。 主唱戴着一个有原始气息的头冠，黑色的翎毛向天指着，是哪一只鸟的残魂？架子手和吉他已就位，右边是一个留长发的艺术家，前面放着横笛、唢呐和葫芦丝。左边的木鼓我叫不上名字。","text":"广州冬天还不算太冷，我把围巾裹了两圈，坐在花城广场的台阶上等着音乐节开场。手里的红茶还是温热的，地板有点凉。周围都是耸入云霄的大厦，这里，像是疲惫的人群喘息的洞口。 乐队登场了。是来自广西的马帮。 主唱戴着一个有原始气息的头冠，黑色的翎毛向天指着，是哪一只鸟的残魂？架子手和吉他已就位，右边是一个留长发的艺术家，前面放着横笛、唢呐和葫芦丝。左边的木鼓我叫不上名字。一声高亢的呼喊，让人从城市抽离。充满历史感和民族感的节奏敲打着大厦的玻璃。与环境格格不入，却又仿佛与我们一脉相承，只是我们遗忘了。 歌声越欢快，越激昂，我就觉得这风，越冷。冷到骨髓里，冷到心灵颤栗着。我们在文明里面丢失了多少祖先留下的瑰宝？我们在虚荣的追逐里面遗失了多少本来的面貌？这歌声是他们的呼喊，还是我们本身的诉求？雨点般的鼓点，叩问心门。 单薄的衣衫挡不住他们的热情。我想，他们一路走来，走到这里，走到众人面前，大概必定经历过许多孤独彷徨的时刻。在众人簇拥的道路旁，默默走着自己的蹊径。日夜磨炼自己的技艺，谱写自己的乐章。可是那又是多么快乐啊。把自己民族的东西，传递给更多的人，把不能遗失的，小心保存。衬得我们这些走着世俗道路的，不知本心的，迷茫无措的人，是多么的渺小。 他们又唱了一首歌，名叫《不能改变河水的流向》。 我又同时想到，有一个叫新世相的自媒体的宣言是：我们终将改变河流的朝向。 这两者之间矛盾吗？没有。这只乐队说的是历史和自然，那个媒体说的是未来和意志。我歌颂着传统的珍贵，你宣扬着思想的良知。立足于各自的信仰，各自为战。他们可真是幸福的人。 我拍了拍尘土，起身往回走。乐音还在耳后激荡。我望着高远的天空，我的信仰在哪里呢？ 我只知道，我不属于现在。它还在其他的地方。","categories":[{"name":"life","slug":"life","permalink":"http://vergessenwang.github.io/categories/life/"}],"tags":[]},{"title":"webpack简单配置","slug":"webpack简单配置","date":"2019-01-11T15:15:09.000Z","updated":"2020-03-11T15:34:13.403Z","comments":true,"path":"posts/frontend/2019-01-11-webpack简单配置.html","link":"","permalink":"http://vergessenwang.github.io/posts/frontend/2019-01-11-webpack简单配置.html","excerpt":"创建一个webpack.config.js文件，基于node，所以要遵循CommonJS规范 打包出真实文件，即上线：webpack 开发的时候：webpack-dev-server","text":"创建一个webpack.config.js文件，基于node，所以要遵循CommonJS规范 打包出真实文件，即上线：webpack 开发的时候：webpack-dev-server #基本配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667let path = require(&apos;path&apos;) ; /* node中path 模块提供了一些工具函数，用于处理文件与目录的路径。path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径。 webpack通过require来判断哪些模板在编译打包时需要引用*/let HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); let webpack = require(&apos;webpack&apos;);let ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)let CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)module.exports = &#123; entry:&#123; js1:&apos;path1&apos;, js2:&apos;path2&apos;, &#125;, // 入口 output:&#123; filename:&apos;[name].js&apos;, path:path.resolve(&apos;./build&apos;), // 必须是绝对路径 &#125;, devServer:&#123; contentBase:&apos;&apos;, port:3000, compress:true, // 服务器压缩 open:true, // 自动打开浏览器 hot:true, // 热更新 &#125;， // 开发服务器 module：&#123; rules:&#123; test:/\\.css$/, use:ExtractTextWebpackPlugin.extract(&#123; fallback:&apos;style-loader&apos;, /* 把style-loader传给了fallback，这个配置的基本含义就是， extract默认行为先使用css-loader编译css，如果一切顺利的话， 结束之后把css导出到规定的文件去。*/ use:&#123; loader:&apos;css-loader&apos; &#125; &#125;) &#125; &#125;， plugins:[ new webpack.HotModuleReplacementPlugin(), new CopyWebpackPlugin([&#123; from:&apos;&apos; to:&apos;&apos; &#125;]), new HtmlWebpackPlugin(&#123; filename:&apos;a.html&apos;, template:&apos;&apos;, title:&apos;&apos;, minify:&#123; removeAttributeQuotes:true, //打包到一行 collapseWhitespace:true, hash:true, &#125; chunks:[&apos;js1&apos;] &#125;) ], mode:&apos;development&apos;, // 可以更改模式 resolve：&#123;&#125;， // 配置解析&#125; 要点： 配置开发服务器 webpack-dev-server，安装包的时候也要用开发模式 插件 将html打包到build下可以自动引入生产的js，用插件html-webpack-plugin 多页面（多入口）配合html-webpack-plugin中的chunks Webpack自带的热更新插件，只刷新更改的局部 针对不同的文件类型（style/css/less/sass/stylus），使用不同的loader进行解析。在module中建立匹配规则 同时为了减小文件大小要抽离CSS样式，用extract-text-webpack-plugin，但是会失去热更新功能，故一般上线的时候才抽离。为了解决这个问题，用fallback（保留样式但不抽离） 直接拷贝文件，copy-webpack-plugin插件，from-to路径","categories":[{"name":"frontend","slug":"frontend","permalink":"http://vergessenwang.github.io/categories/frontend/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://vergessenwang.github.io/tags/webpack/"}]},{"title":"学习之道-note","slug":"学习之道","date":"2018-09-12T12:59:25.000Z","updated":"2020-03-11T15:38:01.667Z","comments":true,"path":"posts/reading/2018-09-12-学习之道.html","link":"","permalink":"http://vergessenwang.github.io/posts/reading/2018-09-12-学习之道.html","excerpt":"运用回想 读完一页书，看向别处回想主要观点（提取练习）。不要被动重复阅读，不要画过多重点（一定程度上说，一旦在材料中做了标记，就破坏了知识的原貌）。通过回忆得到自己心中的想法。加深回忆的方法：尽可能调动更多的感觉，形成记忆宫殿。 自我测试 用抽认卡片检验记忆。做练习题测试，但前提是已经熟悉过教材，不要本末倒置。练习中有错误不要沮丧，它的目的就是让你在真实环境之前经历失败。","text":"运用回想 读完一页书，看向别处回想主要观点（提取练习）。不要被动重复阅读，不要画过多重点（一定程度上说，一旦在材料中做了标记，就破坏了知识的原貌）。通过回忆得到自己心中的想法。加深回忆的方法：尽可能调动更多的感觉，形成记忆宫殿。 自我测试 用抽认卡片检验记忆。做练习题测试，但前提是已经熟悉过教材，不要本末倒置。练习中有错误不要沮丧，它的目的就是让你在真实环境之前经历失败。 对问题进行组块 类比已有知识（理解问题，使用解释性的提问和简单类比，或情境带入如想象自己是一个晶体管，给抽象概念赋予生命。理解通常是解释的产物）→搭建组块（抽象，如意群和口诀；跳出初始问题，获取背景信息，明白应用场景）→归纳解题方法（应用，系统地理解每个步骤）。首先要梳理一个顺畅的思路，然后将组块一一挂载到逻辑之上。组块过程是至下而上的过程，纵览全局是至上而下的，而背景环境正是交汇之处，意味着要做出恰当的选择。 加强模式识别（建立一个思维方案库，快速读取）：章节→主旨→题型→方法。要刻意关注最棘手的概念和解题环节，有思路前不要看解答。 间隔重复，交叉练习 不同学科交叉学习，每天能处理的某学科的练习量是一定的。在练习中还要交替使用不同解题技巧，如果已经掌握某种方法，就不要再做同一类题。 由难入简 一天中头脑中最清醒的时间，做最困难的事情。开始做题的时候，先做看起来最难的那道。如果一两分钟没有进展，再跳到简单题，让发散思维在后台进行处理。一段时间后再回过头来看，逐步获得进展。就好像同时做很多道菜一样。可以防止陷入思维定势，在更多的题型中获得启示。专注模式只着眼于具体的解题过程（套公式和已有方法），即使犯了很离谱的错误也不会察觉到，要不时换到发散模式从全局角度审题和检查（思考方程的意义，从何而来，适用范围），如量纲分。 方程不只是一个有输入由输出的表达式。它描述了我们物理世界如何运转。理解的关键在于，理解它所描述的故事。对方程的定性理解远比定量计算出答案更重要。 “描述世界解决问题的理论必须建立于它自己的术语之上，能够独立存在，而模型往往依赖于他山之石。它们是将所研究之物于相似之物进行联系的比喻。这些相似都是片面的，因此模型必须对事物进行简化，缩减世界的维度。简单来说，理论告诉事物的本质，而模型仅仅告诉你它像什么。 ——艾曼努尔·德尔曼","categories":[{"name":"reading","slug":"reading","permalink":"http://vergessenwang.github.io/categories/reading/"}],"tags":[{"name":"学习方法","slug":"学习方法","permalink":"http://vergessenwang.github.io/tags/学习方法/"}]},{"title":"彷徨","slug":"彷徨","date":"2018-09-09T15:21:42.000Z","updated":"2019-08-11T18:06:15.133Z","comments":true,"path":"posts/poetry/2018-09-09-彷徨.html","link":"","permalink":"http://vergessenwang.github.io/posts/poetry/2018-09-09-彷徨.html","excerpt":"曾迷仗剑执花梦，又耽恓惶怠日终。少年壮志殁荒草，尉为国用笑成空。","text":"曾迷仗剑执花梦，又耽恓惶怠日终。少年壮志殁荒草，尉为国用笑成空。偶闻雾破云开语，欲携玉龙重返疆。闭耳不闻世事嚣，奈何白驹奔如旧。你言光阴倏不待，我道幽井难观天。十年烂柯千年塔，不见鸿雁等归人。世间万般玲珑局，莫执一子空踟躇。凉州道远难顾盼，不若纵马览千山。今朝放下手中剑，年深岁久可相知？","categories":[{"name":"poetry","slug":"poetry","permalink":"http://vergessenwang.github.io/categories/poetry/"}],"tags":[{"name":"醉笑痴狂","slug":"醉笑痴狂","permalink":"http://vergessenwang.github.io/tags/醉笑痴狂/"}]},{"title":"阿里阿德涅之线","slug":"阿里阿德涅之线","date":"2018-09-05T13:26:24.000Z","updated":"2020-03-11T15:41:48.985Z","comments":true,"path":"posts/thinking/2018-09-05-阿里阿德涅之线.html","link":"","permalink":"http://vergessenwang.github.io/posts/thinking/2018-09-05-阿里阿德涅之线.html","excerpt":"克里特岛的迷宫 在迷宫神话中，克里特岛国王的女儿阿里阿德涅给了她爱慕的勇士忒修斯一个线团，他在斩杀了吃童男童女的兽人米诺陶洛斯之后，又靠这个线团原路返回走出了迷宫。 这个故事具有一定的隐喻意义。人类诞生在一个孤独的星球上，在这个无迹可寻的物质世界中，现今的人们对于世界相比于原始人的困惑并不会更少，而且文明一词，本来就是一个相对的概念。人类在所有领域的一切探索，都可以归结到一个总的命题：我们周围的世界，究竟是怎样的？","text":"克里特岛的迷宫 在迷宫神话中，克里特岛国王的女儿阿里阿德涅给了她爱慕的勇士忒修斯一个线团，他在斩杀了吃童男童女的兽人米诺陶洛斯之后，又靠这个线团原路返回走出了迷宫。 这个故事具有一定的隐喻意义。人类诞生在一个孤独的星球上，在这个无迹可寻的物质世界中，现今的人们对于世界相比于原始人的困惑并不会更少，而且文明一词，本来就是一个相对的概念。人类在所有领域的一切探索，都可以归结到一个总的命题：我们周围的世界，究竟是怎样的？ 如果一切是从无到有，那最开始的状态是怎样的？如果背后有一个神秘的创造者，那么万物的规则又是什么？忒修斯代表的是人类，米诺陶洛斯是人类的非理性（实际上，纯粹理性究竟是否存在还是一个问题，基于进化角度的在乎短期利益的非理性似乎更贴近人类的本质），迷宫是经验知识，我们站在中央，被自然科学，社会科学，人文科学，艺术和宗教团团包围。尽管在这些领域都有着各种突破，但它们各自绕成一堆乱麻。即便从因果解释的路径出发，每个岔路口的可能性最终会使可能性累计至无穷。 我们似乎永远连终点都找不到，更别说起点了。亲爱的阿里阿德涅，你在哪？ 在单个领域建立统一规律之后，自然会想到，能否在不同的领域建立一个简约的标准？即使所有的科学都受限于我们这个宇宙的参数。 笛卡尔曾提出的演绎法有一个基本的框架：切中每一个现象的核心，并记下现象的架构。他认为互相关联的真理最后都可以抽象成数学，而且系统性的质疑时学习的首要原则。 然而，数学虽然在架构理论上无懈可击，却是逻辑上的同义反复，即结论实际上和条件是等价的。在现实中，对于复杂系统的研究，整合也比剖析更难。最重要的是：预测的价值。基于普适的数学模型，发展到特殊的物质世界，预测能力到底有多强。 现有的复杂理论发展出分形几何，混沌理论等原理，解释了复杂现象可以经由系统中微小而可测量的变化来决定。可是，并没有太多实际可用于预测的能力。 或许，复杂系统的复杂性就在于：不可预测性。我们清楚生命游戏的原理，却依然为它所产生的美妙结果而惊叹。也许，提出正确的问题比给出正确的答案更为重要。 每个人都活在自己的感官和既有知识构造的世界中，我们尚未感知的，并不一定不存在。 没有完整的世界观，只有不断完善的世界观。 它，就在那里。 “那些死于热诚追寻的人，就像在热血中受了伤，几乎感受不到任何疼痛。”——培根","categories":[{"name":"thinking","slug":"thinking","permalink":"http://vergessenwang.github.io/categories/thinking/"}],"tags":[]},{"title":"栈","slug":"栈","date":"2018-09-02T04:10:45.000Z","updated":"2020-03-31T06:39:48.104Z","comments":true,"path":"posts/DataStructure/2018-09-02-栈.html","link":"","permalink":"http://vergessenwang.github.io/posts/DataStructure/2018-09-02-栈.html","excerpt":"定义 LIFO，仅在表尾进行插入删除操作的一种特殊线性表，是一种逻辑结构，故有多种实现方式。 实现 关键：指针和元素值的对应关系（有时指针指向当前元素——如在数组表示中初始指向-1，有时指向下一个元素——初始指向栈底，视具体情况而定）；指针如何移动（链表实现中）","text":"定义 LIFO，仅在表尾进行插入删除操作的一种特殊线性表，是一种逻辑结构，故有多种实现方式。 实现 关键：指针和元素值的对应关系（有时指针指向当前元素——如在数组表示中初始指向-1，有时指向下一个元素——初始指向栈底，视具体情况而定）；指针如何移动（链表实现中） 顺序栈 结构体 12345#define Maxsize 100typedef struct&#123; ElemType data[Maxsize]; //存放栈中元素，可以是int等类型（int data[Maxsize]) int top;&#125;SqStack; //结构变量对结构成员的访问 : 结构变量.成员名 假设栈指针的初始值为-1（避免浪费一个元素空间的大小） 初始化顺序栈 123456789//考虑空间问题，动态分配void InitStack(SqStack &amp;S)&#123; S.top = (ElemType *)malloc(Maxsize * sizeof(ElemType)); if (!S.top) exit (Overflow);&#125;//静态分配void InitStack(SqStack &amp;S)&#123; S.top = -1; //只须设置指针&#125; 判断栈空(判断指针位置，非引用型) 123bool StackEmpty(S)&#123; (S.top == -1)?true:false;&#125; 进栈 123456 bool Push(SqStack &amp;S，ElemType x)&#123; if (S.top == Maxsize-1) //先判断是否还有空间 return false; S.data[++S.top] = x; //先移动指针，再存数；如果初始值为0，则S.top++ return true;&#125; 出栈（删除栈顶元素） 123456bool Pop(SqStack &amp;S，ElemType &amp;x)&#123; if (S.top == -1) //先判断是否还有元素 return false; x = S.data[S.top--]; //先取数，再移动指针；如果初始值为0，则--S.top return true;&#125; 取栈顶元素（但不删除，非引用型） 123456bool GetTop(SqStack S，ElemType &amp;x)&#123; if (S.top == -1) //先判断是否还有元素 return false; x = S.data[S.top]; //不移动指针 return true;&#125; 基本操作总结 1234int Stack[Maxsize];int top = -1;S.data[++S.top] = x;x = S.data[S.top--]; 链栈 结构体 1234typedef struct LNode&#123; ElemType data; struct Linknode *next;&#125; *LiStack; //使用结构指针对结构成员的访问: 结构指针名-&gt;结构成员 初始化链栈 1234void InitStack(Linknode &amp;S)&#123; S = (LNode *)malloc(sizeof(LNode)); // 假设有头结点，分配空间 S -&gt; next = NULL; //栈空状态&#125; 判断栈空 123bool StackEmpty(LNode S)&#123; (S -&gt; next = NULL)?true:false;&#125; 进栈(离散存储，不用判满) 12345678910 viod Push(LNode &amp;S，ElemType x)&#123; LNode *p; //工作指针, 存储插入元素 p = (LNode *)malloc(sizeof(LNode)); //为进栈元素申请结点空间 p -&gt; next = NULL; //可以不写，但能避免一些错误 //头插法，逆序 p -&gt; data = x; //先存值 p -&gt; next = S -&gt; next; //先连后继指针 S -&gt; next = p; //再连前驱指针 //尾插法， R -&gt; next = p; R = p &#125; 出栈（要判空） 123456789bool Pop(LNode &amp;S，ElemType &amp;x)&#123; LNode *p; if (S -&gt; next = NULL) return false; p = S -&gt; next; //暂存后继结点，防止断链 x = p -&gt; data; //取值 S -&gt; next = p -&gt; next; //连上后继结点 free(p); //释放空间，C需要手动释放 return true；&#125; 基本操作总结 123S -&gt; next = NULL;p -&gt; data = x; p -&gt; next = S -&gt; next; S -&gt; next = p;p = S -&gt; next; x = p -&gt; data; S -&gt; next = p -&gt; next; free(p); 应用括号匹配 原理：栈具有记忆的功能。如果再解决问题的过程中出现了一个子问题，但凭现有条件不能解决它，需要记下，等出现可以解决它的条件后再返回来解决。 思路： 用顺序栈实现 逐个扫描，左括号入栈，右括号与栈顶第一个左括号抵消，若栈已空，出错； 如果有多种括号，右括号与栈顶第一个左括号不一致时出错； 扫描完毕，栈空成功；不空失败拓展：中心对称（回文），前一半元素进栈，匹配剩下的。由于涉及到n/2，要注意指针的位置，奇数时的处理（中间不用比较） 表达式求值 原理：根据算符优先级判断计算顺序，用栈记录顺序 注：此处是指中缀表达式 思路： 用两个工作栈，OPTR用于寄存运算符，OPND用于寄存操作数或运算结果，实现算符优先算法 置OPTR为空栈，OPND的栈底元素为起始运算符# 扫描表达式，操作数进OPTR; 第一个运算符进OPND,用precede比较，后续运算符大于栈顶符号优先级，压栈；相等（只可能是括号匹配）去括号；小于，弹出OPND栈底运算符，再弹出两个操作数，用Operate计算结果，并将计算结果重新压栈 直到OPND栈底和当前扫描符号均为 #细节：熟悉栈内外优先级的判断；运算时注意除数为0的情况拓展：后缀求值的实现（操作数先入栈，每遇到一个运算符出栈两个数，计算后将结果压栈);由中缀表达式输入后缀表达式（去括号，通过改变运算符的顺序来表示机器执行时的顺序） 车辆调度 原理：Y型车道，需要排在前面的不进栈，排在后面的进栈，此时栈中部分起存储作用。前面的都调度完之后，将栈中部分出栈 拓展：此时栈相当于一个中转站，通过它来实现顺序的转换，有点类似Hanoi塔的中间那个柱子 数制转换 原理：N = (N div d) * d + N mod d 从低位到高位的余数，故需要用栈实现输出的逆序。 思路： 做取余运算，将余数进栈 做整除运算，用结果替换N 直到N为0，弹出所有元素拓展：相比于数组实现的好处——利用栈的LIFO特性，不用再去考虑下标增减等细节问题 行编辑 原理：用户输入时可能出错，退格符#删一个，退行符@删一行，输入缓冲区接受一行字符后再存入到用户数据区。 接受的字符不是全文结束符EOF或换行符 /#，退栈一个 @ ClearStack 清空 其他情况，正常进栈 全文或每行结束，将栈内容送至调用过程的数据区，清空栈拓展：注意该缓冲区与为解决主机和外设速度不匹配问题的打印数据缓冲区的区别，那个缓存区是用队列实现的，因打印要保证顺序不变；如果这里也要保证顺序不变，那就要加一个队列","categories":[{"name":"DataStructure","slug":"DataStructure","permalink":"http://vergessenwang.github.io/categories/DataStructure/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://vergessenwang.github.io/tags/栈/"}]},{"title":"基于区块链的信用共识：代码即法律","slug":"基于区块链的信用共识：代码即法律","date":"2018-08-29T05:31:57.000Z","updated":"2020-03-11T15:40:49.508Z","comments":true,"path":"posts/reading/2018-08-29-基于区块链的信用共识：代码即法律.html","link":"","permalink":"http://vergessenwang.github.io/posts/reading/2018-08-29-基于区块链的信用共识：代码即法律.html","excerpt":"从分散到集中 人类社会财产记录方式的发展，与物质的逐步丰盛是密不可分。最开始茹毛饮血的年代，温饱尚成问题，谈不上什么财产拥有权。呐，这个鹿屁股是你的，鹿腿归我，大概就是这样了。随着狩猎工具越来越精巧，以及通过长期观察掌握了自然更替的规律，人类开始从土地获得更为稳定与劳力成正比的耕作物。再不用在一个大锅里较稀稠，个人有了剩余的物质储备，催生了记账的需求。 同时，由于生产力之间的不平衡，物质短缺方和富余方之间还会建立借贷关系。这种互助关系本是出于善意，但是契约之间缺少更多约束，仅能凭借双方各自的人格担保，自然会产生诸多问题。","text":"从分散到集中 人类社会财产记录方式的发展，与物质的逐步丰盛是密不可分。最开始茹毛饮血的年代，温饱尚成问题，谈不上什么财产拥有权。呐，这个鹿屁股是你的，鹿腿归我，大概就是这样了。随着狩猎工具越来越精巧，以及通过长期观察掌握了自然更替的规律，人类开始从土地获得更为稳定与劳力成正比的耕作物。再不用在一个大锅里较稀稠，个人有了剩余的物质储备，催生了记账的需求。 同时，由于生产力之间的不平衡，物质短缺方和富余方之间还会建立借贷关系。这种互助关系本是出于善意，但是契约之间缺少更多约束，仅能凭借双方各自的人格担保，自然会产生诸多问题。 由此可以想到两种解决方案：第一种，找一个大家普遍认可的，具有公信力的第三方，各种借贷交易需要通过这个第三方进行；第二种，每个交易进行时所有人都在场见证，防止日后有一方违约。显然，第二种的成本过高，大家都跑去看人借钱，猪都饿死了。于是，由银行为首的第三方存管机构，辅之以交易所，会计审计等机构开始接管人类社会的借贷交易等记账工作。 记账的核心在于，解决信用共识。既然当初交给第三方是应该公共管理的成本过高，那么一旦成本低于第三方的管理费用，是不是就可以抛弃这种方式，重新回到点对点交易的时代？答案是肯定的。 重回去中心化时代 区块链的本质就是去中心化的分布式账本，能够用基于数学算法的低成本信任机制解决信用共识问题。撇开比特币不谈，因为即使一种载体只要能被大家普通认同是有价值的就能说是有价值的，但是这种每10分钟就产生一些新币，参与者依靠算力或者概率获得新币的增长到底有没有实际价值还是一个值得考虑的问题。与其说新币的拥有是一种价值创造过程，倒不如认为它激励大家普遍参与到达成一致共识这个过程中意图更强一点。 毕竟，记账才是重点，鼓励用户参与验证，保证过往交易历史的不可篡改性才是这种分布式方式的精髓所在。工作量证明，权益证明，Pool验证池等高效共识算法机制，在解决点对点通信中的拜占庭将军问题时，同时将时间控制在一个合适的范围，既不因太短而导致双花问题，也不因太长而影响结算。 同时，文本形式的契约变成了封装区块数据结构的代码和内含于整个系统的构建理念，可以说，代码即是法律，不为任何人或事动摇，比那些偶尔也会堕入腐败的第三方更为可靠。 由此可见，除了去中心化，安全，自治，公开和多备份等特点，低成本的解决信用共识问题也是区块链技术的一大优势。 当面对一项新技术时，不该因其表面的混乱，如比特币作为一种虚拟货币价值暴涨暴跌，就将之视为洪水猛兽。 技术本身，是无罪的。 另外，在2008年中本聪提出比特币基本原则时，也是基于许多前人的研究，任何一项技术，都不会是突然凭空产生的。 1982年，戴维·乔姆提出注重隐私安全的密码学网络支付系统，具有不可追踪性 1990年，莱斯利·兰伯特提出基于消息传递一致性的Paxos算法，解决分布式系统如何就某个值（决议）达成一致 1991年，斯图尔特·哈伯与W.斯科特·斯托尔内塔提出利用时间戳确保数位文件安全 1997年，亚当·巴克发明哈希现金技术，依赖成本函数的不可逆特性，实现容易被验证但是难被破解的特性 1998年，戴伟发表匿名的分散式电子现金系统B-money，强调点对点交易和不可篡改特性。尼克·萨博发表了去中心化的数位货币系统Bit Gold参与者可贡献运算能力解出加密谜题。 哈尔·尼克提出RPOW（可重复使用的工作量证明机制），将B-money和哈希现金结合起来创造了密码学货币 If I have seen further,it is by standing on ye shoulders of Giants","categories":[{"name":"reading","slug":"reading","permalink":"http://vergessenwang.github.io/categories/reading/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://vergessenwang.github.io/tags/区块链/"}]},{"title":"信息熵与设计思维","slug":"信息熵与设计思维","date":"2018-08-26T08:42:28.000Z","updated":"2020-03-11T15:38:18.438Z","comments":true,"path":"posts/reading/2018-08-26-信息熵与设计思维.html","link":"","permalink":"http://vergessenwang.github.io/posts/reading/2018-08-26-信息熵与设计思维.html","excerpt":"信息与不确定性 一切不确定性的谜底，只有一个，那就是：信息。 与人交流时，更多的信息加深理解；面对问题时，综合更多的信息才能给出最优的解决方案。语言，文字，声音，甚至龟壳，都能作为信息的载体，创作者于此端编码，接受者于彼端解码，至于究竟采取何种方式，根本无关紧要。一万个猴子用无穷长的时间在打字机上乱敲，也能写出一本《资本论》。","text":"信息与不确定性 一切不确定性的谜底，只有一个，那就是：信息。 与人交流时，更多的信息加深理解；面对问题时，综合更多的信息才能给出最优的解决方案。语言，文字，声音，甚至龟壳，都能作为信息的载体，创作者于此端编码，接受者于彼端解码，至于究竟采取何种方式，根本无关紧要。一万个猴子用无穷长的时间在打字机上乱敲，也能写出一本《资本论》。 先民对预言者的盲目崇拜，表面上是对那种缥缈神力的敬畏，本质上是因为未来已经被剥去了神秘的美妙感，而成为了一种确定的现实。不管当下是光鲜亮丽，还是匍匐前行，好像最终都会到底那里，不如放弃抵抗，找一个皈依，一切推给命运。 未来是不确定的，人才活着；一眼看穿，就早已死去。 那这些与信息有什么关系？不确定性正是信息量的多少，即信息量的度量就是信息熵。消除不确定性，就是寻找相关信息。没有足够的信息量，不管用多么无懈可击的模型，都不可能得出一个确定的结果；更弱的相关性，也会使推论的过程更加曲折。 从某种意义上说，人当下所做的一切，都只是为了在面对未来的时候有更多的把握。听起来好像有点矛盾，更有把握不就是一眼看穿？那我们这么拼命是为了什么？为了死？不是。问题的根本在于，未来的不确定性是无穷的。人之所能掌握的，终究有限。我们能做的，不过在是包含了所有的不确定性的最大熵中，给自己找一个奋不顾身的理由。 在时间和命运的长河中，瞥见惊涛里一颗闪闪发光的钻石，看清自己的局限和向往之后，用生命作筹码，纵身一跃，仅此而已。 脱离这种大的框架，信息熵到底对生活有什么指导意义？ 解题与设计思维 先来说说数学家波利亚的怎样解题的步骤： 第一阶段：理解阶段。观察和发现问题的核心概念和性质。 第二阶段：规划阶段。规划出如何解决问题。 第三阶段：计划实施阶段。执行和验证。 第四阶段：回顾阶段。从解决方案中学习。 他的这种思想推动因素以及提出解决方案的过程——在工程学领域演化为设计思维。 其一，一定要真正理解你的问题——未知的问题是什么？你掌握了哪些数据？这个阶段就是信息收集，很多具体的问题背后，大多都有一个抽象的模型，基于这个模型你了解多少？基于具体问题又有多少已知的信息？如果曾经看过相似的问题，针对细微的区别，该做怎样的调整？如果这是一个新的挑战，能否找到更低一级的模型去支撑？这是一个无限抽象的过程。 其二，发现已有数据和未知问题的关联，即是一个深度具体的过程。基于选定的框架，每一条已知信息都必然可以通过分析，或多或少消除未知问题的一些不确定性。有的问题本身的模型已经足够精确，用极少的条件就可以得出确定的答案；而有的问题，本身定义就非常模糊，往往只能得出一个局部最优解，只有好坏而没有对错之分。 其三，看看能否证明你的想法，如果条件足够，最后的结果和最初的假设必然可以形成一个闭环。一旦出现矛盾，却可能是很多原因导致的。这又是很常见的，解决问题的过程，就是不断推翻假设的过程，修正是必要的环节。 最后，通过观察解决问题的结果和解决问题的过程，巩固知识，提高解决问题的能力。相似的，有确定答案的问题，往往都没有太大的价值。处于个人能力边界但又不算太遥远的问题，更能给人较大的提升，人的知识之网通过拓扑，可以够到那个边缘。即便解决了问题，也不等于万事大吉，完善曾经的模型或者在后续用更优的方案进行更新，问题才得以发挥其最大价值。 再回到人生上，我们总是要在各个阶段基于所掌握的信息，去做大大小小的决策，用更具逻辑性的方法，不断训练自己解决的能力。那我们在面对未来的时候，总归能少那么一丁点的不确定性，对命运多一点信心。","categories":[{"name":"reading","slug":"reading","permalink":"http://vergessenwang.github.io/categories/reading/"}],"tags":[]}]}