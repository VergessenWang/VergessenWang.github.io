<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/bitbug_favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/bitbug_favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/bitbug_favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/bitbug_favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="栈,C语言,树,队列," />










<meta name="description" content="基于实验楼 C语言实验语言热度排行 果然是犹豫不决学Java…  “不管你懂多少延续、闭包、异常处理，只要你不能解释为什么 while(*s++=*t++); 的作用是复制字符串，那你就是在盲目无知的情况下编程，就像一个医生不懂最基本的解剖学就在开处方”  Linux 不以文件后缀来区分可执行文件，Linux 下的可执行文件后缀理论上是可以任意更改的。 C语言教程 基本命令编译：gcc -c **">
<meta name="keywords" content="栈,C语言,树,队列">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与C语言">
<meta property="og:url" content="http://vergessenwang.github.io/posts/DataStructure/2019-09-01-数据结构与C语言.html">
<meta property="og:site_name" content="Anonymous World">
<meta property="og:description" content="基于实验楼 C语言实验语言热度排行 果然是犹豫不决学Java…  “不管你懂多少延续、闭包、异常处理，只要你不能解释为什么 while(*s++=*t++); 的作用是复制字符串，那你就是在盲目无知的情况下编程，就像一个医生不懂最基本的解剖学就在开处方”  Linux 不以文件后缀来区分可执行文件，Linux 下的可执行文件后缀理论上是可以任意更改的。 C语言教程 基本命令编译：gcc -c **">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-03-31T06:38:35.354Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构与C语言">
<meta name="twitter:description" content="基于实验楼 C语言实验语言热度排行 果然是犹豫不决学Java…  “不管你懂多少延续、闭包、异常处理，只要你不能解释为什么 while(*s++=*t++); 的作用是复制字符串，那你就是在盲目无知的情况下编程，就像一个医生不懂最基本的解剖学就在开处方”  Linux 不以文件后缀来区分可执行文件，Linux 下的可执行文件后缀理论上是可以任意更改的。 C语言教程 基本命令编译：gcc -c **">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://vergessenwang.github.io/posts/DataStructure/2019-09-01-数据结构与C语言.html"/>





  <title>数据结构与C语言 | Anonymous World</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Anonymous World</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">迷失仙境</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://vergessenwang.github.io/posts/DataStructure/2019-09-01-数据结构与C语言.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liana_Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Anonymous World">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据结构与C语言</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-01T23:23:25+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataStructure/" itemprop="url" rel="index">
                    <span itemprop="name">DataStructure</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,863
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>基于<a href="https://www.shiyanlou.com/courses/57" target="_blank" rel="noopener">实验楼</a></p>
<h3 id="C语言实验"><a href="#C语言实验" class="headerlink" title="C语言实验"></a>C语言实验</h3><p><a href="https://www.tiobe.com/tiobe-index//" target="_blank" rel="noopener">语言热度排行</a> 果然是犹豫不决学Java…</p>
<blockquote>
<p>“不管你懂多少延续、闭包、异常处理，只要你不能解释为什么 <code>while(*s++=*t++);</code> 的作用是复制字符串，那你就是在盲目无知的情况下编程，就像一个医生不懂最基本的解剖学就在开处方”</p>
</blockquote>
<p>Linux 不以文件后缀来区分可执行文件，Linux 下的可执行文件后缀理论上是可以任意更改的。</p>
<p><a href="https://www.runoob.com/cprogramming/c-tutorial.html" target="_blank" rel="noopener">C语言教程</a></p>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p>编译：<code>gcc -c **.c</code>  生成对象文件</p>
<p>链接：<code>gcc -o ** **.o</code>  生成没有后缀的可执行文件</p>
<p>同时进行：<code>gcc -o ** **.c</code></p>
<p>执行：<code>./**</code></p>
<a id="more"></a>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>gcc 编译器为每个<code>int</code>类型分配四个字节（32 个二进位）。在存储单元中的存储方式是：用整数的<strong>补码</strong>形式存放。所以当 4 个字节的整数类型取值范围是 -2^31 到（2^31-1）。无符号的基本整型表示为 <code>unsigned int</code>，和 int 类型占有的字节数相同，取值范围是 0 到（2^32-1）</p>
<p>字符型数据在存储时，并不是把该字符本身存放到内存单元中，而是把<strong>该字符相应的 ASCII 码值</strong>存放到该存储单元中。——<strong>真正代表了数据含义的是数据类型，而不是二进制本身</strong>。用小写表示的字符的 ASCII 码比用大写表示的 ASCII 码<strong>大 32</strong>。</p>
<p>存储字符串<strong>常量</strong>时还要自动在其末尾加上 <strong>‘\0’</strong> 作为字符串结束的标志，所以<strong><code>&quot;b&quot;</code>会占用两个字节而<code>&#39;b&#39;</code>是一个字节</strong></p>
<p>要将一个字符串存放在<strong>变量</strong>中，必须使用<strong>字符数组</strong>。C 语言中没有字符串类型，字符串都是存储在字符型数组中的。处理字符串时要加上<code>string.h</code>头文件</p>
<p>在强制类型转换时，得到一个所需类型的中间数据，而<strong>原来变量的类型未发生变化</strong></p>
<p>C 库<code>&lt;stdlib.h&gt;</code>中的函数 <code>int atoi(const char *str)</code>把参数 <code>**str**</code> 所指向的字符串转换为一个整数（类型为 int 型）</p>
<h5 id="atoi-itoa-与强制类型转换的区别"><a href="#atoi-itoa-与强制类型转换的区别" class="headerlink" title="atoi(),itoa() 与强制类型转换的区别"></a><code>atoi()</code>,<code>itoa()</code> 与强制类型转换的区别</h5><p><code>atoi()</code>,<code>itoa()</code>是整型数和字符串表示的整型数字之间的转换，是函数<strong>调用</strong>实现的。对内建基本类型之间的强制类型转换是在<strong>编译</strong>时实现的，对数值可能会截断、<strong>重新解释</strong>（不能用<code>(int)</code>直接把表示数字的字符串转成数字，好像要 <code>-&#39;0&#39;</code>)</p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>自增运算符 (++) 和自减运算符 (–) <strong>只能用于变量</strong>，而不能用于常量或表达式。如 <code>5++</code> 或者 <code>(a+b)++</code> 都是不合法的</p>
<p>字符 (char) 型数据和整形数据进行运算，就是把字符的 ASCII 代码与整形运算</p>
<h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>在 <code>printf</code> 函数中，在格式符 “f” 的前面加 “7.2”。表示的意思是在输出时，<strong>指定数据占 7 列，其中小数占 2 列</strong>。主要是使小数点对齐，输出时更加美观</p>
<ul>
<li><code>%d</code>：按照整型数据的实际长度输出。</li>
<li><code>%md</code>：以m指定的字段宽度输出，右对齐。加 <code>-</code>左对齐</li>
<li><code>%ld</code>：输出长整型数据。</li>
<li><code>%mld</code>：输出指定宽度的长整型数据。</li>
</ul>
<p>在输入函数时，用 %c 格式声明输入字符时，空格字符和转义字符都是作为有效字符输入，所以输入时中间不要有空格</p>
<h4 id="main函数的参数argc和argv"><a href="#main函数的参数argc和argv" class="headerlink" title="main函数的参数argc和argv"></a>main函数的参数<code>argc</code>和<code>argv</code></h4><p><code>int main(int argc,char *argv[]) = int main(int argc,char **argv)</code>其参数<code>argc</code>和<code>argv</code>用于运行时,把命令行参数传入主程序</p>
<p><code>int argc</code>英文名为arguments count(参数计数)。运行程序传送给main函数的<strong>命令行参数总个数</strong>,包括可执行程序名,其中当<code>**argc=1</code>时表示只有一个程序名称<strong>,此时存储在<code></code></strong>argv[0]**<code></code>中.</p>
<p><code>char **argv</code>:英文名为arguments value/vector(参数值)。用来存放<strong>指向字符串参数的指针数组！指针数组！指针数组！不是字符串本身</strong>每个元素指向一个参数,空格分隔参数,其长度为<code>argc</code>.</p>
<ul>
<li><code>argv[0]</code> 指向程序运行时的全路径名</li>
<li><code>argv[1]</code>指向程序在DOS命令中执行程序名后的第一个字符串</li>
<li><code>argv[2]</code> 指向执行程序名后的第二个字符串</li>
<li><code>argv[argc]</code>为NULL</li>
</ul>
<p><a href="https://blog.csdn.net/Eastmount/article/details/20413773" target="_blank" rel="noopener">参考Eastmount的博客</a></p>
<p>命令行运行程序时，要在可执行文件名后加上参数</p>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><h5 id="while和do…while"><a href="#while和do…while" class="headerlink" title="while和do…while"></a>while和do…while</h5><p>和 <code>while</code> 语句不同， <code>do...while</code> 语句中的 <code>while</code>（）；后面是有“；”的</p>
<p>另外，当 <code>while</code> 后面的表达式的第一次值为“真”时，两种循环得到的结果是相同的；否则，二者结果不相同(do…while会先执行一次）</p>
<h4 id="要注意的细节"><a href="#要注意的细节" class="headerlink" title="要注意的细节"></a>要注意的细节</h4><ul>
<li><code>#include&lt;stdio.h&gt;</code>不要忘记写#和.h</li>
<li><code>scanf()</code>函数中的表列是地址表列，要加&amp;，数组不用加</li>
<li>float的精度只有<strong>6~7位</strong>，double是15~16位，long double是18~19位</li>
<li>在 Linux 系统下，Ｃ 源文件若调用了 math 库里的函数，<strong>则编译时要加上<code>-lm</code>（是字母 l ，不是数字１）</strong>，表示链接到 math 库。</li>
<li>打印数组时要换行可以用一个全局变量<strong>整除</strong>来控制</li>
</ul>
<hr>
<h3 id="C语言知识点"><a href="#C语言知识点" class="headerlink" title="C语言知识点"></a>C语言知识点</h3><h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><ul>
<li><code>c  = getchar();  putchar(c);</code>  输入结尾判定<code>getchar() != EOF</code></li>
<li>通过<code>getchar()</code>获得的数字实际上是一个<strong>该数字的ASCII码</strong>，用于数值计算时要用<code>c - &#39;0&#39;</code></li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><code>a == &amp;a[0]</code></li>
<li>每个元素是同一数据类型，只能逐个引用(常用for循环)，不能一次引用整个数组。</li>
<li><strong>编译器</strong>会为数组分配一段连续内存，二维数组<strong>先行后列</strong></li>
<li><strong>定义</strong>可以用常量和<strong>符号常量</strong>，如<code>#define SIZE 10  int a[SIZE];</code>,但一定不能包含变量(访问可用变量)。为了便于后续更改，一般采用符号常量</li>
<li>定义的同时对全部元素赋初值，可以不指定数组长度，如<code>int a[] = {0,1,2,3,4};</code> 对于二维数组，第一维可以不指定但第二维必须指定 （emmm，发布博文时报错，可能是双大括号的原因，这里删去了，试下能发布的话就是这个原因）</li>
<li>一维数组用例：冒泡排序</li>
<li>二维数组用例：矩阵最大值及行列号——打擂台法</li>
</ul>
<h4 id="字符数组与字符串"><a href="#字符数组与字符串" class="headerlink" title="字符数组与字符串"></a>字符数组与字符串</h4><ul>
<li>字符数组：<code>char a[] = {&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;};</code> 长度为4</li>
<li>字符串：<code>char a[] = &quot;abcd&quot;;</code>  以双引号赋值时，系统自动加上<code>&#39;\0&#39;</code>结束符，长度为5<ul>
<li><code>&lt;string.h&gt;</code></li>
<li><code>gets(str); puts(str);</code></li>
<li><code>strcat(str1,str2);  strlen(str); strcpy(str1,str2); strcmp(str1,str2);</code></li>
</ul>
</li>
</ul>
<h4 id="函数化结构"><a href="#函数化结构" class="headerlink" title="函数化结构"></a>函数化结构</h4><ul>
<li>在程序中用到的所有函数，必须<strong>“先定义，后使用”</strong></li>
<li>自定义的函数要<strong>在main函数调用之前声明或定义</strong>。 函数声明的作用是把有关函数的信息（函数名、函数类型、函数参数的个数与类型）通知编译系统，在进行到 main 函数调用时知道他们是函数而不是变量或其他对象。</li>
<li>有参函数在调用函数时，主调函数通过参数向被调函数传输数据，<strong>要注意被调用函数返回值的类型</strong></li>
<li>在定义函数中指定的形参，在未出现函数调用时，他们<strong>并不占内存中的存储单元</strong>。在发生函数调用时，函数形参被<strong>临时分配内存单元</strong>；调用结束，形参单元被释放。所以要注意函数内部变量的作用域</li>
<li>C语言中函数<strong>不能嵌套定义</strong>，但是可以嵌套调用</li>
<li>要访问其他源文件的变量：<code>extern</code> ——用<strong>头文件</strong>的方式更好<code>#ifndef....#define....#endif</code></li>
<li>要自己的变量不被访问：<code>static</code>  <strong>初始化一次，一直占用空间</strong>，循环调用时会<strong>共享</strong></li>
</ul>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ul>
<li>变量是对程序中数据<strong>存储空间的抽象</strong></li>
<li>指针变量的类型，是指针变量<strong>所指向的变量的类型</strong>，而不是自身的类型</li>
</ul>
<p>注意：多维数组中指针的各种运算</p>
<hr>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><a href="https://www.shiyanlou.com/courses/20/learning/" target="_blank" rel="noopener">数据结构实验</a></p>
<h4 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出 T(n) 的同数量级（它的同数量级有以下：1，log(2)n，n，n log(2)n ，n 的平方，n 的三次方，2 的 n 次方，n!），找出后，f(n) = 该数量级，若 T(n)/f(n) 求极限可得到一常数 c，则时间复杂度 <strong>T(n) = O(f(n))</strong>。</p>
<p>计算空间复杂度主要看可变部分，包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。一个算法所需的存储空间用 f(n)表示：<strong>S(n)=O(f(n))</strong>。其中 n 为问题的规模，S(n)表示空间复杂度。</p>
<h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><ol>
<li>集合中必存在唯一的一个”第一个元素”； </li>
<li>集合中必存在唯一的一个”最后的元素”； </li>
<li>除最后元素之外，其它数据元素均有唯一的”后继”； </li>
<li>除第一元素之外，其它数据元素均有唯一的”前驱”。</li>
</ol>
<p>线性表有顺序和链式两种<strong>存储</strong>结构</p>
<h5 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h5><p>易随机存取，已使用的空间存储密度大；不易增删，空间固定难扩充</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elemtype *elem;	<span class="comment">//存储空间基址</span></span><br><span class="line">    <span class="keyword">int</span> length;		<span class="comment">//当前长度</span></span><br><span class="line">    <span class="keyword">int</span> size;		<span class="comment">//当前分配的表长大小</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>插入：先判断表是否已满 –&gt; 判断插入位置是否越界 –&gt; 从最后一个元素开始向后移动一位 –&gt; 插入值，length + 1；平均移动一半元素 <strong>T(n) = O(n)</strong></p>
<h6 id="归并算法"><a href="#归并算法" class="headerlink" title="归并算法"></a>归并算法</h6><p><strong>T(n) = O(n + m)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(SqList *A,SqList *B,SqList *C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>,k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= A-&gt;length &amp;&amp; j &lt;= B-&gt;length)</span><br><span class="line">        <span class="keyword">if</span>(A-&gt;elem[i] &lt;= B -&gt;elem[j]) C-&gt;elem[k++] = A-&gt;elem[i++];</span><br><span class="line">    <span class="keyword">else</span> C-&gt;elem[k++] = B-&gt;elem[j++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= A-&gt;length) C-&gt;elem[k++] = A-&gt;elem[i++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= B-&gt;length) C-&gt;elem[k++] = B-&gt;elem[j++];</span><br><span class="line">    C-&gt;length = A-&gt;length + B-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data; <span class="comment">// 数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指针域</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<p><code>LinkList h</code>头指针数据域为空，指针域指向单链表的第一个节点，可以<strong>避免对链表的第一个结点做特殊处理</strong>。因为对于<strong>无头结点的空表</strong>，插入值时可以<strong>直接对第一个结点的数据域赋值</strong>，而无需新建一个结点，<strong>或者直接改变第一个指针指向的地址为新结点</strong></p>
<p>尾结点指针域为<code>NULL</code></p>
<p><code>LNode *p;</code>  常用指向结点的指针变量p，一般直接赋值为某个已存在结点</p>
<p><code>p = (LinkList)malloc(sizeof(LNode)); free(p);</code> 为要插入的新结点分配空间，删除某结点要释放空间</p>
<p>相比于头插法，<strong>尾插法需要多一个尾指针</strong></p>
<p>另外，对于删除操作，可以使用一个暂存已删除结点的<code>avail</code>链表，下次分配时先用链表中的结点，并可以<strong>用指针操作在O(1)的复杂度实现整个链表的删除</strong></p>
<h6 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h6><p>由于链表不支持随机访问，所以交换头尾值的方法并不可行，最好还是<strong>直接改变指针域方向</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode <span class="title">reverseList</span><span class="params">(LinkList head)</span> </span>&#123;</span><br><span class="line">    LNode next = null;</span><br><span class="line">    LNode pre = null</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != null) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h6><p>通常只设一个<strong>尾指针</strong></p>
<p>连接两个单循环链表：<strong>O(1)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = RA -&gt; next; <span class="comment">// 找到A的头结点</span></span><br><span class="line">RA -&gt; next = RB -&gt; next -&gt; next; <span class="comment">//A尾连B的第一个结点，注意不是头结点</span></span><br><span class="line"><span class="built_in">free</span>(RB -&gt; next); <span class="comment">//记得删除B的头结点</span></span><br><span class="line">RB -&gt; next = p; <span class="comment">//B尾连A头</span></span><br></pre></td></tr></table></figure>
<h6 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dlnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dlnode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DLNode,*DLinkList;</span><br></pre></td></tr></table></figure>
<p>删除结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; prior -&gt; next = p -&gt; next;</span><br><span class="line">p -&gt; next -&gt; prior = p -&gt; prior;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure>
<h6 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h6><p>没有空指针域</p>
<h4 id="栈和队列-受限线性表"><a href="#栈和队列-受限线性表" class="headerlink" title="栈和队列(受限线性表)"></a>栈和队列(受限线性表)</h4><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>通常我们称<strong>表尾端为栈顶</strong>，表头端为栈底。栈上溢是一种出错状态，<strong>下溢</strong>则是一种正常状态，常用作<strong>程序转移控制条件</strong></p>
<p>可以解决例如数值转换、括号匹配、迷宫求解、表达式求值和汉诺塔等等问题。</p>
<p>也有顺序存储结构和链式存储结构两种表示方法</p>
<p>顺序实现结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	SElemType *base;	<span class="comment">//栈尾指针</span></span><br><span class="line">	SElemType *top;		<span class="comment">//栈顶指针</span></span><br><span class="line">	<span class="keyword">int</span> size;			<span class="comment">//栈的大小</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
<p>链式实现结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode;</span><br></pre></td></tr></table></figure>
<p>对于链栈，若<strong>新申请一个结点时<code>t = NULL</code> 则表示链满</strong>；申请成功用头插法插入到<code>top</code>结点前并更新<code>top</code> </p>
<p> 多栈共享存储空间：两个栈的栈底分别设在存储空间的两端，<strong>向中间延伸</strong>，相遇时溢出。</p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>允许插入元素的一端称为队尾，允许删除元素的一端称为队头</p>
<p>应用于操作系统调度任务队列。</p>
<p>顺序实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType elem[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> rear,front;</span><br><span class="line">&#125;SeQueue;</span><br></pre></td></tr></table></figure>
<p>由于队首指针会不断向后移动，前面空间无法利用，造成一种<strong>假溢出</strong>，于是可以将首尾连起来，构成<strong>循环队列</strong>。为了区分队满队空，<strong>要留出一个空间</strong>，队空 <code>sq -&gt; front == sq -&gt; rear</code> 队满<code>sq -&gt; front == (sq -&gt; rear + 1) % MAXSIZE</code></p>
<p>链表实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">	QElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	QueuePtr front;	<span class="comment">//队头指针</span></span><br><span class="line">	QueuePtr rear;	<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<p>入队时空链表要特殊处理，因为此时都指向同一个结点(<strong>对头指针多做一个指向p结点的操作</strong>)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">In_LQueue</span><span class="params">(LQueue  *Lq,ElemType x)</span></span>&#123;</span><br><span class="line">    QNode *p;</span><br><span class="line">    p = (QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    p -&gt; data = x;</span><br><span class="line">    p -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(Lq -&gt; rear == <span class="literal">NULL</span>) Lq -&gt; front = Lq -&gt; rear = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;Lq -&gt; rear -&gt; next = p; Lq -&gt; rear = p;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队时同理，当成为空表时，<strong>对尾结点多做一个指向新的头结点的操作</strong>。</p>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>用<strong>孩子兄弟法</strong>将任意的一棵树转成一个<strong>没有右孩子二叉树</strong>。</p>
<p>树不能为空，<strong>二叉树可以为空</strong>。二叉树<strong>左右子树不能交换</strong>，而树的左右子树可以交换</p>
<h5 id="二叉树重要性质"><a href="#二叉树重要性质" class="headerlink" title="二叉树重要性质"></a>二叉树重要性质</h5><ul>
<li>第 i 层最多  $2^{i-1}$  个结点 </li>
<li>k 层树最多 $2^k-1$ 个结点</li>
<li>$n_0 = n_2 + 1$</li>
</ul>
<h5 id="完全二叉树性质"><a href="#完全二叉树性质" class="headerlink" title="完全二叉树性质"></a>完全二叉树性质</h5><p>假设对各节点从上到下，从左到右依次编号1~n,则对任意节点a编号i，有 ：</p>
<ul>
<li>当n为偶数时，n1=1，n为奇数时，n1=0</li>
<li>如果i=1,则节点i是根节点，无双亲</li>
<li>如果i&gt;1,则节点i的双亲节点为$\lfloor i/2\rfloor$</li>
<li>如果2i&lt;=n，则i的左孩为2i，如果2i&gt;n，则i无左孩</li>
<li>如果2i+1&lt;=n,则i的右孩为2i+1，否则i无右孩</li>
</ul>
<p>顺序存储：由于位置隐含了亲子关系，故可用顺序存储的<strong>索引来表示关系</strong>，元素按在完全二叉树的顺序存储。问题是有很多空闲空间且不便于修改</p>
<p>二叉链式存储：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TElemType data;	<span class="comment">//数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<p>三叉链表多一个<strong>双亲指针</strong></p>
<h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><p>以<strong>递归</strong>的方式先序遍历：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status PreOrderTraverse(BiTree T, void (*visit)(TElemType))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (T)</span><br><span class="line">	&#123;</span><br><span class="line">		visit(T-&gt;data);</span><br><span class="line">		PreOrderTraverse(T-&gt;lchild, visit);</span><br><span class="line">		PreOrderTraverse(T-&gt;rchild, visit);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<strong>栈实现迭代</strong>的中序遍历：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iterInorder</span><span class="params">(treePointer node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    treePointer <span class="built_in">stack</span>[MAX_STACK_SIZE];</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;node;node = node -&gt; lchild)</span><br><span class="line">            push(node);</span><br><span class="line">        node = pop();</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,node -&gt; data);</span><br><span class="line">        node = node -&gt; rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<strong>队列</strong>实现层序遍历：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!BT) <span class="keyword">return</span>;</span><br><span class="line">    Queue Q; </span><br><span class="line">    BinTree T; </span><br><span class="line">    Q = CreatQueue(MaxSize); <span class="comment">//创建变初始化队列 </span></span><br><span class="line">    Add(Q,BT); </span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123; </span><br><span class="line">        T = Delete(Q); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, T-&gt;Data);    <span class="comment">//访问队列中的结点 </span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;Left) Add(Q,T-&gt;Left); </span><br><span class="line">        <span class="keyword">if</span> (T-&gt;Right) Add(Q,T-&gt;Right); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由二叉树的先/后/层序遍历结合一个<strong>中序</strong>遍历可以<strong>唯一确定</strong>一个二叉树</p>
<p>递归判断二叉树相等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">equal</span><span class="params">(BinTree first,BinTree second)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((!first) &amp;&amp; (!second) || (first &amp;&amp; second &amp;&amp; (first -&gt; data == second -&gt; data) &amp;&amp; equal(first -&gt; lchild,second -&gt; lchild) &amp;&amp; equal(first -&gt; rchild,secnd -&gt; rchild)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h5><p>充分利用空指针域，存放<strong>中序</strong>遍历的前驱或后继。要设置一个标志位表明存放的是指向孩子的指针还是指向前驱或后继的指针</p>
<p>则可以在O(n)时间内实现中序遍历</p>
<h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p><strong>基于完全二叉树</strong>，对关键字值有特殊的约束——可以用数组实现</p>
<p>从堆顶删除，从堆底插入，中途可能要做多次调整</p>
<p>常用来实现OS中的<strong>优先级队列</strong></p>
<p>插入大顶堆：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_max_heap</span><span class="params">(element item,<span class="keyword">int</span> *n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(HEAP_FULL(*n))&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"the heap is full.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++(*n);</span><br><span class="line">    <span class="keyword">while</span>((i !=<span class="number">1</span>)&amp;&amp;(item.key &gt; heap[i/<span class="number">2</span>].key))&#123;</span><br><span class="line">        heap[i] = heap[i/<span class="number">2</span>];  <span class="comment">// 比待插入元素值小则下沉到左子树</span></span><br><span class="line">        i /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="最大-最小堆"><a href="#最大-最小堆" class="headerlink" title="最大-最小堆"></a>最大-最小堆</h6><p>各层交替为最小层和最大层，根结点位于最小层</p>
<p>插入删除操作检查从根到待插入位置路径上的相关结点，根据值大小进行相关调整</p>
<p>应用：<strong>双端优先队列</strong></p>
<h6 id="双端堆"><a href="#双端堆" class="headerlink" title="双端堆"></a>双端堆</h6><p>根结点无元素，左子树是最小堆，右子树是最大堆</p>
<p>若 i 是最小堆中的一个结点，则在最大堆中对应的同一位置结点是 $ i + 2^{\lfloor log_2 i \rfloor -1}$ 对应位置相互移动时无需调整，在插入时要用这种方式腾出一个位置</p>
<p>二叉搜索树</p>
<p>所有关键字都不同(所以在插入操作中要先判断是否重复)，中序遍历有序</p>
<p>迭代查找：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tree_pointer <span class="title">search</span><span class="params">(tree_pointer tree,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tree)&#123;</span><br><span class="line">	<span class="keyword">if</span>(key == tree -&gt; data) <span class="keyword">return</span> tree;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; tree -&gt; data) tree = tree -&gt; left_child;</span><br><span class="line">    <span class="keyword">else</span> tree = tree -&gt; right_child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除有两个子树的非叶结点：用<strong>左子树中最大元素或右子树中最小元素</strong>代替被删除结点位置——不同于AVL树，没有平衡要求</p>
<h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5><p>对树高有约束的二叉搜索树，<strong>左右两个子树的高度差的绝对值不超过 1</strong>，并且左右两个子树都是一棵平衡二叉树</p>
<p>构造与调整方法平衡二叉树的常用算法有红黑树、AVL、Treap 等。</p>
<p>最小二叉平衡树的节点的公式如下 $F(n)=F(n-1)+F(n-2)+1$ 这个类似于一个递归的数列，可以参考 Fibonacci 数列，1 是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量</p>
<h5 id="哈弗曼树"><a href="#哈弗曼树" class="headerlink" title="哈弗曼树"></a>哈弗曼树</h5><p>也称最优二叉树，它是带权路径长度最小的二叉树。</p>
<p>常用于解决<strong>最短、最少</strong>类构造问题</p>
<h5 id="败者树-选择树"><a href="#败者树-选择树" class="headerlink" title="败者树(选择树)"></a>败者树(选择树)</h5><p>每个父结点记录较小子树，一直向上比较，直至<strong>根结点表示所有记录中最小的结点</strong>——区别于堆，非叶结点并不是记录，而是比较结果</p>
<p>常用于外部排序的<strong>有序段多路平衡归并</strong>，可大幅减少比较次数。$O(nlog_2 k)$</p>
<h5 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h5><p>转为二叉树：先将每个树转成二叉树，再把后一个树挂在前一个树的<strong>右孩子位置</strong></p>
<p><strong>树的后根遍历—森林中序遍历—二叉树中序遍历</strong> ，先序三者对应</p>
<h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><p>指针<strong>由孩子结点指向父亲结点</strong></p>
<p>由于没有重复元素，可以用数组实现，索引表示元素值，<strong>值域表示其双亲结点，根结点父亲用-1表示</strong></p>
<p>合并：让一棵树的根指针直接指向另一个树的根</p>
<p>合并可能产生退化问题，优化方式：</p>
<ul>
<li>加权规则：结点数多的做父亲</li>
<li><a href="https://blog.csdn.net/luomingjun12315/article/details/47373345" target="_blank" rel="noopener">路径压缩</a></li>
</ul>
<p>应用：等价类</p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>在有向图的邻接表存储中，链表代表的是该顶点的<strong>出边表</strong>   ，<strong>逆邻接表</strong>存储<strong>入边表</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 邻接表存储结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;	<span class="comment">//顶点的位置</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一条边的指针</span></span><br><span class="line">&#125;EdgeNode, *EdgeLink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	VexType data;	<span class="comment">//顶点数据</span></span><br><span class="line">	EdgeNode *firstEdge;	<span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">&#125;VexNode, AdjList[MAX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	AdjList adjList;</span><br><span class="line">	<span class="keyword">int</span> vexNum, edgeNum;	<span class="comment">//顶点数和边数</span></span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure>
<h5 id="DFS-amp-BFS"><a href="#DFS-amp-BFS" class="headerlink" title="DFS&amp;BFS"></a>DFS&amp;BFS</h5><p><strong>深度优先搜索</strong>是树的先根遍历的推广，<strong>广度优先搜索</strong>是树的按层次遍历的推广。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归从第i个结点深度优先遍历图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(ALGraph G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	EdgeLink p;</span><br><span class="line">	visited[i] = TRUE;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c "</span>, G.adjList[i].data);</span><br><span class="line">	p = G.adjList[i].firstEdge;</span><br><span class="line">	<span class="keyword">while</span> (p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited[p-&gt;adjvex])</span><br><span class="line">		&#123;</span><br><span class="line">			DFS(G, p-&gt;adjvex);</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 深度优先遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">DFSTraverse</span><span class="params">(ALGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_NUM; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		visited[i] = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited[i])</span><br><span class="line">		&#123;</span><br><span class="line">			DFS(G, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 广度优先遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">BFSTraverse</span><span class="params">(ALGraph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	EdgeLink p;</span><br><span class="line">	LinkQueue Q;</span><br><span class="line">	InitQueue(&amp;Q);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_NUM; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		visited[i] = FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited[i])</span><br><span class="line">		&#123;</span><br><span class="line">			visited[i] = TRUE;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c "</span>, G.adjList[i].data);</span><br><span class="line">			EnQueue(&amp;Q, i);</span><br><span class="line">			<span class="keyword">while</span> (!IsEmpty(Q))</span><br><span class="line">			&#123;</span><br><span class="line">				DeQueue(&amp;Q, &amp;i);</span><br><span class="line">				p = G.adjList[i].firstEdge;</span><br><span class="line">				<span class="keyword">while</span> (p)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (!visited[p-&gt;adjvex])</span><br><span class="line">					&#123;</span><br><span class="line">						visited[p-&gt;adjvex] = TRUE;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">"%c "</span>, G.adjList[p-&gt;adjvex].data);</span><br><span class="line">						EnQueue(&amp;Q, p-&gt;adjvex);</span><br><span class="line">					&#125;</span><br><span class="line">					p = p-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无向图中的<strong>极大连通子图</strong>称为<strong>连通分量</strong>，如果是有向图中的任意一对顶点都有路径，那么这个就是强连通图，相应的它的极大连通子图就称为<strong>强连通分量</strong>。</p>
<p>一个连通图的一个<strong>极小连通子图</strong>，它包含所有顶点，但足以构成一棵树的 n-1 条边，加一条边必定会形成环，这个就称为<strong>生成树</strong></p>
<p>关节点：删除该点及关联边后的新图至少含两个连通分支</p>
<p>双连通图：不含关节点的连通图</p>
<h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5><p>权值最小的生成树为最小生成树，可以用 </p>
<ul>
<li>kruskal（克鲁斯卡尔）算法：按权值递增加边，保证加入后不构成环路——<strong>中间可能构成森林</strong></li>
<li>Prim（普里姆）算法：从单一节点树开始加边并构成一个树——中间始终是一个树</li>
<li>Sollin算法：第一步形成包含所有树的森林，之后每一步为每棵树选一条边——森林融合成树</li>
</ul>
<h5 id="单源多目标最短路径"><a href="#单源多目标最短路径" class="headerlink" title="单源多目标最短路径"></a>单源多目标最短路径</h5><p>Dijkstra 算法采用的是贪心策略  ，<a href="https://blog.csdn.net/luoshixian099/article/details/51918844" target="_blank" rel="noopener">具体实现</a></p>
<h5 id="完全最短路径"><a href="#完全最短路径" class="headerlink" title="完全最短路径"></a>完全最短路径</h5><p>法一：多次调用Dijkstra 算法</p>
<p>法二：计算代价矩阵</p>
<p>判断任意两个顶点之间是否存在一条路径，可以通过传递闭包矩阵和自反传递闭包矩阵解决</p>
<p>说实话这部分，没看太懂…开学考试完了再回头好好理解一下</p>
<h4 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h4><h5 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 13</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestsum</span><span class="params">(<span class="keyword">int</span> n[])</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[SIZE];</span><br><span class="line">	<span class="keyword">int</span> i,rs;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"please input %d number:\n"</span>,SIZE);</span><br><span class="line">	<span class="keyword">for</span>(i =<span class="number">0</span>;i &lt; SIZE;i++)&#123;	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);&#125;</span><br><span class="line">	rs = longestsum(a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The longest subquence sum is %d"</span>,rs);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestsum</span><span class="params">(<span class="keyword">int</span> n[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> thissum=<span class="number">0</span>,i,maxsum;</span><br><span class="line">	maxsum = n[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(i =<span class="number">0</span>;i &lt; SIZE;i++)&#123;</span><br><span class="line">		thissum += n[i];</span><br><span class="line">		<span class="keyword">if</span>(thissum &gt; maxsum)&#123;maxsum = thissum;&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(thissum &lt; <span class="number">0</span>)&#123;thissum = <span class="number">0</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://my.oschina.net/itblog/blog/267860" target="_blank" rel="noopener">更多常规算法</a></p>
<h5 id="一元多项式相加-O-m-n"><a href="#一元多项式相加-O-m-n" class="headerlink" title="一元多项式相加 O(m + n)"></a>一元多项式相加 O(m + n)</h5><p>特别注意：<strong>两系数之和为0的情况</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poltn_add</span><span class="params">(Node *&amp;A,Node *&amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p,*q,*p1,*m;</span><br><span class="line">    p=A-&gt;next;</span><br><span class="line">    p1=A;</span><br><span class="line">    q=B-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p&amp;&amp;q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;<span class="built_in">exp</span> &lt; q-&gt;<span class="built_in">exp</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">			p1 = p1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;<span class="built_in">exp</span> &gt; q-&gt;<span class="built_in">exp</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				m = q;</span><br><span class="line">				q = q-&gt;next;</span><br><span class="line">				m-&gt;next = p;</span><br><span class="line">				p1-&gt;next = m;</span><br><span class="line">				p1 = m;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				p-&gt;coef = p-&gt;coef + q-&gt;coef;</span><br><span class="line">				<span class="keyword">if</span> (p-&gt;coef != <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					p = p-&gt;next;</span><br><span class="line">					p1 = p1-&gt;next;</span><br><span class="line">					m = q;</span><br><span class="line">					m = q;</span><br><span class="line">					q = q-&gt;next;</span><br><span class="line">					<span class="built_in">free</span>(m);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是更多的多项式相加，可以<strong>创建中间多项式</strong>，用两两相加实现</p>
<p>多项式相乘，也可以分解成一系列的加法运算</p>
<p><a href="https://blog.csdn.net/qq_38265137/article/details/80317209" target="_blank" rel="noopener">更详细解法</a></p>
<h5 id="等价关系和等价类"><a href="#等价关系和等价类" class="headerlink" title="等价关系和等价类"></a>等价关系和等价类</h5><p><strong>定义：集合S上的关系≡≡,称为S上为等价关系，当且仅当它在S上是对称的，自反的，传递的。</strong></p>
<p>时间和空间的开销是O(m+n).</p>
<p>关键步骤：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter a pair of numbers (-1 -1 to quit):"</span> );</span><br><span class="line"><span class="comment">//循环输入等价关系的元素对</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;i,&amp;j);</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   x=(node_pointer)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">   <span class="keyword">if</span>(IS_FULL(x))</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"the memory is full\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//插入到第i个链表的前端</span></span><br><span class="line">   x-&gt;data=j;</span><br><span class="line">   x-&gt;link=seq[i];</span><br><span class="line">   seq[i]=x;</span><br><span class="line">   x=(node_pointer)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">   <span class="keyword">if</span>(IS_FULL(x))</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"the memory is full\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//插入到第j个链表的前端</span></span><br><span class="line">   x-&gt;data=i;</span><br><span class="line">   x-&gt;link=seq[j];</span><br><span class="line">   seq[j]=x;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Enter a pair of numbers (-1 -1 to quit):"</span> );</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;i,&amp;j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别插入到对方的链表中。输出时每遍历到一个新的位置，改变其标志位，以后不再输出。</p>
<h5 id="稀疏矩阵十字链表存储-O-max-col-row-terms"><a href="#稀疏矩阵十字链表存储-O-max-col-row-terms" class="headerlink" title="稀疏矩阵十字链表存储 O(max{col,row} + terms)"></a>稀疏矩阵十字链表存储 O(max{col,row} + terms)</h5><p><a href="https://zhuanlan.zhihu.com/p/37525925" target="_blank" rel="noopener">多种存储方式</a></p>
<p>在十字链表中，数组的每一行的非零元素结点构成一个带头结点的循环链表，每一列的非零元素结点也构成一个带头结点的循环链表，这种组织方法使同一非零元素结点既处在某一行的链表中，又处在某一列的链表中。因此非零元素结点中设有两个指针域：指针域down指向其同列的下一个非零元素的结点，right域指向其同行的下一个非零元素结点。除这两个域外，结点中还应设有存放该非零元素的行值、列值、元素值的域。</p>
<p>结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> row, col;</span><br><span class="line">	<span class="keyword">union</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">next</span>;</span>	<span class="comment">//表头结点使用next域</span></span><br><span class="line">		ElemType e;				<span class="comment">//表中元素结点使用e域</span></span><br><span class="line">	&#125;uval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span> *<span class="title">down</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125;OLNode,*OLink;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/zl908760230/article/details/55214059" target="_blank" rel="noopener">详细解释</a></p>
<p>用<strong>三元组</strong>法比较简单可用数组实现，转置时直接在新的数组中交换原来的行列即可。这种转置的复杂度很高 O(row <em> col </em> terms)</p>
<p>改进：先确定原矩阵中每列非零元素对应转置矩阵的每行非零元素位置，就可以从起始位置开始处理</p>
<p>矩阵乘法：…以后再看</p>
<h5 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h5><p><a href="https://blog.csdn.net/cainv89/article/details/51477947" target="_blank" rel="noopener">回溯法</a></p>
<h5 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h5><p>对朴素串匹配 O( n * m)进行改进：可以先比较第一个和<strong>最后一个字符</strong>，可以在一定程度上减少比较次数</p>
<p>KMP算法O( n + m)：主串不回退，模式串的后缀与前缀在多大程度上重合，<strong>next数组首位为0，第二位为1，之后是前后缀匹配的长度</strong>或将前后缀匹配数组后移一位，next数组首位置-1</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/栈/" rel="tag"><i class="fa fa-tag"></i> 栈</a>
          
            <a href="/tags/C语言/" rel="tag"><i class="fa fa-tag"></i> C语言</a>
          
            <a href="/tags/树/" rel="tag"><i class="fa fa-tag"></i> 树</a>
          
            <a href="/tags/队列/" rel="tag"><i class="fa fa-tag"></i> 队列</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/OS/2019-08-24-进程同步和通信.html" rel="next" title="进程同步和通信">
                <i class="fa fa-chevron-left"></i> 进程同步和通信
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/network/2019-09-04-传输层-网络层.html" rel="prev" title="传输层&网络层">
                传输层&网络层 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/cat.jpg"
                alt="Liana_Wang" />
            
              <p class="site-author-name" itemprop="name">Liana_Wang</p>
              <p class="site-description motion-element" itemprop="description">虚己以游世，乘物以游心</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">113</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/vergessenwang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:vergessenwang@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友链
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.wangyinrui.com/" title="瑞哥上班又开始划水看书了" target="_blank">瑞哥上班又开始划水看书了</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#C语言实验"><span class="nav-number">1.</span> <span class="nav-text">C语言实验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本命令"><span class="nav-number">1.1.</span> <span class="nav-text">基本命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据类型"><span class="nav-number">1.2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#atoi-itoa-与强制类型转换的区别"><span class="nav-number">1.2.1.</span> <span class="nav-text">atoi(),itoa() 与强制类型转换的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运算符"><span class="nav-number">1.3.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输入输出"><span class="nav-number">1.4.</span> <span class="nav-text">输入输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#main函数的参数argc和argv"><span class="nav-number">1.5.</span> <span class="nav-text">main函数的参数argc和argv</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条件语句"><span class="nav-number">1.6.</span> <span class="nav-text">条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#while和do…while"><span class="nav-number">1.6.1.</span> <span class="nav-text">while和do…while</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#要注意的细节"><span class="nav-number">1.7.</span> <span class="nav-text">要注意的细节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C语言知识点"><span class="nav-number">2.</span> <span class="nav-text">C语言知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符"><span class="nav-number">2.1.</span> <span class="nav-text">字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组"><span class="nav-number">2.2.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符数组与字符串"><span class="nav-number">2.3.</span> <span class="nav-text">字符数组与字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数化结构"><span class="nav-number">2.4.</span> <span class="nav-text">函数化结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指针"><span class="nav-number">2.5.</span> <span class="nav-text">指针</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时空复杂度"><span class="nav-number">3.1.</span> <span class="nav-text">时空复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线性表"><span class="nav-number">3.2.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#顺序表"><span class="nav-number">3.2.1.</span> <span class="nav-text">顺序表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#归并算法"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">归并算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#链表"><span class="nav-number">3.2.2.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#反转链表"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#循环链表"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">循环链表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#双向链表"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">双向链表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#双向循环链表"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">双向循环链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈和队列-受限线性表"><span class="nav-number">3.3.</span> <span class="nav-text">栈和队列(受限线性表)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#栈"><span class="nav-number">3.3.1.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#队列"><span class="nav-number">3.3.2.</span> <span class="nav-text">队列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树"><span class="nav-number">3.4.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#二叉树重要性质"><span class="nav-number">3.4.1.</span> <span class="nav-text">二叉树重要性质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#完全二叉树性质"><span class="nav-number">3.4.2.</span> <span class="nav-text">完全二叉树性质</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#遍历"><span class="nav-number">3.4.3.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线索二叉树"><span class="nav-number">3.4.4.</span> <span class="nav-text">线索二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#堆"><span class="nav-number">3.4.5.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#最大-最小堆"><span class="nav-number">3.4.5.1.</span> <span class="nav-text">最大-最小堆</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#双端堆"><span class="nav-number">3.4.5.2.</span> <span class="nav-text">双端堆</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#平衡二叉树"><span class="nav-number">3.4.6.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#哈弗曼树"><span class="nav-number">3.4.7.</span> <span class="nav-text">哈弗曼树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#败者树-选择树"><span class="nav-number">3.4.8.</span> <span class="nav-text">败者树(选择树)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#森林"><span class="nav-number">3.4.9.</span> <span class="nav-text">森林</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#并查集"><span class="nav-number">3.4.10.</span> <span class="nav-text">并查集</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图"><span class="nav-number">3.5.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DFS-amp-BFS"><span class="nav-number">3.5.1.</span> <span class="nav-text">DFS&amp;BFS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最小生成树"><span class="nav-number">3.5.2.</span> <span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#单源多目标最短路径"><span class="nav-number">3.5.3.</span> <span class="nav-text">单源多目标最短路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#完全最短路径"><span class="nav-number">3.5.4.</span> <span class="nav-text">完全最短路径</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法汇总"><span class="nav-number">3.6.</span> <span class="nav-text">算法汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#最大子序和"><span class="nav-number">3.6.1.</span> <span class="nav-text">最大子序和</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一元多项式相加-O-m-n"><span class="nav-number">3.6.2.</span> <span class="nav-text">一元多项式相加 O(m + n)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#等价关系和等价类"><span class="nav-number">3.6.3.</span> <span class="nav-text">等价关系和等价类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#稀疏矩阵十字链表存储-O-max-col-row-terms"><span class="nav-number">3.6.4.</span> <span class="nav-text">稀疏矩阵十字链表存储 O(max{col,row} + terms)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#迷宫问题"><span class="nav-number">3.6.5.</span> <span class="nav-text">迷宫问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符串匹配"><span class="nav-number">3.6.6.</span> <span class="nav-text">字符串匹配</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liana_Wang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>





  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
  </script>

  

  
  


  

  

</body>
</html>
